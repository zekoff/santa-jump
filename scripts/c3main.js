// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

// file-map:scripts/c3runtime.js
{
  let setMatrixArrayType = function(t) {
    ARRAY_TYPE = t;
  }, toRadian = function(t) {
    return t * degree;
  }, equals$9 = function(t, a) {
    return Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
  }, create$8 = function() {
    var t = new ARRAY_TYPE(4);
    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;
  }, clone$8 = function(t) {
    var a = new ARRAY_TYPE(4);
    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a;
  }, copy$8 = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t;
  }, identity$5 = function(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;
  }, fromValues$8 = function(t, a, r, n) {
    var e = new ARRAY_TYPE(4);
    return e[0] = t, e[1] = a, e[2] = r, e[3] = n, e;
  }, set$8 = function(t, a, r, n, e) {
    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t;
  }, transpose$2 = function(t, a) {
    if (t === a) {
      var r = a[1];
      t[1] = a[2], t[2] = r;
    } else t[0] = a[0], t[1] = a[2], t[2] = a[1], t[3] = a[3];
    return t;
  }, invert$5 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = r * o - e * n;
    return u ? (u = 1 / u, t[0] = o * u, t[1] = -n * u, t[2] = -e * u, t[3] = r * u, t) : null;
  }, adjoint$2 = function(t, a) {
    var r = a[0];
    return t[0] = a[3], t[1] = -a[1], t[2] = -a[2], t[3] = r, t;
  }, determinant$3 = function(t) {
    return t[0] * t[3] - t[2] * t[1];
  }, multiply$8 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[0], i = r[1], c = r[2], l = r[3];
    return t[0] = n * s + o * i, t[1] = e * s + u * i, t[2] = n * c + o * l, t[3] = e * c + u * l, t;
  }, rotate$4 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = Math.sin(r), i = Math.cos(r);
    return t[0] = n * i + o * s, t[1] = e * i + u * s, t[2] = n * -s + o * i, t[3] = e * -s + u * i, t;
  }, scale$8 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[0], i = r[1];
    return t[0] = n * s, t[1] = e * s, t[2] = o * i, t[3] = u * i, t;
  }, fromRotation$4 = function(t, a) {
    var r = Math.sin(a), n = Math.cos(a);
    return t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t;
  }, fromScaling$3 = function(t, a) {
    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = a[1], t;
  }, str$8 = function(t) {
    return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
  }, frob$3 = function(t) {
    return Math.hypot(t[0], t[1], t[2], t[3]);
  }, LDU = function(t, a, r, n) {
    return t[2] = n[2] / n[0], r[0] = n[0], r[1] = n[1], r[3] = n[3] - t[2] * r[1], [t, a, r];
  }, add$8 = function(t, a, r) {
    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t;
  }, subtract$6 = function(t, a, r) {
    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t;
  }, exactEquals$8 = function(t, a) {
    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3];
  }, equals$8 = function(t, a) {
    var r = t[0], n = t[1], e = t[2], o = t[3], u = a[0], s = a[1], i = a[2], c = a[3];
    return Math.abs(r - u) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(n - s) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(e - i) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(i)) && Math.abs(o - c) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(c));
  }, multiplyScalar$3 = function(t, a, r) {
    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t;
  }, multiplyScalarAndAdd$3 = function(t, a, r, n) {
    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t;
  }, create$7 = function() {
    var t = new ARRAY_TYPE(6);
    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t;
  }, clone$7 = function(t) {
    var a = new ARRAY_TYPE(6);
    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a;
  }, copy$7 = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t;
  }, identity$4 = function(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
  }, fromValues$7 = function(t, a, r, n, e, o) {
    var u = new ARRAY_TYPE(6);
    return u[0] = t, u[1] = a, u[2] = r, u[3] = n, u[4] = e, u[5] = o, u;
  }, set$7 = function(t, a, r, n, e, o, u) {
    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t;
  }, invert$4 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = r * o - n * e;
    return i ? (i = 1 / i, t[0] = o * i, t[1] = -n * i, t[2] = -e * i, t[3] = r * i, t[4] = (e * s - o * u) * i, t[5] = (n * u - r * s) * i, t) : null;
  }, determinant$2 = function(t) {
    return t[0] * t[3] - t[1] * t[2];
  }, multiply$7 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = r[0], l = r[1], $ = r[2], h = r[3], f = r[4], M = r[5];
    return t[0] = n * c + o * l, t[1] = e * c + u * l, t[2] = n * $ + o * h, t[3] = e * $ + u * h, t[4] = n * f + o * M + s, t[5] = e * f + u * M + i, t;
  }, rotate$3 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = Math.sin(r), l = Math.cos(r);
    return t[0] = n * l + o * c, t[1] = e * l + u * c, t[2] = n * -c + o * l, t[3] = e * -c + u * l, t[4] = s, t[5] = i, t;
  }, scale$7 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = r[0], l = r[1];
    return t[0] = n * c, t[1] = e * c, t[2] = o * l, t[3] = u * l, t[4] = s, t[5] = i, t;
  }, translate$3 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = r[0], l = r[1];
    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = n * c + o * l + s, t[5] = e * c + u * l + i, t;
  }, fromRotation$3 = function(t, a) {
    var r = Math.sin(a), n = Math.cos(a);
    return t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t[4] = 0, t[5] = 0, t;
  }, fromScaling$2 = function(t, a) {
    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = a[1], t[4] = 0, t[5] = 0, t;
  }, fromTranslation$3 = function(t, a) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = a[0], t[5] = a[1], t;
  }, str$7 = function(t) {
    return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
  }, frob$2 = function(t) {
    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);
  }, add$7 = function(t, a, r) {
    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t;
  }, subtract$5 = function(t, a, r) {
    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t;
  }, multiplyScalar$2 = function(t, a, r) {
    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t;
  }, multiplyScalarAndAdd$2 = function(t, a, r, n) {
    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t;
  }, exactEquals$7 = function(t, a) {
    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5];
  }, equals$7 = function(t, a) {
    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = a[0], c = a[1], l = a[2], $ = a[3], h = a[4], f = a[5];
    return Math.abs(r - i) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(n - c) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(c)) && Math.abs(e - l) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(l)) && Math.abs(o - $) <= EPSILON * Math.max(1, Math.abs(o), Math.abs($)) && Math.abs(u - h) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(h)) && Math.abs(s - f) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(f));
  }, create$6 = function() {
    var t = new ARRAY_TYPE(9);
    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
  }, fromMat4$1 = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[4], t[4] = a[5], t[5] = a[6], t[6] = a[8], t[7] = a[9], t[8] = a[10], t;
  }, clone$6 = function(t) {
    var a = new ARRAY_TYPE(9);
    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a;
  }, copy$6 = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t;
  }, fromValues$6 = function(t, a, r, n, e, o, u, s, i) {
    var c = new ARRAY_TYPE(9);
    return c[0] = t, c[1] = a, c[2] = r, c[3] = n, c[4] = e, c[5] = o, c[6] = u, c[7] = s, c[8] = i, c;
  }, set$6 = function(t, a, r, n, e, o, u, s, i, c) {
    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t[8] = c, t;
  }, identity$3 = function(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
  }, transpose$1 = function(t, a) {
    if (t === a) {
      var r = a[1], n = a[2], e = a[5];
      t[1] = a[3], t[2] = a[6], t[3] = r, t[5] = a[7], t[6] = n, t[7] = e;
    } else t[0] = a[0], t[1] = a[3], t[2] = a[6], t[3] = a[1], t[4] = a[4], t[5] = a[7], t[6] = a[2], t[7] = a[5], t[8] = a[8];
    return t;
  }, invert$3 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = l * u - s * c, h = -l * o + s * i, f = c * o - u * i, M = r * $ + n * h + e * f;
    return M ? (M = 1 / M, t[0] = $ * M, t[1] = (-l * n + e * c) * M, t[2] = (s * n - e * u) * M, t[3] = h * M, t[4] = (l * r - e * i) * M, t[5] = (-s * r + e * o) * M, t[6] = f * M, t[7] = (-c * r + n * i) * M, t[8] = (u * r - n * o) * M, t) : null;
  }, adjoint$1 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8];
    return t[0] = u * l - s * c, t[1] = e * c - n * l, t[2] = n * s - e * u, t[3] = s * i - o * l, t[4] = r * l - e * i, t[5] = e * o - r * s, t[6] = o * c - u * i, t[7] = n * i - r * c, t[8] = r * u - n * o, t;
  }, determinant$1 = function(t) {
    var a = t[0], r = t[1], n = t[2], e = t[3], o = t[4], u = t[5], s = t[6], i = t[7], c = t[8];
    return a * (c * o - u * i) + r * (-c * e + u * s) + n * (i * e - o * s);
  }, multiply$6 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = r[0], f = r[1], M = r[2], m = r[3], d = r[4], v = r[5], b = r[6], p = r[7], A = r[8];
    return t[0] = h * n + f * u + M * c, t[1] = h * e + f * s + M * l, t[2] = h * o + f * i + M * $, t[3] = m * n + d * u + v * c, t[4] = m * e + d * s + v * l, t[5] = m * o + d * i + v * $, t[6] = b * n + p * u + A * c, t[7] = b * e + p * s + A * l, t[8] = b * o + p * i + A * $, t;
  }, translate$2 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = r[0], f = r[1];
    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = s, t[5] = i, t[6] = h * n + f * u + c, t[7] = h * e + f * s + l, t[8] = h * o + f * i + $, t;
  }, rotate$2 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = Math.sin(r), f = Math.cos(r);
    return t[0] = f * n + h * u, t[1] = f * e + h * s, t[2] = f * o + h * i, t[3] = f * u - h * n, t[4] = f * s - h * e, t[5] = f * i - h * o, t[6] = c, t[7] = l, t[8] = $, t;
  }, scale$6 = function(t, a, r) {
    var n = r[0], e = r[1];
    return t[0] = n * a[0], t[1] = n * a[1], t[2] = n * a[2], t[3] = e * a[3], t[4] = e * a[4], t[5] = e * a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t;
  }, fromTranslation$2 = function(t, a) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = a[0], t[7] = a[1], t[8] = 1, t;
  }, fromRotation$2 = function(t, a) {
    var r = Math.sin(a), n = Math.cos(a);
    return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
  }, fromScaling$1 = function(t, a) {
    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = a[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
  }, fromMat2d = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = 0, t[3] = a[2], t[4] = a[3], t[5] = 0, t[6] = a[4], t[7] = a[5], t[8] = 1, t;
  }, fromQuat$1 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = r + r, s = n + n, i = e + e, c = r * u, l = n * u, $ = n * s, h = e * u, f = e * s, M = e * i, m = o * u, d = o * s, v = o * i;
    return t[0] = 1 - $ - M, t[3] = l - v, t[6] = h + d, t[1] = l + v, t[4] = 1 - c - M, t[7] = f - m, t[2] = h - d, t[5] = f + m, t[8] = 1 - c - $, t;
  }, normalFromMat4 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], v = a[15], b = r * s - n * u, p = r * i - e * u, A = r * c - o * u, y = n * i - e * s, g = n * c - o * s, R = e * c - o * i, E = l * m - $ * M, q = l * d - h * M, x = l * v - f * M, P = $ * d - h * m, L = $ * v - f * m, O = h * v - f * d, S = b * O - p * L + A * P + y * x - g * q + R * E;
    return S ? (S = 1 / S, t[0] = (s * O - i * L + c * P) * S, t[1] = (i * x - u * O - c * q) * S, t[2] = (u * L - s * x + c * E) * S, t[3] = (e * L - n * O - o * P) * S, t[4] = (r * O - e * x + o * q) * S, t[5] = (n * x - r * L - o * E) * S, t[6] = (m * R - d * g + v * y) * S, t[7] = (d * A - M * R - v * p) * S, t[8] = (M * g - m * A + v * b) * S, t) : null;
  }, projection = function(t, a, r) {
    return t[0] = 2 / a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
  }, str$6 = function(t) {
    return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
  }, frob$1 = function(t) {
    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
  }, add$6 = function(t, a, r) {
    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t[8] = a[8] + r[8], t;
  }, subtract$4 = function(t, a, r) {
    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t[6] = a[6] - r[6], t[7] = a[7] - r[7], t[8] = a[8] - r[8], t;
  }, multiplyScalar$1 = function(t, a, r) {
    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t[8] = a[8] * r, t;
  }, multiplyScalarAndAdd$1 = function(t, a, r, n) {
    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t[6] = a[6] + r[6] * n, t[7] = a[7] + r[7] * n, t[8] = a[8] + r[8] * n, t;
  }, exactEquals$6 = function(t, a) {
    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7] && t[8] === a[8];
  }, equals$6 = function(t, a) {
    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], l = t[8], $ = a[0], h = a[1], f = a[2], M = a[3], m = a[4], d = a[5], v = a[6], b = a[7], p = a[8];
    return Math.abs(r - $) <= EPSILON * Math.max(1, Math.abs(r), Math.abs($)) && Math.abs(n - h) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(e - f) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(f)) && Math.abs(o - M) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(u - m) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(m)) && Math.abs(s - d) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(i - v) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(v)) && Math.abs(c - b) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(b)) && Math.abs(l - p) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(p));
  }, create$5 = function() {
    var t = new ARRAY_TYPE(16);
    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
  }, clone$5 = function(t) {
    var a = new ARRAY_TYPE(16);
    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a[9] = t[9], a[10] = t[10], a[11] = t[11], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15], a;
  }, copy$5 = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;
  }, fromValues$5 = function(t, a, r, n, e, o, u, s, i, c, l, $, h, f, M, m) {
    var d = new ARRAY_TYPE(16);
    return d[0] = t, d[1] = a, d[2] = r, d[3] = n, d[4] = e, d[5] = o, d[6] = u, d[7] = s, d[8] = i, d[9] = c, d[10] = l, d[11] = $, d[12] = h, d[13] = f, d[14] = M, d[15] = m, d;
  }, set$5 = function(t, a, r, n, e, o, u, s, i, c, l, $, h, f, M, m, d) {
    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t[8] = c, t[9] = l, t[10] = $, t[11] = h, t[12] = f, t[13] = M, t[14] = m, t[15] = d, t;
  }, identity$2 = function(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }, transpose = function(t, a) {
    if (t === a) {
      var r = a[1], n = a[2], e = a[3], o = a[6], u = a[7], s = a[11];
      t[1] = a[4], t[2] = a[8], t[3] = a[12], t[4] = r, t[6] = a[9], t[7] = a[13], t[8] = n, t[9] = o, t[11] = a[14], t[12] = e, t[13] = u, t[14] = s;
    } else t[0] = a[0], t[1] = a[4], t[2] = a[8], t[3] = a[12], t[4] = a[1], t[5] = a[5], t[6] = a[9], t[7] = a[13], t[8] = a[2], t[9] = a[6], t[10] = a[10], t[11] = a[14], t[12] = a[3], t[13] = a[7], t[14] = a[11], t[15] = a[15];
    return t;
  }, invert$2 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], v = a[15], b = r * s - n * u, p = r * i - e * u, A = r * c - o * u, y = n * i - e * s, g = n * c - o * s, R = e * c - o * i, E = l * m - $ * M, q = l * d - h * M, x = l * v - f * M, P = $ * d - h * m, L = $ * v - f * m, O = h * v - f * d, S = b * O - p * L + A * P + y * x - g * q + R * E;
    return S ? (S = 1 / S, t[0] = (s * O - i * L + c * P) * S, t[1] = (e * L - n * O - o * P) * S, t[2] = (m * R - d * g + v * y) * S, t[3] = (h * g - $ * R - f * y) * S, t[4] = (i * x - u * O - c * q) * S, t[5] = (r * O - e * x + o * q) * S, t[6] = (d * A - M * R - v * p) * S, t[7] = (l * R - h * A + f * p) * S, t[8] = (u * L - s * x + c * E) * S, t[9] = (n * x - r * L - o * E) * S, t[10] = (M * g - m * A + v * b) * S, t[11] = ($ * A - l * g - f * b) * S, t[12] = (s * q - u * P - i * E) * S, t[13] = (r * P - n * q + e * E) * S, t[14] = (m * p - M * y - d * b) * S, t[15] = (l * y - $ * p + h * b) * S, t) : null;
  }, adjoint = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], v = a[15], b = r * s - n * u, p = r * i - e * u, A = r * c - o * u, y = n * i - e * s, g = n * c - o * s, R = e * c - o * i, E = l * m - $ * M, q = l * d - h * M, x = l * v - f * M, P = $ * d - h * m, L = $ * v - f * m, O = h * v - f * d;
    return t[0] = s * O - i * L + c * P, t[1] = e * L - n * O - o * P, t[2] = m * R - d * g + v * y, t[3] = h * g - $ * R - f * y, t[4] = i * x - u * O - c * q, t[5] = r * O - e * x + o * q, t[6] = d * A - M * R - v * p, t[7] = l * R - h * A + f * p, t[8] = u * L - s * x + c * E, t[9] = n * x - r * L - o * E, t[10] = M * g - m * A + v * b, t[11] = $ * A - l * g - f * b, t[12] = s * q - u * P - i * E, t[13] = r * P - n * q + e * E, t[14] = m * p - M * y - d * b, t[15] = l * y - $ * p + h * b, t;
  }, determinant = function(t) {
    var a = t[0], r = t[1], n = t[2], e = t[3], o = t[4], u = t[5], s = t[6], i = t[7], c = t[8], l = t[9], $ = t[10], h = t[11], f = t[12], M = t[13], m = t[14], d = a * u - r * o, v = a * s - n * o, b = r * s - n * u, p = c * M - l * f, A = c * m - $ * f, y = l * m - $ * M;
    return i * (a * y - r * A + n * p) - e * (o * y - u * A + s * p) + t[15] * (c * b - l * v + $ * d) - h * (f * b - M * v + m * d);
  }, multiply$5 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = a[9], f = a[10], M = a[11], m = a[12], d = a[13], v = a[14], b = a[15], p = r[0], A = r[1], y = r[2], g = r[3];
    return t[0] = p * n + A * s + y * $ + g * m, t[1] = p * e + A * i + y * h + g * d, t[2] = p * o + A * c + y * f + g * v, t[3] = p * u + A * l + y * M + g * b, p = r[4], A = r[5], y = r[6], g = r[7], t[4] = p * n + A * s + y * $ + g * m, t[5] = p * e + A * i + y * h + g * d, t[6] = p * o + A * c + y * f + g * v, t[7] = p * u + A * l + y * M + g * b, p = r[8], A = r[9], y = r[10], g = r[11], t[8] = p * n + A * s + y * $ + g * m, t[9] = p * e + A * i + y * h + g * d, t[10] = p * o + A * c + y * f + g * v, t[11] = p * u + A * l + y * M + g * b, p = r[12], A = r[13], y = r[14], g = r[15], t[12] = p * n + A * s + y * $ + g * m, t[13] = p * e + A * i + y * h + g * d, t[14] = p * o + A * c + y * f + g * v, t[15] = p * u + A * l + y * M + g * b, t;
  }, translate$1 = function(t, a, r) {
    var n, e, o, u, s, i, c, l, $, h, f, M, m = r[0], d = r[1], v = r[2];
    return a === t ? (t[12] = a[0] * m + a[4] * d + a[8] * v + a[12], t[13] = a[1] * m + a[5] * d + a[9] * v + a[13], t[14] = a[2] * m + a[6] * d + a[10] * v + a[14], t[15] = a[3] * m + a[7] * d + a[11] * v + a[15]) : (n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = a[9], f = a[10], M = a[11], t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = s, t[5] = i, t[6] = c, t[7] = l, t[8] = $, t[9] = h, t[10] = f, t[11] = M, t[12] = n * m + s * d + $ * v + a[12], t[13] = e * m + i * d + h * v + a[13], t[14] = o * m + c * d + f * v + a[14], t[15] = u * m + l * d + M * v + a[15]), t;
  }, scale$5 = function(t, a, r) {
    var n = r[0], e = r[1], o = r[2];
    return t[0] = a[0] * n, t[1] = a[1] * n, t[2] = a[2] * n, t[3] = a[3] * n, t[4] = a[4] * e, t[5] = a[5] * e, t[6] = a[6] * e, t[7] = a[7] * e, t[8] = a[8] * o, t[9] = a[9] * o, t[10] = a[10] * o, t[11] = a[11] * o, t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;
  }, rotate$1 = function(t, a, r, n) {
    var e, o, u, s, i, c, l, $, h, f, M, m, d, v, b, p, A, y, g, R, E, q, x, P, L = n[0], O = n[1], S = n[2], Y = Math.hypot(L, O, S);
    return Y < EPSILON ? null : (L *= Y = 1 / Y, O *= Y, S *= Y, e = Math.sin(r), u = 1 - (o = Math.cos(r)), s = a[0], i = a[1], c = a[2], l = a[3], $ = a[4], h = a[5], f = a[6], M = a[7], m = a[8], d = a[9], v = a[10], b = a[11], p = L * L * u + o, A = O * L * u + S * e, y = S * L * u - O * e, g = L * O * u - S * e, R = O * O * u + o, E = S * O * u + L * e, q = L * S * u + O * e, x = O * S * u - L * e, P = S * S * u + o, t[0] = s * p + $ * A + m * y, t[1] = i * p + h * A + d * y, t[2] = c * p + f * A + v * y, t[3] = l * p + M * A + b * y, t[4] = s * g + $ * R + m * E, t[5] = i * g + h * R + d * E, t[6] = c * g + f * R + v * E, t[7] = l * g + M * R + b * E, t[8] = s * q + $ * x + m * P, t[9] = i * q + h * x + d * P, t[10] = c * q + f * x + v * P, t[11] = l * q + M * x + b * P, a !== t && (t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t);
  }, rotateX$3 = function(t, a, r) {
    var n = Math.sin(r), e = Math.cos(r), o = a[4], u = a[5], s = a[6], i = a[7], c = a[8], l = a[9], $ = a[10], h = a[11];
    return a !== t && (t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[4] = o * e + c * n, t[5] = u * e + l * n, t[6] = s * e + $ * n, t[7] = i * e + h * n, t[8] = c * e - o * n, t[9] = l * e - u * n, t[10] = $ * e - s * n, t[11] = h * e - i * n, t;
  }, rotateY$3 = function(t, a, r) {
    var n = Math.sin(r), e = Math.cos(r), o = a[0], u = a[1], s = a[2], i = a[3], c = a[8], l = a[9], $ = a[10], h = a[11];
    return a !== t && (t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[0] = o * e - c * n, t[1] = u * e - l * n, t[2] = s * e - $ * n, t[3] = i * e - h * n, t[8] = o * n + c * e, t[9] = u * n + l * e, t[10] = s * n + $ * e, t[11] = i * n + h * e, t;
  }, rotateZ$3 = function(t, a, r) {
    var n = Math.sin(r), e = Math.cos(r), o = a[0], u = a[1], s = a[2], i = a[3], c = a[4], l = a[5], $ = a[6], h = a[7];
    return a !== t && (t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[0] = o * e + c * n, t[1] = u * e + l * n, t[2] = s * e + $ * n, t[3] = i * e + h * n, t[4] = c * e - o * n, t[5] = l * e - u * n, t[6] = $ * e - s * n, t[7] = h * e - i * n, t;
  }, fromTranslation$1 = function(t, a) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = a[0], t[13] = a[1], t[14] = a[2], t[15] = 1, t;
  }, fromScaling = function(t, a) {
    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = a[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }, fromRotation$1 = function(t, a, r) {
    var n, e, o, u = r[0], s = r[1], i = r[2], c = Math.hypot(u, s, i);
    return c < EPSILON ? null : (u *= c = 1 / c, s *= c, i *= c, n = Math.sin(a), o = 1 - (e = Math.cos(a)), t[0] = u * u * o + e, t[1] = s * u * o + i * n, t[2] = i * u * o - s * n, t[3] = 0, t[4] = u * s * o - i * n, t[5] = s * s * o + e, t[6] = i * s * o + u * n, t[7] = 0, t[8] = u * i * o + s * n, t[9] = s * i * o - u * n, t[10] = i * i * o + e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
  }, fromXRotation = function(t, a) {
    var r = Math.sin(a), n = Math.cos(a);
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }, fromYRotation = function(t, a) {
    var r = Math.sin(a), n = Math.cos(a);
    return t[0] = n, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }, fromZRotation = function(t, a) {
    var r = Math.sin(a), n = Math.cos(a);
    return t[0] = n, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = n, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }, fromRotationTranslation$1 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = n + n, i = e + e, c = o + o, l = n * s, $ = n * i, h = n * c, f = e * i, M = e * c, m = o * c, d = u * s, v = u * i, b = u * c;
    return t[0] = 1 - (f + m), t[1] = $ + b, t[2] = h - v, t[3] = 0, t[4] = $ - b, t[5] = 1 - (l + m), t[6] = M + d, t[7] = 0, t[8] = h + v, t[9] = M - d, t[10] = 1 - (l + f), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;
  }, fromQuat2 = function(t, a) {
    var r = new ARRAY_TYPE(3), n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = n * n + e * e + o * o + u * u;
    return $ > 0 ? (r[0] = 2 * (s * u + l * n + i * o - c * e) / $, r[1] = 2 * (i * u + l * e + c * n - s * o) / $, r[2] = 2 * (c * u + l * o + s * e - i * n) / $) : (r[0] = 2 * (s * u + l * n + i * o - c * e), r[1] = 2 * (i * u + l * e + c * n - s * o), r[2] = 2 * (c * u + l * o + s * e - i * n)), fromRotationTranslation$1(t, a, r), t;
  }, getTranslation$1 = function(t, a) {
    return t[0] = a[12], t[1] = a[13], t[2] = a[14], t;
  }, getScaling = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[4], u = a[5], s = a[6], i = a[8], c = a[9], l = a[10];
    return t[0] = Math.hypot(r, n, e), t[1] = Math.hypot(o, u, s), t[2] = Math.hypot(i, c, l), t;
  }, getRotation = function(t, a) {
    var r = new ARRAY_TYPE(3);
    getScaling(r, a);
    var n = 1 / r[0], e = 1 / r[1], o = 1 / r[2], u = a[0] * n, s = a[1] * e, i = a[2] * o, c = a[4] * n, l = a[5] * e, $ = a[6] * o, h = a[8] * n, f = a[9] * e, M = a[10] * o, m = u + l + M, d = 0;
    return m > 0 ? (d = 2 * Math.sqrt(m + 1), t[3] = 0.25 * d, t[0] = ($ - f) / d, t[1] = (h - i) / d, t[2] = (s - c) / d) : u > l && u > M ? (d = 2 * Math.sqrt(1 + u - l - M), t[3] = ($ - f) / d, t[0] = 0.25 * d, t[1] = (s + c) / d, t[2] = (h + i) / d) : l > M ? (d = 2 * Math.sqrt(1 + l - u - M), t[3] = (h - i) / d, t[0] = (s + c) / d, t[1] = 0.25 * d, t[2] = ($ + f) / d) : (d = 2 * Math.sqrt(1 + M - u - l), t[3] = (s - c) / d, t[0] = (h + i) / d, t[1] = ($ + f) / d, t[2] = 0.25 * d), t;
  }, decompose = function(t, a, r, n) {
    a[0] = n[12], a[1] = n[13], a[2] = n[14];
    var e = n[0], o = n[1], u = n[2], s = n[4], i = n[5], c = n[6], l = n[8], $ = n[9], h = n[10];
    r[0] = Math.hypot(e, o, u), r[1] = Math.hypot(s, i, c), r[2] = Math.hypot(l, $, h);
    var f = 1 / r[0], M = 1 / r[1], m = 1 / r[2], d = e * f, v = o * M, b = u * m, p = s * f, A = i * M, y = c * m, g = l * f, R = $ * M, E = h * m, q = d + A + E, x = 0;
    return q > 0 ? (x = 2 * Math.sqrt(q + 1), t[3] = 0.25 * x, t[0] = (y - R) / x, t[1] = (g - b) / x, t[2] = (v - p) / x) : d > A && d > E ? (x = 2 * Math.sqrt(1 + d - A - E), t[3] = (y - R) / x, t[0] = 0.25 * x, t[1] = (v + p) / x, t[2] = (g + b) / x) : A > E ? (x = 2 * Math.sqrt(1 + A - d - E), t[3] = (g - b) / x, t[0] = (v + p) / x, t[1] = 0.25 * x, t[2] = (y + R) / x) : (x = 2 * Math.sqrt(1 + E - d - A), t[3] = (v - p) / x, t[0] = (g + b) / x, t[1] = (y + R) / x, t[2] = 0.25 * x), t;
  }, fromRotationTranslationScale = function(t, a, r, n) {
    var e = a[0], o = a[1], u = a[2], s = a[3], i = e + e, c = o + o, l = u + u, $ = e * i, h = e * c, f = e * l, M = o * c, m = o * l, d = u * l, v = s * i, b = s * c, p = s * l, A = n[0], y = n[1], g = n[2];
    return t[0] = (1 - (M + d)) * A, t[1] = (h + p) * A, t[2] = (f - b) * A, t[3] = 0, t[4] = (h - p) * y, t[5] = (1 - ($ + d)) * y, t[6] = (m + v) * y, t[7] = 0, t[8] = (f + b) * g, t[9] = (m - v) * g, t[10] = (1 - ($ + M)) * g, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;
  }, fromRotationTranslationScaleOrigin = function(t, a, r, n, e) {
    var o = a[0], u = a[1], s = a[2], i = a[3], c = o + o, l = u + u, $ = s + s, h = o * c, f = o * l, M = o * $, m = u * l, d = u * $, v = s * $, b = i * c, p = i * l, A = i * $, y = n[0], g = n[1], R = n[2], E = e[0], q = e[1], x = e[2], P = (1 - (m + v)) * y, L = (f + A) * y, O = (M - p) * y, S = (f - A) * g, Y = (1 - (h + v)) * g, T = (d + b) * g, N = (M + p) * R, _ = (d - b) * R, I = (1 - (h + m)) * R;
    return t[0] = P, t[1] = L, t[2] = O, t[3] = 0, t[4] = S, t[5] = Y, t[6] = T, t[7] = 0, t[8] = N, t[9] = _, t[10] = I, t[11] = 0, t[12] = r[0] + E - (P * E + S * q + N * x), t[13] = r[1] + q - (L * E + Y * q + _ * x), t[14] = r[2] + x - (O * E + T * q + I * x), t[15] = 1, t;
  }, fromQuat = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = r + r, s = n + n, i = e + e, c = r * u, l = n * u, $ = n * s, h = e * u, f = e * s, M = e * i, m = o * u, d = o * s, v = o * i;
    return t[0] = 1 - $ - M, t[1] = l + v, t[2] = h - d, t[3] = 0, t[4] = l - v, t[5] = 1 - c - M, t[6] = f + m, t[7] = 0, t[8] = h + d, t[9] = f - m, t[10] = 1 - c - $, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }, frustum = function(t, a, r, n, e, o, u) {
    var s = 1 / (r - a), i = 1 / (e - n), c = 1 / (o - u);
    return t[0] = 2 * o * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * o * i, t[6] = 0, t[7] = 0, t[8] = (r + a) * s, t[9] = (e + n) * i, t[10] = (u + o) * c, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = u * o * 2 * c, t[15] = 0, t;
  }, perspectiveNO = function(t, a, r, n, e) {
    var o = 1 / Math.tan(a / 2);
    if (t[0] = o / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0) {
      var u = 1 / (n - e);
      t[10] = (e + n) * u, t[14] = 2 * e * n * u;
    } else t[10] = -1, t[14] = -2 * n;
    return t;
  }, perspectiveZO = function(t, a, r, n, e) {
    var o = 1 / Math.tan(a / 2);
    if (t[0] = o / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0) {
      var u = 1 / (n - e);
      t[10] = e * u, t[14] = e * n * u;
    } else t[10] = -1, t[14] = -n;
    return t;
  }, perspectiveFromFieldOfView = function(t, a, r, n) {
    var e = Math.tan(a.upDegrees * Math.PI / 180), o = Math.tan(a.downDegrees * Math.PI / 180), u = Math.tan(a.leftDegrees * Math.PI / 180), s = Math.tan(a.rightDegrees * Math.PI / 180), i = 2 / (u + s), c = 2 / (e + o);
    return t[0] = i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = c, t[6] = 0, t[7] = 0, t[8] = -(u - s) * i * 0.5, t[9] = (e - o) * c * 0.5, t[10] = n / (r - n), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = n * r / (r - n), t[15] = 0, t;
  }, orthoNO = function(t, a, r, n, e, o, u) {
    var s = 1 / (a - r), i = 1 / (n - e), c = 1 / (o - u);
    return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c, t[11] = 0, t[12] = (a + r) * s, t[13] = (e + n) * i, t[14] = (u + o) * c, t[15] = 1, t;
  }, orthoZO = function(t, a, r, n, e, o, u) {
    var s = 1 / (a - r), i = 1 / (n - e), c = 1 / (o - u);
    return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = c, t[11] = 0, t[12] = (a + r) * s, t[13] = (e + n) * i, t[14] = o * c, t[15] = 1, t;
  }, lookAt = function(t, a, r, n) {
    var e, o, u, s, i, c, l, $, h, f, M = a[0], m = a[1], d = a[2], v = n[0], b = n[1], p = n[2], A = r[0], y = r[1], g = r[2];
    return Math.abs(M - A) < EPSILON && Math.abs(m - y) < EPSILON && Math.abs(d - g) < EPSILON ? identity$2(t) : (l = M - A, $ = m - y, h = d - g, e = b * (h *= f = 1 / Math.hypot(l, $, h)) - p * ($ *= f), o = p * (l *= f) - v * h, u = v * $ - b * l, (f = Math.hypot(e, o, u)) ? (e *= f = 1 / f, o *= f, u *= f) : (e = 0, o = 0, u = 0), s = $ * u - h * o, i = h * e - l * u, c = l * o - $ * e, (f = Math.hypot(s, i, c)) ? (s *= f = 1 / f, i *= f, c *= f) : (s = 0, i = 0, c = 0), t[0] = e, t[1] = s, t[2] = l, t[3] = 0, t[4] = o, t[5] = i, t[6] = $, t[7] = 0, t[8] = u, t[9] = c, t[10] = h, t[11] = 0, t[12] = -(e * M + o * m + u * d), t[13] = -(s * M + i * m + c * d), t[14] = -(l * M + $ * m + h * d), t[15] = 1, t);
  }, targetTo = function(t, a, r, n) {
    var e = a[0], o = a[1], u = a[2], s = n[0], i = n[1], c = n[2], l = e - r[0], $ = o - r[1], h = u - r[2], f = l * l + $ * $ + h * h;
    f > 0 && (l *= f = 1 / Math.sqrt(f), $ *= f, h *= f);
    var M = i * h - c * $, m = c * l - s * h, d = s * $ - i * l;
    return (f = M * M + m * m + d * d) > 0 && (M *= f = 1 / Math.sqrt(f), m *= f, d *= f), t[0] = M, t[1] = m, t[2] = d, t[3] = 0, t[4] = $ * d - h * m, t[5] = h * M - l * d, t[6] = l * m - $ * M, t[7] = 0, t[8] = l, t[9] = $, t[10] = h, t[11] = 0, t[12] = e, t[13] = o, t[14] = u, t[15] = 1, t;
  }, str$5 = function(t) {
    return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
  }, frob = function(t) {
    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
  }, add$5 = function(t, a, r) {
    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t[8] = a[8] + r[8], t[9] = a[9] + r[9], t[10] = a[10] + r[10], t[11] = a[11] + r[11], t[12] = a[12] + r[12], t[13] = a[13] + r[13], t[14] = a[14] + r[14], t[15] = a[15] + r[15], t;
  }, subtract$3 = function(t, a, r) {
    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t[6] = a[6] - r[6], t[7] = a[7] - r[7], t[8] = a[8] - r[8], t[9] = a[9] - r[9], t[10] = a[10] - r[10], t[11] = a[11] - r[11], t[12] = a[12] - r[12], t[13] = a[13] - r[13], t[14] = a[14] - r[14], t[15] = a[15] - r[15], t;
  }, multiplyScalar = function(t, a, r) {
    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t[8] = a[8] * r, t[9] = a[9] * r, t[10] = a[10] * r, t[11] = a[11] * r, t[12] = a[12] * r, t[13] = a[13] * r, t[14] = a[14] * r, t[15] = a[15] * r, t;
  }, multiplyScalarAndAdd = function(t, a, r, n) {
    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t[6] = a[6] + r[6] * n, t[7] = a[7] + r[7] * n, t[8] = a[8] + r[8] * n, t[9] = a[9] + r[9] * n, t[10] = a[10] + r[10] * n, t[11] = a[11] + r[11] * n, t[12] = a[12] + r[12] * n, t[13] = a[13] + r[13] * n, t[14] = a[14] + r[14] * n, t[15] = a[15] + r[15] * n, t;
  }, exactEquals$5 = function(t, a) {
    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7] && t[8] === a[8] && t[9] === a[9] && t[10] === a[10] && t[11] === a[11] && t[12] === a[12] && t[13] === a[13] && t[14] === a[14] && t[15] === a[15];
  }, equals$5 = function(t, a) {
    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], l = t[8], $ = t[9], h = t[10], f = t[11], M = t[12], m = t[13], d = t[14], v = t[15], b = a[0], p = a[1], A = a[2], y = a[3], g = a[4], R = a[5], E = a[6], q = a[7], x = a[8], P = a[9], L = a[10], O = a[11], S = a[12], Y = a[13], T = a[14], N = a[15];
    return Math.abs(r - b) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(b)) && Math.abs(n - p) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(e - A) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(A)) && Math.abs(o - y) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(u - g) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(g)) && Math.abs(s - R) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(R)) && Math.abs(i - E) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(E)) && Math.abs(c - q) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(q)) && Math.abs(l - x) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(x)) && Math.abs($ - P) <= EPSILON * Math.max(1, Math.abs($), Math.abs(P)) && Math.abs(h - L) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(L)) && Math.abs(f - O) <= EPSILON * Math.max(1, Math.abs(f), Math.abs(O)) && Math.abs(M - S) <= EPSILON * Math.max(1, Math.abs(M), Math.abs(S)) && Math.abs(m - Y) <= EPSILON * Math.max(1, Math.abs(m), Math.abs(Y)) && Math.abs(d - T) <= EPSILON * Math.max(1, Math.abs(d), Math.abs(T)) && Math.abs(v - N) <= EPSILON * Math.max(1, Math.abs(v), Math.abs(N));
  }, create$4 = function() {
    var t = new ARRAY_TYPE(3);
    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
  }, clone$4 = function(t) {
    var a = new ARRAY_TYPE(3);
    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a;
  }, length$4 = function(t) {
    var a = t[0], r = t[1], n = t[2];
    return Math.hypot(a, r, n);
  }, fromValues$4 = function(t, a, r) {
    var n = new ARRAY_TYPE(3);
    return n[0] = t, n[1] = a, n[2] = r, n;
  }, copy$4 = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t;
  }, set$4 = function(t, a, r, n) {
    return t[0] = a, t[1] = r, t[2] = n, t;
  }, add$4 = function(t, a, r) {
    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t;
  }, subtract$2 = function(t, a, r) {
    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t;
  }, multiply$4 = function(t, a, r) {
    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t[2] = a[2] * r[2], t;
  }, divide$2 = function(t, a, r) {
    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t[2] = a[2] / r[2], t;
  }, ceil$2 = function(t, a) {
    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t[2] = Math.ceil(a[2]), t;
  }, floor$2 = function(t, a) {
    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t[2] = Math.floor(a[2]), t;
  }, min$2 = function(t, a, r) {
    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t[2] = Math.min(a[2], r[2]), t;
  }, max$2 = function(t, a, r) {
    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t[2] = Math.max(a[2], r[2]), t;
  }, round$2 = function(t, a) {
    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t[2] = Math.round(a[2]), t;
  }, scale$4 = function(t, a, r) {
    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t;
  }, scaleAndAdd$2 = function(t, a, r, n) {
    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t;
  }, distance$2 = function(t, a) {
    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2];
    return Math.hypot(r, n, e);
  }, squaredDistance$2 = function(t, a) {
    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2];
    return r * r + n * n + e * e;
  }, squaredLength$4 = function(t) {
    var a = t[0], r = t[1], n = t[2];
    return a * a + r * r + n * n;
  }, negate$2 = function(t, a) {
    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t;
  }, inverse$2 = function(t, a) {
    return t[0] = 1 / a[0], t[1] = 1 / a[1], t[2] = 1 / a[2], t;
  }, normalize$4 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = r * r + n * n + e * e;
    return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = a[0] * o, t[1] = a[1] * o, t[2] = a[2] * o, t;
  }, dot$4 = function(t, a) {
    return t[0] * a[0] + t[1] * a[1] + t[2] * a[2];
  }, cross$2 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = r[0], s = r[1], i = r[2];
    return t[0] = e * i - o * s, t[1] = o * u - n * i, t[2] = n * s - e * u, t;
  }, lerp$4 = function(t, a, r, n) {
    var e = a[0], o = a[1], u = a[2];
    return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t[2] = u + n * (r[2] - u), t;
  }, slerp$1 = function(t, a, r, n) {
    var e = Math.acos(Math.min(Math.max(dot$4(a, r), -1), 1)), o = Math.sin(e), u = Math.sin((1 - n) * e) / o, s = Math.sin(n * e) / o;
    return t[0] = u * a[0] + s * r[0], t[1] = u * a[1] + s * r[1], t[2] = u * a[2] + s * r[2], t;
  }, hermite = function(t, a, r, n, e, o) {
    var u = o * o, s = u * (2 * o - 3) + 1, i = u * (o - 2) + o, c = u * (o - 1), l = u * (3 - 2 * o);
    return t[0] = a[0] * s + r[0] * i + n[0] * c + e[0] * l, t[1] = a[1] * s + r[1] * i + n[1] * c + e[1] * l, t[2] = a[2] * s + r[2] * i + n[2] * c + e[2] * l, t;
  }, bezier = function(t, a, r, n, e, o) {
    var u = 1 - o, s = u * u, i = o * o, c = s * u, l = 3 * o * s, $ = 3 * i * u, h = i * o;
    return t[0] = a[0] * c + r[0] * l + n[0] * $ + e[0] * h, t[1] = a[1] * c + r[1] * l + n[1] * $ + e[1] * h, t[2] = a[2] * c + r[2] * l + n[2] * $ + e[2] * h, t;
  }, random$3 = function(t, a) {
    a = a || 1;
    var r = 2 * RANDOM() * Math.PI, n = 2 * RANDOM() - 1, e = Math.sqrt(1 - n * n) * a;
    return t[0] = Math.cos(r) * e, t[1] = Math.sin(r) * e, t[2] = n * a, t;
  }, transformMat4$2 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = r[3] * n + r[7] * e + r[11] * o + r[15];
    return u = u || 1, t[0] = (r[0] * n + r[4] * e + r[8] * o + r[12]) / u, t[1] = (r[1] * n + r[5] * e + r[9] * o + r[13]) / u, t[2] = (r[2] * n + r[6] * e + r[10] * o + r[14]) / u, t;
  }, transformMat3$1 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2];
    return t[0] = n * r[0] + e * r[3] + o * r[6], t[1] = n * r[1] + e * r[4] + o * r[7], t[2] = n * r[2] + e * r[5] + o * r[8], t;
  }, transformQuat$1 = function(t, a, r) {
    var n = r[0], e = r[1], o = r[2], u = r[3], s = a[0], i = a[1], c = a[2], l = e * c - o * i, $ = o * s - n * c, h = n * i - e * s, f = e * h - o * $, M = o * l - n * h, m = n * $ - e * l, d = 2 * u;
    return l *= d, $ *= d, h *= d, f *= 2, M *= 2, m *= 2, t[0] = s + l + f, t[1] = i + $ + M, t[2] = c + h + m, t;
  }, rotateX$2 = function(t, a, r, n) {
    var e = [], o = [];
    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[0], o[1] = e[1] * Math.cos(n) - e[2] * Math.sin(n), o[2] = e[1] * Math.sin(n) + e[2] * Math.cos(n), t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;
  }, rotateY$2 = function(t, a, r, n) {
    var e = [], o = [];
    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[2] * Math.sin(n) + e[0] * Math.cos(n), o[1] = e[1], o[2] = e[2] * Math.cos(n) - e[0] * Math.sin(n), t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;
  }, rotateZ$2 = function(t, a, r, n) {
    var e = [], o = [];
    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[0] * Math.cos(n) - e[1] * Math.sin(n), o[1] = e[0] * Math.sin(n) + e[1] * Math.cos(n), o[2] = e[2], t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;
  }, angle$1 = function(t, a) {
    var r = t[0], n = t[1], e = t[2], o = a[0], u = a[1], s = a[2], i = Math.sqrt((r * r + n * n + e * e) * (o * o + u * u + s * s)), c = i && dot$4(t, a) / i;
    return Math.acos(Math.min(Math.max(c, -1), 1));
  }, zero$2 = function(t) {
    return t[0] = 0, t[1] = 0, t[2] = 0, t;
  }, str$4 = function(t) {
    return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
  }, exactEquals$4 = function(t, a) {
    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2];
  }, equals$4 = function(t, a) {
    var r = t[0], n = t[1], e = t[2], o = a[0], u = a[1], s = a[2];
    return Math.abs(r - o) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - u) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(e - s) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(s));
  }, create$3 = function() {
    var t = new ARRAY_TYPE(4);
    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
  }, clone$3 = function(t) {
    var a = new ARRAY_TYPE(4);
    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a;
  }, fromValues$3 = function(t, a, r, n) {
    var e = new ARRAY_TYPE(4);
    return e[0] = t, e[1] = a, e[2] = r, e[3] = n, e;
  }, copy$3 = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t;
  }, set$3 = function(t, a, r, n, e) {
    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t;
  }, add$3 = function(t, a, r) {
    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t;
  }, subtract$1 = function(t, a, r) {
    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t;
  }, multiply$3 = function(t, a, r) {
    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t[2] = a[2] * r[2], t[3] = a[3] * r[3], t;
  }, divide$1 = function(t, a, r) {
    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t[2] = a[2] / r[2], t[3] = a[3] / r[3], t;
  }, ceil$1 = function(t, a) {
    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t[2] = Math.ceil(a[2]), t[3] = Math.ceil(a[3]), t;
  }, floor$1 = function(t, a) {
    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t[2] = Math.floor(a[2]), t[3] = Math.floor(a[3]), t;
  }, min$1 = function(t, a, r) {
    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t[2] = Math.min(a[2], r[2]), t[3] = Math.min(a[3], r[3]), t;
  }, max$1 = function(t, a, r) {
    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t[2] = Math.max(a[2], r[2]), t[3] = Math.max(a[3], r[3]), t;
  }, round$1 = function(t, a) {
    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t[2] = Math.round(a[2]), t[3] = Math.round(a[3]), t;
  }, scale$3 = function(t, a, r) {
    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t;
  }, scaleAndAdd$1 = function(t, a, r, n) {
    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t;
  }, distance$1 = function(t, a) {
    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2], o = a[3] - t[3];
    return Math.hypot(r, n, e, o);
  }, squaredDistance$1 = function(t, a) {
    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2], o = a[3] - t[3];
    return r * r + n * n + e * e + o * o;
  }, length$3 = function(t) {
    var a = t[0], r = t[1], n = t[2], e = t[3];
    return Math.hypot(a, r, n, e);
  }, squaredLength$3 = function(t) {
    var a = t[0], r = t[1], n = t[2], e = t[3];
    return a * a + r * r + n * n + e * e;
  }, negate$1 = function(t, a) {
    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = -a[3], t;
  }, inverse$1 = function(t, a) {
    return t[0] = 1 / a[0], t[1] = 1 / a[1], t[2] = 1 / a[2], t[3] = 1 / a[3], t;
  }, normalize$3 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = r * r + n * n + e * e + o * o;
    return u > 0 && (u = 1 / Math.sqrt(u)), t[0] = r * u, t[1] = n * u, t[2] = e * u, t[3] = o * u, t;
  }, dot$3 = function(t, a) {
    return t[0] * a[0] + t[1] * a[1] + t[2] * a[2] + t[3] * a[3];
  }, cross$1 = function(t, a, r, n) {
    var e = r[0] * n[1] - r[1] * n[0], o = r[0] * n[2] - r[2] * n[0], u = r[0] * n[3] - r[3] * n[0], s = r[1] * n[2] - r[2] * n[1], i = r[1] * n[3] - r[3] * n[1], c = r[2] * n[3] - r[3] * n[2], l = a[0], $ = a[1], h = a[2], f = a[3];
    return t[0] = $ * c - h * i + f * s, t[1] = -l * c + h * u - f * o, t[2] = l * i - $ * u + f * e, t[3] = -l * s + $ * o - h * e, t;
  }, lerp$3 = function(t, a, r, n) {
    var e = a[0], o = a[1], u = a[2], s = a[3];
    return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t[2] = u + n * (r[2] - u), t[3] = s + n * (r[3] - s), t;
  }, random$2 = function(t, a) {
    var r, n, e, o, u, s;
    a = a || 1;
    do {
      u = (r = 2 * RANDOM() - 1) * r + (n = 2 * RANDOM() - 1) * n;
    } while (u >= 1);
    do {
      s = (e = 2 * RANDOM() - 1) * e + (o = 2 * RANDOM() - 1) * o;
    } while (s >= 1);
    var i = Math.sqrt((1 - u) / s);
    return t[0] = a * r, t[1] = a * n, t[2] = a * e * i, t[3] = a * o * i, t;
  }, transformMat4$1 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3];
    return t[0] = r[0] * n + r[4] * e + r[8] * o + r[12] * u, t[1] = r[1] * n + r[5] * e + r[9] * o + r[13] * u, t[2] = r[2] * n + r[6] * e + r[10] * o + r[14] * u, t[3] = r[3] * n + r[7] * e + r[11] * o + r[15] * u, t;
  }, transformQuat = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = r[0], s = r[1], i = r[2], c = r[3], l = c * n + s * o - i * e, $ = c * e + i * n - u * o, h = c * o + u * e - s * n, f = -u * n - s * e - i * o;
    return t[0] = l * c + f * -u + $ * -i - h * -s, t[1] = $ * c + f * -s + h * -u - l * -i, t[2] = h * c + f * -i + l * -s - $ * -u, t[3] = a[3], t;
  }, zero$1 = function(t) {
    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;
  }, str$3 = function(t) {
    return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
  }, exactEquals$3 = function(t, a) {
    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3];
  }, equals$3 = function(t, a) {
    var r = t[0], n = t[1], e = t[2], o = t[3], u = a[0], s = a[1], i = a[2], c = a[3];
    return Math.abs(r - u) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(n - s) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(e - i) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(i)) && Math.abs(o - c) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(c));
  }, create$2 = function() {
    var t = new ARRAY_TYPE(4);
    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
  }, identity$1 = function(t) {
    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
  }, setAxisAngle = function(t, a, r) {
    r *= 0.5;
    var n = Math.sin(r);
    return t[0] = n * a[0], t[1] = n * a[1], t[2] = n * a[2], t[3] = Math.cos(r), t;
  }, getAxisAngle = function(t, a) {
    var r = 2 * Math.acos(a[3]), n = Math.sin(r / 2);
    return n > EPSILON ? (t[0] = a[0] / n, t[1] = a[1] / n, t[2] = a[2] / n) : (t[0] = 1, t[1] = 0, t[2] = 0), r;
  }, getAngle = function(t, a) {
    var r = dot$2(t, a);
    return Math.acos(2 * r * r - 1);
  }, multiply$2 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[0], i = r[1], c = r[2], l = r[3];
    return t[0] = n * l + u * s + e * c - o * i, t[1] = e * l + u * i + o * s - n * c, t[2] = o * l + u * c + n * i - e * s, t[3] = u * l - n * s - e * i - o * c, t;
  }, rotateX$1 = function(t, a, r) {
    r *= 0.5;
    var n = a[0], e = a[1], o = a[2], u = a[3], s = Math.sin(r), i = Math.cos(r);
    return t[0] = n * i + u * s, t[1] = e * i + o * s, t[2] = o * i - e * s, t[3] = u * i - n * s, t;
  }, rotateY$1 = function(t, a, r) {
    r *= 0.5;
    var n = a[0], e = a[1], o = a[2], u = a[3], s = Math.sin(r), i = Math.cos(r);
    return t[0] = n * i - o * s, t[1] = e * i + u * s, t[2] = o * i + n * s, t[3] = u * i - e * s, t;
  }, rotateZ$1 = function(t, a, r) {
    r *= 0.5;
    var n = a[0], e = a[1], o = a[2], u = a[3], s = Math.sin(r), i = Math.cos(r);
    return t[0] = n * i + e * s, t[1] = e * i - n * s, t[2] = o * i + u * s, t[3] = u * i - o * s, t;
  }, calculateW = function(t, a) {
    var r = a[0], n = a[1], e = a[2];
    return t[0] = r, t[1] = n, t[2] = e, t[3] = Math.sqrt(Math.abs(1 - r * r - n * n - e * e)), t;
  }, exp = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = Math.sqrt(r * r + n * n + e * e), s = Math.exp(o), i = u > 0 ? s * Math.sin(u) / u : 0;
    return t[0] = r * i, t[1] = n * i, t[2] = e * i, t[3] = s * Math.cos(u), t;
  }, ln = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = Math.sqrt(r * r + n * n + e * e), s = u > 0 ? Math.atan2(u, o) / u : 0;
    return t[0] = r * s, t[1] = n * s, t[2] = e * s, t[3] = 0.5 * Math.log(r * r + n * n + e * e + o * o), t;
  }, pow = function(t, a, r) {
    return ln(t, a), scale$2(t, t, r), exp(t, t), t;
  }, slerp = function(t, a, r, n) {
    var e, o, u, s, i, c = a[0], l = a[1], $ = a[2], h = a[3], f = r[0], M = r[1], m = r[2], d = r[3];
    return (o = c * f + l * M + $ * m + h * d) < 0 && (o = -o, f = -f, M = -M, m = -m, d = -d), 1 - o > EPSILON ? (e = Math.acos(o), u = Math.sin(e), s = Math.sin((1 - n) * e) / u, i = Math.sin(n * e) / u) : (s = 1 - n, i = n), t[0] = s * c + i * f, t[1] = s * l + i * M, t[2] = s * $ + i * m, t[3] = s * h + i * d, t;
  }, random$1 = function(t) {
    var a = RANDOM(), r = RANDOM(), n = RANDOM(), e = Math.sqrt(1 - a), o = Math.sqrt(a);
    return t[0] = e * Math.sin(2 * Math.PI * r), t[1] = e * Math.cos(2 * Math.PI * r), t[2] = o * Math.sin(2 * Math.PI * n), t[3] = o * Math.cos(2 * Math.PI * n), t;
  }, invert$1 = function(t, a) {
    var r = a[0], n = a[1], e = a[2], o = a[3], u = r * r + n * n + e * e + o * o, s = u ? 1 / u : 0;
    return t[0] = -r * s, t[1] = -n * s, t[2] = -e * s, t[3] = o * s, t;
  }, conjugate$1 = function(t, a) {
    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = a[3], t;
  }, fromMat3 = function(t, a) {
    var r, n = a[0] + a[4] + a[8];
    if (n > 0) r = Math.sqrt(n + 1), t[3] = 0.5 * r, r = 0.5 / r, t[0] = (a[5] - a[7]) * r, t[1] = (a[6] - a[2]) * r, t[2] = (a[1] - a[3]) * r;
    else {
      var e = 0;
      a[4] > a[0] && (e = 1), a[8] > a[3 * e + e] && (e = 2);
      var o = (e + 1) % 3, u = (e + 2) % 3;
      r = Math.sqrt(a[3 * e + e] - a[3 * o + o] - a[3 * u + u] + 1), t[e] = 0.5 * r, r = 0.5 / r, t[3] = (a[3 * o + u] - a[3 * u + o]) * r, t[o] = (a[3 * o + e] + a[3 * e + o]) * r, t[u] = (a[3 * u + e] + a[3 * e + u]) * r;
    }
    return t;
  }, fromEuler = function(t, a, r, n) {
    var e = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : ANGLE_ORDER, o = Math.PI / 360;
    a *= o, n *= o, r *= o;
    var u = Math.sin(a), s = Math.cos(a), i = Math.sin(r), c = Math.cos(r), l = Math.sin(n), $ = Math.cos(n);
    switch (e) {
      case "xyz":
        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ - u * i * l;
        break;
      case "xzy":
        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ + u * i * l;
        break;
      case "yxz":
        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ + u * i * l;
        break;
      case "yzx":
        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ - u * i * l;
        break;
      case "zxy":
        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ - u * i * l;
        break;
      case "zyx":
        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ + u * i * l;
        break;
      default:
        throw new Error("Unknown angle order " + e);
    }
    return t;
  }, str$2 = function(t) {
    return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
  }, equals$2 = function(t, a) {
    return Math.abs(dot$3(t, a)) >= 1 - EPSILON;
  }, create$1 = function() {
    var t = new ARRAY_TYPE(8);
    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t;
  }, clone$1 = function(t) {
    var a = new ARRAY_TYPE(8);
    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a;
  }, fromValues$1 = function(t, a, r, n, e, o, u, s) {
    var i = new ARRAY_TYPE(8);
    return i[0] = t, i[1] = a, i[2] = r, i[3] = n, i[4] = e, i[5] = o, i[6] = u, i[7] = s, i;
  }, fromRotationTranslationValues = function(t, a, r, n, e, o, u) {
    var s = new ARRAY_TYPE(8);
    s[0] = t, s[1] = a, s[2] = r, s[3] = n;
    var i = 0.5 * e, c = 0.5 * o, l = 0.5 * u;
    return s[4] = i * n + c * r - l * a, s[5] = c * n + l * t - i * r, s[6] = l * n + i * a - c * t, s[7] = -i * t - c * a - l * r, s;
  }, fromRotationTranslation = function(t, a, r) {
    var n = 0.5 * r[0], e = 0.5 * r[1], o = 0.5 * r[2], u = a[0], s = a[1], i = a[2], c = a[3];
    return t[0] = u, t[1] = s, t[2] = i, t[3] = c, t[4] = n * c + e * i - o * s, t[5] = e * c + o * u - n * i, t[6] = o * c + n * s - e * u, t[7] = -n * u - e * s - o * i, t;
  }, fromTranslation = function(t, a) {
    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0.5 * a[0], t[5] = 0.5 * a[1], t[6] = 0.5 * a[2], t[7] = 0, t;
  }, fromRotation = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;
  }, fromMat4 = function(t, a) {
    var r = create$2();
    getRotation(r, a);
    var n = new ARRAY_TYPE(3);
    return getTranslation$1(n, a), fromRotationTranslation(t, r, n), t;
  }, copy$1 = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t;
  }, identity = function(t) {
    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;
  }, set$1 = function(t, a, r, n, e, o, u, s, i) {
    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t;
  }, getDual = function(t, a) {
    return t[0] = a[4], t[1] = a[5], t[2] = a[6], t[3] = a[7], t;
  }, setDual = function(t, a) {
    return t[4] = a[0], t[5] = a[1], t[6] = a[2], t[7] = a[3], t;
  }, getTranslation = function(t, a) {
    var r = a[4], n = a[5], e = a[6], o = a[7], u = -a[0], s = -a[1], i = -a[2], c = a[3];
    return t[0] = 2 * (r * c + o * u + n * i - e * s), t[1] = 2 * (n * c + o * s + e * u - r * i), t[2] = 2 * (e * c + o * i + r * s - n * u), t;
  }, translate = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = 0.5 * r[0], i = 0.5 * r[1], c = 0.5 * r[2], l = a[4], $ = a[5], h = a[6], f = a[7];
    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = u * s + e * c - o * i + l, t[5] = u * i + o * s - n * c + $, t[6] = u * c + n * i - e * s + h, t[7] = -n * s - e * i - o * c + f, t;
  }, rotateX = function(t, a, r) {
    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, M = l * u - s * n - i * e - c * o;
    return rotateX$1(t, a, r), n = t[0], e = t[1], o = t[2], u = t[3], t[4] = $ * u + M * n + h * o - f * e, t[5] = h * u + M * e + f * n - $ * o, t[6] = f * u + M * o + $ * e - h * n, t[7] = M * u - $ * n - h * e - f * o, t;
  }, rotateY = function(t, a, r) {
    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, M = l * u - s * n - i * e - c * o;
    return rotateY$1(t, a, r), n = t[0], e = t[1], o = t[2], u = t[3], t[4] = $ * u + M * n + h * o - f * e, t[5] = h * u + M * e + f * n - $ * o, t[6] = f * u + M * o + $ * e - h * n, t[7] = M * u - $ * n - h * e - f * o, t;
  }, rotateZ = function(t, a, r) {
    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, M = l * u - s * n - i * e - c * o;
    return rotateZ$1(t, a, r), n = t[0], e = t[1], o = t[2], u = t[3], t[4] = $ * u + M * n + h * o - f * e, t[5] = h * u + M * e + f * n - $ * o, t[6] = f * u + M * o + $ * e - h * n, t[7] = M * u - $ * n - h * e - f * o, t;
  }, rotateByQuatAppend = function(t, a, r) {
    var n = r[0], e = r[1], o = r[2], u = r[3], s = a[0], i = a[1], c = a[2], l = a[3];
    return t[0] = s * u + l * n + i * o - c * e, t[1] = i * u + l * e + c * n - s * o, t[2] = c * u + l * o + s * e - i * n, t[3] = l * u - s * n - i * e - c * o, s = a[4], i = a[5], c = a[6], l = a[7], t[4] = s * u + l * n + i * o - c * e, t[5] = i * u + l * e + c * n - s * o, t[6] = c * u + l * o + s * e - i * n, t[7] = l * u - s * n - i * e - c * o, t;
  }, rotateByQuatPrepend = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[0], i = r[1], c = r[2], l = r[3];
    return t[0] = n * l + u * s + e * c - o * i, t[1] = e * l + u * i + o * s - n * c, t[2] = o * l + u * c + n * i - e * s, t[3] = u * l - n * s - e * i - o * c, s = r[4], i = r[5], c = r[6], l = r[7], t[4] = n * l + u * s + e * c - o * i, t[5] = e * l + u * i + o * s - n * c, t[6] = o * l + u * c + n * i - e * s, t[7] = u * l - n * s - e * i - o * c, t;
  }, rotateAroundAxis = function(t, a, r, n) {
    if (Math.abs(n) < EPSILON) return copy$1(t, a);
    var e = Math.hypot(r[0], r[1], r[2]);
    n *= 0.5;
    var o = Math.sin(n), u = o * r[0] / e, s = o * r[1] / e, i = o * r[2] / e, c = Math.cos(n), l = a[0], $ = a[1], h = a[2], f = a[3];
    t[0] = l * c + f * u + $ * i - h * s, t[1] = $ * c + f * s + h * u - l * i, t[2] = h * c + f * i + l * s - $ * u, t[3] = f * c - l * u - $ * s - h * i;
    var M = a[4], m = a[5], d = a[6], v = a[7];
    return t[4] = M * c + v * u + m * i - d * s, t[5] = m * c + v * s + d * u - M * i, t[6] = d * c + v * i + M * s - m * u, t[7] = v * c - M * u - m * s - d * i, t;
  }, add$1 = function(t, a, r) {
    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t;
  }, multiply$1 = function(t, a, r) {
    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[4], i = r[5], c = r[6], l = r[7], $ = a[4], h = a[5], f = a[6], M = a[7], m = r[0], d = r[1], v = r[2], b = r[3];
    return t[0] = n * b + u * m + e * v - o * d, t[1] = e * b + u * d + o * m - n * v, t[2] = o * b + u * v + n * d - e * m, t[3] = u * b - n * m - e * d - o * v, t[4] = n * l + u * s + e * c - o * i + $ * b + M * m + h * v - f * d, t[5] = e * l + u * i + o * s - n * c + h * b + M * d + f * m - $ * v, t[6] = o * l + u * c + n * i - e * s + f * b + M * v + $ * d - h * m, t[7] = u * l - n * s - e * i - o * c + M * b - $ * m - h * d - f * v, t;
  }, scale$1 = function(t, a, r) {
    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t;
  }, lerp$1 = function(t, a, r, n) {
    var e = 1 - n;
    return dot$1(a, r) < 0 && (n = -n), t[0] = a[0] * e + r[0] * n, t[1] = a[1] * e + r[1] * n, t[2] = a[2] * e + r[2] * n, t[3] = a[3] * e + r[3] * n, t[4] = a[4] * e + r[4] * n, t[5] = a[5] * e + r[5] * n, t[6] = a[6] * e + r[6] * n, t[7] = a[7] * e + r[7] * n, t;
  }, invert = function(t, a) {
    var r = squaredLength$1(a);
    return t[0] = -a[0] / r, t[1] = -a[1] / r, t[2] = -a[2] / r, t[3] = a[3] / r, t[4] = -a[4] / r, t[5] = -a[5] / r, t[6] = -a[6] / r, t[7] = a[7] / r, t;
  }, conjugate = function(t, a) {
    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = a[3], t[4] = -a[4], t[5] = -a[5], t[6] = -a[6], t[7] = a[7], t;
  }, normalize$1 = function(t, a) {
    var r = squaredLength$1(a);
    if (r > 0) {
      r = Math.sqrt(r);
      var n = a[0] / r, e = a[1] / r, o = a[2] / r, u = a[3] / r, s = a[4], i = a[5], c = a[6], l = a[7], $ = n * s + e * i + o * c + u * l;
      t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = (s - n * $) / r, t[5] = (i - e * $) / r, t[6] = (c - o * $) / r, t[7] = (l - u * $) / r;
    }
    return t;
  }, str$1 = function(t) {
    return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")";
  }, exactEquals$1 = function(t, a) {
    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7];
  }, equals$1 = function(t, a) {
    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], l = a[0], $ = a[1], h = a[2], f = a[3], M = a[4], m = a[5], d = a[6], v = a[7];
    return Math.abs(r - l) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(n - $) <= EPSILON * Math.max(1, Math.abs(n), Math.abs($)) && Math.abs(e - h) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(o - f) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(u - M) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(s - m) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(i - d) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(c - v) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(v));
  }, create = function() {
    var t = new ARRAY_TYPE(2);
    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;
  }, clone = function(t) {
    var a = new ARRAY_TYPE(2);
    return a[0] = t[0], a[1] = t[1], a;
  }, fromValues = function(t, a) {
    var r = new ARRAY_TYPE(2);
    return r[0] = t, r[1] = a, r;
  }, copy = function(t, a) {
    return t[0] = a[0], t[1] = a[1], t;
  }, set = function(t, a, r) {
    return t[0] = a, t[1] = r, t;
  }, add = function(t, a, r) {
    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t;
  }, subtract = function(t, a, r) {
    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t;
  }, multiply = function(t, a, r) {
    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t;
  }, divide = function(t, a, r) {
    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t;
  }, ceil = function(t, a) {
    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t;
  }, floor = function(t, a) {
    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t;
  }, min = function(t, a, r) {
    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t;
  }, max = function(t, a, r) {
    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t;
  }, round = function(t, a) {
    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t;
  }, scale = function(t, a, r) {
    return t[0] = a[0] * r, t[1] = a[1] * r, t;
  }, scaleAndAdd = function(t, a, r, n) {
    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t;
  }, distance = function(t, a) {
    var r = a[0] - t[0], n = a[1] - t[1];
    return Math.hypot(r, n);
  }, squaredDistance = function(t, a) {
    var r = a[0] - t[0], n = a[1] - t[1];
    return r * r + n * n;
  }, length = function(t) {
    var a = t[0], r = t[1];
    return Math.hypot(a, r);
  }, squaredLength = function(t) {
    var a = t[0], r = t[1];
    return a * a + r * r;
  }, negate = function(t, a) {
    return t[0] = -a[0], t[1] = -a[1], t;
  }, inverse = function(t, a) {
    return t[0] = 1 / a[0], t[1] = 1 / a[1], t;
  }, normalize = function(t, a) {
    var r = a[0], n = a[1], e = r * r + n * n;
    return e > 0 && (e = 1 / Math.sqrt(e)), t[0] = a[0] * e, t[1] = a[1] * e, t;
  }, dot = function(t, a) {
    return t[0] * a[0] + t[1] * a[1];
  }, cross = function(t, a, r) {
    var n = a[0] * r[1] - a[1] * r[0];
    return t[0] = t[1] = 0, t[2] = n, t;
  }, lerp = function(t, a, r, n) {
    var e = a[0], o = a[1];
    return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t;
  }, random = function(t, a) {
    a = a || 1;
    var r = 2 * RANDOM() * Math.PI;
    return t[0] = Math.cos(r) * a, t[1] = Math.sin(r) * a, t;
  }, transformMat2 = function(t, a, r) {
    var n = a[0], e = a[1];
    return t[0] = r[0] * n + r[2] * e, t[1] = r[1] * n + r[3] * e, t;
  }, transformMat2d = function(t, a, r) {
    var n = a[0], e = a[1];
    return t[0] = r[0] * n + r[2] * e + r[4], t[1] = r[1] * n + r[3] * e + r[5], t;
  }, transformMat3 = function(t, a, r) {
    var n = a[0], e = a[1];
    return t[0] = r[0] * n + r[3] * e + r[6], t[1] = r[1] * n + r[4] * e + r[7], t;
  }, transformMat4 = function(t, a, r) {
    var n = a[0], e = a[1];
    return t[0] = r[0] * n + r[4] * e + r[12], t[1] = r[1] * n + r[5] * e + r[13], t;
  }, rotate = function(t, a, r, n) {
    var e = a[0] - r[0], o = a[1] - r[1], u = Math.sin(n), s = Math.cos(n);
    return t[0] = e * s - o * u + r[0], t[1] = e * u + o * s + r[1], t;
  }, angle = function(t, a) {
    var r = t[0], n = t[1], e = a[0], o = a[1], u = Math.sqrt((r * r + n * n) * (e * e + o * o)), s = u && (r * e + n * o) / u;
    return Math.acos(Math.min(Math.max(s, -1), 1));
  }, zero = function(t) {
    return t[0] = 0, t[1] = 0, t;
  }, str = function(t) {
    return "vec2(" + t[0] + ", " + t[1] + ")";
  }, exactEquals = function(t, a) {
    return t[0] === a[0] && t[1] === a[1];
  }, equals = function(t, a) {
    var r = t[0], n = t[1], e = a[0], o = a[1];
    return Math.abs(r - e) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(e)) && Math.abs(n - o) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(o));
  };
  setMatrixArrayType2 = setMatrixArrayType, toRadian2 = toRadian, equals$92 = equals$9, create$82 = create$8, clone$82 = clone$8, copy$82 = copy$8, identity$52 = identity$5, fromValues$82 = fromValues$8, set$82 = set$8, transpose$22 = transpose$2, invert$52 = invert$5, adjoint$22 = adjoint$2, determinant$32 = determinant$3, multiply$82 = multiply$8, rotate$42 = rotate$4, scale$82 = scale$8, fromRotation$42 = fromRotation$4, fromScaling$32 = fromScaling$3, str$82 = str$8, frob$32 = frob$3, LDU2 = LDU, add$82 = add$8, subtract$62 = subtract$6, exactEquals$82 = exactEquals$8, equals$82 = equals$8, multiplyScalar$32 = multiplyScalar$3, multiplyScalarAndAdd$32 = multiplyScalarAndAdd$3, create$72 = create$7, clone$72 = clone$7, copy$72 = copy$7, identity$42 = identity$4, fromValues$72 = fromValues$7, set$72 = set$7, invert$42 = invert$4, determinant$22 = determinant$2, multiply$72 = multiply$7, rotate$32 = rotate$3, scale$72 = scale$7, translate$32 = translate$3, fromRotation$32 = fromRotation$3, fromScaling$22 = fromScaling$2, fromTranslation$32 = fromTranslation$3, str$72 = str$7, frob$22 = frob$2, add$72 = add$7, subtract$52 = subtract$5, multiplyScalar$22 = multiplyScalar$2, multiplyScalarAndAdd$22 = multiplyScalarAndAdd$2, exactEquals$72 = exactEquals$7, equals$72 = equals$7, create$62 = create$6, fromMat4$12 = fromMat4$1, clone$62 = clone$6, copy$62 = copy$6, fromValues$62 = fromValues$6, set$62 = set$6, identity$32 = identity$3, transpose$12 = transpose$1, invert$32 = invert$3, adjoint$12 = adjoint$1, determinant$12 = determinant$1, multiply$62 = multiply$6, translate$22 = translate$2, rotate$22 = rotate$2, scale$62 = scale$6, fromTranslation$22 = fromTranslation$2, fromRotation$22 = fromRotation$2, fromScaling$12 = fromScaling$1, fromMat2d2 = fromMat2d, fromQuat$12 = fromQuat$1, normalFromMat42 = normalFromMat4, projection2 = projection, str$62 = str$6, frob$12 = frob$1, add$62 = add$6, subtract$42 = subtract$4, multiplyScalar$12 = multiplyScalar$1, multiplyScalarAndAdd$12 = multiplyScalarAndAdd$1, exactEquals$62 = exactEquals$6, equals$62 = equals$6, create$52 = create$5, clone$52 = clone$5, copy$52 = copy$5, fromValues$52 = fromValues$5, set$52 = set$5, identity$22 = identity$2, transpose2 = transpose, invert$22 = invert$2, adjoint2 = adjoint, determinant2 = determinant, multiply$52 = multiply$5, translate$12 = translate$1, scale$52 = scale$5, rotate$12 = rotate$1, rotateX$32 = rotateX$3, rotateY$32 = rotateY$3, rotateZ$32 = rotateZ$3, fromTranslation$12 = fromTranslation$1, fromScaling2 = fromScaling, fromRotation$12 = fromRotation$1, fromXRotation2 = fromXRotation, fromYRotation2 = fromYRotation, fromZRotation2 = fromZRotation, fromRotationTranslation$12 = fromRotationTranslation$1, fromQuat22 = fromQuat2, getTranslation$12 = getTranslation$1, getScaling2 = getScaling, getRotation2 = getRotation, decompose2 = decompose, fromRotationTranslationScale2 = fromRotationTranslationScale, fromRotationTranslationScaleOrigin2 = fromRotationTranslationScaleOrigin, fromQuat3 = fromQuat, frustum2 = frustum, perspectiveNO2 = perspectiveNO, perspectiveZO2 = perspectiveZO, perspectiveFromFieldOfView2 = perspectiveFromFieldOfView, orthoNO2 = orthoNO, orthoZO2 = orthoZO, lookAt2 = lookAt, targetTo2 = targetTo, str$52 = str$5, frob2 = frob, add$52 = add$5, subtract$32 = subtract$3, multiplyScalar2 = multiplyScalar, multiplyScalarAndAdd2 = multiplyScalarAndAdd, exactEquals$52 = exactEquals$5, equals$52 = equals$5, create$42 = create$4, clone$42 = clone$4, length$42 = length$4, fromValues$42 = fromValues$4, copy$42 = copy$4, set$42 = set$4, add$42 = add$4, subtract$22 = subtract$2, multiply$42 = multiply$4, divide$22 = divide$2, ceil$22 = ceil$2, floor$22 = floor$2, min$22 = min$2, max$22 = max$2, round$22 = round$2, scale$42 = scale$4, scaleAndAdd$22 = scaleAndAdd$2, distance$22 = distance$2, squaredDistance$22 = squaredDistance$2, squaredLength$42 = squaredLength$4, negate$22 = negate$2, inverse$22 = inverse$2, normalize$42 = normalize$4, dot$42 = dot$4, cross$22 = cross$2, lerp$42 = lerp$4, slerp$12 = slerp$1, hermite2 = hermite, bezier2 = bezier, random$32 = random$3, transformMat4$22 = transformMat4$2, transformMat3$12 = transformMat3$1, transformQuat$12 = transformQuat$1, rotateX$22 = rotateX$2, rotateY$22 = rotateY$2, rotateZ$22 = rotateZ$2, angle$12 = angle$1, zero$22 = zero$2, str$42 = str$4, exactEquals$42 = exactEquals$4, equals$42 = equals$4, create$32 = create$3, clone$32 = clone$3, fromValues$32 = fromValues$3, copy$32 = copy$3, set$32 = set$3, add$32 = add$3, subtract$12 = subtract$1, multiply$32 = multiply$3, divide$12 = divide$1, ceil$12 = ceil$1, floor$12 = floor$1, min$12 = min$1, max$12 = max$1, round$12 = round$1, scale$32 = scale$3, scaleAndAdd$12 = scaleAndAdd$1, distance$12 = distance$1, squaredDistance$12 = squaredDistance$1, length$32 = length$3, squaredLength$32 = squaredLength$3, negate$12 = negate$1, inverse$12 = inverse$1, normalize$32 = normalize$3, dot$32 = dot$3, cross$12 = cross$1, lerp$32 = lerp$3, random$22 = random$2, transformMat4$12 = transformMat4$1, transformQuat2 = transformQuat, zero$12 = zero$1, str$32 = str$3, exactEquals$32 = exactEquals$3, equals$32 = equals$3, create$22 = create$2, identity$12 = identity$1, setAxisAngle2 = setAxisAngle, getAxisAngle2 = getAxisAngle, getAngle2 = getAngle, multiply$22 = multiply$2, rotateX$12 = rotateX$1, rotateY$12 = rotateY$1, rotateZ$12 = rotateZ$1, calculateW2 = calculateW, exp2 = exp, ln2 = ln, pow2 = pow, slerp2 = slerp, random$12 = random$1, invert$12 = invert$1, conjugate$12 = conjugate$1, fromMat32 = fromMat3, fromEuler2 = fromEuler, str$22 = str$2, equals$22 = equals$2, create$12 = create$1, clone$12 = clone$1, fromValues$12 = fromValues$1, fromRotationTranslationValues2 = fromRotationTranslationValues, fromRotationTranslation2 = fromRotationTranslation, fromTranslation2 = fromTranslation, fromRotation2 = fromRotation, fromMat42 = fromMat4, copy$12 = copy$1, identity2 = identity, set$12 = set$1, getDual2 = getDual, setDual2 = setDual, getTranslation2 = getTranslation, translate2 = translate, rotateX2 = rotateX, rotateY2 = rotateY, rotateZ2 = rotateZ, rotateByQuatAppend2 = rotateByQuatAppend, rotateByQuatPrepend2 = rotateByQuatPrepend, rotateAroundAxis2 = rotateAroundAxis, add$12 = add$1, multiply$12 = multiply$1, scale$12 = scale$1, lerp$12 = lerp$1, invert2 = invert, conjugate2 = conjugate, normalize$12 = normalize$1, str$12 = str$1, exactEquals$12 = exactEquals$1, equals$12 = equals$1, create2 = create, clone2 = clone, fromValues2 = fromValues, copy2 = copy, set2 = set, add2 = add, subtract2 = subtract, multiply2 = multiply, divide2 = divide, ceil2 = ceil, floor2 = floor, min2 = min, max2 = max, round2 = round, scale2 = scale, scaleAndAdd2 = scaleAndAdd, distance2 = distance, squaredDistance2 = squaredDistance, length2 = length, squaredLength2 = squaredLength, negate2 = negate, inverse2 = inverse, normalize2 = normalize, dot2 = dot, cross2 = cross, lerp2 = lerp, random2 = random, transformMat22 = transformMat2, transformMat2d2 = transformMat2d, transformMat32 = transformMat3, transformMat42 = transformMat4, rotate2 = rotate, angle2 = angle, zero2 = zero, str2 = str, exactEquals2 = exactEquals, equals2 = equals;
  EPSILON = 1e-6, ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, RANDOM = Math.random, ANGLE_ORDER = "zyx";
  degree = Math.PI / 180;
  Math.hypot || (Math.hypot = function() {
    for (var t = 0, a = arguments.length; a--; ) t += arguments[a] * arguments[a];
    return Math.sqrt(t);
  });
  common = { __proto__: null, EPSILON, get ARRAY_TYPE() {
    return ARRAY_TYPE;
  }, RANDOM, ANGLE_ORDER, setMatrixArrayType, toRadian, equals: equals$9 };
  mul$8 = multiply$8, sub$6 = subtract$6, mat2 = Object.freeze({ __proto__: null, create: create$8, clone: clone$8, copy: copy$8, identity: identity$5, fromValues: fromValues$8, set: set$8, transpose: transpose$2, invert: invert$5, adjoint: adjoint$2, determinant: determinant$3, multiply: multiply$8, rotate: rotate$4, scale: scale$8, fromRotation: fromRotation$4, fromScaling: fromScaling$3, str: str$8, frob: frob$3, LDU, add: add$8, subtract: subtract$6, exactEquals: exactEquals$8, equals: equals$8, multiplyScalar: multiplyScalar$3, multiplyScalarAndAdd: multiplyScalarAndAdd$3, mul: mul$8, sub: sub$6 });
  mul$7 = multiply$7, sub$5 = subtract$5, mat2d = Object.freeze({ __proto__: null, create: create$7, clone: clone$7, copy: copy$7, identity: identity$4, fromValues: fromValues$7, set: set$7, invert: invert$4, determinant: determinant$2, multiply: multiply$7, rotate: rotate$3, scale: scale$7, translate: translate$3, fromRotation: fromRotation$3, fromScaling: fromScaling$2, fromTranslation: fromTranslation$3, str: str$7, frob: frob$2, add: add$7, subtract: subtract$5, multiplyScalar: multiplyScalar$2, multiplyScalarAndAdd: multiplyScalarAndAdd$2, exactEquals: exactEquals$7, equals: equals$7, mul: mul$7, sub: sub$5 });
  mul$6 = multiply$6, sub$4 = subtract$4, mat3 = Object.freeze({ __proto__: null, create: create$6, fromMat4: fromMat4$1, clone: clone$6, copy: copy$6, fromValues: fromValues$6, set: set$6, identity: identity$3, transpose: transpose$1, invert: invert$3, adjoint: adjoint$1, determinant: determinant$1, multiply: multiply$6, translate: translate$2, rotate: rotate$2, scale: scale$6, fromTranslation: fromTranslation$2, fromRotation: fromRotation$2, fromScaling: fromScaling$1, fromMat2d, fromQuat: fromQuat$1, normalFromMat4, projection, str: str$6, frob: frob$1, add: add$6, subtract: subtract$4, multiplyScalar: multiplyScalar$1, multiplyScalarAndAdd: multiplyScalarAndAdd$1, exactEquals: exactEquals$6, equals: equals$6, mul: mul$6, sub: sub$4 });
  perspective = perspectiveNO;
  ortho = orthoNO;
  mul$5 = multiply$5, sub$3 = subtract$3, mat4 = Object.freeze({ __proto__: null, create: create$5, clone: clone$5, copy: copy$5, fromValues: fromValues$5, set: set$5, identity: identity$2, transpose, invert: invert$2, adjoint, determinant, multiply: multiply$5, translate: translate$1, scale: scale$5, rotate: rotate$1, rotateX: rotateX$3, rotateY: rotateY$3, rotateZ: rotateZ$3, fromTranslation: fromTranslation$1, fromScaling, fromRotation: fromRotation$1, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation: fromRotationTranslation$1, fromQuat2, getTranslation: getTranslation$1, getScaling, getRotation, decompose, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspectiveNO, perspective, perspectiveZO, perspectiveFromFieldOfView, orthoNO, ortho, orthoZO, lookAt, targetTo, str: str$5, frob, add: add$5, subtract: subtract$3, multiplyScalar, multiplyScalarAndAdd, exactEquals: exactEquals$5, equals: equals$5, mul: mul$5, sub: sub$3 });
  sub$2 = subtract$2, mul$4 = multiply$4, div$2 = divide$2, dist$2 = distance$2, sqrDist$2 = squaredDistance$2, len$4 = length$4, sqrLen$4 = squaredLength$4, forEach$2 = function() {
    var t = create$4();
    return function(a, r, n, e, o, u) {
      var s, i;
      for (r || (r = 3), n || (n = 0), i = e ? Math.min(e * r + n, a.length) : a.length, s = n; s < i; s += r) t[0] = a[s], t[1] = a[s + 1], t[2] = a[s + 2], o(t, t, u), a[s] = t[0], a[s + 1] = t[1], a[s + 2] = t[2];
      return a;
    };
  }(), vec3 = Object.freeze({ __proto__: null, create: create$4, clone: clone$4, length: length$4, fromValues: fromValues$4, copy: copy$4, set: set$4, add: add$4, subtract: subtract$2, multiply: multiply$4, divide: divide$2, ceil: ceil$2, floor: floor$2, min: min$2, max: max$2, round: round$2, scale: scale$4, scaleAndAdd: scaleAndAdd$2, distance: distance$2, squaredDistance: squaredDistance$2, squaredLength: squaredLength$4, negate: negate$2, inverse: inverse$2, normalize: normalize$4, dot: dot$4, cross: cross$2, lerp: lerp$4, slerp: slerp$1, hermite, bezier, random: random$3, transformMat4: transformMat4$2, transformMat3: transformMat3$1, transformQuat: transformQuat$1, rotateX: rotateX$2, rotateY: rotateY$2, rotateZ: rotateZ$2, angle: angle$1, zero: zero$2, str: str$4, exactEquals: exactEquals$4, equals: equals$4, sub: sub$2, mul: mul$4, div: div$2, dist: dist$2, sqrDist: sqrDist$2, len: len$4, sqrLen: sqrLen$4, forEach: forEach$2 });
  sub$1 = subtract$1, mul$3 = multiply$3, div$1 = divide$1, dist$1 = distance$1, sqrDist$1 = squaredDistance$1, len$3 = length$3, sqrLen$3 = squaredLength$3, forEach$1 = function() {
    var t = create$3();
    return function(a, r, n, e, o, u) {
      var s, i;
      for (r || (r = 4), n || (n = 0), i = e ? Math.min(e * r + n, a.length) : a.length, s = n; s < i; s += r) t[0] = a[s], t[1] = a[s + 1], t[2] = a[s + 2], t[3] = a[s + 3], o(t, t, u), a[s] = t[0], a[s + 1] = t[1], a[s + 2] = t[2], a[s + 3] = t[3];
      return a;
    };
  }(), vec4 = Object.freeze({ __proto__: null, create: create$3, clone: clone$3, fromValues: fromValues$3, copy: copy$3, set: set$3, add: add$3, subtract: subtract$1, multiply: multiply$3, divide: divide$1, ceil: ceil$1, floor: floor$1, min: min$1, max: max$1, round: round$1, scale: scale$3, scaleAndAdd: scaleAndAdd$1, distance: distance$1, squaredDistance: squaredDistance$1, length: length$3, squaredLength: squaredLength$3, negate: negate$1, inverse: inverse$1, normalize: normalize$3, dot: dot$3, cross: cross$1, lerp: lerp$3, random: random$2, transformMat4: transformMat4$1, transformQuat, zero: zero$1, str: str$3, exactEquals: exactEquals$3, equals: equals$3, sub: sub$1, mul: mul$3, div: div$1, dist: dist$1, sqrDist: sqrDist$1, len: len$3, sqrLen: sqrLen$3, forEach: forEach$1 });
  clone$2 = clone$3, fromValues$2 = fromValues$3, copy$2 = copy$3, set$2 = set$3, add$2 = add$3, mul$2 = multiply$2, scale$2 = scale$3, dot$2 = dot$3, lerp$2 = lerp$3, length$2 = length$3, len$2 = length$2, squaredLength$2 = squaredLength$3, sqrLen$2 = squaredLength$2, normalize$2 = normalize$3, exactEquals$2 = exactEquals$3;
  rotationTo = function() {
    var t = create$4(), a = fromValues$4(1, 0, 0), r = fromValues$4(0, 1, 0);
    return function(n, e, o) {
      var u = dot$4(e, o);
      return u < -0.999999 ? (cross$2(t, a, e), len$4(t) < 1e-6 && cross$2(t, r, e), normalize$4(t, t), setAxisAngle(n, t, Math.PI), n) : u > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (cross$2(t, e, o), n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = 1 + u, normalize$2(n, n));
    };
  }(), sqlerp = function() {
    var t = create$2(), a = create$2();
    return function(r, n, e, o, u, s) {
      return slerp(t, n, u, s), slerp(a, e, o, s), slerp(r, t, a, 2 * s * (1 - s)), r;
    };
  }(), setAxes = function() {
    var t = create$6();
    return function(a, r, n, e) {
      return t[0] = n[0], t[3] = n[1], t[6] = n[2], t[1] = e[0], t[4] = e[1], t[7] = e[2], t[2] = -r[0], t[5] = -r[1], t[8] = -r[2], normalize$2(a, fromMat3(a, t));
    };
  }(), quat = Object.freeze({ __proto__: null, create: create$2, identity: identity$1, setAxisAngle, getAxisAngle, getAngle, multiply: multiply$2, rotateX: rotateX$1, rotateY: rotateY$1, rotateZ: rotateZ$1, calculateW, exp, ln, pow, slerp, random: random$1, invert: invert$1, conjugate: conjugate$1, fromMat3, fromEuler, str: str$2, clone: clone$2, fromValues: fromValues$2, copy: copy$2, set: set$2, add: add$2, mul: mul$2, scale: scale$2, dot: dot$2, lerp: lerp$2, length: length$2, len: len$2, squaredLength: squaredLength$2, sqrLen: sqrLen$2, normalize: normalize$2, exactEquals: exactEquals$2, equals: equals$2, rotationTo, sqlerp, setAxes });
  getReal = copy$2;
  setReal = copy$2;
  mul$1 = multiply$1;
  dot$1 = dot$2;
  length$1 = length$2, len$1 = length$1, squaredLength$1 = squaredLength$2, sqrLen$1 = squaredLength$1;
  quat2 = Object.freeze({ __proto__: null, create: create$1, clone: clone$1, fromValues: fromValues$1, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy: copy$1, identity, set: set$1, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add: add$1, multiply: multiply$1, mul: mul$1, scale: scale$1, dot: dot$1, lerp: lerp$1, invert, conjugate, length: length$1, len: len$1, squaredLength: squaredLength$1, sqrLen: sqrLen$1, normalize: normalize$1, str: str$1, exactEquals: exactEquals$1, equals: equals$1 });
  len = length, sub = subtract, mul = multiply, div = divide, dist = distance, sqrDist = squaredDistance, sqrLen = squaredLength, forEach = function() {
    var t = create();
    return function(a, r, n, e, o, u) {
      var s, i;
      for (r || (r = 2), n || (n = 0), i = e ? Math.min(e * r + n, a.length) : a.length, s = n; s < i; s += r) t[0] = a[s], t[1] = a[s + 1], o(t, t, u), a[s] = t[0], a[s + 1] = t[1];
      return a;
    };
  }(), vec2 = Object.freeze({ __proto__: null, create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach });
  globalThis.glMatrix = common, globalThis.glMatrix.mat2 = mat2, globalThis.glMatrix.mat2d = mat2d, globalThis.glMatrix.mat3 = mat3, globalThis.glMatrix.mat4 = mat4, globalThis.glMatrix.quat = quat, globalThis.glMatrix.quat2 = quat2, globalThis.glMatrix.vec2 = vec2, globalThis.glMatrix.vec3 = vec3, globalThis.glMatrix.vec4 = vec4;
}
var EPSILON;
var ARRAY_TYPE;
var RANDOM;
var ANGLE_ORDER;
var degree;
var common;
var mul$8;
var sub$6;
var mat2;
var mul$7;
var sub$5;
var mat2d;
var mul$6;
var sub$4;
var mat3;
var perspective;
var ortho;
var mul$5;
var sub$3;
var mat4;
var sub$2;
var mul$4;
var div$2;
var dist$2;
var sqrDist$2;
var len$4;
var sqrLen$4;
var forEach$2;
var vec3;
var sub$1;
var mul$3;
var div$1;
var dist$1;
var sqrDist$1;
var len$3;
var sqrLen$3;
var forEach$1;
var vec4;
var clone$2;
var fromValues$2;
var copy$2;
var set$2;
var add$2;
var mul$2;
var scale$2;
var dot$2;
var lerp$2;
var length$2;
var len$2;
var squaredLength$2;
var sqrLen$2;
var normalize$2;
var exactEquals$2;
var rotationTo;
var sqlerp;
var setAxes;
var quat;
var getReal;
var setReal;
var mul$1;
var dot$1;
var length$1;
var len$1;
var squaredLength$1;
var sqrLen$1;
var quat2;
var len;
var sub;
var mul;
var div;
var dist;
var sqrDist;
var sqrLen;
var forEach;
var vec2;
var setMatrixArrayType2;
var toRadian2;
var equals$92;
var create$82;
var clone$82;
var copy$82;
var identity$52;
var fromValues$82;
var set$82;
var transpose$22;
var invert$52;
var adjoint$22;
var determinant$32;
var multiply$82;
var rotate$42;
var scale$82;
var fromRotation$42;
var fromScaling$32;
var str$82;
var frob$32;
var LDU2;
var add$82;
var subtract$62;
var exactEquals$82;
var equals$82;
var multiplyScalar$32;
var multiplyScalarAndAdd$32;
var create$72;
var clone$72;
var copy$72;
var identity$42;
var fromValues$72;
var set$72;
var invert$42;
var determinant$22;
var multiply$72;
var rotate$32;
var scale$72;
var translate$32;
var fromRotation$32;
var fromScaling$22;
var fromTranslation$32;
var str$72;
var frob$22;
var add$72;
var subtract$52;
var multiplyScalar$22;
var multiplyScalarAndAdd$22;
var exactEquals$72;
var equals$72;
var create$62;
var fromMat4$12;
var clone$62;
var copy$62;
var fromValues$62;
var set$62;
var identity$32;
var transpose$12;
var invert$32;
var adjoint$12;
var determinant$12;
var multiply$62;
var translate$22;
var rotate$22;
var scale$62;
var fromTranslation$22;
var fromRotation$22;
var fromScaling$12;
var fromMat2d2;
var fromQuat$12;
var normalFromMat42;
var projection2;
var str$62;
var frob$12;
var add$62;
var subtract$42;
var multiplyScalar$12;
var multiplyScalarAndAdd$12;
var exactEquals$62;
var equals$62;
var create$52;
var clone$52;
var copy$52;
var fromValues$52;
var set$52;
var identity$22;
var transpose2;
var invert$22;
var adjoint2;
var determinant2;
var multiply$52;
var translate$12;
var scale$52;
var rotate$12;
var rotateX$32;
var rotateY$32;
var rotateZ$32;
var fromTranslation$12;
var fromScaling2;
var fromRotation$12;
var fromXRotation2;
var fromYRotation2;
var fromZRotation2;
var fromRotationTranslation$12;
var fromQuat22;
var getTranslation$12;
var getScaling2;
var getRotation2;
var decompose2;
var fromRotationTranslationScale2;
var fromRotationTranslationScaleOrigin2;
var fromQuat3;
var frustum2;
var perspectiveNO2;
var perspectiveZO2;
var perspectiveFromFieldOfView2;
var orthoNO2;
var orthoZO2;
var lookAt2;
var targetTo2;
var str$52;
var frob2;
var add$52;
var subtract$32;
var multiplyScalar2;
var multiplyScalarAndAdd2;
var exactEquals$52;
var equals$52;
var create$42;
var clone$42;
var length$42;
var fromValues$42;
var copy$42;
var set$42;
var add$42;
var subtract$22;
var multiply$42;
var divide$22;
var ceil$22;
var floor$22;
var min$22;
var max$22;
var round$22;
var scale$42;
var scaleAndAdd$22;
var distance$22;
var squaredDistance$22;
var squaredLength$42;
var negate$22;
var inverse$22;
var normalize$42;
var dot$42;
var cross$22;
var lerp$42;
var slerp$12;
var hermite2;
var bezier2;
var random$32;
var transformMat4$22;
var transformMat3$12;
var transformQuat$12;
var rotateX$22;
var rotateY$22;
var rotateZ$22;
var angle$12;
var zero$22;
var str$42;
var exactEquals$42;
var equals$42;
var create$32;
var clone$32;
var fromValues$32;
var copy$32;
var set$32;
var add$32;
var subtract$12;
var multiply$32;
var divide$12;
var ceil$12;
var floor$12;
var min$12;
var max$12;
var round$12;
var scale$32;
var scaleAndAdd$12;
var distance$12;
var squaredDistance$12;
var length$32;
var squaredLength$32;
var negate$12;
var inverse$12;
var normalize$32;
var dot$32;
var cross$12;
var lerp$32;
var random$22;
var transformMat4$12;
var transformQuat2;
var zero$12;
var str$32;
var exactEquals$32;
var equals$32;
var create$22;
var identity$12;
var setAxisAngle2;
var getAxisAngle2;
var getAngle2;
var multiply$22;
var rotateX$12;
var rotateY$12;
var rotateZ$12;
var calculateW2;
var exp2;
var ln2;
var pow2;
var slerp2;
var random$12;
var invert$12;
var conjugate$12;
var fromMat32;
var fromEuler2;
var str$22;
var equals$22;
var create$12;
var clone$12;
var fromValues$12;
var fromRotationTranslationValues2;
var fromRotationTranslation2;
var fromTranslation2;
var fromRotation2;
var fromMat42;
var copy$12;
var identity2;
var set$12;
var getDual2;
var setDual2;
var getTranslation2;
var translate2;
var rotateX2;
var rotateY2;
var rotateZ2;
var rotateByQuatAppend2;
var rotateByQuatPrepend2;
var rotateAroundAxis2;
var add$12;
var multiply$12;
var scale$12;
var lerp$12;
var invert2;
var conjugate2;
var normalize$12;
var str$12;
var exactEquals$12;
var equals$12;
var create2;
var clone2;
var fromValues2;
var copy2;
var set2;
var add2;
var subtract2;
var multiply2;
var divide2;
var ceil2;
var floor2;
var min2;
var max2;
var round2;
var scale2;
var scaleAndAdd2;
var distance2;
var squaredDistance2;
var length2;
var squaredLength2;
var negate2;
var inverse2;
var normalize2;
var dot2;
var cross2;
var lerp2;
var random2;
var transformMat22;
var transformMat2d2;
var transformMat32;
var transformMat42;
var rotate2;
var angle2;
var zero2;
var str2;
var exactEquals2;
var equals2;
{
  let lineInt = function(o, n, t) {
    t = t || 0;
    var e, l, p, g, r, i, y, u = [0, 0];
    return e = o[1][1] - o[0][1], l = o[0][0] - o[1][0], p = e * o[0][0] + l * o[0][1], g = n[1][1] - n[0][1], r = n[0][0] - n[1][0], i = g * n[0][0] + r * n[0][1], scalar_eq(y = e * r - g * l, 0, t) || (u[0] = (r * p - l * i) / y, u[1] = (e * i - g * p) / y), u;
  }, lineSegmentsIntersect = function(o, n, t, e) {
    var l = n[0] - o[0], p = n[1] - o[1], g = e[0] - t[0], r = e[1] - t[1];
    if (g * p - r * l === 0) return false;
    var i = (l * (t[1] - o[1]) + p * (o[0] - t[0])) / (g * p - r * l), y = (g * (o[1] - t[1]) + r * (t[0] - o[0])) / (r * l - g * p);
    return i >= 0 && i <= 1 && y >= 0 && y <= 1;
  }, triangleArea = function(o, n, t) {
    return (n[0] - o[0]) * (t[1] - o[1]) - (t[0] - o[0]) * (n[1] - o[1]);
  }, isLeft = function(o, n, t) {
    return triangleArea(o, n, t) > 0;
  }, isLeftOn = function(o, n, t) {
    return triangleArea(o, n, t) >= 0;
  }, isRight = function(o, n, t) {
    return triangleArea(o, n, t) < 0;
  }, isRightOn = function(o, n, t) {
    return triangleArea(o, n, t) <= 0;
  }, collinear = function(o, n, t, e) {
    if (e) {
      var l = tmpPoint1, p = tmpPoint2;
      l[0] = n[0] - o[0], l[1] = n[1] - o[1], p[0] = t[0] - n[0], p[1] = t[1] - n[1];
      var g = l[0] * p[0] + l[1] * p[1], r = Math.sqrt(l[0] * l[0] + l[1] * l[1]), i = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
      return Math.acos(g / (r * i)) < e;
    }
    return 0 === triangleArea(o, n, t);
  }, sqdist = function(o, n) {
    var t = n[0] - o[0], e = n[1] - o[1];
    return t * t + e * e;
  }, polygonAt = function(o, n) {
    var t = o.length;
    return o[n < 0 ? n % t + t : n % t];
  }, polygonClear = function(o) {
    o.length = 0;
  }, polygonAppend = function(o, n, t, e) {
    for (var l = t; l < e; l++) o.push(n[l]);
  }, polygonMakeCCW = function(o) {
    for (var n = 0, t = o, e = 1; e < o.length; ++e) (t[e][1] < t[n][1] || t[e][1] === t[n][1] && t[e][0] > t[n][0]) && (n = e);
    return !isLeft(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, n + 1)) && (polygonReverse(o), true);
  }, polygonReverse = function(o) {
    for (var n = [], t = o.length, e = 0; e !== t; e++) n.push(o.pop());
    for (e = 0; e !== t; e++) o[e] = n[e];
  }, polygonIsReflex = function(o, n) {
    return isRight(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, n + 1));
  }, polygonCanSee = function(o, n, t) {
    var e, l, p = tmpLine1, g = tmpLine2;
    if (isLeftOn(polygonAt(o, n + 1), polygonAt(o, n), polygonAt(o, t)) && isRightOn(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, t))) return false;
    l = sqdist(polygonAt(o, n), polygonAt(o, t));
    for (var r = 0; r !== o.length; ++r) if ((r + 1) % o.length !== n && r !== n && isLeftOn(polygonAt(o, n), polygonAt(o, t), polygonAt(o, r + 1)) && isRightOn(polygonAt(o, n), polygonAt(o, t), polygonAt(o, r)) && (p[0] = polygonAt(o, n), p[1] = polygonAt(o, t), g[0] = polygonAt(o, r), g[1] = polygonAt(o, r + 1), e = lineInt(p, g), sqdist(polygonAt(o, n), e) < l)) return false;
    return true;
  }, polygonCanSee2 = function(o, n, t) {
    for (var e = 0; e !== o.length; ++e) if (e !== n && e !== t && (e + 1) % o.length !== n && (e + 1) % o.length !== t && lineSegmentsIntersect(polygonAt(o, n), polygonAt(o, t), polygonAt(o, e), polygonAt(o, e + 1))) return false;
    return true;
  }, polygonCopy = function(o, n, t, e) {
    var l = e || [];
    if (polygonClear(l), n < t) for (var p = n; p <= t; p++) l.push(o[p]);
    else {
      for (p = 0; p <= t; p++) l.push(o[p]);
      for (p = n; p < o.length; p++) l.push(o[p]);
    }
    return l;
  }, polygonGetCutEdges = function(o) {
    for (var n = [], t = [], e = [], l = [], p = Number.MAX_VALUE, g = 0; g < o.length; ++g) if (polygonIsReflex(o, g)) {
      for (var r = 0; r < o.length; ++r) if (polygonCanSee(o, g, r)) {
        t = polygonGetCutEdges(polygonCopy(o, g, r, l)), e = polygonGetCutEdges(polygonCopy(o, r, g, l));
        for (var i = 0; i < e.length; i++) t.push(e[i]);
        t.length < p && (n = t, p = t.length, n.push([polygonAt(o, g), polygonAt(o, r)]));
      }
    }
    return n;
  }, polygonDecomp = function(o) {
    var n = polygonGetCutEdges(o);
    return n.length > 0 ? polygonSlice(o, n) : [o];
  }, polygonSlice = function(o, n) {
    if (0 === n.length) return [o];
    if (n instanceof Array && n.length && n[0] instanceof Array && 2 === n[0].length && n[0][0] instanceof Array) {
      for (var t = [o], e = 0; e < n.length; e++) for (var l = n[e], p = 0; p < t.length; p++) {
        var g = polygonSlice(t[p], l);
        if (g) {
          t.splice(p, 1), t.push(g[0], g[1]);
          break;
        }
      }
      return t;
    }
    l = n, e = o.indexOf(l[0]), p = o.indexOf(l[1]);
    return -1 !== e && -1 !== p && [polygonCopy(o, e, p), polygonCopy(o, p, e)];
  }, polygonIsSimple = function(o) {
    var n, t = o;
    for (n = 0; n < t.length - 1; n++) for (var e = 0; e < n - 1; e++) if (lineSegmentsIntersect(t[n], t[n + 1], t[e], t[e + 1])) return false;
    for (n = 1; n < t.length - 2; n++) if (lineSegmentsIntersect(t[0], t[t.length - 1], t[n], t[n + 1])) return false;
    return true;
  }, getIntersectionPoint = function(o, n, t, e, l) {
    l = l || 0;
    var p = n[1] - o[1], g = o[0] - n[0], r = p * o[0] + g * o[1], i = e[1] - t[1], y = t[0] - e[0], u = i * t[0] + y * t[1], s = p * y - i * g;
    return scalar_eq(s, 0, l) ? [0, 0] : [(y * r - g * u) / s, (p * u - i * r) / s];
  }, polygonQuickDecomp = function(o, n, t, e, l, p, g) {
    p = p || 100, g = g || 0, l = l || 25, n = void 0 !== n ? n : [], t = t || [], e = e || [];
    var r = [0, 0], i = [0, 0], y = [0, 0], u = 0, s = 0, A = 0, a = 0, f = 0, c = 0, h = 0, v = [], m = [], d = o, C = o;
    if (C.length < 3) return n;
    if (++g > p) return console.warn("quickDecomp: max level (" + p + ") reached."), n;
    for (var R = 0; R < o.length; ++R) if (polygonIsReflex(d, R)) {
      t.push(d[R]), u = s = Number.MAX_VALUE;
      for (var q = 0; q < o.length; ++q) isLeft(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q)) && isRightOn(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q - 1)) && (y = getIntersectionPoint(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q), polygonAt(d, q - 1)), isRight(polygonAt(d, R + 1), polygonAt(d, R), y) && (A = sqdist(d[R], y)) < s && (s = A, i = y, c = q)), isLeft(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q + 1)) && isRightOn(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q)) && (y = getIntersectionPoint(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q), polygonAt(d, q + 1)), isLeft(polygonAt(d, R - 1), polygonAt(d, R), y) && (A = sqdist(d[R], y)) < u && (u = A, r = y, f = q));
      if (c === (f + 1) % o.length) y[0] = (i[0] + r[0]) / 2, y[1] = (i[1] + r[1]) / 2, e.push(y), R < f ? (polygonAppend(v, d, R, f + 1), v.push(y), m.push(y), 0 !== c && polygonAppend(m, d, c, d.length), polygonAppend(m, d, 0, R + 1)) : (0 !== R && polygonAppend(v, d, R, d.length), polygonAppend(v, d, 0, f + 1), v.push(y), m.push(y), polygonAppend(m, d, c, R + 1));
      else {
        if (c > f && (f += o.length), a = Number.MAX_VALUE, f < c) return n;
        for (q = c; q <= f; ++q) isLeftOn(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q)) && isRightOn(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q)) && (A = sqdist(polygonAt(d, R), polygonAt(d, q))) < a && polygonCanSee2(d, R, q) && (a = A, h = q % o.length);
        R < h ? (polygonAppend(v, d, R, h + 1), 0 !== h && polygonAppend(m, d, h, C.length), polygonAppend(m, d, 0, R + 1)) : (0 !== R && polygonAppend(v, d, R, C.length), polygonAppend(v, d, 0, h + 1), polygonAppend(m, d, h, R + 1));
      }
      return v.length < m.length ? (polygonQuickDecomp(v, n, t, e, l, p, g), polygonQuickDecomp(m, n, t, e, l, p, g)) : (polygonQuickDecomp(m, n, t, e, l, p, g), polygonQuickDecomp(v, n, t, e, l, p, g)), n;
    }
    return n.push(o), n;
  }, polygonRemoveCollinearPoints = function(o, n) {
    for (var t = 0, e = o.length - 1; o.length > 3 && e >= 0; --e) collinear(polygonAt(o, e - 1), polygonAt(o, e), polygonAt(o, e + 1), n) && (o.splice(e % o.length, 1), t++);
    return t;
  }, polygonRemoveDuplicatePoints = function(o, n) {
    for (var t = o.length - 1; t >= 1; --t) for (var e = o[t], l = t - 1; l >= 0; --l) points_eq(e, o[l], n) && o.splice(t, 1);
  }, scalar_eq = function(o, n, t) {
    return t = t || 0, Math.abs(o - n) <= t;
  }, points_eq = function(o, n, t) {
    return scalar_eq(o[0], n[0], t) && scalar_eq(o[1], n[1], t);
  };
  lineInt2 = lineInt, lineSegmentsIntersect2 = lineSegmentsIntersect, triangleArea2 = triangleArea, isLeft2 = isLeft, isLeftOn2 = isLeftOn, isRight2 = isRight, isRightOn2 = isRightOn, collinear2 = collinear, sqdist2 = sqdist, polygonAt2 = polygonAt, polygonClear2 = polygonClear, polygonAppend2 = polygonAppend, polygonMakeCCW2 = polygonMakeCCW, polygonReverse2 = polygonReverse, polygonIsReflex2 = polygonIsReflex, polygonCanSee3 = polygonCanSee, polygonCanSee22 = polygonCanSee2, polygonCopy2 = polygonCopy, polygonGetCutEdges2 = polygonGetCutEdges, polygonDecomp2 = polygonDecomp, polygonSlice2 = polygonSlice, polygonIsSimple2 = polygonIsSimple, getIntersectionPoint2 = getIntersectionPoint, polygonQuickDecomp2 = polygonQuickDecomp, polygonRemoveCollinearPoints2 = polygonRemoveCollinearPoints, polygonRemoveDuplicatePoints2 = polygonRemoveDuplicatePoints, scalar_eq2 = scalar_eq, points_eq2 = points_eq;
  tmpPoint1 = [], tmpPoint2 = [];
  tmpLine1 = [], tmpLine2 = [];
  self.polyDecomp = { decomp: polygonDecomp, quickDecomp: polygonQuickDecomp, isSimple: polygonIsSimple, removeCollinearPoints: polygonRemoveCollinearPoints, removeDuplicatePoints: polygonRemoveDuplicatePoints, makeCCW: polygonMakeCCW };
}
var tmpPoint1;
var tmpPoint2;
var tmpLine1;
var tmpLine2;
var lineInt2;
var lineSegmentsIntersect2;
var triangleArea2;
var isLeft2;
var isLeftOn2;
var isRight2;
var isRightOn2;
var collinear2;
var sqdist2;
var polygonAt2;
var polygonClear2;
var polygonAppend2;
var polygonMakeCCW2;
var polygonReverse2;
var polygonIsReflex2;
var polygonCanSee3;
var polygonCanSee22;
var polygonCopy2;
var polygonGetCutEdges2;
var polygonDecomp2;
var polygonSlice2;
var polygonIsSimple2;
var getIntersectionPoint2;
var polygonQuickDecomp2;
var polygonRemoveCollinearPoints2;
var polygonRemoveDuplicatePoints2;
var scalar_eq2;
var points_eq2;
{
  let isReady = false, hasAppStarted = false, buildMode = "dev";
  const internalApiToken = Symbol("Construct internal API token");
  let internalApiTokenAccessesRemaining = 16;
  const C32 = self.C3 = class {
    constructor() {
      throw TypeError("static class can't be instantiated");
    }
    static _GetInternalAPIToken() {
      if (internalApiTokenAccessesRemaining <= 0) throw new Error("cannot obtain internal API token");
      return --internalApiTokenAccessesRemaining, internalApiToken;
    }
    static SetReady() {
      isReady = true;
    }
    static IsReady() {
      return isReady;
    }
    static SetAppStarted() {
      hasAppStarted = true;
    }
    static HasAppStarted() {
      return hasAppStarted;
    }
    static SetBuildMode(e) {
      buildMode = e;
    }
    static GetBuildMode() {
      return buildMode;
    }
    static IsReleaseBuild() {
      return "final" === buildMode;
    }
  };
  C32.isDebug = false, C32.isDebugDefend = false, C32.hardwareConcurrency = navigator.hardwareConcurrency || 2, self.C3X = {};
}
{
  const C32 = self.C3;
  C32.QueryParser = class {
    constructor(e) {
      this._queryString = e, this._parameters = /* @__PURE__ */ new Map(), this._Parse();
    }
    _Parse() {
      let e = this._queryString;
      (e.startsWith("?") || e.startsWith("#")) && (e = e.substr(1));
      const r = e.split("&");
      for (const e2 of r) this._ParseParameter(e2);
    }
    _ParseParameter(e) {
      if (!e) return;
      if (!e.includes("=")) return void this._parameters.set(e, null);
      const r = e.indexOf("="), t = decodeURIComponent(e.substring(0, r)), s = decodeURIComponent(e.substring(r + 1));
      this._parameters.set(t, s);
    }
    LogAll() {
      for (const e of this._parameters) console.log("[QueryParser] Parameter '" + e[0] + "' = " + (null === e[1] ? "null" : "'" + e[1] + "'"));
    }
    Has(e) {
      return this._parameters.has(e);
    }
    Get(e) {
      const r = this._parameters.get(e);
      return void 0 === r ? null : r;
    }
    ClearHash() {
      history.replaceState("", document.title, location.pathname + location.search);
    }
    Reparse(e) {
      this._queryString = e, this._parameters.clear(), this._Parse();
    }
  }, C32.QueryString = new C32.QueryParser(location.search), C32.LocationHashString = new C32.QueryParser(location.hash), C32.QueryString.Has("perf") && (C32.isPerformanceProfiling = true), "dev" !== C32.QueryString.Get("mode") && C32.SetBuildMode("final");
}
{
  let GetWindowsNTVersionName = function(r) {
    const o = parseFloat(r), e = windowsNTVerMap.get(o);
    return e || (o >= 13 ? "11" : "NT " + r);
  };
  GetWindowsNTVersionName2 = GetWindowsNTVersionName;
  const C32 = self.C3, UNKNOWN = "(unknown)";
  C32.Platform = { OS: UNKNOWN, OSVersion: UNKNOWN, Browser: UNKNOWN, BrowserVersion: UNKNOWN, BrowserVersionNumber: NaN, BrowserEngine: UNKNOWN, Context: "browser", IsDesktop: true, IsMobile: false, IsAppleOS: false, IsIpadOS: false, GetDetailedInfo: async () => {
  } };
  const windowsNTVerMap = /* @__PURE__ */ new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);
  const uaStr = navigator.userAgent, uaData = navigator["userAgentData"];
  if (uaData && uaData["brands"].length > 0) {
    let ReadBrandList = function(e2) {
      let t = "", a = "", s = "", n = "";
      for (const i of e2) {
        const e3 = r.get(i["brand"]);
        !t && e3 && (t = e3, a = i["version"]);
        const m = o.get(i["brand"]);
        !s && m && (s = m, n = i["version"]);
      }
      t || "Chromium" !== s || (C32.Platform.Browser = "Chromium", C32.Platform.BrowserVersion = n), C32.Platform.Browser = t || UNKNOWN, C32.Platform.BrowserVersion = a || UNKNOWN, C32.Platform.BrowserEngine = s || UNKNOWN;
    };
    ReadBrandList2 = ReadBrandList;
    C32.Platform.OS = uaData["platform"], C32.Platform.IsMobile = uaData["mobile"], C32.Platform.IsDesktop = !C32.Platform.IsMobile;
    const r = /* @__PURE__ */ new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]]), o = /* @__PURE__ */ new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
    ReadBrandList(uaData["brands"]);
    let e = false;
    C32.Platform.GetDetailedInfo = async () => {
      if (!e) try {
        const r2 = await navigator["userAgentData"]["getHighEntropyValues"](["platformVersion", "fullVersionList"]);
        ReadBrandList(r2["fullVersionList"]), "Windows" === C32.Platform.OS ? C32.Platform.OSVersion = GetWindowsNTVersionName(r2["platformVersion"]) : C32.Platform.OSVersion = r2["platformVersion"], e = true;
      } catch (r2) {
        console.warn("Failed to get detailed user agent information: ", r2);
      }
    };
  } else {
    let RunTest = function(r, o) {
      const e = Array.isArray(r) ? r : [r];
      for (const r2 of e) {
        const e2 = r2.exec(uaStr);
        if (e2) {
          o(e2);
          break;
        }
      }
    };
    RunTest2 = RunTest;
    RunTest(/windows\s+nt\s+([\d\.]+)/i, (r) => {
      C32.Platform.OS = "Windows";
      const o = r[1];
      C32.Platform.OSVersion = GetWindowsNTVersionName(o);
    }), RunTest(/mac\s+os\s+x\s+([\d\._]+)/i, (r) => {
      C32.Platform.OS = "macOS", C32.Platform.OSVersion = r[1].replace(/_/g, ".");
    }), RunTest(/CrOS/, () => {
      C32.Platform.OS = "Chrome OS";
    }), RunTest(/linux|openbsd|freebsd|netbsd/i, () => {
      C32.Platform.OS = "Linux";
    }), RunTest(/android/i, () => {
      C32.Platform.OS = "Android";
    }), RunTest(/android\s+([\d\.]+)/i, (r) => {
      C32.Platform.OS = "Android", C32.Platform.OSVersion = r[1];
    }), C32.Platform.OS === UNKNOWN && (RunTest(/(iphone|ipod|ipad)/i, (r) => {
      C32.Platform.OS = "iOS";
    }), RunTest([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i], (r) => {
      C32.Platform.OS = "iOS", C32.Platform.OSVersion = r[1].replace(/_/g, ".");
    }));
    const t = /chrome\//i.test(uaStr), a = /chromium\//i.test(uaStr), s = /edg\//i.test(uaStr), n = /OPR\//.test(uaStr), i = /nwjs/i.test(uaStr), m = /safari\//i.test(uaStr), l = /webkit/i.test(uaStr);
    s || n || RunTest(/chrome\/([\d\.]+)/i, (r) => {
      C32.Platform.Browser = "Chrome", C32.Platform.BrowserVersion = r[1], C32.Platform.BrowserEngine = "Chromium";
    }), RunTest(/edg\/([\d\.]+)/i, (r) => {
      C32.Platform.Browser = "Edge", C32.Platform.BrowserVersion = r[1], C32.Platform.BrowserEngine = "Chromium";
    }), RunTest(/OPR\/([\d\.]+)/, (r) => {
      C32.Platform.Browser = "Opera", C32.Platform.BrowserVersion = r[1], C32.Platform.BrowserEngine = "Chromium";
    }), RunTest(/chromium\/([\d\.]+)/i, (r) => {
      C32.Platform.Browser = "Chromium", C32.Platform.BrowserVersion = r[1], C32.Platform.BrowserEngine = "Chromium";
    }), RunTest(/nwjs\/[0-9.]+/i, (r) => {
      C32.Platform.Browser = "NW.js", C32.Platform.BrowserVersion = r[1], C32.Platform.BrowserEngine = "Chromium", C32.Platform.Context = "nwjs";
    }), RunTest(/firefox\/([\d\.]+)/i, (r) => {
      C32.Platform.Browser = "Firefox", C32.Platform.BrowserVersion = r[1], C32.Platform.BrowserEngine = "Gecko";
    }), !m || t || a || s || n || i || (C32.Platform.Browser = "Safari", C32.Platform.BrowserEngine = "WebKit", RunTest(/version\/([\d\.]+)/i, (r) => {
      C32.Platform.BrowserVersion = r[1];
    }), RunTest(/crios\/([\d\.]+)/i, (r) => {
      C32.Platform.Browser = "Chrome for iOS", C32.Platform.BrowserVersion = r[1];
    }), RunTest(/fxios\/([\d\.]+)/i, (r) => {
      C32.Platform.Browser = "Firefox for iOS", C32.Platform.BrowserVersion = r[1];
    }), RunTest(/edgios\/([\d\.]+)/i, (r) => {
      C32.Platform.Browser = "Edge for iOS", C32.Platform.BrowserVersion = r[1];
    })), C32.Platform.BrowserEngine === UNKNOWN && l && (C32.Platform.BrowserEngine = "WebKit"), "Android" === C32.Platform.OS && "Safari" === C32.Platform.Browser && (C32.Platform.Browser = "Stock");
    const f = (/* @__PURE__ */ new Set(["Windows", "macOS", "Linux", "Chrome OS"])).has(C32.Platform.OS) || "nwjs" === C32.Platform.Context;
    C32.Platform.IsDesktop = f, C32.Platform.IsMobile = !f;
  }
  "Chrome" === C32.Platform.Browser && "browser" === C32.Platform.Context && /wv\)/.test(uaStr) && (C32.Platform.Context = "webview"), "nwjs" !== C32.Platform.Context && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator["standalone"]) && (C32.Platform.Context = "webapp"), C32.Platform.BrowserVersionNumber = parseFloat(C32.Platform.BrowserVersion);
  const looksLikeIPadOS = "macOS" === C32.Platform.OS && navigator["maxTouchPoints"] && navigator["maxTouchPoints"] > 2;
  looksLikeIPadOS && (C32.Platform.OS = "iOS", C32.Platform.OSVersion = C32.Platform.BrowserVersion, C32.Platform.IsDesktop = false, C32.Platform.IsMobile = true, C32.Platform.IsIpadOS = true), C32.Platform.IsAppleOS = "macOS" === C32.Platform.OS || "iOS" === C32.Platform.OS;
}
var ReadBrandList2;
var RunTest2;
var GetWindowsNTVersionName2;
{
  "use strict";
  {
    let s = function(e2) {
      return new Promise((t2, r2) => {
        e2.onsuccess = () => t2(e2.result), e2.onerror = () => r2(e2.error);
      });
    }, a = function(e2) {
      return new Promise((t2, r2) => {
        e2.oncomplete = () => t2(), e2.onerror = () => r2(e2.error), e2.onabort = () => r2(e2.error);
      });
    }, c = function(e2, t2) {
      return u(e2, t2);
    }, i = function(e2, t2) {
      return u(e2, t2, true);
    }, l = function(e2) {
      f(e2);
      let t2 = r.get(e2);
      return t2 instanceof Promise || (t2 = y(e2), r.set(e2, t2), t2.catch((t3) => r.delete(e2))), t2;
    }, f = function(e2) {
      if ("string" != typeof e2) throw new TypeError("expected string");
    }, d = function(e2, r2) {
      const n2 = e2.objectStore(t).openCursor();
      return new Promise((e3) => {
        const t2 = [];
        n2.onsuccess = (n3) => {
          const o2 = n3.target.result;
          if (o2) {
            switch (r2) {
              case "entries":
                t2.push([o2.key, o2.value]);
                break;
              case "keys":
                t2.push(o2.key);
                break;
              case "values":
                t2.push(o2.value);
            }
            o2.continue();
          } else e3(t2);
        };
      });
    };
    s2 = s, a2 = a, c2 = c, i2 = i, l2 = l, f2 = f, d2 = d;
    const e = 2, t = "keyvaluepairs", r = /* @__PURE__ */ new Map(), n = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll, o = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
    async function u(e2, n2, o2 = false, s3 = true) {
      const a3 = await l(e2);
      try {
        return n2(a3.transaction([t], o2 ? "readwrite" : "readonly"));
      } catch (t2) {
        if (s3 && "InvalidStateError" === t2["name"]) return r.delete(e2), u(e2, n2, o2, false);
        throw t2;
      }
    }
    async function y(r2) {
      f(r2);
      const n2 = indexedDB.open(r2, e);
      return n2.addEventListener("upgradeneeded", (e2) => {
        try {
          e2.target.result.createObjectStore(t);
        } catch (e3) {
          console.error(`Failed to create objectstore for database ${r2}`, e3);
        }
      }), s(n2);
    }
    class m {
      constructor(e2) {
        f(e2), this.name = e2;
      }
      async ready() {
        await l(this.name);
      }
      set(e2, r2) {
        return f(e2), i(this.name, async (n2) => {
          const o2 = s(n2.objectStore(t).put(r2, e2)), c3 = a(n2);
          await Promise.all([c3, o2]);
        });
      }
      get(e2) {
        return f(e2), c(this.name, async (r2) => {
          const n2 = s(r2.objectStore(t).get(e2)), o2 = a(r2), [c3, i3] = await Promise.all([o2, n2]);
          return i3;
        });
      }
      delete(e2) {
        return f(e2), i(this.name, async (r2) => {
          const n2 = s(r2.objectStore(t).delete(e2)), o2 = a(r2);
          await Promise.all([o2, n2]);
        });
      }
      clear() {
        return i(this.name, async (e2) => {
          const r2 = s(e2.objectStore(t).clear()), n2 = a(e2);
          await Promise.all([n2, r2]);
        });
      }
      keys() {
        return c(this.name, async (e2) => {
          let r2;
          if (o) {
            r2 = s(e2.objectStore(t).getAllKeys());
          } else r2 = d(e2, "keys");
          const n2 = a(e2), [c3, i3] = await Promise.all([n2, r2]);
          return i3;
        });
      }
      values() {
        return c(this.name, async (e2) => {
          let r2;
          if (n) {
            r2 = s(e2.objectStore(t).getAll());
          } else r2 = d(e2, "values");
          const o2 = a(e2), [c3, i3] = await Promise.all([o2, r2]);
          return i3;
        });
      }
      entries() {
        return c(this.name, async (e2) => {
          const t2 = d(e2, "entries"), r2 = a(e2), [n2, o2] = await Promise.all([r2, t2]);
          return o2;
        });
      }
    }
    self.KVStorageContainer = m;
  }
}
var s2;
var a2;
var c2;
var i2;
var l2;
var f2;
var d2;
{
  "use strict";
  {
    let r = function(e2) {
      throw new Error(`"${e2}" is not implemented`);
    }, a = function(e2) {
      if ("function" == typeof e2) throw new Error("localforage callback API is not implemented; please use the promise API instead");
    }, o = function(e2) {
      return "object" == typeof e2 ? new Promise((t2) => {
        const { port1: r3, port2: a2 } = new MessageChannel();
        a2.onmessage = (e3) => t2(e3.data), r3.postMessage(e2);
      }) : Promise.resolve(e2);
    };
    r2 = r, a2 = a, o2 = o;
    const e = self.KVStorageContainer, t = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i];
    /* @__PURE__ */ new WeakMap();
    class s {
      constructor(e2) {
        this._inst = e2, this._isInMemory = !this._inst, this._isInMemory || "undefined" != typeof indexedDB || (this._isInMemory = true, console.warn("Unable to use local storage because IndexedDB API is not available")), this._memoryStorage = /* @__PURE__ */ new Map();
      }
      _MaybeSwitchToMemoryFallback(e2) {
        if (!this._isInMemory) {
          for (const r3 of t) if (e2 && r3.test(e2.message)) {
            console.error("Unable to use local storage, reverting to in-memory store: ", e2, e2.message), this._isInMemory = true;
            break;
          }
        }
      }
      async _getItemFallback(e2) {
        const t2 = this._memoryStorage.get(e2), r3 = await o(t2);
        return void 0 === r3 ? null : r3;
      }
      async _setItemFallback(e2, t2) {
        t2 = await o(t2), this._memoryStorage.set(e2, t2);
      }
      _removeItemFallback(e2) {
        this._memoryStorage.delete(e2);
      }
      _clearFallback() {
        this._memoryStorage.clear();
      }
      _keysFallback() {
        return Array.from(this._memoryStorage.keys());
      }
      IsInMemory() {
        return this._isInMemory;
      }
      GetMemoryStorage() {
        return this._memoryStorage;
      }
      SetMemoryStorage(e2) {
        this._memoryStorage = e2;
      }
      async getItem(e2, t2) {
        if (a(t2), this._isInMemory) return await this._getItemFallback(e2);
        let r3;
        try {
          r3 = await this._inst.get(e2);
        } catch (t3) {
          return this._MaybeSwitchToMemoryFallback(t3), this._isInMemory ? await this._getItemFallback(e2) : (console.error(`Error reading '${e2}' from storage, returning null: `, t3), null);
        }
        return void 0 === r3 ? null : r3;
      }
      async setItem(e2, t2, r3) {
        if (a(r3), void 0 === t2 && (t2 = null), this._isInMemory) await this._setItemFallback(e2, t2);
        else try {
          await this._inst.set(e2, t2);
        } catch (r4) {
          if (this._MaybeSwitchToMemoryFallback(r4), !this._isInMemory) throw r4;
          await this._setItemFallback(e2, t2);
        }
      }
      async removeItem(e2, t2) {
        if (a(t2), this._isInMemory) this._removeItemFallback(e2);
        else try {
          await this._inst.delete(e2);
        } catch (t3) {
          this._MaybeSwitchToMemoryFallback(t3), this._isInMemory ? this._removeItemFallback(e2) : console.error(`Error removing '${e2}' from storage: `, t3);
        }
      }
      async clear(e2) {
        if (a(e2), this._isInMemory) this._clearFallback();
        else try {
          await this._inst.clear();
        } catch (e3) {
          this._MaybeSwitchToMemoryFallback(e3), this._isInMemory ? this._clearFallback() : console.error("Error clearing storage: ", e3);
        }
      }
      async keys(e2) {
        if (a(e2), this._isInMemory) return this._keysFallback();
        let t2 = [];
        try {
          t2 = await this._inst.keys();
        } catch (e3) {
          if (this._MaybeSwitchToMemoryFallback(e3), this._isInMemory) return this._keysFallback();
          console.error("Error getting storage keys: ", e3);
        }
        return t2;
      }
      ready(e2) {
        return a(e2), this._isInMemory ? Promise.resolve(true) : this._inst.ready();
      }
      createInstance(t2) {
        if (t2.forceInMemoryFallback) return new s(null);
        {
          const r3 = t2.name;
          if ("string" != typeof r3) throw new TypeError("invalid store name");
          const a2 = new e(r3);
          return new s(a2);
        }
      }
      length(e2) {
        r("localforage.length()");
      }
      key(e2, t2) {
        r("localforage.key()");
      }
      iterate(e2, t2) {
        r("localforage.iterate()");
      }
      setDriver(e2) {
        r("localforage.setDriver()");
      }
      config(e2) {
        r("localforage.config()");
      }
      defineDriver(e2) {
        r("localforage.defineDriver()");
      }
      driver() {
        r("localforage.driver()");
      }
      supports(e2) {
        r("localforage.supports()");
      }
      dropInstance() {
        r("localforage.dropInstance()");
      }
    }
    self["localforage"] = new s(new e("localforage"));
  }
}
var r2;
var a2;
var o2;
{
  const C32 = self.C3;
  if (C32.Supports = {}, C32.Supports.WebAnimations = (() => {
    try {
      if ("undefined" == typeof document) return false;
      const e = document.createElement("div");
      if (void 0 === e.animate) return false;
      return void 0 !== e.animate([{ opacity: "0" }, { opacity: "1" }], 1e3).reverse;
    } catch (e) {
      return false;
    }
  })(), C32.Supports.DialogElement = "undefined" != typeof HTMLDialogElement, C32.Supports.RequestIdleCallback = !!self.requestIdleCallback, C32.Supports.ImageBitmap = !!self.createImageBitmap, C32.Supports.ImageBitmapOptions = false, C32.Supports.ImageBitmapOptionsResize = false, C32.Supports.ImageBitmap) {
    try {
      self.createImageBitmap(new ImageData(32, 32), { "premultiplyAlpha": "none" }).then(() => {
        C32.Supports.ImageBitmapOptions = true;
      }).catch(() => {
        C32.Supports.ImageBitmapOptions = false;
      });
    } catch (e) {
      C32.Supports.ImageBitmapOptions = false;
    }
    try {
      self.createImageBitmap(new ImageData(32, 32), { "resizeWidth": 10, "resizeHeight": 10 }).then((e) => {
        C32.Supports.ImageBitmapOptionsResize = 10 === e.width && 10 === e.height;
      }).catch(() => {
        C32.Supports.ImageBitmapOptionsResize = false;
      });
    } catch (e) {
      C32.Supports.ImageBitmapOptionsResize = false;
    }
  }
  if (C32.Supports.ClipboardReadText = !(!navigator["clipboard"] || !navigator["clipboard"]["readText"]), C32.Supports.PermissionsQuery = !(!navigator["permissions"] || !navigator["permissions"]["query"]), C32.Supports.ClipboardPermissionsQuery = false, C32.Supports.PermissionsQuery) {
    const e = { "name": "clipboard-read" };
    navigator["permissions"]["query"](e).then(() => {
      C32.Supports.ClipboardPermissionsQuery = true;
    }).catch(() => {
      C32.Supports.ClipboardPermissionsQuery = false;
    });
  }
  C32.Supports.AsyncClipboardApi = !!(navigator["permissions"] && navigator["clipboard"] && self["ClipboardItem"]), C32.Supports.Proxies = "undefined" != typeof Proxy, C32.Supports.DownloadAttribute = (() => {
    if ("undefined" == typeof document) return false;
    return void 0 !== document.createElement("a").download;
  })(), C32.Supports.Fetch = "function" == typeof fetch, C32.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== C32.Platform.Browser && navigator["storage"] && navigator["storage"]["persist"]), C32.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator["storage"] && navigator["storage"]["estimate"]), C32.Supports.Fullscreen = (() => {
    if ("undefined" == typeof document) return false;
    if ("iOS" === C32.Platform.OS) return false;
    const e = document.documentElement;
    return !!(e.requestFullscreen || e.msRequestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen);
  })(), C32.Supports.ImageDecoder = void 0 !== self["ImageDecoder"], C32.Supports.WebCodecs = !!self["VideoEncoder"], C32.Supports.NativeFileSystemAPI = !!self["showOpenFilePicker"], C32.Supports.QueryLocalFonts = !!self["queryLocalFonts"], C32.Supports.UserActivation = !!navigator["userActivation"], C32.Supports.CanvasToBlobWebP = false, (async () => {
    let e;
    "undefined" == typeof document ? e = new OffscreenCanvas(32, 32) : (e = document.createElement("canvas"), e.width = 32, e.height = 32);
    const t = e.getContext("2d");
    t.fillStyle = "blue", t.fillRect(0, 0, 32, 32);
    let o = null;
    try {
      e["convertToBlob"] ? o = await e["convertToBlob"]({ "type": "image/webp", "quality": 1 }) : e.toBlob && (o = await new Promise((t2) => e.toBlob(t2, "image/webp", 1))), C32.Supports.CanvasToBlobWebP = o && "image/webp" === o.type;
    } catch (e2) {
      C32.Supports.CanvasToBlobWebP = false;
    }
  })();
}
{
  const C32 = self.C3;
  String.prototype.replaceAll || (String.prototype.replaceAll = function(t, e) {
    return this.replace(new RegExp(C32.EscapeRegex(t), "g"), e);
  }), Array.prototype.at || (Array.prototype.at = function(t) {
    if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
  }), String.prototype.at || (String.prototype.at = function(t) {
    if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
  }), RegExp.escape || (RegExp.escape = function(t) {
    return String(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
  }), Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t) {
    if (!(t instanceof Set)) throw new TypeError("argument must be a Set");
    for (const e of this) if (!t.has(e)) return false;
    return true;
  }), navigator["storage"] && !navigator["storage"]["estimate"] && navigator["webkitTemporaryStorage"] && navigator["webkitTemporaryStorage"]["queryUsageAndQuota"] && (navigator["storage"]["estimate"] = function() {
    return new Promise((t, e) => navigator["webkitTemporaryStorage"]["queryUsageAndQuota"]((e2, r) => t({ "usage": e2, "quota": r }), e));
  });
}
{
  let assertFail = function(e) {
    let s = "Assertion failure: " + e + "\n\nStack trace:\n" + C32.GetCallStack();
    console.error(s);
  };
  assertFail2 = assertFail;
  const C32 = self.C3;
  self.assert = function(e, s) {
    e || assertFail(s);
  };
}
var assertFail2;
{
  const C32 = self.C3, C3X = self.C3X;
  C32.IsNumber = function(e) {
    return "number" == typeof e;
  }, C32.IsFiniteNumber = function(e) {
    return C32.IsNumber(e) && isFinite(e);
  }, C32.RequireNumber = function(e) {
    if (!C32.IsNumber(e)) throw new TypeError("expected number");
  }, C32.RequireOptionalNumber = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireNumberInRange = function(e, n, r) {
    if (!C32.IsNumber(e) || isNaN(e) || n > e || r < e) throw new RangeError("number outside of range");
  }, C32.RequireAllNumber = function(...e) {
    for (let n of e) ;
  }, C32.RequireFiniteNumber = function(e) {
    if (!C32.IsFiniteNumber(e)) throw new TypeError("expected finite number");
  }, C32.RequireOptionalFiniteNumber = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllFiniteNumber = function(...e) {
    for (let n of e) ;
  }, C32.IsString = function(e) {
    return "string" == typeof e;
  }, C32.RequireString = function(e) {
    if (!C32.IsString(e)) throw new TypeError("expected string");
  }, C32.RequireOptionalString = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllString = function(...e) {
    for (let n of e) ;
  }, C32.IsSimpleObject = function(e) {
    if ("object" != typeof e || null === e) return false;
    let n = Object.getPrototypeOf(e);
    return n ? n.constructor === Object : null === n;
  }, C32.RequireSimpleObject = function(e) {
    if (!C32.IsSimpleObject(e)) throw new TypeError("expected simple object");
  }, C32.RequireOptionalSimpleObject = function(e) {
    if (!C32.IsNullOrUndefined(e) && !C32.IsSimpleObject(e)) throw new TypeError("expected simple object");
  }, C32.IsObject = function(e) {
    return "object" == typeof e && null !== e && !Array.isArray(e);
  }, C32.RequireObject = function(e) {
    if (!C32.IsObject(e)) throw new TypeError("expected object");
  }, C32.RequireOptionalObject = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllObject = function(...e) {
    for (let n of e) ;
  }, C32.IsFileLike = function(e) {
    return C32.WeakIsInstanceOf(e, Blob) && "string" == typeof e["name"];
  }, C32.RequireFileLike = function(e) {
    if (!C32.IsFileLike(e)) throw new TypeError("expected file");
  }, C32.RequireOptionalFileLike = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.IsArray = function(e) {
    return Array.isArray(e);
  }, C32.RequireArray = function(e) {
    if (!C32.IsArray(e)) throw new TypeError("expected array");
  }, C32.RequireOptionalArray = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllArray = function(...e) {
    for (let n of e) ;
  }, C32.Is2DArray = function(e) {
    return !!C32.IsArray(e) && (!e.length || !!C32.IsArray(e[0]));
  }, C32.Require2DArray = function(e) {
    if (!C32.Is2DArray(e)) throw new TypeError("expected 2d array");
    for (let n of e) if (!C32.IsArray(n)) throw new TypeError("expected 2d array");
  }, C32.RequireOptional2DArray = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.IsFunction = function(e) {
    return "function" == typeof e;
  }, C32.RequireFunction = function(e, n) {
    if (!C32.IsFunction(e)) throw new TypeError("expected function");
    if (!C32.IsNullOrUndefined(n) && e !== n) throw new TypeError("expected same function reference");
  }, C32.RequireOptionalFunction = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllFunction = function(...e) {
    for (let n of e) ;
  }, C32.RequireAnyFunction = function(e, ...n) {
    if (!C32.IsFunction(e)) throw new TypeError("expected function");
    if (!n.length) throw new Error("missing comparison functions");
    for (let r of n) if (!C32.IsNullOrUndefined(r) && e === r) return;
    throw new TypeError("expected same function reference");
  }, C32.RequireOptionalAllFunction = function(...e) {
    if (!C32.IsNullOrUndefined(e)) for (let n of e) ;
  }, C32.IsInstanceOf = function(e, n) {
    return e instanceof n;
  }, C32.IsInstanceOfAny = function(e, ...n) {
    for (let r of n) if (C32.IsInstanceOf(e, r)) return true;
    return false;
  }, C32.RequireInstanceOf = function(e, n) {
    if (!C32.IsInstanceOf(e, n)) throw new TypeError("unexpected type");
  }, C32.RequireOptionalInstanceOf = function(e, n) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllInstanceOf = function(e, ...n) {
    for (let e2 of n) ;
  }, C32.RequireAnyInstanceOf = function(e, ...n) {
    if (!C32.IsInstanceOfAny(e, ...n)) throw new TypeError("unexpected type");
  }, C32.RequireAnyOptionalInstanceOf = function(e, ...n) {
    if (!C32.IsNullOrUndefined(e) && !C32.IsInstanceOfAny(e, ...n)) throw new TypeError("unexpected type");
  }, C32.IsArrayOf = function(e, n) {
    for (let r of e) if (!C32.IsInstanceOf(r, n)) return false;
    return true;
  }, C32.IsArrayOfFiniteNumbers = function(e) {
    for (let n of e) if (!C32.IsFiniteNumber(n)) return false;
    return true;
  }, C32.RequireArrayOf = function(e, n) {
    for (let n2 of e) ;
  }, C32.RequireOptionalArrayOf = function(e, n) {
    if (!C32.IsNullOrUndefined(e)) for (let n2 of e) ;
  }, C32.RequireOptionalArrayOfFunctions = function(e, n) {
    if (!C32.IsNullOrUndefined(e)) for (let n2 of e) ;
  }, C32.RequireArrayOfAny = function(e, ...n) {
    for (let n2 of e) ;
  }, C32.RequireOptionalArrayOfAny = function(e, ...n) {
    if (!C32.IsNullOrUndefined(e)) for (let n2 of e) ;
  }, C32.IsDOMNode = function(e, n) {
    return !(C32.IsNullOrUndefined(e) || !C32.IsString(e.nodeName)) && (!n || C32.equalsNoCase(e.nodeName, n));
  }, C32.RequireDOMNode = function(e, n) {
    if (C32.IsNullOrUndefined(e) || !C32.IsString(e.nodeName)) throw new TypeError("expected DOM node");
    if (n && !C32.equalsNoCase(e.nodeName, n)) throw new TypeError(`expected DOM '${n}' node`);
  }, C32.RequireOptionalDOMNode = function(e, n) {
    C32.IsNullOrUndefined(e);
  }, C32.IsHTMLElement = function(e, n) {
    return !(C32.IsNullOrUndefined(e) || !C32.IsString(e.tagName)) && (!n || C32.equalsNoCase(e.tagName, n));
  }, C32.RequireHTMLElement = function(e, n) {
    if (C32.IsNullOrUndefined(e) || !C32.IsString(e.tagName)) throw new TypeError("expected HTML element");
    if (n && !C32.equalsNoCase(e.tagName, n)) throw new TypeError(`expected HTML '${n}' element`);
  }, C32.RequireOptionalHTMLElement = function(e, n) {
    C32.IsNullOrUndefined(e);
  }, C32.IsDrawable = function(e) {
    return C32.IsHTMLElement(e, "img") || C32.IsHTMLElement(e, "canvas") || C32.IsHTMLElement(e, "video") || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap;
  }, C32.RequireDrawable = function(e) {
    if (!C32.IsDrawable(e)) throw new TypeError("expected drawable");
  }, C32.RequireOptionalDrawable = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.IsDrawableOrImageData = function(e) {
    return e instanceof ImageData || C32.IsDrawable(e);
  }, C32.RequireDrawableOrImageData = function(e) {
    if (!C32.IsDrawableOrImageData(e)) throw new TypeError("expected drawable or image data");
  }, C32.RequireOptionalDrawableOrImageData = function(e) {
    if (!C32.IsNullOrUndefined(e) && !C32.IsDrawableOrImageData(e)) throw new TypeError("expected drawable or image data");
  }, C32.IsStringLike = function(e) {
    return "string" == typeof e || C32.HtmlString && e instanceof C32.HtmlString || e instanceof C32.BBString;
  }, C32.RequireStringLike = function(e) {
    if (!C32.IsStringLike(e)) throw new TypeError("expected string-like");
  }, C32.RequireOptionalStringLike = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllStringLike = function(...e) {
    for (let n of e) ;
  }, C32.RequireOverride = function() {
    throw new Error("must be overridden");
  }, C32.NotYetImplemented = function() {
    throw new Error("not yet implemented");
  }, C32.IsGeneratorFunction = function(e) {
    return e.constructor === function* () {
    }.constructor;
  }, C32.RequireGeneratorFunction = function(e) {
    if (!C32.IsGeneratorFunction(e)) throw new Error("expected generator function");
  }, C32.IsIterable = function(e) {
    return "function" === e[Symbol.iterator];
  }, C32.RequireIterable = function(e) {
    if (!C32.IsIterable(e)) throw new Error("expected iterable");
  }, C32.IsDefined = function(e) {
    return !C32.IsNullOrUndefined(e);
  }, C32.IsNullOrUndefined = function(e) {
    return null == e;
  }, C32.AreArrayElementsOfSameType = function(e) {
    let n = e[0].constructor;
    for (let r of e) if (r.constructor !== n) return false;
    return n;
  }, C32.AreArrayElementsOfType = function(e, n) {
    for (let r of e) if (!(r instanceof n)) return false;
    return true;
  };
  const TypedArray = Object.getPrototypeOf(Uint8Array);
  C32.IsTypedArray = function(e) {
    return C32.IsInstanceOf(e, TypedArray);
  }, C32.RequireTypedArray = function(e) {
  }, C32.WeakRequireTypedArray = function(e) {
    C32.WeakRequireInstanceOf(e, TypedArray);
  }, C32.WeakRequireAnyInstanceOf = function(e, ...n) {
    if (!C32.WeakIsAnyInstanceOf(e, ...n)) throw new TypeError("unexpected type");
  }, C32.WeakIsAnyInstanceOf = function(e, ...n) {
    for (const r of n) if (C32.WeakIsInstanceOf(e, r)) return true;
    return false;
  }, C32.WeakRequireInstanceOf = function(e, n) {
    if (!C32.WeakIsInstanceOf(e, n)) throw new TypeError("unexpected type");
  }, C32.WeakIsInstanceOf = function(e, n) {
    for (; e = Object.getPrototypeOf(e); ) if (e.constructor.name === n.name) return true;
    return false;
  }, C3X.RequireNumber = C32.RequireNumber, C3X.RequireOptionalNumber = C32.RequireOptionalNumber, C3X.RequireFiniteNumber = C32.RequireFiniteNumber, C3X.RequireOptionalFiniteNumber = C32.RequireOptionalFiniteNumber, C3X.RequireString = C32.RequireString, C3X.RequireOptionalString = C32.RequireOptionalString, C3X.RequireObject = C32.RequireObject, C3X.RequireOptionalObject = C32.RequireOptionalObject, C3X.RequireArray = C32.RequireArray, C3X.RequireOptionalArray = C32.RequireOptionalArray, C3X.RequireFunction = C32.RequireFunction, C3X.RequireOptionalFunction = C32.RequireOptionalFunction, C3X.RequireInstanceOf = C32.RequireInstanceOf, C3X.RequireOptionalInstanceOf = C32.RequireOptionalInstanceOf, C3X.IsNullOrUndefined = C32.IsNullOrUndefined;
}
{
  let isValidTypeChange = function(e, t) {
    let r = C32.getType(e), n = C32.getType(t);
    return "null" === r || "null" === n || "undefined" !== r && "undefined" !== n && r === n;
  }, logDefendedObjectWarning = function(e) {
    console.warn("[Defence] " + e + " @", C32.GetCallStack());
  }, CheckDefendedObjectsUsedCorrectly = function() {
    if (checkRafId = -1, ctorObjectToProxy.size > 0 || ctorProxyToObject.size > 0) {
      let e = [...new Set([...ctorObjectToProxy.keys()].map((e2) => C32.getName(e2)))].join(",");
      console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${e}`), ctorObjectToProxy.clear(), ctorProxyToObject.clear();
    }
  }, getObjectPropertySet = function(e) {
    let t = /* @__PURE__ */ new Set();
    for (let r in e) t.add(r);
    return t;
  }, VerifyObjectPropertiesConsistent = function(e, t) {
    let r = getObjectPropertySet(t), n = typeProperties.get(e);
    if (n) {
      let t2 = [];
      for (let e2 of n.values()) r.has(e2) ? r.delete(e2) : t2.push(e2);
      C32.appendArray(t2, [...r]), t2.length && console.warn(`[Defence] '${C32.getName(e)}' constructor creates inconsistent properties: ${t2.join(", ")}`);
    } else typeProperties.set(e, r);
  };
  isValidTypeChange2 = isValidTypeChange, logDefendedObjectWarning2 = logDefendedObjectWarning, CheckDefendedObjectsUsedCorrectly2 = CheckDefendedObjectsUsedCorrectly, getObjectPropertySet2 = getObjectPropertySet, VerifyObjectPropertiesConsistent2 = VerifyObjectPropertiesConsistent;
  const C32 = self.C3, logRafIds = /* @__PURE__ */ new Map();
  let measures;
  C32.ColorLog = function(e, t) {
    console.log(`%c${e}`, `font-weight: bold; color:${t}`);
  }, C32.RafLog = function(e, ...t) {
    logRafIds.has(e) || logRafIds.set(e, -1), -1 === logRafIds.get(e) && logRafIds.set(e, requestAnimationFrame(() => {
      console.log(`%c${e}`, "font-weight: bold", ...t), logRafIds.set(e, -1);
    }));
  }, C32.StartMeasure = function(e) {
    performance.mark(e), measures || (measures = /* @__PURE__ */ new Map()), measures.has(e) || measures.set(e, { current: 0, total: 0, average: 0, calls: 1, toString: function() {
      return `${e} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`;
    } });
  }, C32.EndMeasure = function(e) {
    performance.measure(`measure-${e}`, e);
    const t = performance.getEntriesByName(`measure-${e}`)[0], r = measures.get(e);
    r.current = t.duration, r.total += r.current, r.average = r.total / r.calls, console.log(r.toString()), r.calls++, performance.clearMarks(e), performance.clearMeasures(`measure-${e}`);
  }, C32.GetCallStack = function() {
    return new Error().stack;
  }, C32.Debugger = function() {
  }, C32.cast = function(e, t) {
    return e && e instanceof t ? e : null;
  }, C32.getName = function(e) {
    return void 0 === e ? "undefined" : null === e ? "null" : "boolean" == typeof e ? "<boolean>" : C32.IsNumber(e) ? "<number>" : C32.IsString(e) ? "<string>" : C32.IsArray(e) ? "<array>" : "symbol" == typeof e ? "<" + e.toString() + ">" : C32.IsFunction(e) ? e.name && "Function" !== e.name ? e.name : "<anonymous function>" : "object" == typeof e ? e.constructor && e.constructor.name && "Object" !== e.constructor.name ? e.constructor.name : "<anonymous object>" : "<unknown>";
  }, C32.getType = function(e) {
    return null === e ? "null" : Array.isArray(e) ? "array" : typeof e;
  }, C32.range = function* (e, t) {
    if (!isFinite(Math.abs(e - t))) throw new Error("Invalid parameters");
    if (e > t) for (let r = e - 1; r >= t; r--) yield r;
    else for (let r = e; r < t; r++) yield r;
  };
  let ctorObjectToProxy = /* @__PURE__ */ new Map(), ctorProxyToObject = /* @__PURE__ */ new Map(), proxyToObject = /* @__PURE__ */ new WeakMap(), releasedObjects = /* @__PURE__ */ new WeakMap();
  C32.DefendHandler = {};
  const VALID_GET_MISSING_KEYS = /* @__PURE__ */ new Set(["then", "splice"]);
  C32.DefendHandler.get = function(e, t) {
    return t in e || "symbol" == typeof t || VALID_GET_MISSING_KEYS.has(t) || logDefendedObjectWarning(`Accessed missing property '${t}' from defended object '${C32.getName(e)}', returning undefined`), releasedObjects.has(e) && "symbol" != typeof t && !VALID_GET_MISSING_KEYS.has(t) && logDefendedObjectWarning(`Accessed property '${t}' on a released object '${C32.getName(e)}'
Object was originally released at: ${releasedObjects.get(e)})
Call stack at access: `), e[t];
  }, C32.DefendHandler.set = function(e, t, r) {
    return t in e || ctorObjectToProxy.has(e) || logDefendedObjectWarning(`Set non-existent property '${t}' to '${r}' on defended object '${C32.getName(e)}'`), isValidTypeChange(e[t], r) || ctorObjectToProxy.has(e) || logDefendedObjectWarning(`Set '${C32.getType(e[t])}' property '${t}' to type '${C32.getType(r)}' on defended object '${C32.getName(e)}'`), releasedObjects.has(e) && logDefendedObjectWarning(`Set property '${t}' on a released object '${C32.getName(e)}'
Object was originally released at: ${releasedObjects.get(e)})
Call stack at access: `), e[t] = r, true;
  }, C32.DefendHandler.deleteProperty = function(e, t) {
    throw new ReferenceError(`Cannot delete property '${t}' from defended object '${C32.getName(e)}'`);
  }, C32.DefendHandler.defineProperty = function(e, t, r) {
    throw new ReferenceError(`Cannot define property '${t}' on defended object '${C32.getName(e)}'`);
  }, C32.DefendHandler.enumerate = function(e) {
    throw new ReferenceError(`Cannot enumerate defended object '${C32.getName(e)}'`);
  };
  let checkRafId = -1;
  C32.DefendedBase = class {
    constructor() {
      if (!C32.isDebugDefend || !C32.Supports.Proxies) return;
      let e = new.target, t = Object.create(e.prototype), r = new Proxy(t, C32.DefendHandler);
      return ctorObjectToProxy.set(t, r), ctorProxyToObject.set(r, t), proxyToObject.set(r, t), -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly)), r;
    }
  }, C32.debugDefend = function(e) {
    if (C32.isDebugDefend && C32.Supports.Proxies && e instanceof C32.DefendedBase) {
      if (!ctorProxyToObject.has(e)) return e;
      let t = ctorProxyToObject.get(e);
      return ctorProxyToObject.delete(e), ctorObjectToProxy.delete(t), e;
    }
    return C32.isDebug ? Object.seal(e) : e;
  }, C32.New = function(e, ...t) {
    let r;
    try {
      r = new e(...t);
    } catch (e2) {
      throw ctorProxyToObject.clear(), ctorObjectToProxy.clear(), e2;
    }
    return C32.isDebugDefend && VerifyObjectPropertiesConsistent(e, r), C32.debugDefend(r);
  }, C32.Release = function(e) {
    let t = proxyToObject.get(e);
    t && releasedObjects.set(t, C32.GetCallStack());
  }, C32.WasReleased = function(e) {
    let t = proxyToObject.get(e);
    return !!t && !!releasedObjects.get(t);
  };
  let typeProperties = /* @__PURE__ */ new Map();
  C32.PerfMark = class {
    constructor(e) {
      this._name = "", e && this.start(e);
    }
    start(e) {
      C32.isPerformanceProfiling && (this._name = e, performance.mark(this._name + "-Start"));
    }
    end() {
      C32.isPerformanceProfiling && (performance.mark(this._name + "-End"), performance.measure(this._name, this._name + "-Start", this._name + "-End"));
    }
    next(e) {
      C32.isPerformanceProfiling && (this.end(), this._name = e, performance.mark(this._name + "-Start"));
    }
  };
}
var isValidTypeChange2;
var logDefendedObjectWarning2;
var CheckDefendedObjectsUsedCorrectly2;
var getObjectPropertySet2;
var VerifyObjectPropertiesConsistent2;
{
  let isNegativeZero = function(t) {
    return 0 === t && 1 / t < 0;
  };
  isNegativeZero2 = isNegativeZero;
  const C32 = self.C3, TWO_PI = 2 * Math.PI, D_TO_R = Math.PI / 180, R_TO_D = 180 / Math.PI;
  C32.wrap = function(t, n, e) {
    t = Math.floor(t), n = Math.floor(n);
    const r = (e = Math.floor(e)) - n;
    if (0 === r) return e;
    if (t < n) {
      const a = e - (n - t) % r;
      return a === e ? 0 : a;
    }
    return n + (t - n) % r;
  }, C32.mapToRange = function(t, n, e, r, a) {
    const o = e - n;
    if (0 === o && 0 === r) return t;
    return (t - n) * (a - r) / o + r;
  }, C32.normalize = function(t, n, e) {
    return n - e === 0 ? 1 : (t - n) / (e - n);
  }, C32.clamp = function(t, n, e) {
    return t < n ? n : t > e ? e : t;
  }, C32.clampAngle = function(t) {
    return (t %= TWO_PI) < 0 && (t += TWO_PI), t;
  }, C32.toRadians = function(t) {
    return t * D_TO_R;
  }, C32.toDegrees = function(t) {
    return t * R_TO_D;
  }, C32.hypot2DFast = function(t, n) {
    return Math.sqrt(t * t + n * n);
  }, C32.hypot3DFast = function(t, n, e) {
    return Math.sqrt(t * t + n * n + e * e);
  }, C32.distanceTo = function(t, n, e, r) {
    return C32.hypot2DFast(e - t, r - n);
  }, C32.distanceSquared = function(t, n, e, r) {
    const a = e - t, o = r - n;
    return a * a + o * o;
  }, C32.angleTo = function(t, n, e, r) {
    return Math.atan2(r - n, e - t);
  }, C32.angleDiff = function(t, n) {
    if (t === n) return 0;
    let e = Math.sin(t), r = Math.cos(t), a = e * Math.sin(n) + r * Math.cos(n);
    return a >= 1 ? 0 : a <= -1 ? Math.PI : Math.acos(a);
  }, C32.angleRotate = function(t, n, e) {
    let r = Math.sin(t), a = Math.cos(t), o = Math.sin(n), c = Math.cos(n);
    return Math.acos(r * o + a * c) > e ? a * o - r * c > 0 ? C32.clampAngle(t + e) : C32.clampAngle(t - e) : C32.clampAngle(n);
  }, C32.angleClockwise = function(t, n) {
    let e = Math.sin(t);
    return Math.cos(t) * Math.sin(n) - e * Math.cos(n) <= 0;
  }, C32.angleLerp = function(t, n, e, r = 0) {
    let a = C32.angleDiff(t, n);
    const o = TWO_PI * r;
    return C32.angleClockwise(n, t) ? C32.clampAngle(t + (a + o) * e) : C32.clampAngle(t - (a + o) * e);
  }, C32.angleLerpClockwise = function(t, n, e, r = 0) {
    const a = C32.angleDiff(t, n), o = TWO_PI * r;
    return C32.angleClockwise(n, t) ? C32.clampAngle(t + (a + o) * e) : C32.clampAngle(t + (TWO_PI - a + o) * e);
  }, C32.angleLerpAntiClockwise = function(t, n, e, r = 0) {
    const a = C32.angleDiff(t, n), o = TWO_PI * r;
    return C32.angleClockwise(n, t) ? C32.clampAngle(t - (-TWO_PI + a - o) * e) : C32.clampAngle(t - (a + o) * e);
  }, C32.angleReflect = function(t, n) {
    const e = C32.angleDiff(t, n);
    return C32.angleClockwise(t, n) ? C32.clampAngle(n - e) : C32.clampAngle(n + e);
  }, C32.lerp = function(t, n, e) {
    return t + e * (n - t);
  }, C32.unlerp = function(t, n, e) {
    return t === n ? 0 : (e - t) / (n - t);
  }, C32.relerp = function(t, n, e, r, a) {
    return C32.lerp(r, a, C32.unlerp(t, n, e));
  }, C32.qarp = function(t, n, e, r) {
    return C32.lerp(C32.lerp(t, n, r), C32.lerp(n, e, r), r);
  }, C32.cubic = function(t, n, e, r, a) {
    return C32.lerp(C32.qarp(t, n, e, a), C32.qarp(n, e, r, a), a);
  }, C32.cosp = function(t, n, e) {
    return (t + n + (t - n) * Math.cos(e * Math.PI)) / 2;
  }, C32.isPOT = function(t) {
    return t > 0 && !(t - 1 & t);
  }, C32.nextHighestPowerOfTwo = function(t) {
    --t;
    for (let n = 1; n < 32; n <<= 1) t |= t >> n;
    return t + 1;
  }, C32.roundToNearestFraction = function(t, n) {
    return Math.round(t * n) / n;
  }, C32.floorToNearestFraction = function(t, n) {
    return Math.floor(t * n) / n;
  }, C32.roundToDp = function(t, n) {
    n = Math.max(Math.floor(n), 0);
    const e = Math.pow(10, n);
    return Math.round(t * e) / e;
  }, C32.countDecimals = function(t) {
    return Math.floor(t) !== t && t.toString().split(".")[1].length || 0;
  }, C32.toFixed = function(t, n) {
    let e = t.toFixed(n), r = e.length - 1;
    for (; r >= 0 && "0" === e.charAt(r); --r) ;
    return r >= 0 && "." === e.charAt(r) && --r, r < 0 ? e : e.substr(0, r + 1);
  }, C32.PackRGB = function(t, n, e) {
    return C32.clamp(t, 0, 255) | C32.clamp(n, 0, 255) << 8 | C32.clamp(e, 0, 255) << 16;
  };
  const ALPHAEX_SHIFT = 1024, ALPHAEX_MAX = 1023, RGBEX_SHIFT = 16384, RGBEX_MAX = 8191, RGBEX_MIN = -8192;
  C32.PackRGBAEx = function(t, n, e, r) {
    return (t = C32.clamp(Math.floor(1024 * t), -8192, 8191)) < 0 && (t += 16384), (n = C32.clamp(Math.floor(1024 * n), -8192, 8191)) < 0 && (n += 16384), (e = C32.clamp(Math.floor(1024 * e), -8192, 8191)) < 0 && (e += 16384), -(16384 * t * 16384 * 1024 + 16384 * n * 1024 + 1024 * e + (r = C32.clamp(Math.floor(1023 * r), 0, 1023)));
  }, C32.PackRGBEx = function(t, n, e) {
    return C32.PackRGBAEx(t, n, e, 1);
  }, C32.GetRValue = function(t) {
    if (t >= 0) return (255 & t) / 255;
    {
      let n = Math.floor(-t / 274877906944);
      return n > 8191 && (n -= 16384), n / 1024;
    }
  }, C32.GetGValue = function(t) {
    if (t >= 0) return ((65280 & t) >> 8) / 255;
    {
      let n = Math.floor(-t % 274877906944 / 16777216);
      return n > 8191 && (n -= 16384), n / 1024;
    }
  }, C32.GetBValue = function(t) {
    if (t >= 0) return ((16711680 & t) >> 16) / 255;
    {
      let n = Math.floor(-t % 16777216 / 1024);
      return n > 8191 && (n -= 16384), n / 1024;
    }
  }, C32.GetAValue = function(t) {
    if (isNegativeZero(t)) return 0;
    if (t >= 0) return 1;
    return Math.floor(-t % 1024) / 1023;
  }, C32.greatestCommonDivisor = function(t, n) {
    for (t = Math.floor(t), n = Math.floor(n); 0 !== n; ) {
      let e = n;
      n = t % n, t = e;
    }
    return t;
  };
  const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
  C32.getAspectRatio = function(t, n) {
    if ((t = Math.floor(t)) === (n = Math.floor(n))) return [1, 1];
    for (let e2 of COMMON_ASPECT_RATIOS) {
      let r = t / e2[0] * e2[1];
      if (Math.abs(n - r) < 1) return e2.slice(0);
      if (r = t / e2[1] * e2[0], Math.abs(n - r) < 1) return [e2[1], e2[0]];
    }
    let e = C32.greatestCommonDivisor(t, n);
    return [t / e, n / e];
  }, C32.segmentsIntersect = function(t, n, e, r, a, o, c, u) {
    const i = Math.min(t, e), l = Math.max(t, e), s = Math.min(a, c), C = Math.max(a, c);
    if (l < s || i > C) return false;
    const f = Math.min(n, r), h = Math.max(n, r), M = Math.min(o, u), g = Math.max(o, u);
    if (h < M || f > g) return false;
    const m = a - t + c - e, p = o - n + u - r, I = e - t, T = r - n, P = c - a, A = u - o, _ = Math.abs(T * P - A * I), x = P * p - A * m;
    if (Math.abs(x) > _) return false;
    const O = I * p - T * m;
    return Math.abs(O) <= _;
  }, C32.segmentsIntersectPreCalc = function(t, n, e, r, a, o, c, u, i, l, s, C) {
    const f = Math.min(i, s), h = Math.max(i, s);
    if (o < f || a > h) return false;
    const M = Math.min(l, C), g = Math.max(l, C);
    if (u < M || c > g) return false;
    const m = i - t + s - e, p = l - n + C - r, I = e - t, T = r - n, P = s - i, A = C - l, _ = Math.abs(T * P - A * I), x = P * p - A * m;
    if (Math.abs(x) > _) return false;
    const O = I * p - T * m;
    return Math.abs(O) <= _;
  }, C32.segmentIntersectsQuad = function(t, n, e, r, a) {
    const o = Math.min(t, e), c = Math.max(t, e), u = Math.min(n, r), i = Math.max(n, r), l = a.getTlx(), s = a.getTly(), C = a.getTrx(), f = a.getTry(), h = a.getBrx(), M = a.getBry(), g = a.getBlx(), m = a.getBly();
    return C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, l, s, C, f) || C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, C, f, h, M) || C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, h, M, g, m) || C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, g, m, l, s);
  }, C32.segmentIntersectsAnyN = function(t, n, e, r, a) {
    const o = Math.min(t, e), c = Math.max(t, e), u = Math.min(n, r), i = Math.max(n, r);
    let l = 0;
    for (let s = a.length - 4; l <= s; l += 2) if (C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, a[l], a[l + 1], a[l + 2], a[l + 3])) return true;
    return C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, a[l], a[l + 1], a[0], a[1]);
  };
  const NO_HIT = 2, PADDING = 1e-6;
  C32.rayIntersect = function(t, n, e, r, a, o, c, u) {
    const i = e - t, l = u - o, s = i * l - (r - n) * (c - a);
    if (0 === s) return 2;
    const C = ((n - r) * (c - t) + i * (u - n)) / s;
    return 0 < C && C < 1.000001 ? (l * (c - t) + (a - c) * (u - n)) / s : 2;
  }, C32.rayIntersectExtended = function(t, n, e, r, a, o, c, u, i) {
    const l = (c - a) * i, s = (u - o) * i;
    return C32.rayIntersect(t, n, e, r, a - l, o - s, c + l, u + s);
  }, C32.isPointInTriangleInclusive = function(t, n, e, r, a, o, c, u) {
    const i = a - e, l = o - r, s = c - e, C = u - r, f = t - e, h = n - r, M = i * i + l * l, g = i * s + l * C, m = i * f + l * h, p = s * s + C * C, I = s * f + C * h, T = 1 / (M * p - g * g), P = (p * m - g * I) * T, A = (M * I - g * m) * T;
    return P >= 0 && A >= 0 && P + A <= 1;
  }, C32.triangleCartesianToBarycentric = function(t, n, e, r, a, o, c, u) {
    const i = a - e, l = o - r, s = c - e, C = u - r, f = t - e, h = n - r, M = i * i + l * l, g = i * s + l * C, m = s * s + C * C, p = f * i + h * l, I = f * s + h * C, T = M * m - g * g, P = (m * p - g * I) / T, A = (M * I - g * p) / T;
    return [1 - P - A, P, A];
  }, C32.triangleBarycentricToCartesian3d = function(t, n, e, r, a, o, c, u, i, l, s, C) {
    return [t * r + n * c + e * l, t * a + n * u + e * s, t * o + n * i + e * C];
  };
}
var isNegativeZero2;
{
  const C32 = self.C3;
  let mainDocument = null, baseHref = "";
  if ("undefined" != typeof document) {
    mainDocument = document;
    const e = document.querySelector("base");
    baseHref = e && e.hasAttribute("href") ? e.getAttribute("href") : "", baseHref && (baseHref.startsWith("/") && (baseHref = baseHref.substr(1)), baseHref.endsWith("/") || (baseHref += "/"));
  }
  C32.GetBaseHref = function() {
    return baseHref;
  }, C32.GetBaseURL = function() {
    if (!mainDocument) return "";
    const e = mainDocument.location;
    return C32.GetPathFromURL(e.origin + e.pathname) + baseHref;
  }, C32.GetPathFromURL = function(e) {
    if (!e.length) return e;
    if (e.endsWith("/") || e.endsWith("\\")) return e;
    const t = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
    return -1 === t ? "" : e.substr(0, t + 1);
  }, C32.GetFilenameFromURL = function(e) {
    if (!e.length) return e;
    if (e.endsWith("/") || e.endsWith("\\")) return "";
    const t = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
    return -1 === t ? e : e.substr(t + 1);
  }, C32.GetFileExtension = function(e) {
    let t = e.lastIndexOf(".");
    return t < 1 ? "" : e.substr(t);
  }, C32.SetFileExtension = function(e, t) {
    const n = e.lastIndexOf(".");
    return -1 === n ? e + "." + t : e.substr(0, n + 1) + t;
  }, C32.GetFileNamePart = function(e) {
    let t = e.lastIndexOf(".");
    return t < 1 ? e : e.substr(0, t);
  }, C32.NormalizeFileSeparator = function(e) {
    return e.replace(/\\/g, "/");
  }, C32.IsFileExtension = function(e, t) {
    return t === (e ? C32.GetFileExtension(e).slice(1) : "");
  }, C32.FileNameEquals = function(e, t) {
    let n, r;
    return C32.IsFileLike(e) && (n = C32.GetFileNamePart(e["name"])), C32.IsString(e) && (n = C32.GetFileNamePart(e)), C32.IsFileLike(t) && (r = C32.GetFileNamePart(t["name"])), C32.IsString(t) && (r = C32.GetFileNamePart(t)), n === r;
  }, C32.ParseFilePath = function(e) {
    e = C32.NormalizeFileSeparator(e);
    let t = /^\w\:\//.exec(e);
    t ? (t = t[0], "/" !== (e = e.slice(3))[0] && (e = "/" + e)) : t = "", (e = e.replace(/\/{2,}/g, "/")).length > 1 && "/" === e.slice(-1) && (e = e.slice(0, -1));
    const n = e.lastIndexOf("/") + 1;
    let r, a = "", o = e, s = "";
    n > 0 && (a = e.slice(0, n), o = e.slice(n)), r = o;
    const i = o.lastIndexOf(".");
    i > 0 && (s = o.slice(i), r = o.slice(0, -s.length));
    return { dir: a, base: o, name: r, root: t, ext: s, full: t + a + o };
  }, C32.Wait = function(e, t) {
    return new Promise((n, r) => {
      self.setTimeout(n, e, t);
    });
  }, C32.swallowException = function(e) {
    try {
      e();
    } catch (e2) {
      C32.isDebug && console.warn("Swallowed exception: ", e2);
    }
  }, C32.noop = function() {
  }, C32.equalsNoCase = function(e, t) {
    return "string" == typeof e && "string" == typeof t && (e === t || e.normalize().toLowerCase() === t.normalize().toLowerCase());
  }, C32.equalsCase = function(e, t) {
    return "string" == typeof e && "string" == typeof t && (e === t || e.normalize() === t.normalize());
  }, C32.typedArraySet16 = function(e, t, n) {
    e[n++] = t[0], e[n++] = t[1], e[n++] = t[2], e[n++] = t[3], e[n++] = t[4], e[n++] = t[5], e[n++] = t[6], e[n++] = t[7], e[n++] = t[8], e[n++] = t[9], e[n++] = t[10], e[n++] = t[11], e[n++] = t[12], e[n++] = t[13], e[n++] = t[14], e[n] = t[15];
  }, C32.truncateArray = function(e, t) {
    e.length = t;
  }, C32.clearArray = function(e) {
    e && 0 !== e.length && C32.truncateArray(e, 0);
  }, C32.clear2DArray = function(e) {
    if (e) {
      for (let t = 0; t < e.length; t++) {
        let n = e[t];
        C32.truncateArray(n, 0);
      }
      C32.truncateArray(e, 0);
    }
  }, C32.extendArray = function(e, t, n) {
    t |= 0;
    const r = e.length;
    if (!(t <= r)) for (let a = r; a < t; ++a) e.push(n);
  }, C32.resizeArray = function(e, t, n) {
    t |= 0;
    const r = e.length;
    t < r ? C32.truncateArray(e, t) : t > r && C32.extendArray(e, t, n);
  }, C32.shallowAssignArray = function(e, t) {
    C32.clearArray(e), C32.appendArray(e, t);
  }, C32.appendArray = function(e, t) {
    if (t.length < 1e4) e.push(...t);
    else for (let n = 0, r = t.length; n < r; ++n) e.push(t[n]);
  }, C32.arrayRemove = function(e, t) {
    if ((t = Math.floor(t)) < 0 || t >= e.length) return;
    let n = e.length - 1;
    for (let r = t; r < n; ++r) e[r] = e[r + 1];
    C32.truncateArray(e, n);
  }, C32.arrayFindRemove = function(e, t) {
    let n = e.indexOf(t);
    n >= 0 && e.splice(n, 1);
  }, C32.arraysEqual = function(e, t) {
    let n = e.length;
    if (t.length !== n) return false;
    for (let r = 0; r < n; ++r) if (e[r] !== t[r]) return false;
    return true;
  }, C32.arrayFilterOut = function(e, t) {
    let n = [], r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      let o2 = e[a];
      t(o2) ? n.push(o2) : (e[r] = o2, ++r);
    }
    return C32.truncateArray(e, r), n;
  }, C32.arrayRemoveAllInSet = function(e, t) {
    const n = e.length;
    let r = 0;
    for (let n2 = 0, a = e.length; n2 < a; ++n2) {
      let a2 = e[n2];
      t.has(a2) || (e[r++] = a2);
    }
    return C32.truncateArray(e, r), n - r;
  }, C32.isArrayIndexInBounds = function(e, t) {
    return e === Math.floor(e) && (e >= 0 && e < t.length);
  }, C32.validateArrayIndex = function(e, t) {
    if (!C32.isArrayIndexInBounds(e, t)) throw new RangeError("array index out of bounds");
  }, C32.cloneArray = function(e) {
    return e.slice();
  }, C32.deepCloneArray = function(e, t) {
    let n = [];
    for (let r of e) if (C32.IsObject(r)) {
      let e2 = t(r);
      if (!e2) throw new Error("missing clone");
      if (e2.constructor !== r.constructor) throw new Error("object is not a clone");
      n.push(e2);
    } else C32.IsArray(r) ? n.push(C32.deepCloneArray(r, t)) : n.push(r);
    return n;
  }, C32.clone2DArray = function(e) {
    let t = [];
    for (let n of e) t.push(n.slice());
    return t;
  }, C32.splitStringAndNormalize = function(e, t = " ") {
    return e ? e.split(t).map((e2) => e2.trim()).filter((e2) => !!e2) : [];
  }, C32.filterSet = function(e, t, n) {
    const r = /* @__PURE__ */ new Set();
    for (const a of e.values()) t(a) && (n ? r.add(n(a)) : r.add(a));
    return r;
  }, C32.mergeSets = function(e, t) {
    return e["union"] ? e["union"](t) : /* @__PURE__ */ new Set([...e, ...t]);
  }, C32.mergeSetsInPlace = function(e, t) {
    for (const n of t) e.add(n);
    return e;
  }, C32.first = function(e) {
    for (let t of e) return t;
    return null;
  }, C32.xor = function(e, t) {
    return !e != !t;
  }, C32.compare = function(e, t, n) {
    switch (t) {
      case 0:
        return e === n;
      case 1:
        return e !== n;
      case 2:
        return e < n;
      case 3:
        return e <= n;
      case 4:
        return e > n;
      case 5:
        return e >= n;
      default:
        return false;
    }
  }, C32.hasAnyOwnProperty = function(e) {
    for (let t in e) if (e.hasOwnProperty(t)) return true;
    return false;
  }, C32.PromiseAllWithProgress = function(e, t) {
    return e.length ? new Promise((n, r) => {
      const a = [];
      let o = 0, s = false;
      for (let i = 0, l = e.length; i < l; ++i) a.push(void 0), e[i].then((r2) => {
        s || (a[i] = r2, ++o, o === e.length ? n(a) : t(o, e.length));
      }).catch((e2) => {
        s = true, r(e2);
      });
    }) : Promise.resolve([]);
  };
  let memoryCallbacks = [];
  C32.AddLibraryMemoryCallback = function(e) {
    memoryCallbacks.push(e);
  }, C32.GetEstimatedLibraryMemoryUsage = function() {
    let e = 0;
    for (let t of memoryCallbacks) {
      e += t();
    }
    return Math.floor(e);
  };
  let nextTaskId = 1;
  const activeTaskIds = /* @__PURE__ */ new Map(), taskMessageChannel = new MessageChannel();
  taskMessageChannel.port2.onmessage = function(e) {
    const t = e.data, n = activeTaskIds.get(t);
    activeTaskIds.delete(t), n && n(performance.now());
  }, C32.RequestUnlimitedAnimationFrame = function(e) {
    const t = nextTaskId++;
    return activeTaskIds.set(t, e), taskMessageChannel.port1.postMessage(t), t;
  }, C32.CancelUnlimitedAnimationFrame = function(e) {
    activeTaskIds.delete(e);
  }, C32.PostTask = C32.RequestUnlimitedAnimationFrame, C32.WaitForNextTask = function() {
    return new Promise((e) => C32.PostTask(e));
  };
  const activeRPAFids = /* @__PURE__ */ new Set();
  C32.RequestPostAnimationFrame = function(e) {
    const t = self.requestAnimationFrame(async (n) => {
      await C32.WaitForNextTask(), activeRPAFids.has(t) && (activeRPAFids.delete(t), e(n));
    });
    return activeRPAFids.add(t), t;
  }, C32.CancelPostAnimationFrame = function(e) {
    activeRPAFids.has(e) && (self.cancelAnimationFrame(e), activeRPAFids.delete(e));
  };
}
{
  const C32 = self.C3;
  C32.IsAbsoluteURL = function(e) {
    return /^(?:[a-z\-]+:)?\/\//.test(e) || "data:" === e.substr(0, 5) || "blob:" === e.substr(0, 5);
  }, C32.IsRelativeURL = function(e) {
    return !C32.IsAbsoluteURL(e);
  }, C32.ThrowIfNotOk = function(e) {
    if (!e.ok) throw new Error(`fetch '${e.url}' response returned ${e.status} ${e.statusText}`);
  }, C32.FetchOk = function(e, t) {
    return fetch(e, t).then((e2) => (C32.ThrowIfNotOk(e2), e2));
  }, C32.FetchText = function(e) {
    return C32.FetchOk(e).then((e2) => e2.text());
  }, C32.FetchJson = function(e) {
    return C32.FetchOk(e).then((e2) => e2.json());
  }, C32.FetchBlob = function(e) {
    return C32.FetchOk(e).then((e2) => e2.blob());
  }, C32.FetchArrayBuffer = function(e) {
    return C32.FetchOk(e).then((e2) => e2.arrayBuffer());
  }, C32.FetchImage = function(e) {
    return new Promise((t, n) => {
      const r = new Image();
      r.onload = () => t(r), r.onerror = (e2) => n(e2), r.src = e;
    });
  }, C32.BlobToArrayBuffer = function(e) {
    return "function" == typeof e["arrayBuffer"] ? e["arrayBuffer"]() : new Promise((t, n) => {
      const r = new FileReader();
      r.onload = () => t(r.result), r.onerror = () => n(r.error), r.readAsArrayBuffer(e);
    });
  }, C32.BlobToString = function(e) {
    return "function" == typeof e["text"] ? e["text"]() : new Promise((t, n) => {
      const r = new FileReader();
      r.onload = () => t(r.result), r.onerror = () => n(r.error), r.readAsText(e);
    });
  }, C32.BlobToJson = function(e) {
    return C32.BlobToString(e).then((e2) => JSON.parse(e2));
  }, C32.BlobToImage = async function(e, t) {
    let n = URL.createObjectURL(e);
    try {
      const e2 = await C32.FetchImage(n);
      return URL.revokeObjectURL(n), n = "", t && "function" == typeof e2["decode"] && await e2["decode"](), e2;
    } finally {
      n && URL.revokeObjectURL(n);
    }
  }, C32.CreateCanvas = function(e, t) {
    if ("undefined" != typeof document && "function" == typeof document.createElement) {
      const n = document.createElement("canvas");
      return n.width = e, n.height = t, n;
    }
    return new OffscreenCanvas(e, t);
  }, C32.CanvasToBlob = function(e, t, n) {
    if ("number" != typeof n && (n = 1), t = t || "image/png", n = C32.clamp(n, 0, 1), e["convertToBlob"]) return e["convertToBlob"]({ "type": t, "quality": n });
    if (e.toBlob) return new Promise((r) => e.toBlob(r, t, n));
    throw new Error("could not convert canvas to blob");
  }, C32.DrawableToBlob = function(e, t, n) {
    const r = C32.CreateCanvas(e.width, e.height);
    return r.getContext("2d").drawImage(e, 0, 0), C32.CanvasToBlob(r, t, n);
  }, C32.ImageDataToBlob = function(e, t, n) {
    if (C32.Supports.ImageBitmapOptions) return createImageBitmap(e, { "premultiplyAlpha": "none" }).then((e2) => C32.DrawableToBlob(e2, t, n));
    if (C32.Supports.ImageBitmap) return createImageBitmap(e).then((e2) => C32.DrawableToBlob(e2, t, n));
    {
      const r = C32.CreateCanvas(e.width, e.height);
      return r.getContext("2d").putImageData(e, 0, 0), C32.CanvasToBlob(r, t, n);
    }
  }, C32.CopySet = function(e, t) {
    e.clear();
    for (const n of t) e.add(n);
  }, C32.MapToObject = function(e) {
    const t = /* @__PURE__ */ Object.create(null);
    for (const [n, r] of e.entries()) t[n] = r;
    return t;
  }, C32.ObjectToMap = function(e, t) {
    t.clear();
    for (const [n, r] of Object.entries(e)) t.set(n, r);
  }, C32.ToSuperJSON = function e(t) {
    if ("object" == typeof t && null !== t) {
      if (t instanceof Set) return { "_c3type_": "set", "data": [...t].map((t2) => e(t2)) };
      if (t instanceof Map) return { "_c3type_": "map", "data": [...t].map((t2) => [t2[0], e(t2[1])]) };
      {
        const n = /* @__PURE__ */ Object.create(null);
        for (const [r, o] of Object.entries(t)) n[r] = e(o);
        return n;
      }
    }
    return t;
  }, C32.FromSuperJSON = function e(t) {
    if ("object" == typeof t & null !== t) {
      if ("set" === t["_c3type_"]) return new Set(t["data"].map((t2) => e(t2)));
      if ("map" === t["_c3type_"]) return new Map(t["data"].map((t2) => [t2[0], e(t2[1])]));
      {
        const n = /* @__PURE__ */ Object.create(null);
        for (const [r, o] of Object.entries(t)) n[r] = e(o);
        return n;
      }
    }
    return t;
  }, C32.CSSToCamelCase = function(e) {
    if (e.startsWith("--")) return e;
    let t = "", n = false, r = 0;
    for (const o of e) "-" === o ? r > 0 && (n = true) : n ? (t += o.toUpperCase(), n = false) : t += o, ++r;
    return t;
  }, C32.IsIterator = function(e) {
    return "object" == typeof e && "function" == typeof e.next;
  }, C32.MakeFilledArray = function(e, t) {
    const n = [];
    if ("function" == typeof t) for (let r = 0; r < e; ++r) n.push(t());
    else for (let r = 0; r < e; ++r) n.push(t);
    return n;
  };
}
{
  let padTwoDigits = function(t) {
    return 0 === t.length ? "00" : 1 === t.length ? "0" + t : t;
  }, hueToRGB = function(t, s, e) {
    return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? t + 6 * (s - t) * e : e < 0.5 ? s : e < 2 / 3 ? t + (s - t) * (2 / 3 - e) * 6 : t;
  };
  padTwoDigits2 = padTwoDigits, hueToRGB2 = hueToRGB;
  const C32 = self.C3, HSL_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i, HSLA_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
  C32.Color = class {
    constructor(t, s, e, r) {
      this._r = NaN, this._g = NaN, this._b = NaN, this._a = NaN, this._r = 0, this._g = 0, this._b = 0, this._a = 0, t instanceof C32.Color ? this.set(t) : this.setRgba(t || 0, s || 0, e || 0, r || 0);
    }
    setRgb(t, s, e) {
      return this._r = +t, this._g = +s, this._b = +e, this.clamp(), this;
    }
    setRgba(t, s, e, r) {
      return this._r = +t, this._g = +s, this._b = +e, this._a = +r, this.clamp(), this;
    }
    set(t) {
      return this._r = t._r, this._g = t._g, this._b = t._b, this._a = t._a, this;
    }
    copy(t) {
      return this.set(t);
    }
    add(t) {
      this._r += t._r, this._g += t._g, this._b += t._b, this._a += t._a, this.clamp();
    }
    addRgb(t, s, e, r = 0) {
      this._r += +t, this._g += +s, this._b += +e, this._a += +r, this.clamp();
    }
    diff(t) {
      this.setR(Math.max(this._r, t._r) - Math.min(this._r, t._r)), this.setG(Math.max(this._g, t._g) - Math.min(this._g, t._g)), this.setB(Math.max(this._b, t._b) - Math.min(this._b, t._b)), this.setA(Math.max(this._a, t._a) - Math.min(this._a, t._a)), this.clamp();
    }
    copyRgb(t) {
      this._r = t._r, this._g = t._g, this._b = t._b;
    }
    setR(t) {
      this._r = C32.clamp(+t, 0, 1);
    }
    getR() {
      return this._r;
    }
    setG(t) {
      this._g = C32.clamp(+t, 0, 1);
    }
    getG() {
      return this._g;
    }
    setB(t) {
      this._b = C32.clamp(+t, 0, 1);
    }
    getB() {
      return this._b;
    }
    setA(t) {
      this._a = C32.clamp(+t, 0, 1);
    }
    getA() {
      return this._a;
    }
    clone() {
      return C32.New(C32.Color, this._r, this._g, this._b, this._a);
    }
    toArray() {
      return [this._r, this._g, this._b, this._a];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(t, s) {
      t[s++] = this._r, t[s++] = this._g, t[s++] = this._b, t[s] = this._a;
    }
    writeToTypedArrayx4(t, s) {
      const e = this._r, r = this._g, i = this._b, a = this._a;
      for (let h = 0; h < 4; ++h) t[s++] = e, t[s++] = r, t[s++] = i, t[s++] = a;
    }
    writeRGBToTypedArray(t, s) {
      t[s++] = this._r, t[s++] = this._g, t[s] = this._b;
    }
    equals(t) {
      return this._r === t._r && this._g === t._g && this._b === t._b && this._a === t._a;
    }
    equalsIgnoringAlpha(t) {
      return this._r === t._r && this._g === t._g && this._b === t._b;
    }
    equalsRgb(t, s, e) {
      return this._r === t && this._g === s && this._b === e;
    }
    equalsRgba(t, s, e, r) {
      return this._r === t && this._g === s && this._b === e && this._a === r;
    }
    equalsF32Array(t, s) {
      return t[s] === Math.fround(this._r) && t[s + 1] === Math.fround(this._g) && t[s + 2] === Math.fround(this._b) && t[s + 3] === Math.fround(this._a);
    }
    equalsRGBF32Array(t, s) {
      return t[s] === Math.fround(this._r) && t[s + 1] === Math.fround(this._g) && t[s + 2] === Math.fround(this._b);
    }
    multiply(t) {
      this._r *= t._r, this._g *= t._g, this._b *= t._b, this._a *= t._a;
    }
    multiplyAlpha(t) {
      this._r *= t, this._g *= t, this._b *= t, this._a *= t;
    }
    premultiply() {
      return this._r *= this._a, this._g *= this._a, this._b *= this._a, this;
    }
    unpremultiply() {
      return this._r /= this._a, this._g /= this._a, this._b /= this._a, this;
    }
    clamp() {
      return this._r = C32.clamp(this._r, 0, 1), this._g = C32.clamp(this._g, 0, 1), this._b = C32.clamp(this._b, 0, 1), this._a = C32.clamp(this._a, 0, 1), this;
    }
    setFromRgbValue(t) {
      this._r = C32.GetRValue(t), this._g = C32.GetGValue(t), this._b = C32.GetBValue(t), this._a = C32.GetAValue(t);
    }
    getCssRgb(t, s, e) {
      return `rgb(${100 * (C32.IsFiniteNumber(t) ? t : this.getR())}%, ${100 * (C32.IsFiniteNumber(s) ? s : this.getG())}%, ${100 * (C32.IsFiniteNumber(e) ? e : this.getB())}%)`;
    }
    getCssRgba(t, s, e, r) {
      return `rgba(${100 * (C32.IsFiniteNumber(t) ? t : this.getR())}%, ${100 * (C32.IsFiniteNumber(s) ? s : this.getG())}%, ${100 * (C32.IsFiniteNumber(e) ? e : this.getB())}%, ${C32.IsFiniteNumber(r) ? r : this.getA()})`;
    }
    toHexString(t = false) {
      const s = Math.round(255 * this.getR()), e = Math.round(255 * this.getG()), r = Math.round(255 * this.getB());
      let i = "#" + padTwoDigits(s.toString(16)) + padTwoDigits(e.toString(16)) + padTwoDigits(r.toString(16));
      if (t) {
        i += padTwoDigits(Math.round(255 * this.getA()).toString(16));
      }
      return i;
    }
    parseHexString(t) {
      if ("string" != typeof t) return false;
      let s, e, r, i;
      if ("#" === (t = t.trim()).charAt(0) && (t = t.substr(1)), 3 === t.length || 4 === t.length) s = parseInt(t[0], 16) / 15, e = parseInt(t[1], 16) / 15, r = parseInt(t[2], 16) / 15, 4 === t.length && (i = parseInt(t[3], 16) / 15);
      else {
        if (6 !== t.length && 8 !== t.length) return false;
        s = parseInt(t.substr(0, 2), 16) / 255, e = parseInt(t.substr(2, 2), 16) / 255, r = parseInt(t.substr(4, 2), 16) / 255, 8 === t.length && (i = parseInt(t.substr(6, 2), 16) / 255);
      }
      return !!(Number.isFinite(s) && Number.isFinite(e) && Number.isFinite(r)) && (this.setRgb(s, e, r), Number.isFinite(i) ? this.setA(i) : this.setA(1), true);
    }
    toCommaSeparatedRgb() {
      return `${Math.round(255 * this.getR())}, ${Math.round(255 * this.getG())}, ${Math.round(255 * this.getB())}`;
    }
    toRgbArray() {
      return [Math.round(255 * this.getR()), Math.round(255 * this.getG()), Math.round(255 * this.getB())];
    }
    parseCommaSeparatedRgb(t) {
      if ("string" != typeof t) return false;
      const s = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
      if (s.length < 3) return false;
      const e = parseInt(s[0].trim(), 10) / 255, r = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255;
      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), this.setA(1), true;
    }
    parseCommaSeparatedPercentageRgb(t) {
      if ("string" != typeof t) return false;
      const s = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
      if (s.length < 3) return false;
      const e = parseInt(s[0].trim(), 10) / 100, r = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100;
      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), this.setA(1), true;
    }
    parseCommaSeparatedRgba(t) {
      if ("string" != typeof t) return false;
      const s = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
      if (s.length < 4) return false;
      const e = parseInt(s[0].trim(), 10) / 255, r = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255, a = parseFloat(s[3].trim());
      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), isFinite(a) && this.setA(a), true;
    }
    parseCommaSeparatedPercentageRgba(t) {
      if ("string" != typeof t) return false;
      const s = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
      if (s.length < 4) return false;
      const e = parseInt(s[0].trim(), 10) / 100, r = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100, a = parseFloat(s[3].trim());
      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), isFinite(a) && this.setA(a), true;
    }
    parseString(t) {
      if ("string" != typeof t) return false;
      if ((t = t.replace(/\s+/, "")).includes(",")) {
        if (t.startsWith("rgb(")) return t.includes("%") ? this.parseCommaSeparatedPercentageRgb(t) : this.parseCommaSeparatedRgb(t);
        if (t.startsWith("rgba(")) return t.includes("%") ? this.parseCommaSeparatedPercentageRgba(t) : this.parseCommaSeparatedRgba(t);
        if (t.startsWith("hsl(") || t.startsWith("hsla(")) return this.parseHSLString(t);
        {
          const s = t.split(",");
          return t.includes("%") ? 3 === s.length ? this.parseCommaSeparatedPercentageRgb(t) : 4 === s.length && this.parseCommaSeparatedPercentageRgba(t) : 3 === s.length ? this.parseCommaSeparatedRgb(t) : 4 === s.length && this.parseCommaSeparatedRgba(t);
        }
      }
      return this.parseHexString(t);
    }
    toJSON() {
      return [this._r, this._g, this._b, this._a];
    }
    setFromHSLA(t, s, e, r) {
      let i, a, h;
      if (t %= 360, s = C32.clamp(s, 0, 100), e = C32.clamp(e, 0, 100), r = C32.clamp(r, 0, 1), t /= 360, e /= 100, 0 === (s /= 100)) i = a = h = e;
      else {
        const r2 = e < 0.5 ? e * (1 + s) : e + s - e * s, n = 2 * e - r2;
        i = hueToRGB(n, r2, t + 1 / 3), a = hueToRGB(n, r2, t), h = hueToRGB(n, r2, t - 1 / 3);
      }
      return this.setR(i), this.setG(a), this.setB(h), this.setA(r), this;
    }
    parseHSLString(t) {
      const s = t.replace(/ |hsl|hsla|\(|\)|;/gi, ""), e = HSL_TEST.exec(s), r = HSLA_TEST.exec(s);
      return e && 4 === e.length ? (this.setFromHSLA(+e[1], +e[2], +e[3], 1), true) : !(!r || 5 !== r.length) && (this.setFromHSLA(+e[1], +e[2], +e[3], +e[4]), true);
    }
    toHSLAString() {
      const t = this._r, s = this._g, e = this._b, r = this._a;
      return `hsla(${C32.Color.GetHue(t, s, e)}, ${C32.Color.GetSaturation(t, s, e)}%, ${C32.Color.GetLuminosity(t, s, e)}%, ${r})`;
    }
    toHSLAArray() {
      const t = this._r, s = this._g, e = this._b;
      return [C32.Color.GetHue(t, s, e), C32.Color.GetSaturation(t, s, e), C32.Color.GetLuminosity(t, s, e), this._a];
    }
    setFromJSON(t) {
      Array.isArray(t) && (t.length < 3 || (this._r = t[0], this._g = t[1], this._b = t[2], t.length >= 4 ? this._a = t[3] : this._a = 1));
    }
    set r(t) {
      this.setR(t);
    }
    get r() {
      return this.getR();
    }
    set g(t) {
      this.setG(t);
    }
    get g() {
      return this.getG();
    }
    set b(t) {
      this.setB(t);
    }
    get b() {
      return this.getB();
    }
    set a(t) {
      this.setA(t);
    }
    get a() {
      return this.getA();
    }
    setAtIndex(t, s) {
      switch (t) {
        case 0:
          this.setR(s);
          break;
        case 1:
          this.setG(s);
          break;
        case 2:
          this.setB(s);
          break;
        case 3:
          this.setA(s);
          break;
        default:
          throw new RangeError("invalid color index");
      }
    }
    getAtIndex(t) {
      switch (t) {
        case 0:
          return this.getR();
        case 1:
          return this.getG();
        case 2:
          return this.getB();
        case 3:
          return this.getA();
        default:
          throw new RangeError("invalid color index");
      }
    }
    static Equals(t, s) {
      let e, r;
      if (Array.isArray(t)) e = new C32.Color(), e.setFromJSON(t);
      else {
        if (!(t instanceof C32.Color)) throw new Error("unexpected type");
        e = t;
      }
      if (Array.isArray(s)) r = new C32.Color(), r.setFromJSON(s);
      else {
        if (!(s instanceof C32.Color)) throw new Error("unexpected type");
        r = s;
      }
      return e.equals(r);
    }
    static DiffChannel(t, s) {
      return C32.clamp(Math.max(t, s) - Math.min(t, s), 0, 1);
    }
    static Diff(t, s) {
      const e = new C32.Color();
      return e.setR(Math.max(t._r, s._r) - Math.min(t._r, s._r)), e.setG(Math.max(t._g, s._g) - Math.min(t._g, s._g)), e.setB(Math.max(t._b, s._b) - Math.min(t._b, s._b)), e.setA(Math.max(t._a, s._a) - Math.min(t._a, s._a)), e;
    }
    static DiffNoAlpha(t, s) {
      const e = new C32.Color(0, 0, 0, 1);
      return e.setR(Math.max(t._r, s._r) - Math.min(t._r, s._r)), e.setG(Math.max(t._g, s._g) - Math.min(t._g, s._g)), e.setB(Math.max(t._b, s._b) - Math.min(t._b, s._b)), e;
    }
    static GetHue(t, s, e) {
      const r = Math.max(t, s, e), i = Math.min(t, s, e);
      if (r === i) return 0;
      let a = 0;
      switch (r) {
        case t:
          a = (s - e) / (r - i) + (s < e ? 6 : 0);
          break;
        case s:
          a = (e - t) / (r - i) + 2;
          break;
        case e:
          a = (t - s) / (r - i) + 4;
      }
      return Math.round(a / 6 * 360);
    }
    static GetSaturation(t, s, e) {
      const r = Math.max(t, s, e), i = Math.min(t, s, e);
      if (r === i) return 0;
      const a = r - i, h = (r + i) / 2 > 0.5 ? a / (2 - r - i) : a / (r + i);
      return Math.round(100 * h);
    }
    static GetLuminosity(t, s, e) {
      const r = Math.max(t, s, e), i = (r + Math.min(t, s, e)) / 2;
      return r ? Math.round(100 * i) : 0;
    }
  }, C32.Color.White = Object.freeze(C32.New(C32.Color, 1, 1, 1, 1)), C32.Color.Black = Object.freeze(C32.New(C32.Color, 0, 0, 0, 1)), C32.Color.TransparentBlack = Object.freeze(C32.New(C32.Color, 0, 0, 0, 0));
}
var padTwoDigits2;
var hueToRGB2;
{
  const C32 = self.C3;
  C32.Vector2 = class {
    constructor(t, s) {
      this._x = 0, this._y = 0, t instanceof C32.Vector2 ? this.copy(t) : this.set(t || 0, s || 0);
    }
    set(t, s) {
      this._x = +t, this._y = +s;
    }
    copy(t) {
      this._x = t._x, this._y = t._y;
    }
    equals(t) {
      return this._x === t._x && this._y === t._y;
    }
    equalsValues(t, s) {
      return this._x === t && this._y === s;
    }
    equalsF32Array(t, s) {
      return t[s] === Math.fround(this._x) && t[s + 1] === Math.fround(this._y);
    }
    setX(t) {
      this._x = +t;
    }
    getX() {
      return this._x;
    }
    setY(t) {
      this._y = +t;
    }
    getY() {
      return this._y;
    }
    toArray() {
      return [this._x, this._y];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(t, s) {
      t[s++] = this._x, t[s] = this._y;
    }
    offset(t, s) {
      this._x += +t, this._y += +s;
    }
    scale(t, s) {
      this._x *= t, this._y *= s;
    }
    divide(t, s) {
      this._x /= t, this._y /= s;
    }
    round() {
      this._x = Math.round(this._x), this._y = Math.round(this._y);
    }
    floor() {
      this._x = Math.floor(this._x), this._y = Math.floor(this._y);
    }
    ceil() {
      this._x = Math.ceil(this._x), this._y = Math.ceil(this._y);
    }
    angle() {
      return C32.angleTo(0, 0, this._x, this._y);
    }
    lengthSquared() {
      return this._x * this._x + this._y * this._y;
    }
    length() {
      return C32.hypot2DFast(this._x, this._y);
    }
    rotatePrecalc(t, s) {
      const h = this._x * s - this._y * t;
      this._y = this._y * s + this._x * t, this._x = h;
    }
    rotate(t) {
      0 !== t && this.rotatePrecalc(Math.sin(t), Math.cos(t));
    }
    rotateAbout(t, s, h) {
      0 === t || s === this._x && h === this._y || (this._x -= s, this._y -= h, this.rotatePrecalc(Math.sin(t), Math.cos(t)), this._x += +s, this._y += +h);
    }
    move(t, s) {
      0 !== s && (this._x += Math.cos(t) * s, this._y += Math.sin(t) * s);
    }
    normalize() {
      const t = this.length();
      0 !== t && 1 !== t && (this._x /= t, this._y /= t);
    }
    clamp(t, s) {
      this._x = C32.clamp(this._x, t, s), this._y = C32.clamp(this._y, t, s);
    }
    dot(t) {
      return this._x * t._x + this._y * t._y;
    }
    reverse() {
      this._x = -this._x, this._y = -this._y;
    }
    perp() {
      let t = this._x;
      return this._x = this._y, this._y = -t, this;
    }
  };
}
{
  const C32 = self.C3;
  C32.Rect = class {
    constructor(t, h, i, o) {
      this._left = NaN, this._top = NaN, this._right = NaN, this._bottom = NaN, this._left = 0, this._top = 0, this._right = 0, this._bottom = 0, t instanceof C32.Rect ? this.copy(t) : this.set(t || 0, h || 0, i || 0, o || 0);
    }
    set(t, h, i, o) {
      this._left = +t, this._top = +h, this._right = +i, this._bottom = +o;
    }
    setWH(t, h, i, o) {
      t = +t, h = +h, this._left = t, this._top = h, this._right = t + +i, this._bottom = h + +o;
    }
    copy(t) {
      this._left = +t._left, this._top = +t._top, this._right = +t._right, this._bottom = +t._bottom;
    }
    clone() {
      return new C32.Rect(this._left, this._top, this._right, this._bottom);
    }
    static Merge(t, h) {
      const i = new C32.Rect();
      return i.setLeft(Math.min(t._left, h._left)), i.setTop(Math.min(t._top, h._top)), i.setRight(Math.max(t._right, h._right)), i.setBottom(Math.max(t._bottom, h._bottom)), i;
    }
    static FromObject(t) {
      return new C32.Rect(t.left, t.top, t.right, t.bottom);
    }
    equals(t) {
      return this._left === t._left && this._top === t._top && this._right === t._right && this._bottom === t._bottom;
    }
    equalsWH(t, h, i, o) {
      return this._left === t && this._top === h && this.width() === i && this.height() === o;
    }
    equalsF32Array(t, h) {
      return t[h] === Math.fround(this._left) && t[h + 1] === Math.fround(this._top) && t[h + 2] === Math.fround(this._right) && t[h + 3] === Math.fround(this._bottom);
    }
    setLeft(t) {
      this._left = +t;
    }
    getLeft() {
      return this._left;
    }
    setTop(t) {
      this._top = +t;
    }
    getTop() {
      return this._top;
    }
    setRight(t) {
      this._right = +t;
    }
    getRight() {
      return this._right;
    }
    setBottom(t) {
      this._bottom = +t;
    }
    getBottom() {
      return this._bottom;
    }
    toArray() {
      return [this._left, this._top, this._right, this._bottom];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    toDOMRect() {
      return new DOMRect(this._left, this._top, this.width(), this.height());
    }
    static fromDOMRect(t) {
      return C32.New(C32.Rect, t.left, t.top, t.right, t.bottom);
    }
    writeToTypedArray(t, h) {
      t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h] = this._bottom;
    }
    writeAsQuadToTypedArray(t, h) {
      t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h++] = this._top, t[h++] = this._right, t[h++] = this._bottom, t[h++] = this._left, t[h] = this._bottom;
    }
    writeAsQuadToTypedArray3D(t, h, i) {
      t[h++] = this._left, t[h++] = this._top, t[h++] = i, t[h++] = this._right, t[h++] = this._top, t[h++] = i, t[h++] = this._right, t[h++] = this._bottom, t[h++] = i, t[h++] = this._left, t[h++] = this._bottom, t[h] = i;
    }
    width() {
      return this._right - this._left;
    }
    height() {
      return this._bottom - this._top;
    }
    midX() {
      return (this._left + this._right) / 2;
    }
    midY() {
      return (this._top + this._bottom) / 2;
    }
    offset(t, h) {
      t = +t, h = +h, this._left += t, this._top += h, this._right += t, this._bottom += h;
    }
    offsetLeft(t) {
      this._left += +t;
    }
    offsetTop(t) {
      this._top += +t;
    }
    offsetRight(t) {
      this._right += +t;
    }
    offsetBottom(t) {
      this._bottom += +t;
    }
    toSquare(t) {
      if ("x" !== t) throw new Error("invalid axis, only 'x' supported");
      this._top < this._bottom ? this._left < this._right ? this._bottom = this._top + this.width() : this._bottom = this._top - this.width() : this._left < this._right ? this._bottom = this._top - this.width() : this._bottom = this._top + this.width();
    }
    inflate(t, h) {
      t = +t, h = +h, this._left -= t, this._top -= h, this._right += t, this._bottom += h;
    }
    deflate(t, h) {
      t = +t, h = +h, this._left += t, this._top += h, this._right -= t, this._bottom -= h;
    }
    multiply(t, h) {
      this._left *= t, this._top *= h, this._right *= t, this._bottom *= h;
    }
    divide(t, h) {
      this._left /= t, this._top /= h, this._right /= t, this._bottom /= h;
    }
    mirrorAround(t) {
      this._left = +t - this._left, this._right = +t - this._right;
    }
    flipAround(t) {
      this._top = +t - this._top, this._bottom = +t - this._bottom;
    }
    rotate90DegreesAround(t, h) {
      const i = this.width(), o = this.height(), s = this.getLeft() + i * t, _ = this.getTop() + o * h;
      this.setWH(s - o * h, _ - i * t, o, i);
    }
    swapLeftRight() {
      const t = this._left;
      this._left = this._right, this._right = t;
    }
    swapTopBottom() {
      const t = this._top;
      this._top = this._bottom, this._bottom = t;
    }
    shuntY(t) {
      const h = this._top;
      this._top = +t - this._bottom, this._bottom = +t - h;
    }
    round() {
      this._left = Math.round(this._left), this._top = Math.round(this._top), this._right = Math.round(this._right), this._bottom = Math.round(this._bottom);
    }
    roundInner() {
      this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);
    }
    roundOuter() {
      this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);
    }
    floor() {
      this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);
    }
    ceil() {
      this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);
    }
    clamp(t, h, i, o) {
      this._left = Math.max(this._left, +t), this._top = Math.max(this._top, +h), this._right = Math.min(this._right, +i), this._bottom = Math.min(this._bottom, +o);
    }
    clampBoth(t, h, i, o) {
      t = +t, h = +h, i = +i, o = +o, this._left = C32.clamp(this._left, t, i), this._top = C32.clamp(this._top, h, o), this._right = C32.clamp(this._right, t, i), this._bottom = C32.clamp(this._bottom, h, o);
    }
    normalize() {
      this._left > this._right && this.swapLeftRight(), this._top > this._bottom && this.swapTopBottom();
    }
    intersectsRect(t) {
      return !(t._right < this._left || t._bottom < this._top || t._left > this._right || t._top > this._bottom);
    }
    intersectsRectOffset(t, h, i) {
      return !(t._right + h < this._left || t._bottom + i < this._top || t._left + h > this._right || t._top + i > this._bottom);
    }
    containsPoint(t, h) {
      return t >= this._left && t <= this._right && h >= this._top && h <= this._bottom;
    }
    containsRect(t) {
      return t._left >= this._left && t._top >= this._top && t._right <= this._right && t._bottom <= this._bottom;
    }
    expandToContain(t) {
      t._left < this._left && (this._left = +t._left), t._top < this._top && (this._top = +t._top), t._right > this._right && (this._right = +t._right), t._bottom > this._bottom && (this._bottom = +t._bottom);
    }
    lerpInto(t) {
      this._left = C32.lerp(t._left, t._right, this._left), this._top = C32.lerp(t._top, t._bottom, this._top), this._right = C32.lerp(t._left, t._right, this._right), this._bottom = C32.lerp(t._top, t._bottom, this._bottom);
    }
  };
}
{
  const C32 = self.C3;
  C32.Quad = class {
    constructor(t, s, i, h, _, r, l, e) {
      this._tlx = NaN, this._tly = NaN, this._trx = NaN, this._try = NaN, this._brx = NaN, this._bry = NaN, this._blx = NaN, this._bly = NaN, this._tlx = 0, this._tly = 0, this._trx = 0, this._try = 0, this._brx = 0, this._bry = 0, this._blx = 0, this._bly = 0, t instanceof C32.Quad ? this.copy(t) : this.set(t || 0, s || 0, i || 0, h || 0, _ || 0, r || 0, l || 0, e || 0);
    }
    set(t, s, i, h, _, r, l, e) {
      this._tlx = +t, this._tly = +s, this._trx = +i, this._try = +h, this._brx = +_, this._bry = +r, this._blx = +l, this._bly = +e;
    }
    setRect(t, s, i, h) {
      this.set(t, s, i, s, i, h, t, h);
    }
    copy(t) {
      this._tlx = t._tlx, this._tly = t._tly, this._trx = t._trx, this._try = t._try, this._brx = t._brx, this._bry = t._bry, this._blx = t._blx, this._bly = t._bly;
    }
    equals(t) {
      return this._tlx === t._tlx && this._tly === t._tly && this._trx === t._trx && this._try === t._try && this._brx === t._brx && this._bry === t._bry && this._blx === t._blx && this._bly === t._bly;
    }
    setTlx(t) {
      this._tlx = +t;
    }
    getTlx() {
      return this._tlx;
    }
    setTly(t) {
      this._tly = +t;
    }
    getTly() {
      return this._tly;
    }
    setTrx(t) {
      this._trx = +t;
    }
    getTrx() {
      return this._trx;
    }
    setTry(t) {
      this._try = +t;
    }
    getTry() {
      return this._try;
    }
    setBrx(t) {
      this._brx = +t;
    }
    getBrx() {
      return this._brx;
    }
    setBry(t) {
      this._bry = +t;
    }
    getBry() {
      return this._bry;
    }
    setBlx(t) {
      this._blx = +t;
    }
    getBlx() {
      return this._blx;
    }
    setBly(t) {
      this._bly = +t;
    }
    getBly() {
      return this._bly;
    }
    toDOMQuad() {
      return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly));
    }
    static fromDOMQuad(t) {
      return C32.New(C32.Quad, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y);
    }
    toArray() {
      return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(t, s) {
      t[s++] = this._tlx, t[s++] = this._tly, t[s++] = this._trx, t[s++] = this._try, t[s++] = this._brx, t[s++] = this._bry, t[s++] = this._blx, t[s] = this._bly;
    }
    writeToTypedArray3D(t, s, i) {
      t[s++] = this._tlx, t[s++] = this._tly, t[s++] = i, t[s++] = this._trx, t[s++] = this._try, t[s++] = i, t[s++] = this._brx, t[s++] = this._bry, t[s++] = i, t[s++] = this._blx, t[s++] = this._bly, t[s] = i;
    }
    offset(t, s) {
      t = +t, s = +s, this._tlx += t, this._tly += s, this._trx += t, this._try += s, this._brx += t, this._bry += s, this._blx += t, this._bly += s;
    }
    round() {
      this._tlx = Math.round(this._tlx), this._tly = Math.round(this._tly), this._trx = Math.round(this._trx), this._try = Math.round(this._try), this._brx = Math.round(this._brx), this._bry = Math.round(this._bry), this._blx = Math.round(this._blx), this._bly = Math.round(this._bly);
    }
    floor() {
      this._tlx = Math.floor(this._tlx), this._tly = Math.floor(this._tly), this._trx = Math.floor(this._trx), this._try = Math.floor(this._try), this._brx = Math.floor(this._brx), this._bry = Math.floor(this._bry), this._blx = Math.floor(this._blx), this._bly = Math.floor(this._bly);
    }
    ceil() {
      this._tlx = Math.ceil(this._tlx), this._tly = Math.ceil(this._tly), this._trx = Math.ceil(this._trx), this._try = Math.ceil(this._try), this._brx = Math.ceil(this._brx), this._bry = Math.ceil(this._bry), this._blx = Math.ceil(this._blx), this._bly = Math.ceil(this._bly);
    }
    setFromRect(t) {
      this._tlx = t._left, this._tly = t._top, this._trx = t._right, this._try = t._top, this._brx = t._right, this._bry = t._bottom, this._blx = t._left, this._bly = t._bottom;
    }
    setFromRotatedRect(t, s) {
      0 === s ? this.setFromRect(t) : this.setFromRotatedRectPrecalc(t, Math.sin(s), Math.cos(s));
    }
    setFromRotatedRectPrecalc(t, s, i) {
      const h = t._left * s, _ = t._top * s, r = t._right * s, l = t._bottom * s, e = t._left * i, x = t._top * i, y = t._right * i, b = t._bottom * i;
      this._tlx = e - _, this._tly = x + h, this._trx = y - _, this._try = x + r, this._brx = y - l, this._bry = b + r, this._blx = e - l, this._bly = b + h;
    }
    getBoundingBox(t) {
      t.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly));
    }
    containsPoint(t, s) {
      let i = this._trx - this._tlx, h = this._try - this._tly;
      const _ = this._brx - this._tlx, r = this._bry - this._tly, l = t - this._tlx, e = s - this._tly;
      let x = i * i + h * h, y = i * _ + h * r, b = i * l + h * e;
      const a = _ * _ + r * r, n = _ * l + r * e;
      let o = 1 / (x * a - y * y), c = (a * b - y * n) * o, u = (x * n - y * b) * o;
      return c >= 0 && u > 0 && c + u < 1 || (i = this._blx - this._tlx, h = this._bly - this._tly, x = i * i + h * h, y = i * _ + h * r, b = i * l + h * e, o = 1 / (x * a - y * y), c = (a * b - y * n) * o, u = (x * n - y * b) * o, c >= 0 && u > 0 && c + u < 1);
    }
    midX() {
      return (this._tlx + this._trx + this._brx + this._blx) / 4;
    }
    midY() {
      return (this._tly + this._try + this._bry + this._bly) / 4;
    }
    intersectsSegment(t, s, i, h) {
      return !(!this.containsPoint(t, s) && !this.containsPoint(i, h)) || C32.segmentIntersectsQuad(t, s, i, h, this);
    }
    intersectsQuad(t) {
      let s = t.midX(), i = t.midY();
      if (this.containsPoint(s, i)) return true;
      if (s = this.midX(), i = this.midY(), t.containsPoint(s, i)) return true;
      const h = this._tlx, _ = this._tly, r = this._trx, l = this._try, e = this._brx, x = this._bry, y = this._blx, b = this._bly;
      return C32.segmentIntersectsQuad(h, _, r, l, t) || C32.segmentIntersectsQuad(r, l, e, x, t) || C32.segmentIntersectsQuad(e, x, y, b, t) || C32.segmentIntersectsQuad(y, b, h, _, t);
    }
    rotatePointsAnticlockwise() {
      const t = this._tlx, s = this._tly;
      this._tlx = this._trx, this._tly = this._try, this._trx = this._brx, this._try = this._bry, this._brx = this._blx, this._bry = this._bly, this._blx = t, this._bly = s;
    }
    mirror() {
      this._swap(0, 2), this._swap(1, 3), this._swap(6, 4), this._swap(7, 5);
    }
    flip() {
      this._swap(0, 6), this._swap(1, 7), this._swap(2, 4), this._swap(3, 5);
    }
    diag() {
      this._swap(2, 6), this._swap(3, 7);
    }
    _swap(t, s) {
      const i = this._getAtIndex(t);
      this._setAtIndex(t, this._getAtIndex(s)), this._setAtIndex(s, i);
    }
    _getAtIndex(t) {
      switch (t) {
        case 0:
          return this._tlx;
        case 1:
          return this._tly;
        case 2:
          return this._trx;
        case 3:
          return this._try;
        case 4:
          return this._brx;
        case 5:
          return this._bry;
        case 6:
          return this._blx;
        case 7:
          return this._bly;
        default:
          throw new RangeError("invalid quad point index");
      }
    }
    _setAtIndex(t, s) {
      switch (s = +s, t) {
        case 0:
          this._tlx = s;
          break;
        case 1:
          this._tly = s;
          break;
        case 2:
          this._trx = s;
          break;
        case 3:
          this._try = s;
          break;
        case 4:
          this._brx = s;
          break;
        case 5:
          this._bry = s;
          break;
        case 6:
          this._blx = s;
          break;
        case 7:
          this._bly = s;
          break;
        default:
          throw new RangeError("invalid quad point index");
      }
    }
    divide(t, s) {
      this._tlx /= t, this._tly /= s, this._trx /= t, this._try /= s, this._brx /= t, this._bry /= s, this._blx /= t, this._bly /= s;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert, DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1], tempQuad = C32.New(C32.Quad);
  C32.CollisionPoly = class extends C32.DefendedBase {
    constructor(t, s = true) {
      super(), t || (t = DEFAULT_POLY_POINTS), this._ptsArr = Float64Array.from(t), this._bbox = new C32.Rect(), this._isBboxChanged = true, this._enabled = s;
    }
    Release() {
    }
    pointsArr() {
      return this._ptsArr;
    }
    pointCount() {
      return this._ptsArr.length / 2;
    }
    setPoints(t) {
      this._ptsArr.length === t.length ? this._ptsArr.set(t) : this._ptsArr = Float64Array.from(t), this._isBboxChanged = true;
    }
    setDefaultPoints() {
      this.setPoints(DEFAULT_POLY_POINTS);
    }
    copy(t) {
      this.setPoints(t._ptsArr);
    }
    setBboxChanged() {
      this._isBboxChanged = true;
    }
    _updateBbox() {
      if (!this._isBboxChanged) return;
      const t = this._ptsArr;
      let s = t[0], e = t[1], r = s, n = e;
      for (let o = 0, i = t.length; o < i; o += 2) {
        const i2 = t[o], h = t[o + 1];
        i2 < s && (s = i2), i2 > r && (r = i2), h < e && (e = h), h > n && (n = h);
      }
      this._bbox.set(s, e, r, n), this._isBboxChanged = false;
    }
    setFromRect(t, s, e) {
      let r = this._ptsArr;
      8 !== r.length && (r = new Float64Array(8), this._ptsArr = r), r[0] = t.getLeft() - s, r[1] = t.getTop() - e, r[2] = t.getRight() - s, r[3] = t.getTop() - e, r[4] = t.getRight() - s, r[5] = t.getBottom() - e, r[6] = t.getLeft() - s, r[7] = t.getBottom() - e, this._bbox.copy(t), 0 === s && 0 === e || this._bbox.offset(-s, -e), this._isBboxChanged = false;
    }
    setFromQuad(t, s, e) {
      tempQuad.copy(t), tempQuad.offset(s, e), this.setPoints(tempQuad.toArray()), this._isBboxChanged = true;
    }
    transform(t, s, e) {
      let r = 0, n = 1;
      0 !== e && (r = Math.sin(e), n = Math.cos(e)), this.transformPrecalc(t, s, r, n);
    }
    transformPrecalc(t, s, e, r) {
      const n = this._ptsArr;
      for (let o = 0, i = n.length; o < i; o += 2) {
        const i2 = o + 1, h = n[o] * t, l = n[i2] * s;
        n[o] = h * r - l * e, n[i2] = l * r + h * e;
      }
      this._isBboxChanged = true;
    }
    offset(t, s) {
      const e = this._ptsArr;
      for (let r = 0, n = e.length; r < n; r += 2) e[r] += t, e[r + 1] += s;
    }
    containsPoint(t, s) {
      const e = this._ptsArr;
      if (t === e[0] && s === e[1]) return true;
      this._updateBbox();
      const r = this._bbox, n = r.getLeft() - 110, o = r.getTop() - 101, i = r.getRight() + 131, h = r.getBottom() + 120;
      let l = 0, a = 0, c = 0, g = 0, _ = 0, p = 0, f = 0, u = 0;
      n < t ? (l = n, c = t) : (l = t, c = n), o < s ? (a = o, g = s) : (a = s, g = o), i < t ? (_ = i, f = t) : (_ = t, f = i), h < s ? (p = h, u = s) : (p = s, u = h);
      let C = 0, A = 0;
      for (let r2 = 0, d = e.length; r2 < d; r2 += 2) {
        const b = (r2 + 2) % d, P = e[r2], m = e[r2 + 1], x = e[b], B = e[b + 1];
        C32.segmentsIntersectPreCalc(n, o, t, s, l, c, a, g, P, m, x, B) && ++C, C32.segmentsIntersectPreCalc(i, h, t, s, _, f, p, u, P, m, x, B) && ++A;
      }
      return C % 2 == 1 || A % 2 == 1;
    }
    intersectsPoly(t, s, e) {
      const r = t._ptsArr, n = this._ptsArr;
      if (this.containsPoint(r[0] + s, r[1] + e)) return true;
      if (t.containsPoint(n[0] - s, n[1] - e)) return true;
      for (let t2 = 0, o = n.length; t2 < o; t2 += 2) {
        const i = (t2 + 2) % o, h = n[t2], l = n[t2 + 1], a = n[i], c = n[i + 1];
        let g = 0, _ = 0, p = 0, f = 0;
        h < a ? (g = h, p = a) : (g = a, p = h), l < c ? (_ = l, f = c) : (_ = c, f = l);
        for (let t3 = 0, n2 = r.length; t3 < n2; t3 += 2) {
          const o2 = (t3 + 2) % n2, i2 = r[t3] + s, u = r[t3 + 1] + e, C = r[o2] + s, A = r[o2 + 1] + e;
          if (C32.segmentsIntersectPreCalc(h, l, a, c, g, p, _, f, i2, u, C, A)) return true;
        }
      }
      return false;
    }
    intersectsSegment(t, s, e, r, n, o) {
      if (this.containsPoint(e - t, r - s)) return true;
      if (this.containsPoint(n - t, o - s)) return true;
      let i = 0, h = 0, l = 0, a = 0;
      e < n ? (i = e, l = n) : (i = n, l = e), r < o ? (h = r, a = o) : (h = o, a = r);
      const c = this._ptsArr;
      for (let g = 0, _ = c.length; g < _; g += 2) {
        const p = (g + 2) % _, f = c[g] + t, u = c[g + 1] + s, C = c[p] + t, A = c[p + 1] + s;
        if (C32.segmentsIntersectPreCalc(e, r, n, o, i, l, h, a, f, u, C, A)) return true;
      }
      return false;
    }
    mirror(t) {
      const s = this._ptsArr;
      for (let e = 0, r = s.length; e < r; e += 2) s[e] = 2 * t - s[e];
      this._isBboxChanged = true;
    }
    flip(t) {
      const s = this._ptsArr;
      for (let e = 0, r = s.length; e < r; e += 2) {
        const r2 = e + 1;
        s[r2] = 2 * t - s[r2];
      }
      this._isBboxChanged = true;
    }
    diag() {
      const t = this._ptsArr;
      for (let s = 0, e = t.length; s < e; s += 2) {
        const e2 = s + 1, r = t[s];
        t[s] = t[e2], t[e2] = r;
      }
      this._isBboxChanged = true;
    }
    GetMidX() {
      const t = this._ptsArr;
      let s = 0;
      for (let e = 0, r = t.length; e < r; e += 2) s += t[e];
      return s / this.pointCount();
    }
    GetMidY() {
      const t = this._ptsArr;
      let s = 0;
      for (let e = 0, r = t.length; e < r; e += 2) s += t[e + 1];
      return s / this.pointCount();
    }
    GetPointsArray() {
      return this._ptsArr;
    }
    GetPointCount() {
      return this.pointCount();
    }
    IsEnabled() {
      return this._enabled;
    }
  };
}
{
  const C32 = self.C3;
  C32.PairMap = class extends C32.DefendedBase {
    constructor(e) {
      if (super(), this._firstMap = /* @__PURE__ */ new Map(), e) for (const [t, s, r] of e) this.Set(t, s, r);
    }
    Release() {
      this.Clear(), this._firstMap = null;
    }
    IsEmpty() {
      return 0 === this._firstMap.size;
    }
    Clear() {
      const e = this._firstMap;
      for (const t of e.values()) t.clear();
      e.clear();
    }
    Set(e, t, s) {
      const r = this._firstMap;
      let i = r.get(e);
      i || (i = /* @__PURE__ */ new Map(), r.set(e, i)), i.set(t, s);
    }
    Get(e, t) {
      const s = this._firstMap.get(e);
      return s ? s.get(t) : s;
    }
    Has(e, t) {
      const s = this._firstMap.get(e);
      return !!s && s.has(t);
    }
    Delete(e, t) {
      const s = this._firstMap, r = s.get(e);
      if (!r) return false;
      const i = r.delete(t);
      return i && 0 === r.size && s.delete(e), i;
    }
    DeleteEither(e) {
      const t = this._firstMap, s = t.get(e);
      s && (s.clear(), t.delete(e));
      for (const [s2, r] of t.entries()) r.delete(e) && 0 === r.size && t.delete(s2);
    }
    GetSize() {
      let e = 0;
      for (const t of this._firstMap.values()) e += t.size;
      return e;
    }
    *values() {
      for (const e of this._firstMap.values()) yield* e.values();
    }
    *keyPairs() {
      for (const [e, t] of this._firstMap.entries()) for (const s of t.keys()) yield [e, s];
    }
    *entries() {
      for (const [e, t] of this._firstMap.entries()) for (const [s, r] of t.entries()) yield [e, s, r];
    }
  };
}
{
  const C32 = self.C3;
  C32.ArraySet = class extends C32.DefendedBase {
    constructor() {
      super(), this._set = /* @__PURE__ */ new Set(), this._arr = [], this._needToRebuildArray = false;
    }
    Release() {
      this.Clear();
    }
    Clear() {
      this._set.clear(), C32.clearArray(this._arr), this._needToRebuildArray = false;
    }
    Add(e) {
      this._set.has(e) || (this._set.add(e), this._needToRebuildArray || this._arr.push(e));
    }
    Has(e) {
      return this._set.has(e);
    }
    Delete(e) {
      this._set.delete(e) && (this._needToRebuildArray = true);
    }
    GetSize() {
      return this._set.size;
    }
    IsEmpty() {
      return 0 === this._set.size;
    }
    GetArray() {
      return this._needToRebuildArray && (this._RebuildArray(), this._needToRebuildArray = false), this._arr;
    }
    _RebuildArray() {
      const e = this._arr;
      C32.clearArray(e);
      for (const r of this._set) e.push(r);
    }
  };
}
{
  const C32 = self.C3, EASE_MAP = /* @__PURE__ */ new Map(), PREDEFINED_EASE_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_RUNTIME_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_RUNTIME_MAP = /* @__PURE__ */ new Map(), PRIVATE_EASE_MAP = /* @__PURE__ */ new Map(), BUILT_IN_TRANSITION_MAP = /* @__PURE__ */ new Map(), ALIAS_MAP = /* @__PURE__ */ new Map();
  ALIAS_MAP.set("linear", "noease"), ALIAS_MAP.set("default", "noease");
  const EASE_TRANSLATION_KEYS = ["default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce"], SHORT_EASE_TRANSLATION_KEYS = ["default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce"], EASE_API2INTERNAL_NAMES = /* @__PURE__ */ new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"], ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]);
  self.Ease = class e {
    constructor() {
    }
    static InheritEase() {
      return "default";
    }
    static DefaultEase() {
      return "noease";
    }
    static ToInternal(e2) {
      return EASE_API2INTERNAL_NAMES.get(e2);
    }
    static GetEditorEaseNames(a2, ...s) {
      let t, i;
      this._CreateEaseMap(), a2 ? (CUSTOM_EASE_EDITOR_MAP.has(a2) || CUSTOM_EASE_EDITOR_MAP.set(a2, /* @__PURE__ */ new Map()), t = CUSTOM_EASE_EDITOR_MAP.get(a2), i = [...t.keys()].filter((s2) => !e.GetEditorEaseData(s2, a2) || e.GetEditorEaseData(s2, a2).transition.IsForAnyPurpose())) : (t = CUSTOM_EASE_RUNTIME_MAP, i = [...t.keys()]);
      const x = i.sort();
      return [...PREDEFINED_EASE_MAP.keys()].concat(x).filter((e2) => !s.includes(e2));
    }
    static GetRuntimeEaseNames() {
      this._CreateEaseMap();
      const e2 = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
      return e2.sort(), [...PREDEFINED_EASE_MAP.keys()].concat(e2);
    }
    static GetCustomRuntimeEaseNames() {
      this._CreateEaseMap();
      const e2 = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
      return e2.sort(), e2;
    }
    static IsPredefinedTranslatedName(e2) {
      for (const a2 of EASE_TRANSLATION_KEYS) {
        if (self.lang(`ui.bars.timeline.eases.${a2}`) === e2) return true;
      }
      for (const a2 of SHORT_EASE_TRANSLATION_KEYS) {
        if (self.lang(`ui.bars.timeline.short-eases.${a2}`) === e2) return true;
      }
    }
    static IsNamePredefined(e2) {
      return this._CreateEaseMap(), [...PREDEFINED_EASE_MAP.keys()].includes(e2);
    }
    static _GetEase(a2) {
      const s = ALIAS_MAP.get(a2);
      return s ? EASE_MAP.get(s) : e.IsNamePredefined(a2) ? EASE_MAP.get(a2) : PRIVATE_EASE_MAP.has(a2) ? PRIVATE_EASE_MAP.get(a2) : void 0;
    }
    static GetBuiltInTransition(e2) {
      return this._CreateEaseMap(), BUILT_IN_TRANSITION_MAP.get(e2);
    }
    static GetEditorEase(a2, s) {
      this._CreateEaseMap();
      const t = e._GetEase(a2);
      if (t) return t;
      if (!s) throw new Error("missing ease function");
      return CUSTOM_EASE_EDITOR_MAP.get(s).get(a2);
    }
    static GetEditorEaseData(e2, a2) {
      this._CreateEaseMap();
      const s = CUSTOM_EASE_DATA_EDITOR_MAP.get(a2);
      if (s) return s.get(e2);
    }
    static HasEditorEase(a2, s) {
      this._CreateEaseMap();
      return !!e._GetEase(a2) || !!CUSTOM_EASE_EDITOR_MAP.get(s).get(a2);
    }
    static GetRuntimeEase(a2) {
      this._CreateEaseMap();
      const s = e._GetEase(a2);
      return s || CUSTOM_EASE_RUNTIME_MAP.get(a2);
    }
    static GetRuntimeEaseData(e2) {
      return this._CreateEaseMap(), CUSTOM_EASE_DATA_RUNTIME_MAP.get(e2);
    }
    static GetEaseFromIndex(e2) {
      this._CreateEaseMap();
      return this.GetRuntimeEaseNames()[e2];
    }
    static GetIndexForEase(e2, a2) {
      this._CreateEaseMap();
      return this.GetEditorEaseNames(a2).indexOf(e2);
    }
    static GetIndexForEaseAtRuntime(e2) {
      return this.GetIndexForEase(e2);
    }
    static _CreateEaseMap() {
      0 === EASE_MAP.size && (this._AddPredifinedEase("default", () => {
      }), this._AddPredifinedEase("noease", [{ "x": 0, "y": 0, "sax": 0.336, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.336, "eay": 0, "se": false, "ee": true }], true), this._AddPredifinedEase("easeinsine", [{ "x": 0, "y": 0, "sax": 0.485, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.038, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutsine", [{ "x": 0, "y": 0, "sax": 0.038, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.485, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutsine", [{ "x": 0, "y": 0, "sax": 0.336, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.336, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinelastic", [{ "x": 0, "y": 0, "sax": 0.018, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.116, "y": 2e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.266, "y": -5e-3, "sax": 0.024, "say": 0, "eax": -0.021, "eay": 0, "se": true, "ee": true }, { "x": 0.416, "y": 0.016, "sax": 0.024, "say": 0, "eax": -0.026, "eay": 0, "se": true, "ee": true }, { "x": 0.566, "y": -0.045, "sax": 0.061, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.716, "y": 0.132, "sax": 0.072, "say": -4e-3, "eax": -0.045, "eay": 0, "se": true, "ee": true }, { "x": 0.866, "y": -0.373, "sax": 0.06, "say": 0, "eax": -0.049, "eay": -2e-3, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.038, "eay": -0.263, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutelastic", [{ "x": 0, "y": 0, "sax": 0.038, "say": 0.263, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.136, "y": 1.373, "sax": 0.049, "say": 2e-3, "eax": -0.06, "eay": 0, "se": true, "ee": true }, { "x": 0.286, "y": 0.868, "sax": 0.045, "say": 0, "eax": -0.072, "eay": 4e-3, "se": true, "ee": true }, { "x": 0.436, "y": 1.045, "sax": 0.025, "say": 0, "eax": -0.061, "eay": 0, "se": true, "ee": true }, { "x": 0.586, "y": 0.984, "sax": 0.026, "say": 0, "eax": -0.024, "eay": 0, "se": true, "ee": true }, { "x": 0.736, "y": 1.005, "sax": 0.021, "say": 0, "eax": -0.024, "eay": 0, "se": true, "ee": true }, { "x": 0.886, "y": 0.998, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.018, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutelastic", [{ "x": 0, "y": 0, "sax": 0.025, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.067, "y": 1e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.18, "y": -5e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.292, "y": 0.025, "sax": 0.053, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.405, "y": -0.118, "sax": 0.069, "say": 0, "eax": -0.027, "eay": 0, "se": true, "ee": true }, { "x": 0.597, "y": 1.118, "sax": 0.027, "say": 0, "eax": -0.069, "eay": 0, "se": true, "ee": true }, { "x": 0.71, "y": 0.975, "sax": 0.025, "say": 0, "eax": -0.053, "eay": 0, "se": true, "ee": true }, { "x": 0.822, "y": 1.005, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.935, "y": 0.999, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.025, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinback", [{ "x": 0, "y": 0, "sax": 0.35, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.34, "eay": -1.579, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutback", [{ "x": 0, "y": 0, "sax": 0.34, "say": 1.579, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.35, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutback", [{ "x": 0, "y": 0, "sax": 0.035, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.242, "y": -0.1, "sax": 0.258, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.76, "y": 1.1, "sax": 0.025, "say": 0, "eax": -0.26, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.035, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinbounce", [{ "x": 0, "y": 0, "sax": 0.033, "say": 0.025, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.092, "y": 0, "sax": 0.026, "say": 0.078, "eax": -0.033, "eay": 0.025, "se": true, "ee": true }, { "x": 0.274, "y": 0, "sax": 0.097, "say": 0.319, "eax": -0.026, "eay": 0.078, "se": true, "ee": true }, { "x": 0.637, "y": 0, "sax": 0.105, "say": 0.625, "eax": -0.097, "eay": 0.319, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.125, "eay": -4e-3, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutbounce", [{ "x": 0, "y": 0, "sax": 0.125, "say": 4e-3, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.365, "y": 1, "sax": 0.097, "say": -0.319, "eax": -0.105, "eay": -0.625, "se": true, "ee": true }, { "x": 0.728, "y": 1, "sax": 0.026, "say": -0.078, "eax": -0.097, "eay": -0.319, "se": true, "ee": true }, { "x": 0.91, "y": 1, "sax": 0.033, "say": -0.025, "eax": -0.026, "eay": -0.078, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.033, "eay": -0.025, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutbounce", [{ "x": 0, "y": 0, "sax": 0.01, "say": 6e-3, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.046, "y": 0, "sax": 0.021, "say": 0.038, "eax": -0.01, "eay": 6e-3, "se": true, "ee": true }, { "x": 0.137, "y": 0, "sax": 0.059, "say": 0.158, "eax": -0.021, "eay": 0.038, "se": true, "ee": true }, { "x": 0.319, "y": 0, "sax": 0.117, "say": 0.744, "eax": -0.059, "eay": 0.158, "se": true, "ee": true }, { "x": 0.683, "y": 1, "sax": 0.059, "say": -0.158, "eax": -0.117, "eay": -0.744, "se": true, "ee": true }, { "x": 0.865, "y": 1, "sax": 0.021, "say": -0.038, "eax": -0.059, "eay": -0.158, "se": true, "ee": true }, { "x": 0.956, "y": 1, "sax": 0.01, "say": -6e-3, "eax": -0.021, "eay": -0.038, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.01, "eay": -6e-3, "se": false, "ee": true }]), this._AddPredifinedEase("easeincubic", [{ "x": 0, "y": 0, "sax": 0.75, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.138, "eay": -0.321, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutcubic", [{ "x": 0, "y": 0, "sax": 0.138, "say": 0.321, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.75, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutcubic", [{ "x": 0, "y": 0, "sax": 0.285, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.081, "say": 0.272, "eax": -0.081, "eay": -0.272, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.285, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquad", [{ "x": 0, "y": 0, "sax": 0.4, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.178, "eay": -0.392, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquad", [{ "x": 0, "y": 0, "sax": 0.178, "say": 0.392, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.4, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquad", [{ "x": 0, "y": 0, "sax": 0.25, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.03, "say": 0.065, "eax": -0.03, "eay": -0.065, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquart", [{ "x": 0, "y": 0, "sax": 0.5, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquart", [{ "x": 0, "y": 0, "sax": 0.25, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.5, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquart", [{ "x": 0, "y": 0, "sax": 0.765, "say": 0.03, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.765, "eay": -0.03, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquint", [{ "x": 0, "y": 0, "sax": 0.6, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.2, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquint", [{ "x": 0, "y": 0, "sax": 0.2, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.6, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquint", [{ "eax": 0, "eay": 0, "ee": false, "sax": 0.84, "say": 0, "se": true, "x": 0, "y": 0 }, { "eax": -0.84, "eay": 0, "ee": true, "sax": 0, "say": 0, "se": false, "x": 1, "y": 1 }]), this._AddPredifinedEase("easeincirc", [{ "x": 0, "y": 0, "sax": 0.25, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.024, "eay": -0.808, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutcirc", [{ "x": 0, "y": 0, "sax": 0.024, "say": 0.808, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutcirc", [{ "x": 0, "y": 0, "sax": 0.125, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.02, "say": 0.428, "eax": -0.02, "eay": -0.428, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.125, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinexpo", [{ "x": 0, "y": 0, "sax": 0.66, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.14, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutexpo", [{ "x": 0, "y": 0, "sax": 0.14, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.66, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutexpo", [{ "eax": 0, "eay": 0, "ee": false, "sax": 0.345, "say": 0, "se": true, "x": 0, "y": 0 }, { "eax": -0.06, "eay": -0.5, "ee": true, "sax": 0.06, "say": 0.5, "se": true, "x": 0.5, "y": 0.5 }, { "eax": -0.335, "eay": 0, "ee": true, "sax": 0, "say": 0, "se": false, "x": 1, "y": 1 }]), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline", this.EaseSpline));
    }
    static _AddPredifinedEase(a2, s, t = false) {
      if ("function" == typeof s) e._AddEase(a2, s, "predefined");
      else {
        if (!C32.IsArray(s)) throw new Error("unexpected arguments");
        if (self.BuiltInTransition) {
          const i = C32.New(self.BuiltInTransition, a2, t);
          i.SetFromJson(s), e._AddEase(a2, (e2, a3, s2, t2) => i.Interpolate(e2, a3, s2, t2), "predefined"), BUILT_IN_TRANSITION_MAP.set(a2, i);
        } else {
          const i = C32.New(C32.Transition, [a2, s.map((e2) => [e2["x"], e2["y"], e2["sax"], e2["say"], e2["eax"], e2["eay"], e2["se"], e2["ee"]])], false);
          i.MakeLinear(t), e._AddEase(a2, (e2, a3, s2, t2) => i.Interpolate(e2, a3, s2, t2), "predefined");
        }
      }
    }
    static _AddPrivateCustomEase(a2, s) {
      e._AddEase(a2, s, "private");
    }
    static AddCustomEase(a2, s, t, i) {
      this._CreateEaseMap(), e._AddEase(a2, s, "custom", t, i);
    }
    static RemoveCustomEase(e2, a2) {
      if (this.IsNamePredefined(e2)) return;
      if ([...PRIVATE_EASE_MAP.keys()].includes(e2)) return;
      const s = CUSTOM_EASE_EDITOR_MAP.get(a2);
      s && s.delete(e2);
      const t = CUSTOM_EASE_DATA_EDITOR_MAP.get(a2);
      t && t.delete(e2);
    }
    static _AddEase(e2, a2, s, t, i) {
      switch (s) {
        case "predefined":
          EASE_MAP.set(e2, a2), PREDEFINED_EASE_MAP.set(e2, a2);
          break;
        case "custom":
          if (t) {
            CUSTOM_EASE_EDITOR_MAP.has(t) || CUSTOM_EASE_EDITOR_MAP.set(t, /* @__PURE__ */ new Map()), CUSTOM_EASE_DATA_EDITOR_MAP.has(t) || CUSTOM_EASE_DATA_EDITOR_MAP.set(t, /* @__PURE__ */ new Map());
            CUSTOM_EASE_EDITOR_MAP.get(t).set(e2, a2);
            CUSTOM_EASE_DATA_EDITOR_MAP.get(t).set(e2, i);
          } else CUSTOM_EASE_RUNTIME_MAP.set(e2, a2), CUSTOM_EASE_DATA_RUNTIME_MAP.set(e2, i);
          break;
        case "private":
          EASE_MAP.set(e2, a2), PRIVATE_EASE_MAP.set(e2, a2);
          break;
        default:
          throw new Error("unexpected ease mode");
      }
    }
    static NoEase(e2, a2, s, t) {
      return 0 === t ? a2 : s * e2 / t + a2;
    }
    static EaseCubicBezier(e2, a2, s, t, i) {
      return a2 + 3 * e2 * (s - a2) + 3 * e2 ** 2 * (a2 + t - 2 * s) + e2 ** 3 * (i - a2 + 3 * s - 3 * t);
    }
    static EaseSpline(e2, s, t, i, x, y, n, E, _, r) {
      if (i === x && y === n) return e2;
      const u = get_t_for_x(e2, s, i, y, E, r), d = a(t, x, n, _), A = b(t, x, n, _), o = c(t, x, n, _);
      return calc_bezier(u, d, A, o);
    }
    static GetBezierSamples(e2, s, t, i) {
      const x = [], y = a(e2, s, t, i), n = b(e2, s, t, i), E = c(e2, s, t, i);
      for (let e3 = 0; e3 < SAMPLE_COUNT; ++e3) {
        const a2 = calc_bezier(e3 * SAMPLE_STEP, y, n, E);
        x.push(a2);
      }
      return x;
    }
  };
  const SAMPLE_COUNT = 11, SAMPLE_STEP = 1 / (SAMPLE_COUNT - 1), NEWTON_RAPHSON_ITERATIONS = 4, NEWTON_RAPHSON_MIN_SLOPE = 0.01, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, a = (e, a2, s, t) => t - 3 * s + 3 * a2 - e, b = (e, a2, s, t) => 3 * s - 6 * a2 + 3 * e, c = (e, a2, s, t) => 3 * (a2 - e), calc_bezier = (e, a2, s, t) => ((a2 * e + s) * e + t) * e, get_slope = (e, a2, s, t) => 3 * a2 * e * e + 2 * s * e + t, get_t_for_x = (e, s, t, i, x, y) => {
    if (1 == e) return 1;
    let n = 0, E = 1, _ = y[E], r = SAMPLE_COUNT - 1;
    y[SAMPLE_COUNT - 1];
    for (; E != r && _ <= e; ) E++, _ = y[E], n += SAMPLE_STEP;
    E--, _ = y[E];
    let u = n + (e - _) / (y[E + 1] - _) * SAMPLE_STEP;
    const d = a(s, t, i, x), A = b(s, t, i, x), o = c(s, t, i, x), M = get_slope(u, d, A, o);
    if (0 === M) return u;
    if (M >= 0.01) {
      for (let a2 = 0; a2 < 4; ++a2) {
        u -= (calc_bezier(u, d, A, o) - e) / get_slope(u, d, A, o);
      }
      return u;
    }
    {
      let a2, s2, t2 = n, i2 = n + SAMPLE_STEP, x2 = 0;
      do {
        u = t2 + (i2 - t2) / 2;
        let y2 = calc_bezier(u, d, A, o) - e;
        y2 > 0 ? i2 = u : t2 = u, a2 = Math.abs(y2) > 1e-7, s2 = ++x2 < 10;
      } while (a2 && s2);
      return u;
    }
  };
}
{
  let RequireStringOrNumber = function(t) {
    C32.IsString(t);
  };
  RequireStringOrNumber2 = RequireStringOrNumber;
  const C32 = self.C3;
  C32.ProbabilityTable = class {
    constructor(t) {
      this._items = [], this._name = t || "", this._totalWeight = 0;
    }
    Release() {
      this.Clear(), this._items = null;
    }
    GetName() {
      return this._name;
    }
    Clear() {
      C32.clear2DArray(this._items), this._totalWeight = 0;
    }
    GetTotalWeight() {
      return this._totalWeight;
    }
    Sample(t = Math.random() * this.GetTotalWeight()) {
      let e = 0;
      for (const [i, s] of this._items) if (e += i, t < e) return s;
      return 0;
    }
    HasItems() {
      return !!this._items.length;
    }
    AddItem(t, e) {
      RequireStringOrNumber(e), this._totalWeight += t, this._items.push([t, e]);
    }
    RemoveItem(t, e) {
      RequireStringOrNumber(e);
      const i = 0 === t;
      for (let s = 0; s < this._items.length; s++) {
        const r = this._items[s], h = i || r[0] === t, n = r[1] === e;
        if (h && n) {
          this._items.splice(s, 1), this._totalWeight -= r[0];
          break;
        }
      }
    }
    asJSON() {
      return JSON.stringify(this._items);
    }
    static fromJSON(t, e) {
      const i = new C32.ProbabilityTable(e), s = JSON.parse(t);
      for (const t2 of s) {
        const e2 = t2[0], s2 = t2[1];
        i.AddItem(e2, s2);
      }
      return i;
    }
  };
}
var RequireStringOrNumber2;
{
  const C32 = self.C3;
  let nextId = 0;
  C32.ScreenReaderText = class {
    constructor(t, e) {
      this._runtime = t, this._text = e, this._id = nextId++, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "create", "id": this._id, "text": this._text });
    }
    Release() {
      this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "release", "id": this._id }), this._runtime = null, this._text = "", this._id = -1;
    }
    SetText(t) {
      this._text !== t && (this._text = t, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "update", "id": this._id, "text": this._text }));
    }
  };
}
{
  const C32 = self.C3;
  C32.Event = class {
    constructor(t, e) {
      this.type = t, this.cancelable = !!e, this.defaultPrevented = false, this.propagationStopped = false, this.isAsync = false;
    }
    preventDefault() {
      if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);
      this.defaultPrevented = true;
    }
    stopPropagation() {
      if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);
      if (this.isAsync) throw new Error(`cannot stop async event '${this.type}' propagation`);
      this.propagationStopped = true;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert;
  C32.Event.Handler = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._type = e, this._captureListeners = [], this._captureListenersSet = /* @__PURE__ */ new Set(), this._listeners = [], this._listenersSet = /* @__PURE__ */ new Set(), this._fireDepth = 0, this._queueModifyListeners = [];
    }
    Release() {
      this._fireDepth > 0 || (C32.clearArray(this._captureListeners), this._captureListenersSet.clear(), C32.clearArray(this._listeners), this._listenersSet.clear(), C32.clearArray(this._queueModifyListeners), C32.Release(this));
    }
    _AddListener(e, t) {
      if (this._IsFiring()) this._queueModifyListeners.push({ op: "add", func: e, capture: t });
      else if (t) {
        if (this._captureListenersSet.has(e)) return;
        this._captureListeners.push(e), this._captureListenersSet.add(e);
      } else {
        if (this._listenersSet.has(e)) return;
        this._listeners.push(e), this._listenersSet.add(e);
      }
    }
    _RemoveListener(e, t) {
      this._IsFiring() ? this._queueModifyListeners.push({ op: "remove", func: e, capture: t }) : t ? this._captureListenersSet.has(e) && (this._captureListenersSet.delete(e), C32.arrayFindRemove(this._captureListeners, e)) : this._listenersSet.has(e) && (this._listenersSet.delete(e), C32.arrayFindRemove(this._listeners, e));
    }
    _IsEmpty() {
      return !this._captureListeners.length && !this._listeners.length;
    }
    _IsFiring() {
      return this._fireDepth > 0;
    }
    _ProcessQueuedListeners() {
      const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
      for (const s of this._queueModifyListeners) if ("add" === s.op) this._AddListener(s.func, s.capture), s.capture ? t.delete(s.func) : e.delete(s.func);
      else {
        if ("remove" !== s.op) throw new Error("invalid op");
        s.capture ? (this._captureListenersSet.delete(s.func), t.add(s.func)) : (this._listenersSet.delete(s.func), e.add(s.func));
      }
      C32.arrayRemoveAllInSet(this._listeners, e), C32.arrayRemoveAllInSet(this._captureListeners, t), C32.clearArray(this._queueModifyListeners);
    }
    _FireCancellable(e) {
      this._IncreaseFireDepth();
      let t = false;
      for (let s = 0, r = this._captureListeners.length; s < r; ++s) if (this._captureListeners[s](e), e.propagationStopped) {
        t = true;
        break;
      }
      if (!t) for (let t2 = 0, s = this._listeners.length; t2 < s && (this._listeners[t2](e), !e.propagationStopped); ++t2) ;
      return this._DecreaseFireDepth(), !e.defaultPrevented;
    }
    _FireNonCancellable(e) {
      this._IncreaseFireDepth();
      for (let t = 0, s = this._captureListeners.length; t < s; ++t) this._captureListeners[t](e);
      for (let t = 0, s = this._listeners.length; t < s; ++t) this._listeners[t](e);
      return this._DecreaseFireDepth(), true;
    }
    _IncreaseFireDepth() {
      this._fireDepth++;
    }
    _DecreaseFireDepth() {
      this._fireDepth--, 0 === this._fireDepth && this._queueModifyListeners.length > 0 && this._ProcessQueuedListeners();
    }
    SetDelayRemoveEventsEnabled(e) {
      e ? this._IncreaseFireDepth() : this._DecreaseFireDepth();
    }
    _FireAsync(e) {
      let t = [];
      for (let s = 0, r = this._captureListeners.length; s < r; ++s) {
        let r2 = this._captureListeners[s];
        t.push(C32.Asyncify(() => r2(e)));
      }
      for (let s = 0, r = this._listeners.length; s < r; ++s) {
        let r2 = this._listeners[s];
        t.push(C32.Asyncify(() => r2(e)));
      }
      return Promise.all(t).then(() => !e.defaultPrevented);
    }
    _FireAndWait_AsyncOptional(e) {
      const t = [];
      this._IncreaseFireDepth();
      for (let s = 0, r = this._captureListeners.length; s < r; ++s) {
        const r2 = this._captureListeners[s](e);
        r2 instanceof Promise && t.push(r2);
      }
      for (let s = 0, r = this._listeners.length; s < r; ++s) {
        const r2 = this._listeners[s](e);
        r2 instanceof Promise && t.push(r2);
      }
      return this._DecreaseFireDepth(), t.length ? Promise.all(t).then(() => !e.defaultPrevented) : !e.defaultPrevented;
    }
    async _FireAndWaitAsync(e) {
      return await this._FireAndWait_AsyncOptional(e);
    }
    async _FireAndWaitAsyncSequential(e) {
      this._IncreaseFireDepth();
      for (let t = 0, s = this._captureListeners.length; t < s; ++t) {
        const s2 = this._captureListeners[t](e);
        s2 instanceof Promise && await s2;
      }
      for (let t = 0, s = this._listeners.length; t < s; ++t) {
        const s2 = this._listeners[t](e);
        s2 instanceof Promise && await s2;
      }
      return this._DecreaseFireDepth(), !e.defaultPrevented;
    }
    *_FireAsGenerator(e) {
      this._IncreaseFireDepth();
      for (let t = 0, s = this._captureListeners.length; t < s; ++t) {
        const s2 = this._captureListeners[t](e);
        C32.IsIterator(s2) && (yield* s2);
      }
      for (let t = 0, s = this._listeners.length; t < s; ++t) {
        const s2 = this._listeners[t](e);
        C32.IsIterator(s2) && (yield* s2);
      }
      this._DecreaseFireDepth();
    }
  };
}
{
  const C32 = self.C3;
  C32.Event.Dispatcher = class extends C32.DefendedBase {
    constructor() {
      super(), this._eventHandlers = /* @__PURE__ */ new Map(), this._dispatcherWasReleased = false;
    }
    Release() {
      if (this._dispatcherWasReleased) throw new Error("already released");
      this.ClearEvents(), this._dispatcherWasReleased = true, C32.Release(this);
    }
    WasReleased() {
      return this._dispatcherWasReleased;
    }
    ClearEvents() {
      if (this._eventHandlers) {
        for (let e of this._eventHandlers.values()) e.Release();
        this._eventHandlers.clear();
      }
    }
    _GetHandlerByType(e, t) {
      let n = this._eventHandlers.get(e);
      return n || (t ? (n = C32.New(C32.Event.Handler, e), this._eventHandlers.set(e, n), n) : null);
    }
    HasAnyHandlerFor(e) {
      return this._eventHandlers.has(e);
    }
    addEventListener(e, t, n) {
      this._GetHandlerByType(e, true)._AddListener(t, !!n);
    }
    removeEventListener(e, t, n) {
      let s = this._GetHandlerByType(e, false);
      s && (s._RemoveListener(t, !!n), s._IsEmpty() && this._eventHandlers.delete(e));
    }
    dispatchEvent(e) {
      const t = this._GetHandlerByType(e.type, false);
      return !t || (e.cancelable ? t._FireCancellable(e) : t._FireNonCancellable(e));
    }
    dispatchEventAsync(e) {
      const t = this._GetHandlerByType(e.type, false);
      return t ? (e.isAsync = true, t._FireAsync(e)) : Promise.resolve(true);
    }
    async dispatchEventAndClearAsync(e) {
      const t = this._GetHandlerByType(e.type, false);
      if (!t) return true;
      this._eventHandlers.delete(e.type), e.isAsync = true;
      const n = await t._FireAsync(e);
      return t.Release(), n;
    }
    async dispatchEventAndWaitAsync(e) {
      const t = this._GetHandlerByType(e.type, false);
      return !t || await t._FireAndWaitAsync(e);
    }
    dispatchEventAndWait_AsyncOptional(e) {
      const t = this._GetHandlerByType(e.type, false);
      return !t || t._FireAndWait_AsyncOptional(e);
    }
    async dispatchEventAndWaitAsyncSequential(e) {
      const t = this._GetHandlerByType(e.type, false);
      return !t || await t._FireAndWaitAsyncSequential(e);
    }
    dispatchGeneratorEvent(e) {
      const t = this._GetHandlerByType(e.type, false);
      if (!t) return null;
      if (e.cancelable) throw new Error("not supported");
      return t._FireAsGenerator(e);
    }
    SetDelayRemoveEventsEnabled(e) {
      for (const t of this._eventHandlers.values()) t.SetDelayRemoveEventsEnabled(e);
    }
  };
}
{
  let SetNewCallback = function(e) {
    callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork, { timeout: 35 }) : setTimeout(DoAsyncifiedWork, highThroughputMode > 0 ? 1 : e);
  }, DoAsyncifiedWork = function(e) {
    if (callbackId = -1, !workQueue.length) return;
    let o = performance.now(), i = o, t = 0, n = 0;
    do {
      DoNextAsyncifiedJob(workQueue.shift()), i = performance.now(), ++t, n = (i - o) / t * 1.1;
    } while (workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && void 0 !== e ? n < e["timeRemaining"]() : i - o + n < 12));
    if (-1 === callbackId && workQueue.length) {
      let e2 = i - o;
      SetNewCallback(Math.max(16 - e2, 4));
    }
  }, DoNextAsyncifiedJob = function(e) {
    let o;
    try {
      o = e.func();
    } catch (o2) {
      return void e.reject(o2);
    }
    e.resolve(o);
  };
  SetNewCallback2 = SetNewCallback, DoAsyncifiedWork2 = DoAsyncifiedWork, DoNextAsyncifiedJob2 = DoNextAsyncifiedJob;
  const C32 = self.C3, SETTIMEOUT_WORK_DURATION = 12, SETTIMEOUT_INTERVAL = 16, IDLECALLBACK_TIMEOUT = 35, SUPPORTS_RIC = "undefined" != typeof requestIdleCallback;
  let workQueue = [], callbackId = -1, highThroughputMode = 0;
  let asyncifyDisabled = C32.QueryString.Has("disable-asyncify");
  asyncifyDisabled && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."), C32.Asyncify = function(e) {
    let o = null;
    return C32.isDebug && (o = C32.GetCallStack()), new Promise((i, t) => {
      workQueue.push({ func: e, resolve: i, reject: t, stack: o }), asyncifyDisabled ? DoNextAsyncifiedJob(workQueue.pop()) : -1 === callbackId && SetNewCallback(16);
    });
  }, C32.Asyncify.SetHighThroughputMode = function(e) {
    if (e) ++highThroughputMode;
    else if (--highThroughputMode, highThroughputMode < 0) throw new Error("already turned off high throughput mode");
  };
}
var SetNewCallback2;
var DoAsyncifiedWork2;
var DoNextAsyncifiedJob2;
{
  let ClearTimeCache = function() {
    cachedNowTime = -1;
  }, CheckActiveIdleTimeouts = function() {
    timerId = -1, nextDeadline = -1;
    let e = Date.now();
    for (let t of activeIdleTimeouts) if (t._CheckTimeout(e)) {
      let e2 = t._GetDeadline();
      (-1 === nextDeadline || e2 < nextDeadline) && (nextDeadline = e2);
    } else activeIdleTimeouts.delete(t);
    if (-1 !== nextDeadline) {
      let t = Math.max(nextDeadline - e + 100, 1e3);
      timerId = self.setTimeout(CheckActiveIdleTimeouts, t);
    }
  };
  ClearTimeCache2 = ClearTimeCache, CheckActiveIdleTimeouts2 = CheckActiveIdleTimeouts;
  const C32 = self.C3, IDLE_CHECK_MIN_INTERVAL = 1e3, IDLE_CHECK_TIMER_OVERSHOOT = 100;
  let cachedNowTime = -1;
  C32.FastGetDateNow = function() {
    return -1 === cachedNowTime && (cachedNowTime = Date.now(), self.setTimeout(ClearTimeCache, 16)), cachedNowTime;
  };
  let timerId = -1, nextDeadline = -1, activeIdleTimeouts = /* @__PURE__ */ new Set();
  C32.IdleTimeout = class {
    constructor(e, t) {
      this._callback = e, this._timeout = 1e3 * t, this._deadline = 0, this._isActive = false;
    }
    Reset() {
      let e = C32.FastGetDateNow();
      this._deadline = e + this._timeout, this._isActive || (activeIdleTimeouts.add(this), this._isActive = true), -1 === timerId ? (nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100)) : this._deadline < nextDeadline && nextDeadline > e + 1e3 && (self.clearTimeout(timerId), nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100));
    }
    _CheckTimeout(e) {
      return !(e >= this._deadline) || (this._callback() ? (this._deadline = e + this._timeout, true) : (this._isActive = false, false));
    }
    _GetDeadline() {
      return this._deadline;
    }
    Cancel() {
      this._isActive && (activeIdleTimeouts.delete(this), this._isActive = false, 0 === activeIdleTimeouts.size && -1 !== timerId && (self.clearTimeout(timerId), timerId = -1, nextDeadline = -1));
    }
    Release() {
      this.Cancel(), this._callback = null;
    }
  };
}
var ClearTimeCache2;
var CheckActiveIdleTimeouts2;
{
  const C32 = self.C3;
  C32.Disposable = class s {
    constructor(s2) {
      this._disposed = false, this._disposeAction = s2;
    }
    Dispose() {
      this._disposed || (this._disposed = true, this._disposeAction && (this._disposeAction(), this._disposeAction = null));
    }
    IsDisposed() {
      return this._disposed;
    }
    Release() {
      this.Dispose();
    }
    static Release(e) {
      return new s(() => e.Release());
    }
    static From(s2, e, i, o, t) {
      if ("string" != typeof e && !Array.isArray(e)) throw new TypeError("expected string or array");
      if (null == o) o = false;
      else if ("boolean" != typeof o && "object" != typeof o) throw new TypeError("invalid event listener options");
      if (t && (i = i.bind(t)), Array.isArray(e) || e.includes(" ")) {
        "string" == typeof e && (e = e.split(" "));
        const t2 = new C32.CompositeDisposable();
        for (const r of e) s2.addEventListener(r, i, o), t2.Add(C32.New(C32.Disposable, () => s2.removeEventListener(r, i, o)));
        return t2;
      }
      return s2.addEventListener(e, i, o), C32.New(C32.Disposable, () => s2.removeEventListener(e, i, o));
    }
  }, C32.StubDisposable = class extends C32.Disposable {
    SetAction(s) {
      this._disposeAction = s;
    }
  }, C32.CompositeDisposable = class extends C32.Disposable {
    constructor(...s) {
      super(), this._disposables = /* @__PURE__ */ new Set();
      for (let e of s) this.Add(e);
    }
    Add(...s) {
      if (this._disposed) throw new Error("already disposed");
      for (let e of s) this._disposables.add(e);
    }
    Remove(s) {
      if (this._disposed) throw new Error("already disposed");
      this._disposables.delete(s);
    }
    RemoveAll() {
      if (this._disposed) throw new Error("already disposed");
      if (this._disposables) {
        for (let s of this._disposables) s.Dispose();
        this._disposables.clear();
      }
    }
    IsDisposed() {
      return this._disposed;
    }
    Dispose() {
      if (this._disposed) throw new Error("already disposed");
      this._disposed = true;
      for (let s of this._disposables) s.Dispose();
      this._disposables.clear(), this._disposables = null;
    }
    Release() {
      this.Dispose();
    }
  };
}
{
  const C32 = self.C3;
  C32.KahanSum = class extends C32.DefendedBase {
    constructor() {
      super(), this._c = 0, this._y = 0, this._t = 0, this._sum = 0;
    }
    Add(s) {
      s = +s, this._y = s - this._c, this._t = this._sum + this._y, this._c = this._t - this._sum - this._y, this._sum = this._t;
    }
    Subtract(s) {
      this._sum -= +s;
    }
    Get() {
      return this._sum;
    }
    Reset() {
      this._c = 0, this._y = 0, this._t = 0, this._sum = 0;
    }
    Set(s) {
      this._c = 0, this._y = 0, this._t = 0, this._sum = +s;
    }
    Copy(s) {
      this._c = s._c, this._y = s._y, this._t = s._t, this._sum = s._sum;
    }
    Release() {
    }
  };
}
{
  const C32 = self.C3, js_cols = {}, RED = true, BLACK = false;
  js_cols.RBnode = function(t) {
    this.tree = t, this.right = this.tree.sentinel, this.left = this.tree.sentinel, this.parent = null, this.color = false, this.key = null;
  }, js_cols.RedBlackSet = function(t) {
    this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = false, this.root = this.sentinel, this.root.parent = this.sentinel, this.compare = t || this.default_compare;
  }, js_cols.RedBlackSet.prototype.default_compare = function(t, e) {
    return t < e ? -1 : e < t ? 1 : 0;
  }, js_cols.RedBlackSet.prototype.clone = function() {
    var t = new js_cols.RedBlackSet(this.compare);
    return t.insertAll(this), t;
  }, js_cols.RedBlackSet.prototype.clear = function() {
    this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = false, this.root = this.sentinel, this.root.parent = this.sentinel;
  }, js_cols.RedBlackSet.prototype.leftRotate = function(t) {
    var e = t.right;
    t.right = e.left, e.left != this.sentinel && (e.left.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.left ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;
  }, js_cols.RedBlackSet.prototype.rightRotate = function(t) {
    var e = t.left;
    t.left = e.right, e.right != this.sentinel && (e.right.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.right ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;
  }, js_cols.RedBlackSet.prototype.insert = function(t) {
    if (this.contains(t)) {
      this.get_(t).key = t;
    } else {
      var e = new js_cols.RBnode(this);
      e.key = t;
      for (var s = this.sentinel, r = this.root; r != this.sentinel; ) s = r, r = this.compare(e.key, r.key) < 0 ? r.left : r.right;
      e.parent = s, s == this.sentinel ? this.root = e : this.compare(e.key, s.key) < 0 ? s.left = e : s.right = e, e.left = this.sentinel, e.right = this.sentinel, e.color = RED, this.insertFixup(e), this.size++;
    }
  }, js_cols.RedBlackSet.prototype.insertFixup = function(t) {
    for (; t != this.sentinel && t != this.root && t.parent.color == RED; ) {
      var e;
      if (t.parent == t.parent.parent.left) (e = t.parent.parent.right).color == RED ? (t.parent.color = false, e.color = false, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.right && (t = t.parent, this.leftRotate(t)), t.parent.color = false, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.rightRotate(t.parent.parent));
      else (e = t.parent.parent.left).color == RED ? (t.parent.color = false, e.color = false, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.left && (t = t.parent, this.rightRotate(t)), t.parent.color = false, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.leftRotate(t.parent.parent));
    }
    this.root.color = false;
  }, js_cols.RedBlackSet.prototype.delete_ = function(t) {
    var e, s;
    (s = (e = t.left == this.sentinel || t.right == this.sentinel ? t : this.successor_(t)).left != this.sentinel ? e.left : e.right).parent = e.parent, e.parent == this.sentinel ? this.root = s : e == e.parent.left ? e.parent.left = s : e.parent.right = s, e != t && (t.key = e.key), false == e.color && this.deleteFixup(s), this.size--;
  }, js_cols.RedBlackSet.prototype.deleteFixup = function(t) {
    for (; t != this.root && false == t.color; ) {
      var e;
      if (t == t.parent.left) (e = t.parent.right).color == RED && (e.color = false, t.parent.color = RED, this.leftRotate(t.parent), e = t.parent.right), false == e.left.color && false == e.right.color ? (e.color = RED, t = t.parent) : (false == e.right.color && (e.left.color = false, e.color = RED, this.rightRotate(e), e = t.parent.right), e.color = t.parent.color, t.parent.color = false, e.right.color = false, this.leftRotate(t.parent), t = this.root);
      else (e = t.parent.left).color == RED && (e.color = false, t.parent.color = RED, this.rightRotate(t.parent), e = t.parent.left), false == e.right.color && false == e.left.color ? (e.color = RED, t = t.parent) : (false == e.left.color && (e.right.color = false, e.color = RED, this.leftRotate(e), e = t.parent.left), e.color = t.parent.color, t.parent.color = false, e.left.color = false, this.rightRotate(t.parent), t = this.root);
    }
    t.color = false;
  }, js_cols.RedBlackSet.prototype.remove = function(t) {
    var e = this.get_(t);
    if (e != this.sentinel) {
      var s = e.key;
      return this.delete_(e), s;
    }
    return null;
  }, js_cols.RedBlackSet.prototype.removeSwapped = function(t, e) {
    this.remove(e);
  }, js_cols.RedBlackSet.prototype.min = function(t) {
    for (; t.left != this.sentinel; ) t = t.left;
    return t;
  }, js_cols.RedBlackSet.prototype.max = function(t) {
    for (; t.right != this.sentinel; ) t = t.right;
    return t;
  }, js_cols.RedBlackSet.prototype.successor_ = function(t) {
    if (t.right != this.sentinel) return this.min(t.right);
    for (var e = t.parent; e != this.sentinel && t == e.right; ) t = e, e = e.parent;
    return e;
  }, js_cols.RedBlackSet.prototype.predeccessor_ = function(t) {
    if (t.left != this.sentinel) return this.max(t.left);
    for (var e = t.parent; e != this.sentinel && t == e.left; ) t = e, e = e.parent;
    return e;
  }, js_cols.RedBlackSet.prototype.successor = function(t) {
    if (this.size > 0) {
      var e = this.get_(t);
      if (e == this.sentinel) return null;
      if (e.right != this.sentinel) return this.min(e.right).key;
      for (var s = e.parent; s != this.sentinel && e == s.right; ) e = s, s = s.parent;
      return s != this.sentinel ? s.key : null;
    }
    return null;
  }, js_cols.RedBlackSet.prototype.predecessor = function(t) {
    if (this.size > 0) {
      var e = this.get_(t);
      if (e == this.sentinel) return null;
      if (e.left != this.sentinel) return this.max(e.left).key;
      for (var s = e.parent; s != this.sentinel && e == s.left; ) e = s, s = s.parent;
      return s != this.sentinel ? s.key : null;
    }
    return null;
  }, js_cols.RedBlackSet.prototype.getMin = function() {
    return this.min(this.root).key;
  }, js_cols.RedBlackSet.prototype.getMax = function() {
    return this.max(this.root).key;
  }, js_cols.RedBlackSet.prototype.get_ = function(t) {
    for (var e = this.root; e != this.sentinel && 0 != this.compare(e.key, t); ) e = this.compare(t, e.key) < 0 ? e.left : e.right;
    return e;
  }, js_cols.RedBlackSet.prototype.contains = function(t) {
    return null != this.get_(t).key;
  }, js_cols.RedBlackSet.prototype.getValues = function() {
    var t = [];
    return this.forEach(function(e) {
      t.push(e);
    }), t;
  }, js_cols.RedBlackSet.prototype.insertAll = function(t) {
    if ("array" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.insert(t[e]);
    else if ("function" == js_cols.typeOf(t.forEach)) t.forEach(this.insert, this);
    else if ("function" == js_cols.typeOf(t.getValues)) {
      var s = t.getValues();
      for (e = 0; e < s.length; e++) this.insert(s[e]);
    } else if ("object" == js_cols.typeOf(t)) for (var r in t) this.insert(t[r]);
  }, js_cols.RedBlackSet.prototype.removeAll = function(t) {
    if ("array" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.remove(t[e]);
    else if ("function" == js_cols.typeOf(t.forEach)) t.forEach(this.removeSwapped, this);
    else if ("function" == js_cols.typeOf(t.getValues)) {
      var s = t.getValues();
      for (e = 0; e < s.length; e++) this.remove(s[e]);
    } else if ("object" == js_cols.typeOf(t)) for (var r in t) this.remove(t[r]);
  }, js_cols.RedBlackSet.prototype.containsAll = function(t) {
    if ("array" == js_cols.typeOf(t)) {
      for (var e = 0; e < t.length; e++) if (!this.contains(t[e])) return false;
      return true;
    }
    if ("function" == js_cols.typeOf(t.forEach)) return t.every(this.contains, this);
    if ("function" == js_cols.typeOf(t.getValues)) {
      var s = t.getValues();
      for (e = 0; e < s.length; e++) if (!this.contains(s[e])) return false;
      return true;
    }
    if ("object" == js_cols.typeOf(t)) {
      for (var r in t) if (!this.contains(t[r])) return false;
      return true;
    }
  }, js_cols.RedBlackSet.prototype.range = function(t, e) {
    var s = [];
    return this.traverseFromTo(function(t2) {
      s.push(t2);
    }, t, e), s;
  }, js_cols.RedBlackSet.prototype.traverse = function(t, e) {
    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; ) {
      if (t.call(e, s.key, this)) return;
      s = this.successor_(s);
    }
  }, js_cols.RedBlackSet.prototype.traverseFrom = function(t, e, s) {
    if (!this.isEmpty()) for (var r = this.get_(e); r != this.sentinel; ) {
      if (t.call(s, r.key, this)) return;
      r = this.successor_(r);
    }
  }, js_cols.RedBlackSet.prototype.traverseTo = function(t, e, s) {
    if (!this.isEmpty()) for (var r = this.min(this.root), i = this.get_(e); r != i; ) {
      if (t.call(s, r.key, this)) return;
      r = this.successor_(r);
    }
  }, js_cols.RedBlackSet.prototype.traverseFromTo = function(t, e, s, r) {
    if (!this.isEmpty()) for (var i = this.get_(e), o = this.get_(s); i != o; ) {
      if (t.call(r, i.key, this)) return;
      i = this.successor_(i);
    }
  }, js_cols.RedBlackSet.prototype.traverseBackwards = function(t, e) {
    if (!this.isEmpty()) for (var s = this.max(this.root); s != this.sentinel; ) {
      if (t.call(e, s.key, this)) return;
      s = this.predeccessor_(s);
    }
  }, js_cols.RedBlackSet.prototype.forEach = function(t, e) {
    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t.call(e, s.key, s.key, this);
  }, js_cols.RedBlackSet.prototype.some = function(t, e) {
    if (this.isEmpty()) return false;
    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (t.call(e, s.key, s.key, this)) return true;
    return false;
  }, js_cols.RedBlackSet.prototype.every = function(t, e) {
    if (this.isEmpty()) return false;
    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (!t.call(e, s.key, s.key, this)) return false;
    return true;
  }, js_cols.RedBlackSet.prototype.map = function(t, e) {
    var s = [];
    if (this.isEmpty()) return s;
    for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) s.push(t.call(e, r.key, r.key, this));
    return s;
  }, js_cols.RedBlackSet.prototype.filter = function(t, e) {
    var s = [];
    if (this.isEmpty()) return s;
    for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) t.call(e, r.key, r.key, this) && s.push(r.key);
    return s;
  }, js_cols.RedBlackSet.prototype.getCount = function() {
    return this.size;
  }, js_cols.RedBlackSet.prototype.isEmpty = function() {
    return 0 == this.size;
  }, js_cols.RedBlackSet.prototype.isSubsetOf = function(t) {
    var e = js_cols.getCount(t);
    if (this.getCount() > e) return false;
    var s = 0;
    if (this.isEmpty()) return true;
    for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) js_cols.contains.call(t, t, r.key) && s++;
    return s == this.getCount();
  }, js_cols.RedBlackSet.prototype.intersection = function(t) {
    var e = new js_cols.RedBlackSet(this.compare);
    if (this.isEmpty()) return e;
    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t.contains.call(t, s.key, s.key, this) && e.insert(s.key);
    return e;
  }, C32.RedBlackSet = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._rbSet = new js_cols.RedBlackSet(t), this._enableQueue = false, this._queueInsert = /* @__PURE__ */ new Set(), this._queueRemove = /* @__PURE__ */ new Set();
    }
    Add(t) {
      this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.delete(t) : this._queueInsert.add(t) : this._rbSet.insert(t);
    }
    Remove(t) {
      this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.add(t) : this._queueInsert.delete(t) : this._rbSet.remove(t);
    }
    Has(t) {
      return this._enableQueue ? !!this._queueInsert.has(t) || !this._queueRemove.has(t) && this._rbSet.contains(t) : this._rbSet.contains(t);
    }
    Clear() {
      this._rbSet.clear(), this._queueInsert.clear(), this._queueRemove.clear();
    }
    toArray() {
      if (this._enableQueue) throw new Error("cannot be used in queueing mode");
      return this._rbSet.getValues();
    }
    GetSize() {
      return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size;
    }
    IsEmpty() {
      return 0 === this.GetSize();
    }
    Front() {
      if (this.IsEmpty()) throw new Error("empty set");
      if (this._enableQueue) throw new Error("cannot be used in queueing mode");
      const t = this._rbSet;
      return t.min(t.root).key;
    }
    Shift() {
      if (this.IsEmpty()) throw new Error("empty set");
      if (this._enableQueue) throw new Error("cannot be used in queueing mode");
      const t = this.Front();
      return this.Remove(t), t;
    }
    SetQueueingEnabled(t) {
      if (t = !!t, this._enableQueue !== t && (this._enableQueue = t, !t)) {
        for (const t2 of this._queueRemove) this._rbSet.remove(t2);
        this._queueRemove.clear();
        for (const t2 of this._queueInsert) this._rbSet.insert(t2);
        this._queueInsert.clear();
      }
    }
    ForEach(t) {
      this._rbSet.forEach(t);
    }
    *values() {
      if (this.IsEmpty()) return;
      const t = this._rbSet;
      for (let e = t.min(t.root); e != t.sentinel; e = t.successor_(e)) yield e.key;
    }
    [Symbol.iterator]() {
      return this.values();
    }
  };
}
{
  const C32 = self.C3;
  C32.PromiseThrottle = class {
    constructor(e = C32.hardwareConcurrency) {
      this._maxParallel = e, this._queue = [], this._activeCount = 0;
    }
    Add(e, t) {
      return new Promise((r, n) => {
        const s = { func: e, resolve: r, reject: n, opts: t };
        t?.signal && t.signal.aborted ? n(new Error("abort")) : (t?.signal && (s.onabort = () => {
          const e2 = this._queue.indexOf(s);
          -1 !== e2 && (this._queue.splice(e2, 1), n(new Error("abort")));
        }, t.signal.addEventListener("abort", s.onabort)), this._queue.push(s), this._MaybeStartNext());
      });
    }
    _FindInQueue(e) {
      for (let t = 0, r = this._queue.length; t < r; ++t) if (this._queue[t].func === e) return t;
      return -1;
    }
    RemoveAndResolve(e, t) {
      const r = this._FindInQueue(e);
      if (-1 === r) throw new Error("cannot find promise to resolve");
      this._queue[r].resolve(t), this._queue.splice(r, 1);
    }
    RemoveAndReject(e, t) {
      const r = this._FindInQueue(e);
      if (-1 === r) throw new Error("cannot find promise to reject");
      this._queue[r].reject(t), this._queue.splice(r, 1);
    }
    async _MaybeStartNext() {
      if (!this._queue.length) return;
      if (this._activeCount >= this._maxParallel) return;
      this._activeCount++;
      const e = this._queue.shift();
      e.opts?.signal && e.onabort && e.opts.signal.removeEventListener("abort", e.onabort);
      try {
        const t = await e.func();
        e.resolve(t);
      } catch (t) {
        e.reject(t);
      }
      this._activeCount--, this._MaybeStartNext();
    }
  };
}
{
  const C32 = self.C3;
  C32.RateLimiter = class {
    constructor(t, e, i) {
      this._callback = t, this._interval = e, this._intervalOnBattery = i || 2 * e, this._timerId = -1, this._lastCallTime = -1 / 0, this._timerCallFunc = () => this._OnTimer(), this._ignoreReset = false, this._canRunImmediate = false, this._callbackArguments = null;
    }
    SetCanRunImmediate(t) {
      this._canRunImmediate = !!t;
    }
    _GetInterval() {
      return void 0 !== C32.Battery && C32.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval;
    }
    Call(...t) {
      if (-1 !== this._timerId) return;
      this._callbackArguments = t;
      let e = C32.FastGetDateNow(), i = e - this._lastCallTime, l = this._GetInterval();
      i >= l && this._canRunImmediate ? (this._lastCallTime = e, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(l - i, 4));
    }
    _RunCallback() {
      this._ignoreReset = true;
      const t = this._callbackArguments;
      this._callbackArguments = null, t ? this._callback(...t) : this._callback(), this._ignoreReset = false;
    }
    Reset() {
      this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = C32.FastGetDateNow());
    }
    _OnTimer() {
      this._timerId = -1, this._lastCallTime = C32.FastGetDateNow(), this._RunCallback();
    }
    _CancelTimer() {
      -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1);
    }
    Release() {
      this._CancelTimer(), this._callback = null, this._callbackArguments = null, this._timerCallFunc = null;
    }
  };
}
{
  const C32 = self.C3;
  C32.SVGRasterManager = class {
    constructor() {
      this._images = /* @__PURE__ */ new Map(), this._allowNpotSurfaces = false, this._getBaseSizeCallback = null, this._rasterAtSizeCallback = null, this._releaseResultCallback = null, this._redrawCallback = null;
    }
    SetNpotSurfaceAllowed(e) {
      this._allowNpotSurfaces = !!e;
    }
    IsNpotSurfaceAllowed() {
      return this._allowNpotSurfaces;
    }
    SetGetBaseSizeCallback(e) {
      this._getBaseSizeCallback = e;
    }
    GetBaseSize(e) {
      if (!this._getBaseSizeCallback) throw new Error("no get base size callback set");
      return this._getBaseSizeCallback(e);
    }
    SetRasterAtSizeCallback(e) {
      this._rasterAtSizeCallback = e;
    }
    RasterAtSize(e, a, t, l, s, r) {
      if (!this._rasterAtSizeCallback) throw new Error("no raster at size callback set");
      return this._rasterAtSizeCallback(e, a, t, l, s, r);
    }
    SetReleaseResultCallback(e) {
      this._releaseResultCallback = e;
    }
    ReleaseResult(e) {
      if (!this._releaseResultCallback) throw new Error("no release result callback set");
      this._releaseResultCallback(e);
    }
    SetRedrawCallback(e) {
      this._redrawCallback = e;
    }
    Redraw() {
      if (!this._redrawCallback) throw new Error("no redraw callback set");
      this._redrawCallback();
    }
    AddImage(e) {
      let a = this._images.get(e);
      return a || (a = C32.New(C32.SVGRasterImage, this, e), this._images.set(e, a)), a.IncReference(), a;
    }
    _RemoveImage(e) {
      this._images.delete(e.GetDataSource());
    }
    OnTexturesChanged() {
      for (const e of this._images.values()) e.ReleaseRasterizedResult(), e.ForceRasterAgain();
    }
  };
}
{
  const C32 = self.C3, MAX_SURFACE_SIZE = 4096;
  C32.SVGRasterImage = class {
    constructor(e, t) {
      this._manager = e, this._dataSource = t, this._refCount = 0, this._baseWidth = 0, this._baseHeight = 0, this._getBaseSizePromise = this._manager.GetBaseSize(t).then((e2) => {
        this._manager && (this._baseWidth = e2[0], this._baseHeight = e2[1], this._manager.Redraw());
      }).catch((e2) => {
        console.error("[SVG] Error loading SVG: ", e2), this._hadError = true, this._manager && this._manager.Redraw();
      }), this._rasterSurfaceWidth = 0, this._rasterSurfaceHeight = 0, this._rasterImageWidth = 0, this._rasterImageHeight = 0, this._isRasterizing = false, this._rasterizedResult = null, this._forceRaster = false, this._hadError = false;
    }
    Release() {
      if (this._refCount <= 0) throw new Error("already released");
      this._refCount--, 0 === this._refCount && this._Release();
    }
    ReleaseRasterizedResult() {
      this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null);
    }
    _Release() {
      this.ReleaseRasterizedResult(), this._manager._RemoveImage(this), this._manager = null;
    }
    GetDataSource() {
      return this._dataSource;
    }
    IncReference() {
      this._refCount++;
    }
    HasReferences() {
      return this._refCount > 0;
    }
    GetRasterizedResult() {
      return this._rasterizedResult;
    }
    ForceRasterAgain() {
      this._forceRaster = true;
    }
    async StartRasterForSize(e, t, r) {
      if (0 === t || 0 === r || this._hadError) return;
      if (this._isRasterizing) return;
      let s = C32.nextHighestPowerOfTwo(Math.ceil(t)), a = C32.nextHighestPowerOfTwo(Math.ceil(r));
      const i = Math.max(s, a);
      if (i > 4096) {
        const e2 = 4096 / i;
        t *= e2, r *= e2, s = Math.min(Math.ceil(s * e2), 4096), a = Math.min(Math.ceil(a * e2), 4096);
      }
      if (t < s && r < a) {
        const e2 = t / r;
        s / a > e2 ? (t = a * e2, r = a) : (t = s, r = s / e2);
      }
      if (this._manager.IsNpotSurfaceAllowed() && (s = Math.ceil(t), a = Math.ceil(r)), s <= this._rasterSurfaceWidth && a <= this._rasterSurfaceHeight && !this._forceRaster) return;
      this._isRasterizing = true, this._rasterSurfaceWidth = s, this._rasterSurfaceHeight = a;
      const h = await this._manager.RasterAtSize(this._dataSource, e, this._rasterSurfaceWidth, this._rasterSurfaceHeight, t, r);
      this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = h, this._rasterImageWidth = t, this._rasterImageHeight = r, this._isRasterizing = false, this._forceRaster = false, this._manager.Redraw());
    }
    WhenBaseSizeReady() {
      return this._getBaseSizePromise;
    }
    GetBaseWidth() {
      return this._baseWidth;
    }
    GetBaseHeight() {
      return this._baseHeight;
    }
    GetRasterWidth() {
      return this._rasterImageWidth;
    }
    GetRasterHeight() {
      return this._rasterImageHeight;
    }
    HadError() {
      return this._hadError;
    }
  };
}
{
  let lookupHtmlEntity = function(t) {
    return HTML_ENTITY_MAP.get(t);
  };
  lookupHtmlEntity2 = lookupHtmlEntity;
  const C32 = self.C3;
  C32.UTF8_BOM = "\uFEFF";
  const NUMERIC_CHARS = new Set("0123456789");
  C32.IsNumericChar = function(t) {
    return NUMERIC_CHARS.has(t);
  };
  const WHITESPACE_CHARS = new Set(" 	\n\r\xA0\x85\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2028\u2029\u202F\u205F\u3000");
  C32.IsWhitespaceChar = function(t) {
    return WHITESPACE_CHARS.has(t);
  }, C32.FilterWhitespace = function(t) {
    return [...t].filter((t2) => !C32.IsWhitespaceChar(t2)).join("");
  }, C32.IsStringAllWhitespace = function(t) {
    for (const e of t) if (!C32.IsWhitespaceChar(e)) return false;
    return true;
  }, C32.IsCharArrayAllWhitespace = function(t) {
    for (const e of t) if (!C32.IsWhitespaceChar(e)) return false;
    return true;
  }, C32.IsUnprintableChar = function(t) {
    return 1 === t.length && t.charCodeAt(0) < 32;
  }, C32.FilterUnprintableChars = function(t) {
    return [...t].filter((t2) => !C32.IsUnprintableChar(t2)).join("");
  };
  let cjkPunctuationRegex = null;
  try {
    cjkPunctuationRegex = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])", "u");
  } catch (t) {
    console.warn("Unable to detect CJK punctuation: ", t);
  }
  C32.IsCJKPunctuationChar = function(t) {
    return !C32.IsWhitespaceChar(t) && cjkPunctuationRegex && cjkPunctuationRegex.test(t);
  };
  const NUMERIC_STRING_CHARS = new Set("0123456789.+-e");
  C32.IsStringNumber = function(t) {
    if (!(t = t.trim()).length) return false;
    let e = t.charAt(0);
    if ("-" !== e && !NUMERIC_CHARS.has(e)) return false;
    for (let e2 of t) if (!NUMERIC_STRING_CHARS.has(e2)) return false;
    return true;
  }, C32.RemoveTrailingDigits = function(t) {
    let e = t.length;
    for (; e > 0; ) {
      let n = t.charAt(e - 1);
      if (!C32.IsNumericChar(n)) break;
      --e;
    }
    return t.substr(0, e);
  }, C32.IncrementNumberAtEndOf = function(t) {
    let e = C32.RemoveTrailingDigits(t), n = t.substr(e.length);
    return n = n ? (parseInt(n, 10) + 1).toString() : "2", e + n;
  };
  const HTML_ENTITY_MAP = /* @__PURE__ */ new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]);
  const HTML_ENTITY_REGEX = /[&<>"']/g;
  C32.EscapeHTML = function(t) {
    return t.replace(HTML_ENTITY_REGEX, lookupHtmlEntity);
  }, C32.EscapeJS = function(t) {
    let e = C32.ReplaceAll(t, "\\", "\\\\");
    return e = C32.ReplaceAll(e, '"', '\\"'), e = C32.ReplaceAll(e, "	", "\\t"), e = C32.ReplaceAll(e, "\r", ""), C32.ReplaceAll(e, "\n", "\\n");
  }, C32.EscapeXML = function(t) {
    let e = C32.ReplaceAll(t, "&", "&amp;");
    return e = C32.ReplaceAll(e, "<", "&lt;"), e = C32.ReplaceAll(e, ">", "&gt;"), C32.ReplaceAll(e, '"', "&quot;");
  };
  const ESCAPE_REGEX = /[-[\]{}()*+?.,\\^$|#\s]/g;
  C32.EscapeRegex = function(t) {
    return t.replace(ESCAPE_REGEX, "\\$&");
  }, C32.CountCharsInString = function(t, e) {
    let n = 0;
    for (const r of t) r === e && ++n;
    return n;
  }, C32.StringPosToLineNumber = function(t, e) {
    let n = 0, r = 0;
    for (; n < e; ) {
      if (n = t.indexOf("\n", n), -1 === n) return r;
      r++, n++;
    }
    return r;
  }, C32.FindAll = function(t, e, n = false) {
    if (!e) return [];
    n || (t = t.toLowerCase(), e = e.toLowerCase());
    const r = e.length;
    let o = 0, i = 0, l = [];
    for (; (i = t.indexOf(e, o)) > -1; ) l.push(i), o = i + r;
    return l;
  }, C32.ReplaceAll = function(t, e, n) {
    return t.replaceAll(e, () => n);
  }, C32.ReplaceAllCaseInsensitive = function(t, e, n) {
    return t.replace(new RegExp(C32.EscapeRegex(e), "gi"), () => n);
  }, C32.SetElementContent = function(t, e) {
    "string" == typeof e ? t.textContent = e : e.isPlainText() ? t.textContent = e.toString() : (t.innerHTML = e.toHTML(), e instanceof C32.BBString && e.attachLinkHandlers(t));
  }, C32.StringLikeEquals = function(t, e) {
    return t instanceof C32.HtmlString || t instanceof C32.BBString ? t.equals(e) : e instanceof C32.HtmlString || e instanceof C32.BBString ? e.equals(t) : t === e;
  }, C32.StringSubstitute = function(t, ...e) {
    let n = t;
    for (let r = 0, o = e.length; r < o; ++r) {
      const o2 = `{${r}}`;
      if (!t.includes(o2)) throw new Error(`missing placeholder '${o2}' in string substitution`);
      n = n.replace(o2, e[r].toString());
    }
    return n;
  }, C32.StringSubstituteAllowMissing = function(t, ...e) {
    let n = t, r = -1, o = -1;
    for (let i = 0, l = e.length; i < l; ++i) {
      const l2 = `{${i}}`;
      t.includes(l2) ? (o = i, n = n.replace(l2, e[i].toString())) : -1 === r && (r = i);
    }
    if (r >= 0 && o >= 0 && r < o) throw new Error(`missing placeholder '${r}' in string substitution`);
    return n;
  }, C32.StringSubstituteMap = function(t, e) {
    let n = t;
    for (let [t2, r] of Object.entries(e)) n = n.replaceAll(t2, r.toString());
    return n;
  }, C32.SortAZ = function(t, e) {
    return t > e ? 1 : t < e ? -1 : 0;
  }, C32.SortAZCaseInsensitive = function(t, e) {
    let n = t.toLowerCase(), r = e.toLowerCase();
    return n > r ? 1 : n < r ? -1 : 0;
  };
  const intlSegmenter = new self["Intl"]["Segmenter"]();
  C32.SplitGraphemes = function(t) {
    if (1 === t.length) return [t];
    const e = [];
    for (const n of intlSegmenter["segment"](t)) e.push(n["segment"]);
    return e;
  }, C32.IterateGraphemes = function* (t) {
    for (const e of intlSegmenter["segment"](t)) yield e["segment"];
  }, C32.CountGraphemes = function(t) {
    let e = 0;
    for (const n of intlSegmenter["segment"](t)) ++e;
    return e;
  };
  const KILOBYTE = 1024, MEGABYTE = 1048576, GIGABYTE = 1073741824, TERABYTE = 1099511627776;
  C32.FormatDataSize = function(t, e) {
    let n = "common." + (e ? "dataRates" : "dataSizes") + ".";
    const r = self.langSub;
    if (t < 1024) return r(n + "bytes", t);
    if (t < 1048576) {
      let e2 = t / 1024;
      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r(n + "kilobytes", e2);
    }
    if (t < GIGABYTE) {
      let e2 = t / 1048576;
      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r(n + "megabytes", e2);
    }
    if (t < TERABYTE) {
      let e2 = t / GIGABYTE;
      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r(n + "gigabytes", e2);
    }
    {
      let e2 = t / TERABYTE;
      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r(n + "terabytes", e2);
    }
  };
  const DEFAULT_FORMATTIME_OPTS = { approximate: false, days: true, hours: true, minutes: true, seconds: true };
  C32.FormatTime = function(t, e) {
    e = Object.assign({}, DEFAULT_FORMATTIME_OPTS, e), C32.Lang.PushContext("common.time");
    const n = [], r = self.lang, o = self.langPluralSub;
    if (e.days) {
      const e2 = Math.floor(t / 86400);
      e2 > 0 && (t -= 24 * e2 * 3600, n.push(o(".days", null, e2)));
    }
    if (e.hours) {
      const e2 = Math.floor(t / 3600);
      (e2 > 0 || n.length) && (t -= 3600 * e2, n.push(o(".hours", null, e2)));
    }
    if (e.minutes) {
      const r2 = Math.floor(t / 60);
      (r2 > 0 || n.length || !e.seconds) && (t -= 60 * r2, n.push(o(".minutes", null, r2)));
    }
    if (e.seconds) {
      const e2 = Math.floor(t % 60);
      n.push(o(".seconds", null, e2));
    }
    const i = (e.approximate ? r(".approx-prefix") : "") + n.join(r(".separator"));
    return C32.Lang.PopContext(), i;
  }, C32.ZeroPad = function(t, e) {
    let n = t < 0 ? "-" : "", r = (t = Math.abs(t)).toString(), o = e - r.length;
    for (let t2 = 0; t2 < o; ++t2) n += "0";
    return n + r;
  }, C32.StringToTitleCase = function(t) {
    return t.toLowerCase().replace(/\b\w/g, (t2) => t2.toUpperCase());
  }, C32.CompareVersionStrings = function(t, e) {
    let n = t.split(".").map((t2) => t2.trim()), r = e.split(".").map((t2) => t2.trim());
    C32.resizeArray(n, 4, "0"), C32.resizeArray(r, 4, "0"), n = n.map((t2) => parseInt(t2, 10)), r = r.map((t2) => parseInt(t2, 10));
    for (let t2 = 0; t2 < 4; ++t2) {
      const e2 = n[t2] - r[t2];
      if (0 !== e2) return e2 < 0 ? -1 : 1;
    }
    return 0;
  }, C32.CreateGUID = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
      const e = Math.floor(16 * Math.random());
      return ("x" === t ? e : 3 & e | 8).toString(16);
    });
  }, C32.StringHammingDistance = function(t, e) {
    if (t.length !== e.length) throw new Error("strings must be same length");
    let n = 0;
    for (let r = 0, o = t.length; r < o; ++r) t.charAt(r) !== e.charAt(r) && ++n;
    return n;
  }, C32.StringLevenshteinDistance = function(t, e) {
    if (0 === t.length) return e.length;
    if (0 === e.length) return t.length;
    let n, r, o, i, l, s;
    for (t.length > e.length && (n = t, t = e, e = n), s = Array(t.length + 1), r = 0; r <= t.length; r++) s[r] = r;
    for (r = 1; r <= e.length; r++) {
      for (i = r, o = 1; o <= t.length; o++) l = e[r - 1] === t[o - 1] ? s[o - 1] : Math.min(s[o - 1] + 1, Math.min(i + 1, s[o] + 1)), s[o - 1] = i, i = l;
      s[t.length] = i;
    }
    return s[t.length];
  }, C32.StringByteLengthAsUTF8 = function(t) {
    return new TextEncoder().encode(t).length;
  };
}
var lookupHtmlEntity2;
{
  let bbToHtmlReplacerFunc = function(t, s, i) {
    const n = BB_CODE_MAP.get(i);
    if (!n) return "class" === i ? s ? "</span>" : `<span class="bbclass${classIndex++}">` : t;
    if ("string" == typeof n) {
      if ("a" === n && 0 === linkActions.length || "abbr" === n && 0 === tipList.length) return t;
      if ("a" !== n || s) {
        if ("abbr" !== n || s) return "<" + s + n + ">";
        {
          const t2 = parseInt(i.substring(3), 10) - 1;
          if (t2 < 0 || t2 >= tipList.length) throw new Error("invalid bbcode tip substitution");
          const s2 = tipList[t2];
          let n2 = "";
          if ("string" == typeof s2 ? n2 = s2 : "function" == typeof s2 && (n2 = s2()), "string" != typeof n2) throw new TypeError("invalid bbcode tip");
          return `<abbr title="${C32.ReplaceAll(n2, '"', "&quot;")}">`;
        }
      }
      {
        const t2 = parseInt(i.substring(1), 10) - 1;
        if (t2 < 0 || t2 >= linkActions.length) throw new Error("invalid bbcode link substitution");
        const s2 = linkActions[t2];
        if ("string" == typeof s2) return `<a href="${linkActions[t2]}">`;
        if ("function" == typeof s2) return `<a class="bblink${t2}">`;
        throw new TypeError("invalid bbcode link action");
      }
    }
    if (Array.isArray(n)) {
      let t2 = n[0], i2 = n[1];
      return s ? "</" + t2 + ">" : `<${t2} class="${i2}">`;
    }
  };
  bbToHtmlReplacerFunc2 = bbToHtmlReplacerFunc;
  const C32 = self.C3, assert = self.assert, BB_CODE_MAP = /* @__PURE__ */ new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]]), SELF_CLOSING_TAGS = /* @__PURE__ */ new Set(["icon"]), BBREGEX = /\[(\/?)([a-zA-Z0-9]+)\]/g, CUSTOM_BBREGEX = /\[(\/?)([^\[\n]*?)\]/g;
  let linkActions = null, tipList = null, classIndex = 0;
  const LINEBREAK_REGEX = /\n/g;
  C32.BBString = class {
    constructor(t, s) {
      if (this._bbstr = s && s.noEscape ? t : C32.EscapeHTML(t), this._htmlstr = "", this._convertLineBreaks = false, this._linkActions = [], this._tipList = [], s) {
        if (this._convertLineBreaks = !!s.convertLineBreaks, s.links) {
          if (s.links.length > 9) throw new Error("too many links");
          this._linkActions = s.links;
        }
        if (s.tips) {
          if (s.tips.length > 9) throw new Error("too many tips");
          this._tipList = s.tips;
        }
      }
      this._hasAnyBBtags = this._bbstr.includes("["), this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n"), this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&"), this._hasParsedFragments = false, this._fragments = [];
    }
    toString() {
      return this._bbstr;
    }
    valueOf() {
      return this._bbstr;
    }
    isPlainText() {
      return this._isPlain;
    }
    toPlainText() {
      return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, "") : this._bbstr;
    }
    toHTML() {
      if (this._isPlain) return this._bbstr;
      if (!this._htmlstr && this._bbstr) {
        let t = this._bbstr;
        this._hasAnyBBtags && (classIndex = 0, linkActions = this._linkActions, tipList = this._tipList, t = t.replace(BBREGEX, bbToHtmlReplacerFunc), linkActions = null, tipList = null), this._needsLineBreakConversion && (t = t.replace(LINEBREAK_REGEX, "<br>")), this._htmlstr = t;
      }
      return this._htmlstr;
    }
    attachLinkHandlers(t) {
      if (this._linkActions.length) for (let s = 0, i = this._linkActions.length; s < i; ++s) {
        const i2 = this._linkActions[s];
        if ("function" != typeof i2) continue;
        const n = t.querySelector(".bblink" + s);
        if (!n) throw new Error("unable to attach BBString link handler");
        n.onclick = i2;
      }
    }
    equals(t) {
      return t instanceof C32.HtmlString ? this.toHTML() === t.toHTML() : t instanceof C32.BBString ? this._bbstr === t._bbstr : this._bbstr === t;
    }
    toFragmentList() {
      if (this._hasParsedFragments) return this._fragments;
      const t = [], s = this._bbstr, i = [];
      CUSTOM_BBREGEX.lastIndex = 0;
      let n = 0, e = null;
      for (; null !== (e = CUSTOM_BBREGEX.exec(s)); ) {
        const r = e.index;
        if (r > 0 && "\\" === s.charAt(r - 1)) continue;
        const a = e[0], o = e[1], l = e[2], b = s.substring(n, r);
        if (n = r + a.length, b && t.push({ text: b, styles: i.slice(0) }), l) if (o) {
          const t2 = l.toLowerCase();
          for (let s2 = i.length - 1; s2 >= 0; --s2) if (i[s2].tag === t2) {
            i.splice(s2, 1);
            break;
          }
        } else {
          let s2 = l, n2 = null;
          const e2 = l.indexOf("=");
          if (-1 !== e2 ? (s2 = l.substring(0, e2).toLowerCase(), n2 = l.substring(e2 + 1)) : s2 = s2.toLowerCase(), SELF_CLOSING_TAGS.has(s2)) {
            if ("icon" !== s2) throw new Error(`unknown self-closing tag ${s2}`);
            t.push({ icon: n2, styles: i.slice(0) });
          } else i.push({ tag: s2, param: n2 });
        }
      }
      n < s.length && t.push({ text: s.substring(n), styles: i.slice(0) });
      for (const s2 of t) s2.text && (s2.text = this._ProcessBBCodeEscapeSequences(s2.text));
      return this._fragments = t.map((t2) => t2.icon ? C32.New(C32.IconFragment, { icon: t2.icon, styles: t2.styles }) : C32.New(C32.TextFragment, { chArr: C32.SplitGraphemes(t2.text), styles: t2.styles })), this._hasParsedFragments = true, this._fragments;
    }
    _ProcessBBCodeEscapeSequences(t) {
      return t = C32.ReplaceAll(t, "\\[", "["), C32.ReplaceAll(t, "\\\\", "\\");
    }
    static StripTags(t) {
      return C32.New(C32.BBString, t, { noEscape: true }).toPlainText();
    }
    static StripAnyTags(t) {
      return t.replace(CUSTOM_BBREGEX, "");
    }
  };
}
var bbToHtmlReplacerFunc2;
{
  let IsWordBreakWhiteSpace = function(t) {
    return "\xA0" !== t && "\u202F" !== t && C32.IsWhitespaceChar(t);
  }, IsOpeningCJKPunctiationChar = function(t) {
    return CJK_OPEN_PUNCTUATION.has(t);
  }, IsContinuingCJKPunctuationChar = function(t) {
    return C32.IsCJKPunctuationChar(t) && !IsOpeningCJKPunctiationChar(t);
  }, WordBreakTrimEnd = function(t) {
    for (; t.length > 0 && IsWordBreakWhiteSpace(t.at(-1)); ) t.pop();
  }, IsNewline = function(t) {
    return "\n" === t || "\r\n" === t;
  };
  IsWordBreakWhiteSpace2 = IsWordBreakWhiteSpace, IsOpeningCJKPunctiationChar2 = IsOpeningCJKPunctiationChar, IsContinuingCJKPunctuationChar2 = IsContinuingCJKPunctuationChar, WordBreakTrimEnd2 = WordBreakTrimEnd, IsNewline2 = IsNewline;
  const C32 = self.C3;
  const CJK_OPEN_PUNCTUATION = new Set("\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D");
  class CurrentLineState {
    constructor() {
      this.fragments = [], this.width = 0, this.height = 0, this.fontBoundingBoxAscent = 0, this.fontBoundingBoxDescent = 0, this.topToAlphabeticDistance = 0, this.isMeasured = false;
    }
    static FromSingleFragment(t, e, n, i, s, r) {
      const h = new CurrentLineState();
      return h.fragments.push(t), h.width = e, h.height = n, h.fontBoundingBoxAscent = i, h.fontBoundingBoxDescent = s, h.topToAlphabeticDistance = r, h;
    }
    Copy(t) {
      this.fragments = t.fragments.map((t2) => t2._Clone()), this.width = t.width, this.height = t.height, this.fontBoundingBoxAscent = t.fontBoundingBoxAscent, this.fontBoundingBoxDescent = t.fontBoundingBoxDescent, this.topToAlphabeticDistance = t.topToAlphabeticDistance, this.isMeasured = t.isMeasured;
    }
    Reset() {
      this.fragments = [], this.width = 0, this.height = 0, this.fontBoundingBoxAscent = 0, this.fontBoundingBoxDescent = 0, this.topToAlphabeticDistance = 0, this.isMeasured = false;
    }
    SetMetrics(t, e) {
      e || (this.width = t.width), this.height = t.height || 0, this.fontBoundingBoxAscent = t.fontBoundingBoxAscent || 0, this.fontBoundingBoxDescent = t.fontBoundingBoxDescent || 0, this.topToAlphabeticDistance = t.topToAlphabeticDistance || 0, this.isMeasured = true;
    }
    AddWord(t) {
      const e = this.fragments.length ? this.fragments.at(-1) : null;
      let n = 0;
      e && e.IsText() && t[0].IsText() && t[0].GetStyles() === e.GetStyles() && (e._Append(t[0].GetCharacterArray()), n = 1);
      for (let e2 = t.length; n < e2; ++n) {
        const e3 = t[n];
        this.fragments.push(e3._Clone());
      }
      this.isMeasured = false;
    }
  }
  C32.WordWrap = class {
    constructor() {
      this._lines = [], this._iconSet = null, this._lastFitLineState = new CurrentLineState(), this._tryLineState = new CurrentLineState(), this._hitNewline = false;
    }
    GetLines() {
      return this._lines;
    }
    GetLineCount() {
      return this._lines.length;
    }
    SetIconSet(t) {
      this._iconSet = t;
    }
    WordWrap(t, e, n, i, s) {
      if ("string" == typeof t && (t = [C32.New(C32.TextFragment, { chArr: C32.SplitGraphemes(t) })]), C32.clearArray(this._lines), !t.length || 1 === t.length && t[0].IsText() && t[0].IsEmpty() || n < 2) return;
      if (1 === t.length) {
        const i2 = t[0];
        if (i2.IsText() && i2.GetLength() <= 100 && !i2.HasNewLine()) {
          let { width: t2, height: r2, fontBoundingBoxAscent: h2, fontBoundingBoxDescent: o, topToAlphabeticDistance: a } = e(i2);
          if (t2 += s, i2.SetWidth(t2), i2.SetHeight(r2), i2.SetFontBoundingBoxAscent(h2 || 0), i2.SetFontBoundingBoxDescent(o || 0), i2.SetTopToAlphabeticDistance(a || 0), t2 <= n) return void this._AddLine(CurrentLineState.FromSingleFragment(i2, t2, r2, h2, o, a));
        }
      }
      let r, h = 4;
      "word" === i ? r = this._TokeniseByWord(t) : "cjk" === i ? (r = this._TokeniseByCJK(t), h = 8) : (r = this._TokeniseByChar(t), h = 8), this._WrapText(r, e, n, h, s);
    }
    _TokeniseByWord(t) {
      const e = [];
      let n = [], i = false;
      for (const s of t) {
        const t2 = s.GetStyles();
        if (s.IsIcon()) n.length > 0 && e.push(n), e.push([s]), n = [];
        else for (const r of s.GetCharacterArray()) if (IsNewline(r)) n.length > 0 && e.push(n), e.push([C32.New(C32.TextFragment, { chArr: ["\n"], styles: t2 })]), n = [];
        else if (0 === n.length) n.push(C32.New(C32.TextFragment, { chArr: [r], styles: t2 })), i = IsWordBreakWhiteSpace(r);
        else {
          const s2 = IsWordBreakWhiteSpace(r);
          if (s2 === i) {
            const e2 = n.at(-1);
            e2.GetStyles() === t2 ? e2._AppendChar(r) : n.push(C32.New(C32.TextFragment, { chArr: [r], styles: t2 }));
          } else e.push(n), n = [C32.New(C32.TextFragment, { chArr: [r], styles: t2 })], i = s2;
        }
      }
      return n.length > 0 && e.push(n), e;
    }
    _TokeniseByCJK(t) {
      const e = [];
      let n = [], i = false;
      for (const s of t) {
        const t2 = s.GetStyles();
        if (s.IsIcon()) n.length > 0 && e.push(n), e.push([s]), n = [];
        else for (const r of s.GetCharacterArray()) if (IsNewline(r)) n.length > 0 && e.push(n), e.push([C32.New(C32.TextFragment, { chArr: ["\n"], styles: t2 })]), n = [];
        else if (0 === n.length) n.push(C32.New(C32.TextFragment, { chArr: [r], styles: t2 })), i = IsOpeningCJKPunctiationChar(r);
        else if (i || IsContinuingCJKPunctuationChar(r)) {
          const e2 = n.at(-1);
          e2.GetStyles() === t2 ? e2._AppendChar(r) : n.push(C32.New(C32.TextFragment, { chArr: [r], styles: t2 })), i = IsOpeningCJKPunctiationChar(r);
        } else e.push(n), n = [C32.New(C32.TextFragment, { chArr: [r], styles: t2 })], i = IsOpeningCJKPunctiationChar(r);
      }
      return n.length > 0 && e.push(n), e;
    }
    _TokeniseByChar(t) {
      const e = [];
      for (const n of t) if (n.IsText()) {
        const t2 = n.GetCharacterArray();
        C32.appendArray(e, t2.map((t3) => [C32.New(C32.TextFragment, { chArr: [t3], styles: n.GetStyles() })]));
      } else e.push([n]);
      return e;
    }
    _MeasureLine(t, e) {
      let n = 0, i = 0, s = 0, r = 0, h = 0;
      for (const o of t) {
        if (-1 === o.GetWidth()) {
          const t2 = e(o);
          o.SetHeight(t2.height), o.SetFontBoundingBoxAscent(t2.fontBoundingBoxAscent || 0), o.SetFontBoundingBoxDescent(t2.fontBoundingBoxDescent || 0), o.SetTopToAlphabeticDistance(t2.topToAlphabeticDistance || 0), o.IsText() ? o.SetWidth(t2.width) : o.IsIcon() && o.CalculateWidthFromHeight(this._iconSet);
        }
        n += o.GetWidth(), i = Math.max(i, o.GetHeight()), s = Math.max(s, o.GetFontBoundingBoxAscent()), r = Math.max(r, o.GetFontBoundingBoxDescent()), h = Math.max(h, o.GetTopToAlphabeticDistance());
      }
      return { width: n, height: i, fontBoundingBoxAscent: s, fontBoundingBoxDescent: r, topToAlphabeticDistance: h };
    }
    _ResetLineStates() {
      this._lastFitLineState.Reset(), this._tryLineState.Reset();
    }
    _AddLine(t) {
      this._lines.push(new C32.WordWrap.Line(t)), this._ResetLineStates();
    }
    _IsWordNewLine(t) {
      return 1 === t.length && t[0].IsText() && 1 === t[0].GetLength() && IsNewline(t[0].GetCharacterArray()[0]);
    }
    _IsWordWhitespace(t) {
      return t[0].IsText() && C32.IsCharArrayAllWhitespace(t[0].GetCharacterArray());
    }
    _WrapText(t, e, n, i, s) {
      let r = 0;
      for (; r < t.length; ) r = this._WrapText_Chunk(t, r, e, n, i);
      if (this._tryLineState.fragments.length > 0) {
        if (!this._tryLineState.isMeasured) {
          const t2 = this._MeasureLine(this._tryLineState.fragments, e);
          this._tryLineState.SetMetrics(t2);
        }
        this._AddLine(this._tryLineState);
      }
      this._TrimLinesTrailingWhitespace(e, s), this._ResetLineStates(), this._hitNewline = false;
    }
    _WrapText_Chunk(t, e, n, i, s) {
      const r = this._lastFitLineState, h = this._tryLineState, o = t[e];
      if (this._IsWordNewLine(o)) {
        if (!h.isMeasured) {
          const t2 = n(C32.New(C32.TextFragment, { chArr: [" "], styles: o[0].GetStyles() }));
          h.SetMetrics(t2, true);
        }
        return this._AddLine(h), e + 1;
      }
      const a = this._WrapText_CollectChunk(t, e, s), c = this._MeasureLine(h.fragments, n);
      return h.SetMetrics(c), c.width >= i ? this._WrapText_RetryChunk(t, e, n, i) : (r.Copy(h), this._hitNewline && this._AddLine(r), a + 1);
    }
    _WrapText_CollectChunk(t, e, n) {
      const i = this._tryLineState;
      this._hitNewline = false;
      let s = e, r = 0;
      for (let e2 = t.length; s < e2; ++s) {
        const e3 = t[s];
        if (this._IsWordNewLine(e3)) {
          this._hitNewline = true;
          break;
        }
        if (i.AddWord(e3), !this._IsWordWhitespace(e3) && (++r, r === n)) break;
      }
      return s;
    }
    _WrapText_RetryChunk(t, e, n, i) {
      const s = this._lastFitLineState, r = this._tryLineState;
      r.Copy(s);
      let h = e;
      for (let e2 = t.length; h < e2; ++h) {
        const o = t[h];
        if (this._IsWordNewLine(o)) return this._AddLine(s), h + 1;
        if (r.AddWord(o), !this._IsWordWhitespace(o) || 0 === s.fragments.length) {
          const o2 = this._MeasureLine(r.fragments, n);
          if (r.SetMetrics(o2), o2.width >= i) {
            let n2;
            return s.fragments.length > 0 ? n2 = s : (n2 = r, ++h, h < e2 && this._IsWordWhitespace(t[h]) && ++h), this._AddLine(n2), h;
          }
          s.Copy(r);
        }
      }
      return h;
    }
    _TrimLinesTrailingWhitespace(t, e) {
      for (const n of this._lines) {
        const i = n._GetFragmentsArray();
        if (!i.length) continue;
        let s = i.at(-1);
        if (s.IsText()) {
          const r = s.GetCharacterArray(), h = r.slice(0);
          if (WordBreakTrimEnd(h), 0 === h.length) n.OffsetWidth(-s.GetWidth()), i.pop();
          else if (h.length < r.length) {
            s.SetCharacterArray(h);
            const e2 = t(s).width, i2 = s.GetWidth() - e2;
            s.SetWidth(e2), n.OffsetWidth(-i2);
          }
          0 !== e && i.length > 0 && (s = i.at(-1), s.OffsetWidth(e), n.OffsetWidth(e));
        }
      }
    }
    Clear() {
      C32.clearArray(this._lines);
    }
    GetMaxLineWidth() {
      return this._lines.reduce((t, e) => Math.max(t, e.GetWidth()), 0);
    }
    GetTotalLineHeight() {
      return this._lines.reduce((t, e) => t + e.GetHeight(), 0);
    }
  };
}
var IsWordBreakWhiteSpace2;
var IsOpeningCJKPunctiationChar2;
var IsContinuingCJKPunctuationChar2;
var WordBreakTrimEnd2;
var IsNewline2;
{
  const C32 = self.C3;
  C32.WordWrap.Line = class {
    constructor(t) {
      this._fragments = t.fragments, this._width = t.width, this._height = t.height, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent, this._topToAlphabeticDistance = t.topToAlphabeticDistance, this._posX = 0, this._posY = 0;
    }
    fragments() {
      return this._fragments.values();
    }
    *fragmentsReverse() {
      const t = this._fragments;
      for (let e = t.length - 1; e >= 0; --e) yield t[e];
    }
    _GetFragmentsArray() {
      return this._fragments;
    }
    OffsetWidth(t) {
      this._width += t;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetFoundBoundingBoxAscent() {
      return this._fontBoundingBoxAscent;
    }
    GetFontBoundingBoxDescent() {
      return this._fontBoundingBoxDescent;
    }
    GetTopToAlphabeticDistance() {
      return this._topToAlphabeticDistance;
    }
    SetPosX(t) {
      this._posX = t;
    }
    GetPosX() {
      return this._posX;
    }
    SetPosY(t) {
      this._posY = t;
    }
    GetPosY() {
      return this._posY;
    }
  };
}
{
  const C32 = self.C3;
  C32.FragmentBase = class {
    constructor(t) {
      this._styles = t.styles || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;
    }
    IsText() {
      return false;
    }
    IsIcon() {
      return false;
    }
    GetStyles() {
      return this._styles;
    }
    GetStyleTag(t) {
      const e = this._styles;
      for (let s = e.length - 1; s >= 0; --s) {
        const n = e[s];
        if (n.tag === t) return n;
      }
      return null;
    }
    HasStyleTag(t) {
      return !!this.GetStyleTag(t);
    }
    GetStyleMap() {
      const t = /* @__PURE__ */ new Map();
      for (const e of this._styles) t.set(e.tag, e.param);
      return t;
    }
    OffsetWidth(t) {
      this._width += t;
    }
    SetWidth(t) {
      this._width = t;
    }
    GetWidth() {
      return this._width;
    }
    SetHeight(t) {
      this._height = t;
    }
    GetHeight() {
      return this._height;
    }
    SetFontBoundingBoxAscent(t) {
      this._fontBoundingBoxAscent = t;
    }
    GetFontBoundingBoxAscent() {
      return this._fontBoundingBoxAscent;
    }
    SetFontBoundingBoxDescent(t) {
      this._fontBoundingBoxDescent = t;
    }
    GetFontBoundingBoxDescent() {
      return this._fontBoundingBoxDescent;
    }
    SetTopToAlphabeticDistance(t) {
      this._topToAlphabeticDistance = t;
    }
    GetTopToAlphabeticDistance() {
      return this._topToAlphabeticDistance;
    }
    SetPosX(t) {
      this._posX = t;
    }
    GetPosX() {
      return this._posX;
    }
    SetPosY(t) {
      this._posY = t;
    }
    GetPosY() {
      return this._posY;
    }
  };
}
{
  const C32 = self.C3;
  C32.TextFragment = class extends C32.FragmentBase {
    constructor(t) {
      super(t), this._chArr = t.chArr;
    }
    IsText() {
      return true;
    }
    _Append(t) {
      C32.appendArray(this._chArr, t), this._width = -1, this._height = -1, this._fontBoundingBoxAscent = -1, this._fontBoundingBoxDescent = -1, this._topToAlphabeticDistance = -1;
    }
    _AppendChar(t) {
      this._chArr.push(t);
    }
    _Clone() {
      return C32.New(C32.TextFragment, { chArr: this._chArr.slice(0), styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });
    }
    GetCharacterArray() {
      return this._chArr;
    }
    SetCharacterArray(t) {
      this._chArr = t;
    }
    GetLength() {
      return this._chArr.length;
    }
    IsEmpty() {
      return 0 === this._chArr.length;
    }
    HasNewLine() {
      return this._chArr.includes("\n");
    }
  };
}
{
  const C32 = self.C3;
  C32.IconFragment = class extends C32.FragmentBase {
    constructor(t) {
      super(t), this._icon = t.icon;
    }
    IsIcon() {
      return true;
    }
    GetIconParameter() {
      return this._icon;
    }
    _Clone() {
      return C32.New(C32.IconFragment, { icon: this._icon, styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });
    }
    GetTextIcon(t) {
      if (!t) return null;
      let e = Number(this._icon);
      return String(e) === this._icon ? (e = Math.floor(e), t.GetTextIconByIndex(e)) : t.GetTextIconByTag(this._icon);
    }
    CalculateWidthFromHeight(t) {
      const e = this.GetTextIcon(t);
      this._width = e ? this._height * e.GetWidth() / e.GetHeight() : 0;
    }
    GetDrawable(t) {
      const e = this.GetTextIcon(t);
      return e ? e.GetDrawable() : null;
    }
    GetLength() {
      return 1;
    }
  };
}
{
  const C32 = self.C3;
  C32.TextIconManager = class {
    constructor(t) {
      this._iconSets = /* @__PURE__ */ new Map(), this._getIconSetMetaCallback = t.getIconSetMeta, this._getIconSetContentCallback = t.getIconSetContent;
    }
    Release() {
      for (const t of this._iconSets.values()) t.Release();
      this._iconSets.clear();
    }
    GetIconSet(t) {
      let e = this._iconSets.get(t);
      if (e) return e;
      const n = this._getIconSetMetaCallback(t);
      return e = C32.New(C32.TextIconSet, this, { source: t, iconMeta: n }), this._iconSets.set(t, e), e;
    }
    HasIconSet(t) {
      return this._iconSets.has(t);
    }
    DeleteIconSet(t) {
      const e = this._iconSets.get(t);
      e && e.Release(), this._iconSets.delete(t);
    }
    async _GetIconSetContent(t) {
      return await this._getIconSetContentCallback(t);
    }
  };
}
{
  const C32 = self.C3;
  C32.TextIconSet = class {
    constructor(t, s) {
      this._textIconManager = t, this._source = s.source, this._iconsArray = [], this._iconsByTag = /* @__PURE__ */ new Map(), this._hasStartedLoad = false, this._isLoading = false, this._loadPromise = null;
      const o = s.iconMeta.icons;
      for (let t2 = 0, s2 = o.length; t2 < s2; ++t2) {
        const s3 = o[t2], e = C32.New(C32.TextIcon, this, { index: t2, tag: s3.tag, source: s3.source, width: s3.width, height: s3.height });
        this._iconsArray.push(e), s3.tag && this._iconsByTag.set(s3.tag.toLowerCase(), e);
      }
    }
    Release() {
      for (const t of this._iconsArray) t.Release();
      C32.clearArray(this._iconsArray), this._iconsByTag.clear(), this._textIconManager = null, this._source = null;
    }
    HasLoaded() {
      return this._hasStartedLoad;
    }
    IsLoading() {
      return this._isLoading;
    }
    LoadContent() {
      return this._loadPromise || (this._loadPromise = this._DoLoadContent()), this._loadPromise;
    }
    async _DoLoadContent() {
      if (this._hasStartedLoad) return;
      this._hasStartedLoad = true, this._isLoading = true;
      const t = await this._textIconManager._GetIconSetContent(this._source);
      if (!this._textIconManager) return;
      const s = t.icons;
      for (let t2 = 0, o = Math.min(s.length, this._iconsArray.length); t2 < o; ++t2) {
        const o2 = s[t2].drawable;
        this._iconsArray[t2]._SetDrawable(o2);
      }
      this._isLoading = false;
    }
    GetTextIconByIndex(t) {
      return (t = Math.floor(t)) < 0 || t >= this._iconsArray.length ? null : this._iconsArray[t];
    }
    GetTextIconByTag(t) {
      return this._iconsByTag.get(t.toLowerCase()) || null;
    }
  };
}
{
  const C32 = self.C3;
  C32.TextIcon = class {
    constructor(t, e) {
      this._textIconSet = t, this._source = e.source || null, this._index = e.index, this._tag = e.tag, this._width = e.width, this._height = e.height, this._drawable = null;
    }
    Release() {
      this._width = 0, this._height = 0, this._textIconSet = null;
    }
    GetSource() {
      return this._source;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    _SetDrawable(t) {
      this._drawable = t;
    }
    GetDrawable() {
      return this._drawable;
    }
  };
}
{
  let PlaneFromPoints = function(t, e, r, n) {
    const a = tempVec3c;
    vec3.subtract(tempVec3a, r, e), vec3.subtract(tempVec3b, t, e), vec3.cross(a, tempVec3a, tempVec3b), vec3.normalize(a, a), n.set(a[0], a[1], a[2], vec3.dot(t, a));
  }, IsInFrontOfPlane = function(t, e, r, n, a, c, s) {
    const o = s.x, i = s.y, l = s.z, f = s.w, P = s.xF, h = s.yF, m = s.zF, p = 1 - P, v = 1 - h, u = 1 - m;
    if (o * t * P + o * n * p + i * e * h + i * a * v + l * r * m + l * c * u >= f) return true;
    return o * n * P + o * t * p + i * a * h + i * e * v + l * c * m + l * r * u > f;
  }, IsPointInFrontOfPlane = function(t, e, r, n) {
    return n.x * t + n.y * e + n.z * r >= n.w;
  };
  PlaneFromPoints2 = PlaneFromPoints, IsInFrontOfPlane2 = IsInFrontOfPlane, IsPointInFrontOfPlane2 = IsPointInFrontOfPlane;
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempVec3a = vec3.create(), tempVec3b = vec3.create(), tempVec3c = vec3.create(), tempVec4 = vec4.create(), tempMat4 = mat4.create(), neartl = vec3.create(), neartr = vec3.create(), nearbl = vec3.create(), nearbr = vec3.create(), fartl = vec3.create(), fartr = vec3.create(), farbl = vec3.create(), farbr = vec3.create(), unitViewport = vec4.fromValues(0, 0, 1, 1);
  C32.Gfx = { Project(t, e, r, n, a, c, s) {
    const o = n[0] * t + n[4] * e + n[8] * r + n[12], i = n[1] * t + n[5] * e + n[9] * r + n[13], l = n[2] * t + n[6] * e + n[10] * r + n[14], f = n[3] * t + n[7] * e + n[11] * r + n[15];
    let P = a[0] * o + a[4] * i + a[8] * l + a[12] * f, h = a[1] * o + a[5] * i + a[9] * l + a[13] * f, m = a[2] * o + a[6] * i + a[10] * l + a[14] * f, p = a[3] * o + a[7] * i + a[11] * l + a[15] * f;
    return 0 !== p && (p = 1 / p, P *= p, h *= p, m *= p, s[0] = (0.5 * P + 0.5) * c[2] + c[0], s[1] = (0.5 * h + 0.5) * c[3] + c[1], s[2] = 0.5 * (1 + m), true);
  }, Unproject(t, e, r, n, a, c, s) {
    const o = tempMat4, i = tempVec4;
    return mat4.multiply(o, a, n), null !== mat4.invert(o, o) && (i[0] = (t - c[0]) / c[2] * 2 - 1, i[1] = (e - c[1]) / c[3] * 2 - 1, i[2] = 2 * r - 1, i[3] = 1, vec4.transformMat4(i, i, o), 0 !== i[3] && (i[3] = 1 / i[3], s[0] = i[0] * i[3], s[1] = i[1] * i[3], s[2] = i[2] * i[3], true));
  }, UnprojectScreenToWorldZ(t, e, r, n, a, c, s) {
    const o = tempVec3a, i = tempVec3b;
    if (!C32.Gfx.Unproject(t, e, 0, n, a, c, o)) return false;
    if (!C32.Gfx.Unproject(t, e, 1, n, a, c, i)) return false;
    const l = tempVec3b;
    vec3.subtract(l, i, o);
    const f = tempVec3c;
    vec3.set(f, 0, 0, 1);
    const P = -r, h = vec3.dot(f, l);
    let m = 0;
    if (0 === h) {
      if (0 !== vec3.dot(f, o) + P) return false;
    } else if (m = -(vec3.dot(o, f) + P) / h, m < 0) return false;
    return vec3.scaleAndAdd(s, o, l, m), true;
  } };
  class Plane {
    constructor() {
      this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this.xF = NaN, this.yF = NaN, this.zF = NaN;
    }
    set(t, e, r, n) {
      this.x = t, this.y = e, this.z = r, this.w = n, this.xF = t > 0 ? 1 : 0, this.yF = e > 0 ? 1 : 0, this.zF = r > 0 ? 1 : 0;
    }
  }
  C32.Gfx.ViewFrustum = class {
    constructor() {
      this._leftP = new Plane(), this._topP = new Plane(), this._rightP = new Plane(), this._bottomP = new Plane(), this._nearP = new Plane(), this._farP = new Plane();
    }
    CalculatePlanes(t, e) {
      const r = unitViewport;
      C32.Gfx.Unproject(0, 1, 0, t, e, r, neartl), C32.Gfx.Unproject(1, 1, 0, t, e, r, neartr), C32.Gfx.Unproject(0, 0, 0, t, e, r, nearbl), C32.Gfx.Unproject(1, 0, 0, t, e, r, nearbr), C32.Gfx.Unproject(0, 1, 1, t, e, r, fartl), C32.Gfx.Unproject(1, 1, 1, t, e, r, fartr), C32.Gfx.Unproject(0, 0, 1, t, e, r, farbl), C32.Gfx.Unproject(1, 0, 1, t, e, r, farbr), PlaneFromPoints(nearbl, neartl, fartl, this._leftP), PlaneFromPoints(neartl, neartr, fartr, this._topP), PlaneFromPoints(neartr, nearbr, farbr, this._rightP), PlaneFromPoints(nearbr, nearbl, farbl, this._bottomP), PlaneFromPoints(farbl, fartl, fartr, this._farP), PlaneFromPoints(nearbr, neartr, neartl, this._nearP);
    }
    ContainsAABB(t, e, r, n, a, c) {
      return IsInFrontOfPlane(t, e, r, n, a, c, this._leftP) && IsInFrontOfPlane(t, e, r, n, a, c, this._topP) && IsInFrontOfPlane(t, e, r, n, a, c, this._rightP) && IsInFrontOfPlane(t, e, r, n, a, c, this._bottomP) && IsInFrontOfPlane(t, e, r, n, a, c, this._nearP) && IsInFrontOfPlane(t, e, r, n, a, c, this._farP);
    }
    IsBehindNearPlane(t, e, r) {
      return !IsPointInFrontOfPlane(t, e, r, this._nearP);
    }
  };
}
var PlaneFromPoints2;
var IsInFrontOfPlane2;
var IsPointInFrontOfPlane2;
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempMat4 = mat4.create(), tmpVec3a = vec3.fromValues(0, 0, 0), tmpVec3b = vec3.fromValues(0, 0, 0), tmpVec3c = vec3.fromValues(0, 0, 0), defaultUpVector = vec3.fromValues(0, 1, 0), tmpVec4 = vec4.fromValues(0, 0, 0, 0), tmpQuad = new C32.Quad(), tmpRect = new C32.Rect(), defaultTexCoordsQuad = new C32.Quad(0, 0, 1, 0, 1, 1, 0, 1), DEFAULT_RENDERERBASE_OPTS = { nearZ: 1, farZ: 1e4 }, matWebGLtoWebGPU = mat4.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
  C32.Gfx.RendererBase = class {
    constructor(e) {
      e = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, e), this._width = 0, this._height = 0, this._fovY = C32.toRadians(45), this._tan_fovY_2 = Math.tan(this._fovY / 2), this._matP = mat4.create(), this._matMV = mat4.create(), this._zAxisScale = false, this._nearZ = e.nearZ, this._farZ = e.farZ, this._allShaderPrograms = [], this._shaderProgramsByName = /* @__PURE__ */ new Map(), this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._stateGroups = /* @__PURE__ */ new Map(), this._currentStateGroup = null, this._blendModeTable = [], this._namedBlendModeMap = /* @__PURE__ */ new Map(), this._baseZ = 0, this._currentZ = 0, this._lineWidth = 1, this._lineWidthStack = [this._lineWidth], this._lineCap = 1, this._lineCapStack = [this._lineCap], this._lineOffset = 0.5, this._lineOffsetStack = [this._lineOffset], this._frameNumber = 0, this._enableMipmaps = true, this._hasMajorPerformanceCaveat = false;
    }
    _ClearState() {
      this._baseZ = 0, this._currentZ = 0, this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._ClearAllShaderPrograms();
    }
    InitState() {
      this._ClearState(), this._currentStateGroup = null;
    }
    OnDeviceOrContextLost() {
      for (const e of this._allShaderPrograms) e.Release();
      this._ClearState();
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetDefaultCameraZ(e) {
      return this.IsZAxisScaleNormalized() ? 100 : e / (2 * this._GetTanFovYDiv2());
    }
    GetZAxisScaleFactor(e) {
      if (this.IsZAxisScaleNormalized()) {
        return e / (2 * this._GetTanFovYDiv2()) / this.GetDefaultCameraZ(e);
      }
      return 1;
    }
    SetNearZ(e) {
      this._nearZ = e;
    }
    GetNearZ() {
      return this._nearZ;
    }
    SetFarZ(e) {
      this._farZ = e;
    }
    GetFarZ() {
      return this._farZ;
    }
    SetFovY(e) {
      this._fovY = e, this._tan_fovY_2 = Math.tan(this._fovY / 2);
    }
    GetFovY() {
      return this._fovY;
    }
    _GetTanFovYDiv2() {
      return this._tan_fovY_2;
    }
    SetZAxisScaleNormalized() {
      this._zAxisScale = false;
    }
    SetZAxisScaleRegular() {
      this._zAxisScale = true;
    }
    IsZAxisScaleNormalized() {
      return !this._zAxisScale;
    }
    IsZAxisScaleRegular() {
      return this._zAxisScale;
    }
    CalculatePerspectiveMatrix(e, t, i = 0.5, a = 0.5) {
      const s = this.GetNearZ(), r = this.GetFarZ(), l = this.GetFovY();
      if (0.5 === i && 0.5 === a) this.IsWebGPU() ? mat4.perspectiveZO(e, l, t, s, r) : mat4.perspective(e, l, t, s, r);
      else {
        const l2 = 2 * (i = 1 - i) - 2, n = 2 * i, h = 2 * a - 2, o = 2 * a, p = this._GetTanFovYDiv2() * s, _ = p * t;
        mat4.frustum(e, l2 * _, n * _, h * p, o * p, s, r), this.IsWebGPU() && mat4.mul(e, matWebGLtoWebGPU, e);
      }
    }
    CalculateOrthographicMatrix(e, t, i, a = 1) {
      const s = self.devicePixelRatio, r = 2 * this.GetDefaultCameraZ(i) * s * this._GetTanFovYDiv2() / i, l = t * r / (2 * s * a), n = i * r / (2 * s * a), h = -l, o = l, p = -n, _ = n;
      this.IsWebGPU() ? mat4.orthoZO(e, h, o, p, _, this.GetNearZ(), this.GetFarZ()) : mat4.ortho(e, h, o, p, _, this.GetNearZ(), this.GetFarZ());
    }
    CalculateLookAtModelView(e, t, i, a, s, r = 1) {
      let l = 1;
      this.IsZAxisScaleNormalized() && (l = 200 * this._GetTanFovYDiv2() / s);
      const n = tmpVec3c;
      vec3.set(n, l, -l, 1);
      const h = tmpVec3a, o = tmpVec3b;
      vec3.multiply(h, t, n), vec3.multiply(o, i, n), mat4.lookAt(e, h, o, a || defaultUpVector), n[2] = r, mat4.scale(e, e, n);
    }
    CalculateLookAtModelView2(e, t, i, a, s, r, l, n) {
      return vec3.set(tmpVec3a, e, t, i), vec3.set(tmpVec3b, a, s, r), this.CalculateLookAtModelView(tempMat4, tmpVec3a, tmpVec3b, defaultUpVector, l, n), tempMat4;
    }
    _AddShaderProgram(e) {
      this._allShaderPrograms.push(e), this._shaderProgramsByName.set(e.GetName(), e);
    }
    _RemoveShaderProgram(e) {
      const t = this._allShaderPrograms.indexOf(e);
      -1 !== t && this._allShaderPrograms.splice(t, 1), this._shaderProgramsByName.delete(e.GetName());
    }
    _ClearAllShaderPrograms() {
      C32.clearArray(this._allShaderPrograms), this._shaderProgramsByName.clear();
    }
    GetShaderProgramByName(e) {
      return this._shaderProgramsByName.get(e) || null;
    }
    GetTextureFillShaderProgram() {
      return this._spTextureFill;
    }
    SetTextureFillMode() {
      this.SetProgram(this._spTextureFill);
    }
    GetPointsRenderingProgram() {
      return this._spPoints;
    }
    SetPointsRenderingProgram() {
      this.SetProgram(this._spPoints);
    }
    SetTilemapFillMode() {
      this.SetProgram(this._spTilemapFill);
    }
    SetTileRandomizationMode() {
      this.SetProgram(this._spTileRandomization);
    }
    SetColorFillMode() {
      this.SetProgram(this._spColorFill);
    }
    SetLinearGradientFillMode() {
      this.SetProgram(this._spLinearGradientFill);
    }
    SetPenumbraFillMode() {
      this.SetProgram(this._spPenumbraFill);
    }
    SetHardEllipseFillMode() {
      this.SetProgram(this._spHardEllipseFill);
    }
    SetHardEllipseOutlineMode() {
      this.SetProgram(this._spHardEllipseOutline);
    }
    SetSmoothEllipseFillMode() {
      this.SetProgram(this._spSmoothEllipseFill);
    }
    SetSmoothEllipseOutlineMode() {
      this.SetProgram(this._spSmoothEllipseOutline);
    }
    SetSmoothLineFillMode() {
      this.SetProgram(this._spSmoothLineFill);
    }
    _SetCurrentStateGroup(e) {
      this._currentStateGroup = e;
    }
    GetCurrentStateGroup() {
      return this._currentStateGroup;
    }
    AcquireStateGroup(e, t, i, a, s, r) {
      const l = C32.Gfx.StateGroup.MakeKey(e, t, i, a, s, r);
      let n = this._stateGroups.get(l);
      return n || (n = C32.New(C32.Gfx.StateGroup, this, e, t, i, a, s, r), this._stateGroups.set(l, n)), n.AddRef(), n;
    }
    ReleaseStateGroup(e) {
      e.DecRef(), 0 === e._GetRefCount() && (this._currentStateGroup === e && (this._currentStateGroup = null), this._stateGroups.delete(e.GetKey()), e.Release());
    }
    _InitBlendModeData(e) {
      C32.clearArray(this._blendModeTable), this._namedBlendModeMap.clear();
      let t = 0;
      for (const i of e) {
        const e2 = i[0], a = i[1];
        this._blendModeTable.push(a), this._namedBlendModeMap.set(e2, t), t++;
      }
    }
    _GetBlendParametersByIndex(e) {
      return this._blendModeTable[e];
    }
    NamedBlendToNumber(e) {
      const t = this._namedBlendModeMap.get(e);
      if (void 0 === t) throw new Error("invalid blend name");
      return t;
    }
    SetBaseZ(e) {
      this._baseZ = e;
    }
    GetBaseZ() {
      return this._baseZ;
    }
    SetCurrentZ(e) {
      this._currentZ = e, this._currentStateGroup = null;
    }
    GetCurrentZ() {
      return this._currentZ;
    }
    Line(e, t, i, a) {
      const s = C32.angleTo(e, t, i, a), r = Math.sin(s), l = Math.cos(s), n = 0.5 * this._lineWidth, h = r * n, o = l * n, p = this._lineCap;
      2 === p ? this.LinePreCalc_LineCap2(e, t, 0, i, a, 0, h, o) : 1 === p ? this.LinePreCalc_LineCap1(e, t, 0, i, a, 0, h, o) : this.LinePreCalc_LineCap0(e, t, 0, i, a, 0, h, o);
    }
    Line3D(e, t, i, a, s, r) {
      const l = C32.angleTo(e, t, a, s), n = Math.sin(l), h = Math.cos(l), o = 0.5 * this._lineWidth, p = n * o, _ = h * o, c = this._lineCap;
      2 === c ? this.LinePreCalc_LineCap2(e, t, i, a, s, r, p, _) : 1 === c ? this.LinePreCalc_LineCap1(e, t, i, a, s, r, p, _) : this.LinePreCalc_LineCap0(e, t, i, a, s, r, p, _);
    }
    LinePreCalc_LineCap2(e, t, i, a, s, r, l, n) {
      const h = this._lineOffset, o = e + h - n, p = t + h - l, _ = a + h + n, c = s + h + l, u = 2 * n, C = 2 * l, d = o + l, m = p - n, L = o - l + u, g = p + n + C, S = _ + l, f = c - n, P = _ - l - u, T = c + n - C;
      this.Quad3D2(d, m, i, S, f, r, P, T, r, L, g, i, defaultTexCoordsQuad);
    }
    LinePreCalc_LineCap1(e, t, i, a, s, r, l, n) {
      const h = this._lineOffset, o = e + h - n, p = t + h - l, _ = a + h + n, c = s + h + l, u = o + l, C = p - n, d = o - l, m = p + n, L = _ + l, g = c - n, S = _ - l, f = c + n;
      this.Quad3D2(u, C, i, L, g, r, S, f, r, d, m, i, defaultTexCoordsQuad);
    }
    LinePreCalc_LineCap0(e, t, i, a, s, r, l, n) {
      const h = this._lineOffset, o = e + h, p = t + h, _ = a + h, c = s + h, u = o + l, C = p - n, d = o - l, m = p + n, L = _ + l, g = c - n, S = _ - l, f = c + n;
      this.Quad3D2(u, C, i, L, g, r, S, f, r, d, m, i, defaultTexCoordsQuad);
    }
    TexturedLine(e, t, i, a, s, r) {
      const l = C32.angleTo(e, t, i, a), n = Math.sin(l), h = Math.cos(l), o = 0.5 * this._lineWidth, p = n * o, _ = h * o, c = this._lineCap;
      2 === c ? this.TexturedLinePreCalc_LineCap2(e, t, i, a, p, _, s, r) : 1 === c ? this.TexturedLinePreCalc_LineCap1(e, t, i, a, p, _, s, r) : this.TexturedLinePreCalc_LineCap0(e, t, i, a, p, _, s, r);
    }
    TexturedLinePreCalc_LineCap2(e, t, i, a, s, r, l, n) {
      const h = this._lineOffset, o = e + h - r, p = t + h - s, _ = i + h + r, c = a + h + s, u = 2 * r, C = 2 * s, d = o + s, m = p - r, L = o - s + u, g = p + r + C, S = _ + s, f = c - r, P = _ - s - u, T = c + r - C;
      tmpQuad.set(d, m, S, f, P, T, L, g), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
    }
    TexturedLinePreCalc_LineCap1(e, t, i, a, s, r, l, n) {
      const h = this._lineOffset, o = e + h - r, p = t + h - s, _ = i + h + r, c = a + h + s, u = o + s, C = p - r, d = o - s, m = p + r, L = _ + s, g = c - r, S = _ - s, f = c + r;
      tmpQuad.set(u, C, L, g, S, f, d, m), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
    }
    TexturedLinePreCalc_LineCap0(e, t, i, a, s, r, l, n) {
      const h = this._lineOffset, o = e + h, p = t + h, _ = i + h, c = a + h, u = o + s, C = p - r, d = o - s, m = p + r, L = _ + s, g = c - r, S = _ - s, f = c + r;
      tmpQuad.set(u, C, L, g, S, f, d, m), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
    }
    LineRect(e, t, i, a) {
      const s = 0.5 * this._lineWidth, r = this._lineCap;
      2 === r ? this._LineRectPreCalc_LineCap2(e, t, i, a, s) : 1 === r ? this._LineRectPreCalc_LineCap1(e, t, i, a, s) : this._LineRectPreCalc_LineCap0(e, t, i, a, s);
    }
    _LineRectPreCalc_LineCap2(e, t, i, a, s) {
      this.LinePreCalc_LineCap2(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap2(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap2(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap2(e, a, 0, e, t, 0, -s, 0);
    }
    _LineRectPreCalc_LineCap1(e, t, i, a, s) {
      this.LinePreCalc_LineCap1(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap1(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap1(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap1(e, a, 0, e, t, 0, -s, 0);
    }
    _LineRectPreCalc_LineCap0(e, t, i, a, s) {
      this.LinePreCalc_LineCap0(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap0(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap0(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap0(e, a, 0, e, t, 0, -s, 0);
    }
    LineRect2(e) {
      this.LineRect(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());
    }
    LineQuad(e) {
      const t = C32.angleTo(e.getTlx(), e.getTly(), e.getTrx(), e.getTry()), i = Math.sin(t), a = Math.cos(t), s = 0.5 * this._lineWidth, r = i * s, l = a * s, n = this._lineCap;
      2 === n ? this._LineQuadPreCalc_LineCap2(e, r, l) : 1 === n ? this._LineQuadPreCalc_LineCap1(e, r, l) : this._LineQuadPreCalc_LineCap0(e, r, l);
    }
    _LineQuadPreCalc_LineCap2(e, t, i) {
      this.LinePreCalc_LineCap2(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap2(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap2(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap2(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);
    }
    _LineQuadPreCalc_LineCap1(e, t, i) {
      this.LinePreCalc_LineCap1(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap1(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap1(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap1(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);
    }
    _LineQuadPreCalc_LineCap0(e, t, i) {
      this.LinePreCalc_LineCap0(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap0(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap0(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap0(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);
    }
    SetLineWidth(e) {
      this._lineWidth = e, this._lineWidthStack[this._lineWidthStack.length - 1] = e;
    }
    GetLineWidth() {
      return this._lineWidth;
    }
    PushLineWidth(e) {
      if (this._lineWidthStack.length >= 100) throw new Error("pushed too many line widths - check push/pop pairs");
      this._lineWidthStack.push(e), this._lineWidth = e;
    }
    PopLineWidth() {
      if (this._lineWidthStack.length <= 1) throw new Error("cannot pop last line width - check push/pop pairs");
      this._lineWidthStack.pop(), this._lineWidth = this._lineWidthStack.at(-1);
    }
    SetLineCapButt() {
      this._lineCap = 0, this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    SetLineCapSquare() {
      this._lineCap = 1, this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    SetLineCapZag() {
      this._lineCap = 2, this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    PushLineCap(e) {
      if ("butt" === e) this.PushLineCapButt();
      else if ("square" === e) this.PushLineCapSquare();
      else {
        if ("zag" !== e) throw new Error("invalid line cap");
        this.PushLineCapZag();
      }
    }
    PushLineCapButt() {
      if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(0), this._lineCap = 0;
    }
    PushLineCapSquare() {
      if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(1), this._lineCap = 1;
    }
    PushLineCapZag() {
      if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(2), this._lineCap = 2;
    }
    PopLineCap() {
      if (this._lineCapStack.length <= 1) throw new Error("cannot pop last line cap - check push/pop pairs");
      this._lineCapStack.pop(), this._lineCap = this._lineCapStack.at(-1);
    }
    SetLineOffset(e) {
      this._lineOffset = e, this._lineOffsetStack[this._lineOffsetStack.length - 1] = e;
    }
    GetLineOffset() {
      return this._lineOffset;
    }
    PushLineOffset(e) {
      if (this._lineOffsetStack.length >= 100) throw new Error("pushed too many line offsets - check push/pop pairs");
      this._lineOffsetStack.push(e), this._lineOffset = e;
    }
    PopLineOffset() {
      if (this._lineOffsetStack.length <= 1) throw new Error("cannot pop last line offset - check push/pop pairs");
      this._lineOffsetStack.pop(), this._lineOffset = this._lineOffsetStack.at(-1);
    }
    ResetCullState() {
      this.SetCullFaceMode(0), this.SetFrontFaceWinding(0);
    }
    ConvexPoly(e) {
      const t = e.length / 2;
      if (t < 3) throw new Error("need at least 3 points");
      const i = t - 2, a = i - 1, s = e[0], r = e[1];
      for (let t2 = 0; t2 < i; t2 += 2) {
        const i2 = 2 * t2, l = e[i2 + 2], n = e[i2 + 3], h = e[i2 + 4], o = e[i2 + 5];
        if (t2 === a) this.Quad2(s, r, l, n, h, o, h, o);
        else {
          const t3 = e[i2 + 6], a2 = e[i2 + 7];
          this.Quad2(s, r, l, n, h, o, t3, a2);
        }
      }
    }
    Finish() {
      this.EndBatch(true), this._frameNumber++;
    }
    GetFrameNumber() {
      return this._frameNumber;
    }
    IncrementFrameNumber() {
      this._frameNumber++;
    }
    SetMipmapsEnabled(e) {
      this._enableMipmaps = !!e;
    }
    AreMipmapsEnabled() {
      return this._enableMipmaps;
    }
    SetHasMajorPerformanceCaveat(e) {
      this._hasMajorPerformanceCaveat = !!e;
    }
    HasMajorPerformanceCaveat() {
      return this._hasMajorPerformanceCaveat;
    }
    IsWebGL() {
      return false;
    }
    IsWebGPU() {
      return false;
    }
    GetEstimatedBackBufferMemoryUsage() {
    }
    GetEstimatedRenderBufferMemoryUsage() {
    }
    GetEstimatedTextureMemoryUsage() {
    }
    GetEstimatedTotalMemoryUsage() {
      return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage();
    }
    CreateRendererText() {
      return C32.New(C32.Gfx.RendererText, this);
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.ShaderProgramBase = class {
    constructor(e, t) {
      this._name = t.name, this._renderer = e, this._extendBoxHorizontal = t.extendBoxHorizontal || 0, this._extendBoxVertical = t.extendBoxVertical || 0, this._crossSampling = !!t.crossSampling, this._mustPreDraw = !!t.mustPreDraw, this._preservesOpaqueness = !!t.preservesOpaqueness, this._supports3dDirectRendering = !!t.supports3dDirectRendering, this._animated = !!t.animated, this._blendsBackground = !!t.blendsBackground, this._usesDepth = !!t.usesDepth, this._usesAnySrcRectOrPixelSize = false, this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
    }
    Release() {
      this._renderer = null;
    }
    GetRenderer() {
      return this._renderer;
    }
    GetName() {
      return this._name;
    }
    ExtendsBox() {
      return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
    }
    GetBoxExtendHorizontal() {
      return this._extendBoxHorizontal;
    }
    GetBoxExtendVertical() {
      return this._extendBoxVertical;
    }
    UsesCrossSampling() {
      return this._crossSampling;
    }
    MustPreDraw() {
      return this._mustPreDraw;
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness;
    }
    Supports3DDirectRendering() {
      return this._supports3dDirectRendering;
    }
    IsAnimated() {
      return this._animated;
    }
    BlendsBackground() {
      return this._blendsBackground;
    }
    UsesDepth() {
      return this._usesDepth;
    }
    UsesAnySrcRectOrPixelSize() {
      return this._usesAnySrcRectOrPixelSize;
    }
    NeedsPostDrawOrExtendsBox() {
      return this._needsPostDrawOrExtendBox;
    }
    UsesIsSrcTexRotated() {
      return false;
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.StateGroup = class {
    constructor(e, r, t, s, o, a, i) {
      this._renderer = e, this._refCount = 0, this._shaderProgram = null, this._shaderProgramName = "", this._blendMode = t, this._color = C32.New(C32.Color), this._color.set(s), this._zElevation = o, this._cullFaceMode = a, this._frontFaceWinding = i, "string" == typeof r ? this._shaderProgramName = r : (this._shaderProgram = r, this._shaderProgramName = this._shaderProgram.GetName());
    }
    Release() {
      if (this._refCount > 0) throw new Error("releasing state group still in use");
      this._renderer = null, this._shaderProgram = null, this._shaderProgramName = "";
    }
    Apply() {
      const e = this._renderer;
      e.SetProgram(this._shaderProgram), e.SetBlendMode(this._blendMode), e.SetColor(this._color), e.SetCurrentZ(this._zElevation), e.SetCullFaceMode(this._cullFaceMode), e.SetFrontFaceWinding(this._frontFaceWinding), e._SetCurrentStateGroup(this);
    }
    GetKey() {
      return C32.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation, this._cullFaceMode, this._frontFaceWinding);
    }
    AddRef() {
      ++this._refCount;
    }
    DecRef() {
      --this._refCount;
    }
    _GetRefCount() {
      return this._refCount;
    }
    OnContextLost() {
      this._shaderProgram = null;
    }
    OnContextRestored(e) {
      if (this._shaderProgram = e.GetShaderProgramByName(this._shaderProgramName), !this._shaderProgram) throw new Error("failed to restore shader program");
    }
    static MakeKey(e, r, t, s, o, a) {
      return ("string" == typeof e ? e : e.GetName()) + "," + r + "," + t.getR() + "," + t.getG() + "," + t.getB() + "," + t.getA() + "," + s + "," + o + "," + a;
    }
  };
}
{
  let interpolateQuad = function(t, e, s) {
    const i = s.getTlx(), n = s.getTly(), r = s.getTrx() - i, h = s.getTry() - n;
    return [i + r * t + (s.getBlx() - i) * e, n + h * t + (s.getBly() - n) * e];
  };
  interpolateQuad2 = interpolateQuad;
  const C32 = globalThis.C3, assert = globalThis.assert, MAX_VERTICES = 65535;
  C32.Gfx.MeshPoint = class {
    constructor(t, e, s) {
      this._mesh = t, this._col = e, this._row = s, this._x = NaN, this._y = NaN, this._zElevation = NaN, this._u = NaN, this._v = NaN, this._x = 0, this._y = 0, this._zElevation = 0, this._u = 0, this._v = 0;
    }
    _Init(t, e, s, i) {
      this._x = t, this._y = e, this._u = s, this._v = i;
    }
    GetX() {
      return this._x;
    }
    SetX(t) {
      this._x !== t && (this._x = t, this._mesh._SetPointsChanged());
    }
    GetY() {
      return this._y;
    }
    SetY(t) {
      this._y !== t && (this._y = t, this._mesh._SetPointsChanged());
    }
    GetZElevation() {
      return this._zElevation;
    }
    SetZElevation(t) {
      this._zElevation !== t && (this._zElevation = Math.max(t, 0), this._mesh._SetPointsChanged());
    }
    GetU() {
      return this._u;
    }
    SetU(t) {
      this._u = t;
    }
    GetV() {
      return this._v;
    }
    SetV(t) {
      this._v = t;
    }
    _Interpolate_TexRect(t, e, s) {
      [this._x, this._y] = interpolateQuad(t._x, t._y, e), this._zElevation = t._zElevation, this._u = C32.lerp(s.getLeft(), s.getRight(), t._u), this._v = C32.lerp(s.getTop(), s.getBottom(), t._v);
    }
    _Interpolate_TexQuad(t, e, s) {
      [this._x, this._y] = interpolateQuad(t._x, t._y, e), this._zElevation = t._zElevation, [this._u, this._v] = interpolateQuad(t._u, t._v, s);
    }
    SaveToJson() {
      return { "x": this.GetX(), "y": this.GetY(), "z": this.GetZElevation(), "u": this.GetU(), "v": this.GetV() };
    }
    LoadFromJson(t) {
      this.SetX(t["x"]), this.SetY(t["y"]), t.hasOwnProperty("z") && this.SetZElevation(t["z"]), this.SetU(t["u"]), this.SetV(t["v"]);
    }
    GetMesh() {
      return this._mesh;
    }
    GetColumn() {
      return this._col;
    }
    GetRow() {
      return this._row;
    }
  }, C32.Gfx.Mesh = class {
    constructor(t, e, s) {
      if (t < 2 || e < 2) throw new Error("invalid mesh size");
      this._hsize = t, this._vsize = e, this._owner = s || null, this._pts = [], this._minX = 0, this._minY = 0, this._maxX = 1, this._maxY = 1, this._maxZ = 0, this._bboxChanged = false, this._meshChunks = [], this._lastZOffset = 0, this._dataArrsChanged = true;
      const i = t - 1, n = e - 1;
      for (let s2 = 0; s2 < e; ++s2) {
        const e2 = [];
        for (let r = 0; r < t; ++r) {
          const t2 = C32.New(C32.Gfx.MeshPoint, this, r, s2), h = r / i, o = s2 / n;
          t2._Init(h, o, h, o), e2.push(t2);
        }
        this._pts.push(e2);
      }
    }
    Release() {
      C32.clearArray(this._pts), C32.clearArray(this._meshChunks);
    }
    GetHSize() {
      return this._hsize;
    }
    GetVSize() {
      return this._vsize;
    }
    GetOwner() {
      return this._owner;
    }
    _GetPoints() {
      return this._pts;
    }
    _SetPointsChanged() {
      this._bboxChanged = true, this._dataArrsChanged = true;
    }
    _MaybeComputeBounds() {
      if (!this._bboxChanged) return;
      let t = 1 / 0, e = 1 / 0, s = -1 / 0, i = -1 / 0, n = 0;
      for (const r of this._pts) for (const h of r) {
        const r2 = h.GetX(), o = h.GetY();
        t = Math.min(t, r2), e = Math.min(e, o), s = Math.max(s, r2), i = Math.max(i, o), n = Math.max(n, h.GetZElevation());
      }
      this._minX = t, this._minY = e, this._maxX = s, this._maxY = i, this._maxZ = n, this._bboxChanged = false;
    }
    GetMinX() {
      return this._MaybeComputeBounds(), this._minX;
    }
    GetMinY() {
      return this._MaybeComputeBounds(), this._minY;
    }
    GetMaxX() {
      return this._MaybeComputeBounds(), this._maxX;
    }
    GetMaxY() {
      return this._MaybeComputeBounds(), this._maxY;
    }
    GetMaxZ() {
      return this._MaybeComputeBounds(), this._maxZ;
    }
    HasAnyZElevation() {
      return this.GetMaxZ() > 0;
    }
    GetMeshPointAt(t, e) {
      return t = Math.floor(t), e = Math.floor(e), t < 0 || t >= this._hsize || e < 0 || e >= this._vsize ? null : this._pts[e][t];
    }
    CalculateTransformedMesh(t, e, s) {
      const i = s instanceof C32.Rect;
      if (t.GetHSize() !== this.GetHSize() || t.GetVSize() !== this.GetVSize()) throw new Error("source mesh wrong size");
      const n = t._pts, r = this._pts;
      for (let t2 = 0, h = r.length; t2 < h; ++t2) {
        const h2 = n[t2], o = r[t2];
        for (let t3 = 0, n2 = o.length; t3 < n2; ++t3) {
          const n3 = h2[t3], r2 = o[t3];
          i ? r2._Interpolate_TexRect(n3, e, s) : r2._Interpolate_TexQuad(n3, e, s);
        }
      }
      this._dataArrsChanged = true;
    }
    _MaybeUpdateDataArrays(t) {
      if (!this._dataArrsChanged && this._lastZOffset === t) return;
      const e = this._hsize, s = this._vsize, i = this._meshChunks, n = Math.floor(65535 / e) - 1;
      if (n <= 0) throw new Error("mesh too large");
      const r = Math.ceil((s - 1) / n);
      r < i.length && (i.length = r);
      let h = 0;
      for (let o = 0; o < r; ++o) {
        const r2 = Math.min(n, s - h - 1), a = (r2 + 1) * e, l = 3 * a, _ = 2 * a, u = (e - 1) * r2 * 6;
        if (o === i.length) i.push({ posArr: new Float32Array(l), uvArr: new Float32Array(_), indexArr: new Uint16Array(u) });
        else {
          const t2 = i[o];
          t2.posArr.length !== l && (t2.posArr = new Float32Array(l)), t2.uvArr.length !== _ && (t2.uvArr = new Float32Array(_)), t2.indexArr.length !== u && (t2.indexArr = new Uint16Array(u));
        }
        const { posArr: c, uvArr: G, indexArr: m } = i[o];
        this._WriteChunkDataArrays(h, r2, t, c, G, m), h += n;
      }
      this._lastZOffset = t, this._dataArrsChanged = false;
    }
    _WriteChunkDataArrays(t, e, s, i, n, r) {
      const h = this._pts, o = this._hsize;
      let a = 0, l = 0, _ = 0;
      for (let u = t, c = t + e + 1; u < c; ++u) {
        const e2 = h[u], G = u + 1, m = u - t, C = m * o, f = (m + 1) * o;
        for (let t2 = 0, h2 = e2.length; t2 < h2; ++t2) {
          const o2 = e2[t2], u2 = t2 + 1;
          if (i[a++] = o2.GetX(), i[a++] = o2.GetY(), i[a++] = o2.GetZElevation() + s, n[l++] = o2.GetU(), n[l++] = o2.GetV(), u2 < h2 && G < c) {
            const e3 = t2 + C, s2 = u2 + C, i2 = u2 + f, n2 = t2 + f;
            r[_++] = e3, r[_++] = s2, r[_++] = i2, r[_++] = e3, r[_++] = i2, r[_++] = n2;
          }
        }
      }
    }
    Draw(t, e) {
      this._MaybeUpdateDataArrays(e);
      for (const { posArr: e2, uvArr: s, indexArr: i } of this._meshChunks) t.DrawMesh(e2, s, i);
    }
    Outline(t, e) {
      e || (e = (t2, e2, s2) => [t2, e2, s2]);
      const s = this._pts;
      let i = s[0];
      for (let n = 1, r = s.length; n < r; ++n) {
        const h = s[n];
        let o = i[0], a = h[0];
        for (let s2 = 1, l = h.length; s2 < l; ++s2) {
          const _ = i[s2], u = h[s2], [c, G, m] = e(o.GetX(), o.GetY(), o.GetZElevation()), [C, f, p] = e(_.GetX(), _.GetY(), _.GetZElevation()), [g, y, d] = e(u.GetX(), u.GetY(), u.GetZElevation()), [x, M, v] = e(a.GetX(), a.GetY(), a.GetZElevation());
          t.Line3D(c, G, m, C, f, p), t.Line3D(c, G, m, g, y, d), t.Line3D(c, G, m, x, M, v), s2 === l - 1 && t.Line3D(C, f, p, g, y, d), n === r - 1 && t.Line3D(x, M, v, g, y, d), o = _, a = u;
        }
        i = h;
      }
    }
    InsertPolyMeshVertices(t) {
      const e = 1e-3, s = 0.99999999, i = t.pointsArr(), n = [], r = this.GetHSize() - 1, h = this.GetVSize() - 1, o = 1 / r, a = 1 / h, l = r - 1, _ = h - 1;
      let u = i[0], c = i[1], G = C32.clamp(Math.floor(u * r), 0, l), m = C32.clamp(Math.floor(c * h), 0, _), C = true, f = 0, p = 0, g = 0;
      let y = -1;
      const d = () => {
        u = C32.clamp(C32.lerp(u, f, g), 0, 1), c = C32.clamp(C32.lerp(c, p, g), 0, 1), n.push(u, c);
      };
      for (let t2 = 0, x = i.length; t2 < x; t2 += 2) {
        u = i[t2], c = i[t2 + 1], n.push(u, c), G = C32.clamp(Math.floor(u * r), 0, l), m = C32.clamp(Math.floor(c * h), 0, _);
        const M = (t2 + 2) % x;
        for (f = i[M], p = i[M + 1], y = -1; ; ) {
          if (n.length > 1e6) throw new Error("Too many mesh poly points");
          const t3 = G * o, i2 = m * a, r2 = (G + 1) * o, h2 = (m + 1) * a;
          if (C = C32.isPointInTriangleInclusive(u, c, t3, i2, r2, i2, r2, h2), 0 !== y && (g = C32.rayIntersectExtended(u, c, f, p, t3, i2, r2, h2, -1e-3), g >= 0 && g <= s)) d(), C = !C, y = 0;
          else if (m > 0 && 2 !== y && (g = C32.rayIntersectExtended(u, c, f, p, t3, i2, r2, i2, e), g >= 0 && g <= s)) d(), m--, C = false, y = 4;
          else if (G < l && 3 !== y && (g = C32.rayIntersectExtended(u, c, f, p, r2, i2, r2, h2, e), g >= 0 && g <= s)) d(), G++, C = false, y = 1;
          else if (G > 0 && 1 !== y && (g = C32.rayIntersectExtended(u, c, f, p, t3, i2, t3, h2, e), g >= 0 && g <= s)) d(), G--, C = true, y = 3;
          else {
            if (!(m < _ && 4 !== y && (g = C32.rayIntersectExtended(u, c, f, p, t3, h2, r2, h2, e), g >= 0 && g <= s))) break;
            d(), m++, C = true, y = 2;
          }
        }
      }
      return C32.New(C32.CollisionPoly, n);
    }
    TransformCollisionPoly(t, e) {
      const s = this._TransformPolyPoints(t);
      this._SimplifyPoly(s), e.setPoints(s);
    }
    _TransformPolyPoints(t) {
      const e = [], s = t.pointsArr();
      for (let t2 = 0, i = s.length; t2 < i; t2 += 2) {
        const i2 = s[t2], n = s[t2 + 1], [r, h] = this.TransformPoint(i2, n);
        e.push(r, h);
      }
      return e;
    }
    TransformPoint(t, e) {
      const s = this.GetHSize() - 1, i = this.GetVSize() - 1, n = 1 / s, r = 1 / i, h = C32.clamp(Math.floor(t * s), 0, s - 1), o = C32.clamp(Math.floor(e * i), 0, i - 1), a = h * n, l = o * r, _ = (h + 1) * n, u = (o + 1) * r, c = this.GetMeshPointAt(h, o), G = this.GetMeshPointAt(h + 1, o + 1), m = C32.isPointInTriangleInclusive(t, e, a, l, _, l, _, u), C = m ? a + n : a, f = m ? l : l + r, p = this.GetMeshPointAt(h + (m ? 1 : 0), o + (m ? 0 : 1)), [g, y, d] = C32.triangleCartesianToBarycentric(t, e, a, l, C, f, _, u);
      return C32.triangleBarycentricToCartesian3d(g, y, d, c.GetX(), c.GetY(), c.GetZElevation(), p.GetX(), p.GetY(), p.GetZElevation(), G.GetX(), G.GetY(), G.GetZElevation());
    }
    _SimplifyPoly(t) {
      const e = [], s = 1e-7;
      let i = t[0], n = t[1], r = i - t.at(-2), h = n - t.at(-1);
      for (let o = 0, a = t.length; o < a; o += 2) {
        const l = (o + 2) % a, _ = t[l], u = t[l + 1], c = _ - i, G = u - n, m = Math.abs(c) < s && Math.abs(r) < s && Math.sign(G) === Math.sign(h), C = Math.abs(G) < s && Math.abs(h) < s && Math.sign(c) === Math.sign(r);
        (!m && !C && Math.abs(c / r - G / h) > 1e-3 || 0 == c && 0 === G) && e.push(i, n), i = _, n = u, r = c, h = G;
      }
      e.length >= 6 && e.length < t.length && C32.shallowAssignArray(t, e);
    }
    SaveToJson() {
      return { "cols": this.GetHSize(), "rows": this.GetVSize(), "points": this._pts.map((t) => t.map((t2) => t2.SaveToJson())) };
    }
    LoadFromJson(t) {
      const e = this.GetHSize(), s = this.GetVSize();
      if (t["cols"] !== e || t["rows"] !== s) throw new Error("mesh data wrong size");
      const i = t["points"];
      for (let t2 = 0; t2 < s; ++t2) {
        const s2 = i[t2];
        for (let i2 = 0; i2 < e; ++i2) {
          this.GetMeshPointAt(i2, t2).LoadFromJson(s2[i2]);
        }
      }
    }
  };
}
var interpolateQuad2;
{
  let GetFormatSpecifiers = function(e, t) {
    let i, r, a, s;
    switch (e) {
      case "rgba8":
        i = t.RGBA8, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_BYTE;
        break;
      case "rgb8":
        i = t.RGB8, r = t.RGB, a = t.RGB, s = t.UNSIGNED_BYTE;
        break;
      case "rgba4":
        i = t.RGBA4, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_SHORT_4_4_4_4;
        break;
      case "rgb5_a1":
        i = t.RGB5_A1, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_SHORT_5_5_5_1;
        break;
      case "rgb565":
        i = t.RGB565, r = t.RGB, a = t.RGB, s = t.UNSIGNED_SHORT_5_6_5;
        break;
      default:
        throw new Error("invalid pixel format");
    }
    return { sizedinternalformat: i, internalformat: r, format: a, type: s };
  };
  GetFormatSpecifiers2 = GetFormatSpecifiers;
  const C32 = self.C3, VALID_PIXEL_FORMATS = /* @__PURE__ */ new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]), VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), VALID_MIPMAP_QUALITIES = /* @__PURE__ */ new Set(["default", "low", "high"]), VALID_WRAP_MODES = /* @__PURE__ */ new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
  const CREATEFROM_DEFAULT_OPTIONS = { wrapX: "clamp-to-edge", wrapY: "clamp-to-edge", sampling: "trilinear", anisotropy: 0, pixelFormat: "rgba8", mipMap: true, mipMapQuality: "default", premultiplyAlpha: true, isSvg: false, width: -1, height: -1 }, UPDATE_DEFAULT_OPTIONS = { premultiplyAlpha: true, flipY: false }, allTextures = /* @__PURE__ */ new Set();
  C32.Gfx.WebGLRendererTexture = class {
    constructor(e) {
      this._renderer = e, this._texture = null, this._width = 0, this._height = 0, this._isStatic = true, this._wrapX = "clamp-to-edge", this._wrapY = "clamp-to-edge", this._sampling = "trilinear", this._anisotropy = 0, this._pixelFormat = "rgba8", this._isMipMapped = false, this._mipMapQuality = "default", this._refCount = 0;
    }
    _CreateStatic(e, t) {
      if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData || e instanceof ArrayBuffer)) throw new Error("invalid texture source");
      if (t = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, t), this._texture) throw new Error("already created texture");
      if (this._wrapX = t.wrapX, this._wrapY = t.wrapY, this._sampling = t.sampling, this._anisotropy = t.anisotropy, this._pixelFormat = t.pixelFormat, this._isMipMapped = !!t.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = t.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
      if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
      if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error("invalid pixel format");
      if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
      if (this._isStatic = true, e instanceof ArrayBuffer || null === e || t.isSvg) {
        if (this._width = t.width, this._height = t.height, e instanceof ArrayBuffer && e.byteLength !== this._width * this._height * 4) throw new Error("ArrayBuffer wrong size");
      } else this._width = e.width, this._height = e.height;
      if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture data size");
      if (t.isSvg) {
        const t2 = C32.CreateCanvas(this._width, this._height);
        t2.getContext("2d").drawImage(e, 0, 0, this._width, this._height), e = t2;
      }
      const i = C32.isPOT(this._width) && C32.isPOT(this._height), r = this._renderer.GetMaxTextureSize();
      if (this._width > r || this._height > r) throw new Error("texture data exceeds maximum texture size");
      const a = this._renderer.GetContext(), s = this._renderer.GetWebGLVersionNumber();
      this._texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this._texture), a.pixelStorei(a["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], t.premultiplyAlpha), a.pixelStorei(a["UNPACK_FLIP_Y_WEBGL"], false);
      const h = GetFormatSpecifiers(this._pixelFormat, a);
      if (this._renderer.SupportsNPOTTextures() || i || !this._IsTiled()) if (s >= 2) {
        let t2;
        t2 = this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, a.texStorage2D(a.TEXTURE_2D, t2, h.sizedinternalformat, this._width, this._height), e instanceof ArrayBuffer ? a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this._width, this._height, h.format, h.type, new Uint8Array(e)) : null !== e && a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, h.format, h.type, e);
      } else e instanceof ArrayBuffer ? a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, new Uint8Array(e)) : null === e ? a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, null) : a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, h.format, h.type, e);
      else {
        if (null === e) throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
        if (e instanceof ArrayBuffer && (e = new ImageData(new Uint8ClampedArray(e), this._width, this._height)), e instanceof ImageData) {
          const t3 = C32.CreateCanvas(this._width, this._height);
          t3.getContext("2d").putImageData(e, 0, 0), e = t3;
        }
        const t2 = C32.CreateCanvas(C32.nextHighestPowerOfTwo(this._width), C32.nextHighestPowerOfTwo(this._height)), i2 = t2.getContext("2d");
        i2.imageSmoothingEnabled = "nearest" !== this._sampling, i2.drawImage(e, 0, 0, this._width, this._height, 0, 0, t2.width, t2.height), a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, h.format, h.type, t2);
      }
      null !== e && this._SetTextureParameters(a), a.bindTexture(a.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);
    }
    _CreateDynamic(e, t, i) {
      if (i = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, i), this._texture) throw new Error("already created texture");
      if (this._wrapX = i.wrapX, this._wrapY = i.wrapY, this._sampling = i.sampling, this._pixelFormat = i.pixelFormat, this._isMipMapped = !!i.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = i.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
      if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
      if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error("invalid pixel format");
      if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
      this._isStatic = false, this._width = Math.floor(e), this._height = Math.floor(t);
      const r = C32.isPOT(this._width) && C32.isPOT(this._height), a = this._renderer.GetMaxTextureSize();
      if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture size");
      if (this._width > a || this._height > a) throw new Error("texture exceeds maximum texture size");
      if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !r) throw new Error("non-power-of-two tiled textures not supported");
      const s = this._renderer.GetContext(), h = this._renderer.GetWebGLVersionNumber();
      this._texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], i.premultiplyAlpha), s.pixelStorei(s["UNPACK_FLIP_Y_WEBGL"], false);
      const n = GetFormatSpecifiers(this._pixelFormat, s), _ = h >= 2 ? n.sizedinternalformat : n.internalformat;
      s.texImage2D(s.TEXTURE_2D, 0, _, this._width, this._height, 0, n.format, n.type, null), this._SetTextureParameters(s), s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);
    }
    _GetMipMapHint(e) {
      if ("default" === this._mipMapQuality) return this._isStatic ? e.NICEST : e.FASTEST;
      if ("low" === this._mipMapQuality) return e.FASTEST;
      if ("high" === this._mipMapQuality) return e.NICEST;
      throw new Error("invalid mipmap quality");
    }
    _IsTiled() {
      return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY;
    }
    _GetTextureWrapMode(e, t) {
      if ("clamp-to-edge" === t) return e.CLAMP_TO_EDGE;
      if ("repeat" === t) return e.REPEAT;
      if ("mirror-repeat" === t) return e.MIRRORED_REPEAT;
      throw new Error("invalid wrap mode");
    }
    _SetTextureParameters(e) {
      const t = C32.isPOT(this._width) && C32.isPOT(this._height);
      if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, this._GetTextureWrapMode(e, this._wrapX)), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, this._GetTextureWrapMode(e, this._wrapY)), "nearest" === this._sampling) e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), this._isMipMapped = false;
      else if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), (t || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {
        e.hint(e.GENERATE_MIPMAP_HINT, this._GetMipMapHint(e)), e.generateMipmap(e.TEXTURE_2D);
        const t2 = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat();
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t2 ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR_MIPMAP_NEAREST);
      } else e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), this._isMipMapped = false;
      const i = this._renderer._GetAnisotropicExtension();
      i && this._anisotropy > 0 && "nearest" !== this._sampling && e.texParameterf(e.TEXTURE_2D, i["TEXTURE_MAX_ANISOTROPY_EXT"], Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()));
    }
    _Update(e, t) {
      if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData)) throw new Error("invalid texture source");
      if (!this._texture || this._refCount <= 0) throw new Error("texture not created");
      if (this._isStatic) throw new Error("cannot update static texture");
      t = Object.assign({}, UPDATE_DEFAULT_OPTIONS, t);
      const i = e.width || e.videoWidth, r = e.height || e.videoHeight, a = this._renderer.GetWebGLVersionNumber(), s = this._renderer.GetContext();
      s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], t.premultiplyAlpha), s.pixelStorei(s["UNPACK_FLIP_Y_WEBGL"], !!t.flipY);
      const h = GetFormatSpecifiers(this._pixelFormat, s), n = a >= 2 ? h.sizedinternalformat : h.internalformat;
      try {
        if (this._width === i && this._height === r) {
          const t2 = C32.isPOT(this._width) && C32.isPOT(this._height);
          s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, h.format, h.type, e), (t2 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));
        } else {
          this._width = i, this._height = r;
          const t2 = C32.isPOT(this._width) && C32.isPOT(this._height);
          if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !t2) throw new Error("non-power-of-two tiled textures not supported");
          s.texImage2D(s.TEXTURE_2D, 0, n, h.format, h.type, e), (t2 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));
        }
      } catch (e2) {
        console.error("Error updating WebGL texture: ", e2);
      }
      s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture();
    }
    _Delete() {
      if (this._refCount > 0) throw new Error("texture still has references");
      if (!this._texture) throw new Error("already deleted texture");
      allTextures.delete(this);
      this._renderer.GetContext().deleteTexture(this._texture), this._texture = null;
    }
    IsValid() {
      return !!this._texture;
    }
    _GetTexture() {
      return this._texture;
    }
    GetRenderer() {
      return this._renderer;
    }
    AddReference() {
      this._refCount++;
    }
    SubtractReference() {
      if (this._refCount <= 0) throw new Error("no more references");
      this._refCount--;
    }
    GetReferenceCount() {
      return this._refCount;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    IsStatic() {
      return this._isStatic;
    }
    GetEstimatedMemoryUsage() {
      let e = this._width * this._height;
      switch (this._pixelFormat) {
        case "rgba8":
          e *= 4;
          break;
        case "rgb8":
          e *= 3;
          break;
        case "rgba4":
        case "rgb5_a1":
        case "rgb565":
          e *= 2;
      }
      return this._isMipMapped && (e += Math.floor(e / 3)), e;
    }
    static OnContextLost() {
      allTextures.clear();
    }
    static allTextures() {
      return allTextures.values();
    }
  };
}
var GetFormatSpecifiers2;
{
  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), DEFAULT_RENDERTARGET_OPTIONS = { sampling: "trilinear", alpha: true, depth: false, isSampled: true, isDefaultSize: true, multisampling: 0 }, allRenderTargets = /* @__PURE__ */ new Set();
  C32.Gfx.WebGLRenderTarget = class {
    constructor(e) {
      this._renderer = e, this._frameBuffer = null, this._frameBufferNoDepth = null, this._texture = null, this._renderBuffer = null, this._width = 0, this._height = 0, this._isDefaultSize = true, this._sampling = "trilinear", this._alpha = true, this._depth = false, this._isSampled = true, this._multisampling = 0, this._projectionMatrix = mat4.create(), this._lastFov = 0, this._lastNearZ = 0, this._lastFarZ = 0;
    }
    _Create(e, t, r) {
      r = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, r);
      const i = this._renderer.GetWebGLVersionNumber();
      if (this._texture || this._renderBuffer) throw new Error("already created render target");
      if (this._sampling = r.sampling, this._alpha = !!r.alpha, this._depth = !!r.depth, this._isSampled = !!r.isSampled, this._isDefaultSize = !!r.isDefaultSize, this._multisampling = r.multisampling, !VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
      if (this._multisampling > 0 && (i < 2 || this._isSampled)) throw new Error("invalid use of multisampling");
      if (i < 2 && (this._isSampled = true), this._width = e, this._height = t, this._width <= 0 || this._height <= 0) throw new Error("invalid render target size");
      this._CalculateProjection();
      const s = this._renderer.GetContext();
      if (this._frameBuffer = s.createFramebuffer(), this._depth && (this._frameBufferNoDepth = s.createFramebuffer()), this._isSampled) {
        this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, { sampling: this._sampling, pixelFormat: this._alpha ? "rgba8" : "rgb8", mipMap: false });
        const e2 = this._texture._GetTexture();
        s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e2, 0), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e2, 0));
      } else {
        this._renderBuffer = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, this._renderBuffer);
        const e2 = this._alpha ? s.RGBA8 : s.RGB8;
        if (this._multisampling > 0) {
          const t2 = s.getInternalformatParameter(s.RENDERBUFFER, e2, s.SAMPLES);
          if (t2 && t2[0]) {
            const e3 = t2[0];
            this._multisampling > e3 && (this._multisampling = e3);
          } else this._multisampling = 0;
        }
        0 === this._multisampling ? s.renderbufferStorage(s.RENDERBUFFER, e2, this._width, this._height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, this._multisampling, e2, this._width, this._height), s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer)), s.bindRenderbuffer(s.RENDERBUFFER, null);
      }
      const h = this._renderer._GetDepthBuffer();
      this._depth && h && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), this._renderer._CanSampleDepth() ? s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, h, 0) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, h)), s.bindFramebuffer(s.FRAMEBUFFER, null), allRenderTargets.add(this);
    }
    _Resize(e, t) {
      if (this._width === e && this._height === t) return;
      this._width = e, this._height = t, this._CalculateProjection();
      const r = this._renderer.GetContext();
      r.bindFramebuffer(r.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (r.bindRenderbuffer(r.RENDERBUFFER, this._renderBuffer), r.renderbufferStorage(r.RENDERBUFFER, this._alpha ? r.RGBA8 : r.RGB8, this._width, this._height), r.bindRenderbuffer(r.RENDERBUFFER, null));
      const i = this._renderer._GetDepthBuffer();
      this._depth && i && (this._renderer._CanSampleDepth() ? r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, i, 0) : r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, i)), r.bindFramebuffer(r.FRAMEBUFFER, null);
    }
    _Delete() {
      if (!this._texture && !this._renderBuffer) throw new Error("already deleted render target");
      allRenderTargets.delete(this);
      const e = this._renderer.GetContext();
      this._texture ? (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null)), e.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null), e.bindFramebuffer(e.FRAMEBUFFER, null), this._renderer.GetWebGLVersionNumber() >= 2 && (e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null)), e.deleteFramebuffer(this._frameBuffer), this._depth && e.deleteFramebuffer(this._frameBufferNoDepth);
      const t = this._renderer.GetBatchState();
      t.currentFramebuffer = null, t.currentFramebufferNoDepth = null, this._frameBuffer = null;
    }
    _CalculateProjection() {
      this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height), this._lastFov = this._renderer.GetFovY(), this._lastNearZ = this._renderer.GetNearZ(), this._lastFarZ = this._renderer.GetFarZ();
    }
    _GetFramebuffer() {
      return this._frameBuffer;
    }
    _GetFramebufferNoDepth() {
      return this._frameBufferNoDepth;
    }
    GetRenderer() {
      return this._renderer;
    }
    GetTexture() {
      return this._texture;
    }
    GetProjectionMatrix() {
      return this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection(), this._projectionMatrix;
    }
    IsLinearSampling() {
      return "nearest" !== this._sampling;
    }
    HasAlpha() {
      return this._alpha;
    }
    IsSampled() {
      return this._isSampled;
    }
    HasDepthBuffer() {
      return this._depth;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    IsDefaultSize() {
      return this._isDefaultSize;
    }
    GetMultisampling() {
      return this._multisampling;
    }
    GetOptions() {
      const e = { sampling: this._sampling, alpha: this._alpha, isSampled: this._isSampled };
      return this._isDefaultSize || (e.width = this._width, e.height = this._height), e;
    }
    IsCompatibleWithOptions(e) {
      return "nearest" !== (e = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, e)).sampling === this.IsLinearSampling() && (!!e.alpha === this.HasAlpha() && (!!e.depth === this.HasDepthBuffer() && (!(this._renderer.GetWebGLVersionNumber() >= 2 && !!e.isSampled !== this.IsSampled()) && ("number" == typeof e.width || "number" == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(e.width) && this.GetHeight() === Math.floor(e.height) : this.IsDefaultSize()))));
    }
    _GetWebGLTexture() {
      return this._texture ? this._texture._GetTexture() : null;
    }
    GetEstimatedMemoryUsage() {
      return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3);
    }
    static async DebugReadPixelsToBlob(e, t) {
      const r = await e.ReadBackRenderTargetToImageData(t, true);
      return await C32.ImageDataToBlob(r);
    }
    static OnContextLost() {
      allRenderTargets.clear();
    }
    static allRenderTargets() {
      return allRenderTargets.values();
    }
    static ResizeAll(e, t) {
      for (const r of allRenderTargets) r.IsDefaultSize() && r._Resize(e, t);
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, RESERVED_UNIFORM_NAMES = /* @__PURE__ */ new Set(["aPos", "aTex", "aColor", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar"]);
  C32.Gfx.WebGLShaderProgram = class extends C32.Gfx.ShaderProgramBase {
    static async Compile(e, t) {
      const i = e.GetContext(), r = t.src, o = t.vertexSrc, n = t.name, a = i.createShader(i.FRAGMENT_SHADER);
      i.shaderSource(a, r), i.compileShader(a);
      const l = i.createShader(i.VERTEX_SHADER);
      i.shaderSource(l, o), i.compileShader(l);
      const s = i.createProgram();
      i.attachShader(s, a), i.attachShader(s, l), i.bindAttribLocation(s, 0, "aPos"), i.bindAttribLocation(s, 1, "aTex"), i.bindAttribLocation(s, 2, "aColor"), i.bindAttribLocation(s, 3, "aPoints"), i.linkProgram(s);
      const h = e._GetParallelShaderCompileExtension();
      if (h ? await e._WaitForObjectReady(() => i.getProgramParameter(s, h["COMPLETION_STATUS_KHR"])) : await C32.Wait(5), !i.getShaderParameter(a, i.COMPILE_STATUS)) {
        const e2 = i.getShaderInfoLog(a);
        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error("Error compiling fragment shader: " + e2);
      }
      if (!i.getShaderParameter(l, i.COMPILE_STATUS)) {
        const e2 = i.getShaderInfoLog(l);
        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error("Error compiling vertex shader: " + e2);
      }
      if (!i.getProgramParameter(s, i.LINK_STATUS)) {
        const e2 = i.getProgramInfoLog(s);
        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error("Error linking shader program: " + e2);
      }
      const c = C32.FilterUnprintableChars(i.getProgramInfoLog(s) || "").trim();
      return c && !C32.IsStringAllWhitespace(c) && console.info(`[WebGL] Shader program '${n}' compilation log: `, c), i.deleteShader(a), i.deleteShader(l), s;
    }
    static async Create(e, t) {
      const i = await C32.Gfx.WebGLShaderProgram.Compile(e, t);
      return new C32.Gfx.WebGLShaderProgram(e, i, t);
    }
    constructor(e, t, i) {
      super(e, i);
      const r = e.GetContext(), o = e.GetBatchState();
      e.EndBatch(), r.useProgram(t), this._gl = r, this._shaderProgram = t, this._isDeviceTransform = "<default-device-transform>" === i.name;
      const n = r.getAttribLocation(t, "aPos"), a = r.getAttribLocation(t, "aTex"), l = r.getAttribLocation(t, "aColor");
      this._locAPoints = r.getAttribLocation(t, "aPoints"), -1 !== n && (r.bindBuffer(r.ARRAY_BUFFER, e._vertexBuffer), r.vertexAttribPointer(n, 3, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(n)), -1 !== a && (r.bindBuffer(r.ARRAY_BUFFER, e._texcoordBuffer), r.vertexAttribPointer(a, 2, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(a)), -1 !== l && (r.bindBuffer(r.ARRAY_BUFFER, e._colorBuffer), r.vertexAttribPointer(l, 4, e.IsColorDataF16() ? r["HALF_FLOAT"] : r.FLOAT, false, 0, 0), r.enableVertexAttribArray(l)), -1 !== this._locAPoints && (r.bindBuffer(r.ARRAY_BUFFER, e._pointBuffer), r.vertexAttribPointer(this._locAPoints, 4, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(this._locAPoints)), r.bindBuffer(r.ARRAY_BUFFER, null), this._uMatP = new C32.Gfx.WebGLShaderUniform(this, "matP", "mat4"), this._uMatMV = new C32.Gfx.WebGLShaderUniform(this, "matMV", "mat4"), this._uColor = new C32.Gfx.WebGLShaderUniform(this, "color", "vec4"), this._uSamplerFront = new C32.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler"), this._uPointTexStart = new C32.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2"), this._uPointTexEnd = new C32.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2"), this._uZElevation = new C32.Gfx.WebGLShaderUniform(this, "zElevation", "float"), this._uTileSize = new C32.Gfx.WebGLShaderUniform(this, "tileSize", "vec2"), this._uTileSpacing = new C32.Gfx.WebGLShaderUniform(this, "tileSpacing", "vec2"), this._uColor2 = new C32.Gfx.WebGLShaderUniform(this, "color2_", "vec4"), this._uOutlineThickness = new C32.Gfx.WebGLShaderUniform(this, "outlineThickness", "float"), this._uSamplerBack = new C32.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler"), this._uSamplerDepth = new C32.Gfx.WebGLShaderUniform(this, "samplerDepth", "sampler"), this._uDestStart = new C32.Gfx.WebGLShaderUniform(this, "destStart", "vec2"), this._uDestEnd = new C32.Gfx.WebGLShaderUniform(this, "destEnd", "vec2"), this._uSrcStart = new C32.Gfx.WebGLShaderUniform(this, "srcStart", "vec2"), this._uSrcEnd = new C32.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2"), this._uSrcOriginStart = new C32.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2"), this._uSrcOriginEnd = new C32.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2"), this._uPixelSize = new C32.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2"), this._uSeconds = new C32.Gfx.WebGLShaderUniform(this, "seconds", "float"), this._uDevicePixelRatio = new C32.Gfx.WebGLShaderUniform(this, "devicePixelRatio", "float"), this._uLayerScale = new C32.Gfx.WebGLShaderUniform(this, "layerScale", "float"), this._uLayerAngle = new C32.Gfx.WebGLShaderUniform(this, "layerAngle", "float"), this._uLayoutStart = new C32.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2"), this._uLayoutEnd = new C32.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2"), this._uZNear = new C32.Gfx.WebGLShaderUniform(this, "zNear", "float"), this._uZFar = new C32.Gfx.WebGLShaderUniform(this, "zFar", "float"), this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
      const s = i.parameters || [];
      this._uCustomParameters = [], this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed(), this._hasCurrentMatP = false, this._hasCurrentMatMV = false, this._uColor.Init4f(1, 1, 1, 1), this._uColor2.Init4f(1, 1, 1, 1), this._uSamplerFront.Init1i(0), this._uSamplerBack.Init1i(1), this._uSamplerDepth.Init1i(2), this._uPointTexStart.Init2f(0, 0), this._uPointTexEnd.Init2f(1, 1), this._uZElevation.Init1f(0), this._uTileSize.Init2f(0, 0), this._uTileSpacing.Init2f(0, 0), this._uDestStart.Init2f(0, 0), this._uDestEnd.Init2f(1, 1), this._uSrcStart.Init2f(0, 0), this._uSrcEnd.Init2f(0, 0), this._uSrcOriginStart.Init2f(0, 0), this._uSrcOriginEnd.Init2f(0, 0), this._uPixelSize.Init2f(0, 0), this._uDevicePixelRatio.Init1f(1), this._uZNear.Init1f(e.GetNearZ()), this._uZFar.Init1f(e.GetFarZ()), this._uLayerScale.Init1f(1), this._uLayerAngle.Init1f(0), this._uSeconds.Init1f(0), this._uLayoutStart.Init2f(0, 0), this._uLayoutEnd.Init2f(0, 0), this._uOutlineThickness.Init1f(1);
      for (const e2 of s) {
        const t2 = e2[0], i2 = e2[2], r2 = new C32.Gfx.WebGLShaderUniform(this, t2, i2);
        "color" === i2 ? r2.Init3f(0, 0, 0) : r2.Init1f(0), this._uCustomParameters.push(r2);
      }
      this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(o.currentMatP) : (this.UpdateMatP(o.currentMatP, true), this.UpdateMatMV(o.currentMV, true));
      const h = o.currentShader;
      r.useProgram(h ? h._shaderProgram : null);
    }
    Release() {
      this._gl.deleteProgram(this._shaderProgram), this._shaderProgram = null, this._renderer._RemoveShaderProgram(this), this._gl = null, super.Release();
    }
    GetWebGLContext() {
      return this._gl;
    }
    GetShaderProgram() {
      return this._shaderProgram;
    }
    GetParameterCount() {
      return this._uCustomParameters.length;
    }
    GetParameterType(e) {
      return e < 0 || e >= this._uCustomParameters.length ? null : this._uCustomParameters[e].GetType();
    }
    AreCustomParametersAlreadySetInBatch(e) {
      for (let t = 0, i = e.length; t < i; ++t) if (!this._uCustomParameters[t].IsSetToCustomInBatch(e[t])) return false;
      return true;
    }
    SetCustomParametersInBatch(e) {
      for (let t = 0, i = e.length; t < i; ++t) this._uCustomParameters[t].SetBatchValueCustom(e[t]);
    }
    AreOptionalUniformsAlreadySetInBatch(e, t, i, r, o, n, a, l, s, h) {
      return !this._uSamplerBack.IsUsed() && (!(this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(o, n)) && (!(this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(e.getLeft(), e.getTop())) && (!(this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(e.getRight(), e.getBottom())) && (!(this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(a)) && (!(this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(l)) && (!(this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(s)) && (!(this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(t.getLeft(), t.getTop())) && (!(this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(t.getRight(), t.getBottom())) && (!(this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(i.getLeft(), i.getTop())) && (!(this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(i.getRight(), i.getBottom())) && (!(this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(r.getLeft(), r.getTop())) && (!(this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(r.getTop(), r.getBottom())) && !(this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(h))))))))))))));
    }
    SetOptionalUniformsInBatch(e, t, i, r, o, n, a, l, s, h) {
      this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(o, n), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(e.getLeft(), e.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(e.getRight(), e.getBottom()), this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(a), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(l), this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(s), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(t.getLeft(), t.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(t.getRight(), t.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(i.getLeft(), i.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(i.getRight(), i.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(r.getLeft(), r.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(r.getTop(), r.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(h));
    }
    UpdateMatP(e, t) {
      this._hasCurrentMatP && !t || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e), this._hasCurrentMatP = true);
    }
    SetMatPStale() {
      this._hasCurrentMatP = false;
    }
    UpdateMatMV(e, t) {
      this._hasCurrentMatMV && !t || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e), this._hasCurrentMatMV = true);
    }
    SetMatMVStale() {
      this._hasCurrentMatMV = false;
    }
    _UpdateDeviceTransformUniforms(e) {
      if (!this._isDeviceTransform) throw new Error("not device transform shader");
      this._uMatP.UpdateMatrix4fv(e);
      const t = this._renderer, i = t.GetWidth() / 2, r = t.GetHeight() / 2, o = t.CalculateLookAtModelView2(i, r, t.GetDefaultCameraZ(t.GetHeight()), i, r, 0, t.GetHeight());
      this._uMatMV.UpdateMatrix4fv(o);
    }
    UpdateColor(e) {
      this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3]);
    }
    static GetReservedUniformNames() {
      return RESERVED_UNIFORM_NAMES;
    }
    static _GetConservativeDepthShaderPrefix(e) {
      return e ? "\n#extension GL_EXT_conservative_depth : enable\nlayout (depth_greater) out highp float gl_FragDepth;\n	" : "";
    }
    static GetDefaultVertexShaderSource(e) {
      const t = e ? "highp" : "mediump";
      return ["attribute highp vec3 aPos;", `attribute ${t} vec2 aTex;`, `varying ${t} vec2 vTex;`, "attribute lowp vec4 aColor;", "varying lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPos, 1.0);", "	vTex = aTex;", "	vColor = aColor;", "}"].join("\n");
    }
    static GetDefaultVertexShaderSource_WebGL2(e) {
      const t = e ? "highp" : "mediump";
      return ["#version 300 es", "in highp vec3 aPos;", `in ${t} vec2 aTex;`, `out ${t} vec2 vTex;`, "in lowp vec4 aColor;", "out lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPos, 1.0);", "	vTex = aTex;", "	vColor = aColor;", "}"].join("\n");
    }
    static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {
      return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * vColor;", "}"].join("\n");
    }
    static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {
      return ["#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * vColor;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetTextureFillFragmentShaderSource_WebGL2(e) {
      return ["#version 300 es", C32.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "in mediump vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	outColor = texture(samplerFront, vTex) * vColor;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "}"].join("\n");
    }
    static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT() {
      return ["#extension GL_EXT_frag_depth : enable", "varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetTilemapFragmentShaderSource_WebGL2(e) {
      return ["#version 300 es", C32.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "in highp vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	outColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetTileRandomizationFragmentShaderSource(e, t, i, r) {
      let o = "";
      return e >= 2 ? o = "#version 300 es\n" + C32.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(r) : (t && (o = "#extension GL_EXT_frag_depth : enable\n"), i && (o += "#extension GL_EXT_shader_texture_lod : enable\n", o += "#extension GL_OES_standard_derivatives : enable\n")), o + `
precision highp float;
${e >= 2 ? "in" : "varying"} vec2 vTex;
${e >= 2 ? "out lowp vec4 outColor;" : ""}
${e >= 2 ? "in" : "varying"} lowp vec4 vColor;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
	return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
				fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
				fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
	vec2 posRandom = tileSize;
	float angleRandom = outlineThickness;
	
	vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;
	
	float angle = angleRandom * rand.z * PI;
	float sin_a = sin(angle);
	float cos_a = cos(angle);
	float aspect = pixelSize.x / pixelSize.y;

	vec2 mid = tile + vec2(0.5, 0.5);
	vec2 dp = uv - mid;
	dp.x /= aspect;
	vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
				  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	vec2 p = mid + r + (posRandom * rand.xy / 2.0);
	
	${e >= 2 ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
	${e < 2 && i ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
	${e < 2 && !i ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {
	
	${e < 2 ? "lowp vec4 outColor;" : ""}
	
	float blendMarginX = tileSpacing.x;
	float blendMarginY = tileSpacing.y;
	
	vec2 tile = floor(vTex);
	vec2 tex = fract(vTex);
	vec2 ddx = ${e >= 2 || i ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
	vec2 ddy = ${e >= 2 || i ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};
	
	vec4 curTile = sampleTile(tile, vTex, ddx, ddy);
	
	bool inLeftMargin = (tex.x < blendMarginX);
	bool inRightMargin = (tex.x > 1.0 - blendMarginX);
	bool inTopMargin = (tex.y < blendMarginY);
	bool inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
		float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
		float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
		outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
		outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		outColor = curTile;
	}
	
	outColor *= vColor;
	${e < 2 ? "gl_FragColor = outColor;" : ""}
	${e >= 2 ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
	${e < 2 && t ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`;
    }
    static GetPointVertexShaderSource_WebGL1() {
      return ["attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join("\n");
    }
    static GetPointVertexShaderSource_WebGL2() {
      return ["#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join("\n");
    }
    static GetPointFragmentShaderSource_WebGL1_NoFragDepth() {
      return ["uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	gl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}"].join("\n");
    }
    static GetPointFragmentShaderSource_WebGL1_FragDepthEXT() {
      return ["#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	gl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetPointFragmentShaderSource_WebGL2(e) {
      return ["#version 300 es", C32.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	outColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetColorFillFragmentShaderSource() {
      return ["varying lowp vec4 vColor;", "void main(void) {", "	gl_FragColor = vColor;", "}"].join("\n");
    }
    static GetLinearGradientFillFragmentShaderSource() {
      return ["precision lowp float;", "varying mediump vec2 vTex;", "varying vec4 vColor;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "	bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "	vec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "	vec3 lower = linearRGB * vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "	bvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "	vec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "	vec3 lower = sRGB/vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "	vec3 linearGrad = mix(toLinear(vColor.rgb), toLinear(color2_.rgb), vTex.x);", "	float a = mix(vColor.a, color2_.a, vTex.x);", "	gl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}"].join("\n");
    }
    static GetPenumbraFillFragmentShaderSource() {
      return ["precision lowp float;", "varying highp vec2 vTex;", "varying vec4 vColor;", "void main(void) {", "	highp float grad = vTex.x / (1.0 - vTex.y);", "	gl_FragColor = vColor * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);", "}"].join("\n");
    }
    static GetSmoothLineFillFragmentShaderSource() {
      return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "	lowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "	gl_FragColor = vColor * f;", "}"].join("\n");
    }
    static GetHardEllipseFillFragmentShaderSource() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float f = step(diffSq.x + diffSq.y, 0.25);", "	gl_FragColor = vColor * f;", "}"].join("\n");
    }
    static GetHardEllipseOutlineFragmentShaderSource() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float distSq = diffSq.x + diffSq.y;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp float innerF = step(distSq, 0.25);", "	highp vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "	highp vec2 innerEdgeSq = innerEdge * innerEdge;", "	highp float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "	gl_FragColor = vColor * innerF * outerF;", "}"].join("\n");
    }
    static GetSmoothEllipseFillFragmentShaderSource() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp vec2 halfNormSq = halfNorm * halfNorm;", "	highp vec2 innerEdge = halfNorm - pixelSize * norm;", "	highp vec2 innerEdgeSq = innerEdge * innerEdge;", "	highp float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "	gl_FragColor = vColor * f;", "}"].join("\n");
    }
    static GetSmoothEllipseOutlineFragmentShaderSource() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float distSq = diffSq.x + diffSq.y;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp vec2 halfNormSq = halfNorm * halfNorm;", "	highp vec2 pxNorm = pixelSize * norm;", "	highp vec2 innerEdge1 = halfNorm - pxNorm;", "	highp vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "	highp float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "	highp vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "	highp vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "	highp vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "	highp vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "	highp float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "	gl_FragColor = vColor * innerF * outerF;", "}"].join("\n");
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, mat4 = glMatrix.mat4, TYPE_SIZES = /* @__PURE__ */ new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
  C32.Gfx.WebGLShaderUniform = class {
    constructor(t, s, a) {
      if (!TYPE_SIZES.has(a)) throw new Error("invalid uniform type");
      this._owner = t, this._gl = this._owner.GetWebGLContext(), this._name = s, this._type = a, this._isColorType = "color" === this._type, this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), s), this._isUsed = !!this._location;
      const i = TYPE_SIZES.get(a);
      this._lastValue = new Float32Array(i), this._lastBatchValue = new Float32Array(i);
    }
    Release() {
      this._owner = null, this._gl = null, this._location = null;
    }
    IsUsed() {
      return this._isUsed;
    }
    GetType() {
      return this._type;
    }
    IsColorType() {
      return this._isColorType;
    }
    Init1f(t) {
      this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, t));
    }
    Init1i(t) {
      this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, t));
    }
    Init2f(t, s) {
      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, t, s));
    }
    Init3f(t, s, a) {
      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastValue[2] = a, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, t, s, a));
    }
    Init4f(t, s, a, i) {
      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastValue[2] = a, this._lastValue[3] = i, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, t, s, a, i));
    }
    Update1f(t) {
      t = Math.fround(t);
      const s = this._lastValue;
      s[0] !== t && (s[0] = t, this._gl.uniform1f(this._location, t));
    }
    Update1i(t) {
      const s = this._lastValue;
      s[0] !== t && (s[0] = t, this._gl.uniform1i(this._location, t));
    }
    Update2f(t, s) {
      t = Math.fround(t), s = Math.fround(s);
      const a = this._lastValue;
      a[0] === t && a[1] === s || (a[0] = t, a[1] = s, this._gl.uniform2f(this._location, t, s));
    }
    Update3f(t, s, a) {
      t = Math.fround(t), s = Math.fround(s), a = Math.fround(a);
      const i = this._lastValue;
      i[0] === t && i[1] === s && i[2] === a || (i[0] = t, i[1] = s, i[2] = a, this._gl.uniform3f(this._location, t, s, a));
    }
    Update4f(t, s, a, i) {
      t = Math.fround(t), s = Math.fround(s), a = Math.fround(a), i = Math.fround(i);
      const l = this._lastValue;
      l[0] === t && l[1] === s && l[2] === a && l[3] === i || (l[0] = t, l[1] = s, l[2] = a, l[3] = i, this._gl.uniform4f(this._location, t, s, a, i));
    }
    UpdateMatrix4fv(t) {
      const s = this._lastValue;
      mat4.exactEquals(s, t) || (C32.typedArraySet16(s, t, 0), this._gl.uniformMatrix4fv(this._location, false, t));
    }
    IsSetToCustomInBatch(t) {
      const s = this._lastBatchValue;
      return this.IsColorType() ? s[0] === Math.fround(t.getR()) && s[1] === Math.fround(t.getG()) && s[2] === Math.fround(t.getB()) : s[0] === Math.fround(t);
    }
    SetBatchValueCustom(t) {
      const s = this._lastBatchValue;
      this.IsColorType() ? (s[0] = t.getR(), s[1] = t.getG(), s[2] = t.getB()) : s[0] = t;
    }
    IsSetTo1InBatch(t) {
      return this._lastBatchValue[0] === Math.fround(t);
    }
    IsSetTo2InBatch(t, s) {
      const a = this._lastBatchValue;
      return a[0] === Math.fround(t) && a[1] === Math.fround(s);
    }
    SetBatch1(t) {
      this._lastBatchValue[0] = t;
    }
    SetBatch2(t, s) {
      const a = this._lastBatchValue;
      a[0] = t, a[1] = s;
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, BATCH_NULL = 0, BATCH_DRAW = 1, BATCH_SETTEXTURE = 2, BATCH_SETBLEND = 3, BATCH_SETVIEWPORT = 4, BATCH_SETPROJECTION = 5, BATCH_SETMODELVIEW = 6, BATCH_SETRENDERTARGET = 7, BATCH_CLEARSURFACE = 8, BATCH_POINTS = 9, BATCH_SETPROGRAM = 10, BATCH_SETPROGRAMPARAMETERS = 11, BATCH_SETPROGRAMCUSTOMPARAMETERS = 12, BATCH_INVALIDATEFRAMEBUFFER = 13, BATCH_SETPOINTTEXCOORDS = 14, BATCH_SETTILEMAPINFO = 15, BATCH_BLITFRAMEBUFFER = 16, BATCH_STARTQUERY = 17, BATCH_ENDQUERY = 18, BATCH_SETELLIPSEPARAMS = 19, BATCH_SETGRADIENTCOLOR = 20, BATCH_CLEARDEPTH = 21, BATCH_SETDEPTHENABLED = 22, BATCH_SETDEPTHSAMPLINGENABLED = 23, BATCH_COPLANAR_STARTSTENCILPASS = 24, BATCH_COPLANAR_STARTCOLORPASS = 25, BATCH_COPLANAR_RESTORE = 26, BATCH_SET_SCISSOR = 27, BATCH_SETTILERANDOMIZATIONINFO = 28, BATCH_SETCULLFACEMODE = 29, BATCH_SETFRONTFACEWINDING = 30;
  C32.Gfx.BatchState = class {
    constructor(t) {
      this.renderer = t, this.currentMV = mat4.create(), this.currentMatP = mat4.create(), this.currentFramebuffer = null, this.currentFramebufferNoDepth = null, this.isDepthSamplingEnabled = false, this.currentShader = null, this.pointTexCoords = new C32.Rect(), this.clearColor = C32.New(C32.Color, 0, 0, 0, 0);
    }
  }, C32.Gfx.WebGLBatchJob = class {
    constructor(t) {
      const e = new ArrayBuffer(96);
      this._type = 0, this._batchState = t, this._gl = t.renderer.GetContext(), this._startIndex = 0, this._indexCount = 0, this._texParam = null, this._mat4param = new Float32Array(e, 0, 16), this._colorParam = new Float32Array(e, 64, 4), this._srcOriginRect = new Float32Array(e, 80, 4), this._shaderParams = [];
    }
    InitDraw(t, e) {
      this._type = 1, this._startIndex = t, this._indexCount = e;
    }
    DoDraw() {
      const t = this._gl;
      t.drawElements(t.TRIANGLES, this._indexCount, t.UNSIGNED_SHORT, this._startIndex);
    }
    InitSetTexture(t) {
      this._type = 2, this._texParam = t;
    }
    DoSetTexture() {
      const t = this._gl, e = this._texParam;
      t.bindTexture(t.TEXTURE_2D, e ? e._GetTexture() : null);
    }
    InitSetGradientColor(t) {
      this._type = 20, t.writeToTypedArray(this._colorParam, 0);
    }
    DoSetGradientColor() {
      const t = this._colorParam, e = this._batchState.currentShader;
      e._uColor2.IsUsed() && e._uColor2.Update4f(t[0], t[1], t[2], t[3]);
    }
    InitSetBlend(t) {
      this._type = 3;
      const e = this._mat4param;
      e[0] = t.length;
      for (let r = 0, a = t.length; r < a; ++r) e[r + 1] = t[r];
    }
    DoSetBlend() {
      const t = this._gl, e = this._mat4param, r = e[0], a = e[1], s = e[2];
      let i = a, n = s, o = t.FUNC_ADD, _ = t.FUNC_ADD;
      r >= 4 && (i = e[3], n = e[4]), 6 === r && (o = e[5], _ = e[6]), t.blendFuncSeparate(a, s, i, n), t.blendEquationSeparate(o, _);
    }
    InitSetViewport(t, e, r, a) {
      this._type = 4;
      const s = this._colorParam;
      s[0] = t, s[1] = e, s[2] = r, s[3] = a;
    }
    DoSetViewport() {
      const t = this._colorParam;
      this._gl.viewport(t[0], t[1], t[2], t[3]);
    }
    InitSetProjection(t) {
      this._type = 5, mat4.copy(this._mat4param, t);
    }
    DoSetProjection() {
      const t = this._batchState, e = t.renderer._allShaderPrograms, r = t.currentShader, a = this._mat4param;
      for (let t2 = 0, s = e.length; t2 < s; ++t2) {
        const s2 = e[t2];
        s2 === r ? s2.UpdateMatP(a, true) : s2.SetMatPStale();
      }
      mat4.copy(t.currentMatP, a);
    }
    InitSetModelView(t) {
      this._type = 6, mat4.copy(this._mat4param, t);
    }
    DoSetModelView() {
      const t = this._batchState, e = t.renderer._allShaderPrograms, r = t.currentShader, a = this._mat4param;
      for (let t2 = 0, s = e.length; t2 < s; ++t2) {
        const s2 = e[t2];
        s2 === r ? s2.UpdateMatMV(a, true) : s2.SetMatMVStale();
      }
      mat4.copy(t.currentMV, a);
    }
    InitSetRenderTarget(t) {
      this._type = 7, this._texParam = t;
    }
    DoSetRenderTarget() {
      const t = this._gl, e = this._texParam, r = this._batchState;
      e ? (r.currentFramebuffer = e._GetFramebuffer(), r.currentFramebufferNoDepth = e._GetFramebufferNoDepth(), r.isDepthSamplingEnabled && r.currentFramebufferNoDepth ? t.bindFramebuffer(t.FRAMEBUFFER, r.currentFramebufferNoDepth) : t.bindFramebuffer(t.FRAMEBUFFER, r.currentFramebuffer)) : (r.currentFramebuffer = null, r.currentFramebufferNoDepth = null, t.bindFramebuffer(t.FRAMEBUFFER, null));
    }
    InitClearSurface(t) {
      this._type = 8, t.writeToTypedArray(this._mat4param, 0);
    }
    InitClearSurface2(t, e, r, a) {
      this._type = 8;
      const s = this._mat4param;
      s[0] = t, s[1] = e, s[2] = r, s[3] = a;
    }
    DoClearSurface() {
      const t = this._gl, e = this._mat4param, r = this._batchState.clearColor, a = e[0], s = e[1], i = e[2], n = e[3];
      r.equalsRgba(a, s, i, n) || (t.clearColor(a, s, i, n), r.setRgba(a, s, i, n)), t.clear(t.COLOR_BUFFER_BIT);
    }
    InitSetPointTexCoords(t) {
      this._type = 14, t.writeToTypedArray(this._mat4param, 0);
    }
    DoSetPointTextureCoords() {
      const t = this._mat4param;
      this._batchState.pointTexCoords.set(t[0], t[1], t[2], t[3]);
    }
    InitPoints(t, e, r) {
      this._type = 9, this._startIndex = t, this._indexCount = 1, this._mat4param[0] = e, r.writeToTypedArray(this._colorParam, 0);
    }
    DoPoints() {
      const t = this._gl, e = this._batchState, r = e.renderer._spPoints;
      t.useProgram(r._shaderProgram), r.UpdateMatP(e.currentMatP, false), r.UpdateMatMV(e.currentMV, false);
      const a = e.pointTexCoords;
      r._uPointTexStart.IsUsed() && r._uPointTexStart.Update2f(a.getLeft(), a.getTop()), r._uPointTexEnd.IsUsed() && r._uPointTexEnd.Update2f(a.getRight(), a.getBottom());
      const s = this._mat4param[0];
      if (r._uZElevation.IsUsed() && r._uZElevation.Update1f(s), r._uColor.IsUsed()) {
        const t2 = this._colorParam;
        r._uColor.Update4f(t2[0], t2[1], t2[2], t2[3]);
      }
      t.drawArrays(t.POINTS, this._startIndex / 4, this._indexCount), t.useProgram(e.currentShader._shaderProgram);
    }
    InitSetProgram(t) {
      this._type = 10, this._texParam = t;
    }
    DoSetProgram() {
      const t = this._gl, e = this._batchState, r = this._texParam;
      e.currentShader = r, t.useProgram(r._shaderProgram), r.UpdateMatP(e.currentMatP, false), r.UpdateMatMV(e.currentMV, false);
    }
    InitSetProgramParameters() {
      this._type = 11;
    }
    DoSetProgramParameters() {
      const t = this._batchState.currentShader, e = this._gl, r = this._mat4param, a = this._colorParam, s = this._srcOriginRect;
      if (t._uSamplerBack.IsUsed()) {
        const t2 = this._batchState.renderer, r2 = this._texParam;
        t2._lastTexture1 !== r2 && (e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, r2 ? r2._GetTexture() : null), t2._lastTexture1 = r2, e.activeTexture(e.TEXTURE0));
      }
      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(r[0], r[1]), t._uDestStart.IsUsed() && t._uDestStart.Update2f(r[2], r[3]), t._uDestEnd.IsUsed() && t._uDestEnd.Update2f(r[4], r[5]), t._uDevicePixelRatio.IsUsed() && t._uDevicePixelRatio.Update1f(this._indexCount), t._uLayerScale.IsUsed() && t._uLayerScale.Update1f(r[6]), t._uLayerAngle.IsUsed() && t._uLayerAngle.Update1f(r[7]), t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(r[12], r[13]), t._uSrcEnd.IsUsed() && t._uSrcEnd.Update2f(r[14], r[15]), t._uSrcOriginStart.IsUsed() && t._uSrcOriginStart.Update2f(s[0], s[1]), t._uSrcOriginEnd.IsUsed() && t._uSrcOriginEnd.Update2f(s[2], s[3]), t._uLayoutStart.IsUsed() && t._uLayoutStart.Update2f(a[0], a[1]), t._uLayoutEnd.IsUsed() && t._uLayoutEnd.Update2f(a[2], a[3]), t._uSeconds.IsUsed() && t._uSeconds.Update1f(this._startIndex);
    }
    InitSetProgramCustomParameters() {
      this._type = 12;
    }
    DoSetProgramCustomParameters() {
      const t = this._batchState.currentShader._uCustomParameters, e = this._shaderParams;
      for (let r = 0, a = t.length; r < a; ++r) {
        const a2 = t[r], s = e[r];
        a2.IsColorType() ? a2.Update3f(s.getR(), s.getG(), s.getB()) : a2.Update1f(s);
      }
    }
    InitInvalidateFramebuffer(t) {
      this._type = 13, this._texParam = t;
    }
    DoInvalidateFramebuffer() {
      const t = this._gl, e = this._texParam, r = this._batchState.currentFramebuffer;
      e !== r && t.bindFramebuffer(t.FRAMEBUFFER, e), t.invalidateFramebuffer(t.FRAMEBUFFER, [t.COLOR_ATTACHMENT0]), e !== r && t.bindFramebuffer(t.FRAMEBUFFER, r);
    }
    InitBlitFramebuffer(t, e, r) {
      this._type = 16;
      const a = this._mat4param, s = this._batchState.renderer;
      a[0] = t.GetWidth(), a[1] = t.GetHeight(), a[2] = e ? e.GetWidth() : s.GetWidth(), a[3] = e ? e.GetHeight() : s.GetHeight(), a[4] = t.IsLinearSampling() ? 1 : 0, a[5] = "stretch" === r;
      const i = this._shaderParams;
      C32.clearArray(i), i.push(t._GetFramebuffer()), i.push(e ? e._GetFramebuffer() : null);
    }
    DoBlitFramebuffer() {
      const t = this._mat4param, e = this._shaderParams, r = this._gl, a = t[0], s = t[1], i = t[2], n = t[3], o = 0 !== t[4], _ = 0 !== t[5], h = e[0], d = e[1];
      if (r.bindFramebuffer(r.READ_FRAMEBUFFER, h), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, d), _) r.blitFramebuffer(0, 0, a, s, 0, 0, i, n, r.COLOR_BUFFER_BIT, o ? r.LINEAR : r.NEAREST);
      else {
        const t2 = Math.min(a, i), e2 = Math.min(s, n), o2 = Math.max(s - n, 0), _2 = Math.max(n - s, 0);
        r.blitFramebuffer(0, o2, t2, e2 + o2, 0, _2, t2, e2 + _2, r.COLOR_BUFFER_BIT, r.NEAREST);
      }
    }
    InitStartQuery(t) {
      this._type = 17, this._texParam = t;
    }
    DoStartQuery() {
      this._texParam.BeginTimeElapsed(), this._texParam = null;
    }
    InitEndQuery(t) {
      this._type = 18, this._texParam = t;
    }
    DoEndQuery() {
      this._texParam.EndTimeElapsed(), this._texParam = null;
    }
    InitSetEllipseParams(t, e, r) {
      this._type = 19;
      const a = this._mat4param;
      a[0] = t, a[1] = e, a[2] = r;
    }
    DoSetEllipseParams() {
      const t = this._batchState.currentShader, e = this._mat4param;
      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[2]);
    }
    InitSetTilemapInfo(t, e, r, a, s, i, n) {
      this._type = 15;
      const o = this._mat4param;
      t.writeToTypedArray(o, 0), o[4] = 1 / e, o[5] = 1 / r, o[6] = a / e, o[7] = s / r, o[8] = i / e, o[9] = n / r;
    }
    DoSetTilemapInfo() {
      const t = this._batchState.currentShader, e = this._mat4param;
      t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(e[0], e[1]), t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[4], e[5]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[6], e[7]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[8], e[9]);
    }
    InitSetTileRandomizationInfo(t, e, r, a, s, i, n) {
      this._type = 28;
      const o = this._mat4param;
      o[0] = 1 / t, o[1] = 1 / e, o[2] = r, o[3] = a, o[4] = s, o[5] = i, o[6] = n;
    }
    DoSetTileRandomizationInfo() {
      const t = this._batchState.currentShader, e = this._mat4param;
      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[2], e[3]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[4]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[5], e[6]);
    }
    InitClearDepth(t) {
      this._type = 21, this._startIndex = t ? 1 : 0;
    }
    DoClearDepth() {
      const t = this._gl, e = 0 !== this._startIndex;
      e || t.depthMask(true), t.clear(t.DEPTH_BUFFER_BIT), e || t.depthMask(false);
    }
    InitSetDepthEnabled(t) {
      this._type = 22, this._startIndex = t ? 1 : 0;
    }
    DoSetDepthEnabled() {
      const t = this._gl;
      0 === this._startIndex ? (t.disable(t.DEPTH_TEST), t.depthMask(false)) : (t.enable(t.DEPTH_TEST), t.depthMask(true));
    }
    InitSetDepthSamplingEnabled(t) {
      this._type = 23, this._startIndex = t ? 1 : 0;
    }
    DoSetDepthSamplingEnabled() {
      const t = this._gl, e = this._batchState, r = e.renderer, a = 0 !== this._startIndex;
      e.isDepthSamplingEnabled = a, t.activeTexture(t.TEXTURE2), a ? (e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebufferNoDepth), t.bindTexture(t.TEXTURE_2D, r._GetDepthBuffer())) : (t.bindTexture(t.TEXTURE_2D, null), e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebuffer)), t.activeTexture(t.TEXTURE0);
    }
    InitCoplanarStartStencilPass() {
      this._type = 24;
    }
    DoCoplanarStartStencilPass() {
      const t = this._gl;
      t.clear(t.STENCIL_BUFFER_BIT), t.enable(t.STENCIL_TEST), t.stencilFunc(t.ALWAYS, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.REPLACE), t.colorMask(false, false, false, false);
    }
    InitCoplanarStartColorPass() {
      this._type = 25;
    }
    DoCoplanarStartColorPass() {
      const t = this._gl;
      t.enable(t.STENCIL_TEST), t.colorMask(true, true, true, true), t.stencilFunc(t.EQUAL, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
    }
    InitCoplanarRestore() {
      this._type = 26;
    }
    DoCoplanarRestore() {
      const t = this._gl;
      t.disable(t.STENCIL_TEST);
    }
    InitSetScissor(t, e, r, a, s) {
      this._type = 27, this._startIndex = t ? 1 : 0;
      const i = this._mat4param;
      i[0] = e, i[1] = r, i[2] = a, i[3] = s;
    }
    DoSetScissor() {
      const t = this._gl, e = this._mat4param;
      1 === this._startIndex ? (t.enable(t.SCISSOR_TEST), t.scissor(e[0], e[1], e[2], e[3])) : t.disable(t.SCISSOR_TEST);
    }
    InitSetCullFaceMode(t) {
      this._type = 29, this._startIndex = t;
    }
    DoSetCullFaceMode() {
      const t = this._gl, e = this._startIndex;
      0 === e ? t.disable(t.CULL_FACE) : (t.enable(t.CULL_FACE), 1 === e ? t.cullFace(t.BACK) : t.cullFace(t.FRONT));
    }
    InitSetFrontFaceWinding(t) {
      this._type = 30, this._startIndex = t;
    }
    DoSetFrontFaceWinding() {
      const t = this._gl;
      t.frontFace(0 === this._startIndex ? t.CW : t.CCW);
    }
    Run() {
      switch (this._type) {
        case 1:
          return void this.DoDraw();
        case 2:
          return void this.DoSetTexture();
        case 3:
          return void this.DoSetBlend();
        case 4:
          return void this.DoSetViewport();
        case 5:
          return void this.DoSetProjection();
        case 6:
          return void this.DoSetModelView();
        case 7:
          return void this.DoSetRenderTarget();
        case 8:
          return void this.DoClearSurface();
        case 9:
          return void this.DoPoints();
        case 10:
          return void this.DoSetProgram();
        case 11:
          return void this.DoSetProgramParameters();
        case 12:
          return void this.DoSetProgramCustomParameters();
        case 13:
          return void this.DoInvalidateFramebuffer();
        case 14:
          return void this.DoSetPointTextureCoords();
        case 15:
          return void this.DoSetTilemapInfo();
        case 16:
          return void this.DoBlitFramebuffer();
        case 17:
          return void this.DoStartQuery();
        case 18:
          return void this.DoEndQuery();
        case 19:
          return void this.DoSetEllipseParams();
        case 20:
          return void this.DoSetGradientColor();
        case 21:
          return void this.DoClearDepth();
        case 22:
          return void this.DoSetDepthEnabled();
        case 23:
          return void this.DoSetDepthSamplingEnabled();
        case 24:
          return void this.DoCoplanarStartStencilPass();
        case 25:
          return void this.DoCoplanarStartColorPass();
        case 26:
          return void this.DoCoplanarRestore();
        case 27:
          return void this.DoSetScissor();
        case 28:
          return void this.DoSetTileRandomizationInfo();
        case 29:
          return void this.DoSetCullFaceMode();
        case 30:
          return void this.DoSetFrontFaceWinding();
      }
    }
  };
}
{
  let fillOrStrokeRect = function(t, e, i, s, a, n) {
    e ? t.strokeRect(i, s, a, n) : t.fillRect(i, s, a, n);
  }, ptToPx = function(t) {
    return t * (4 / 3);
  }, getOffsetParam = function(t, e) {
    t = t.trim();
    const i = parseFloat(t);
    return isFinite(i) ? t.endsWith("%") ? e * i / 100 : i : 0;
  };
  fillOrStrokeRect2 = fillOrStrokeRect, ptToPx2 = ptToPx, getOffsetParam2 = getOffsetParam;
  const C32 = self.C3, MAX_TEXTURE_SIZE = 4096, EXTRA_LINE_HEIGHT = 4, GENERIC_FONT_FAMILIES = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), DEFAULT_OPTS = { timeout: 60 }, tempColor = new C32.Color(0, 0, 0, 1), VALID_HORIZ_ALIGNMENTS = /* @__PURE__ */ new Set(["left", "center", "right"]), VALID_VERT_ALIGNMENTS = /* @__PURE__ */ new Set(["top", "center", "bottom"]), VALID_WORD_WRAP_MODES = /* @__PURE__ */ new Set(["word", "cjk", "character"]), VALID_TEXT_DIRECTIONS = /* @__PURE__ */ new Set(["ltr", "rtl"]), MEASUREMENT_CACHE_MAX_ENTRIES = 1e3, MEASUREMENT_CACHE_DELETE_COUNT = 10, MEASUREMENT_CACHE_TIMEOUT = 2, allRendererTexts = /* @__PURE__ */ new Set();
  C32.FontManager && C32.FontManager.addEventListener("fontload", (t) => {
    const e = t.font.GetName();
    for (const t2 of allRendererTexts) (t2.IsBBCodeEnabled() || C32.equalsNoCase(t2.GetFontName(), e)) && (t2._SetWordWrapChanged(), t2._ClearMeasurementCache());
  });
  let didCheckFoundBoundingBoxSupport = false, supportsFontBoundingBoxMeasurements = false;
  C32.Gfx.RendererText = class {
    constructor(t, e) {
      e = Object.assign({}, DEFAULT_OPTS, e), this._renderer = t, this._fontName = "Arial", this._fontSize = 16, this._fontSizeScale = 1, this._lineHeight = 0, this._isBold = false, this._isItalic = false, this._colorStr = "black", this._isBBcodeEnabled = false, this._iconSet = null, this._iconSmoothing = true, this.onloadfont = null, this._alreadyLoadedFonts = /* @__PURE__ */ new Set(), this._horizontalAlign = "left", this._verticalAlign = "top", this._text = "", this._bbString = null, this._wrappedText = C32.New(C32.WordWrap), this._wrapMode = "word", this._textDirection = "ltr", this._wordWrapChanged = false, this._textLayoutChanged = false, this._drawChanged = false, this._forceRecreateTexture = false, this._drawMaxCharCount = -1, this._drawCharCount = 0, this._cssWidth = 0, this._cssHeight = 0, this._width = 0, this._height = 0, this._zoom = 1, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._lastCanvasWidth = -1, this._lastCanvasHeight = -1, this._lastTextCanvasFont = "", this._lastMeasureCanvasFont = "", this._lastTextCanvasFillStyle = "", this._lastTextCanvasOpacity = 1, this._lastTextCanvasLineWidth = 1, this._measureTextCallback = (t2) => this._MeasureText(t2), this._measurementCache = /* @__PURE__ */ new Map(), this._measurementCacheIdleTimeout = new C32.IdleTimeout(() => this._ClearMeasurementCache(true), 2), this._texture = null, this._enableMipMap = true, this._rcTex = new C32.Rect(), this._scaleFactor = 1, this._textureTimeout = new C32.IdleTimeout(() => {
        this.ReleaseTexture(), this._SetTextCanvasSize(8, 8), this._SetDrawChanged();
      }, e.timeout), this.ontextureupdate = null, this._wasReleased = false, allRendererTexts.add(this);
    }
    Release() {
      this.onloadfont = null, this._alreadyLoadedFonts.clear(), this._iconSet = null, this._bbString = null, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._measureTextCallback = null, this._ClearMeasurementCache(), this._measurementCacheIdleTimeout.Release(), this._textureTimeout.Release(), this.ontextureupdate = null, this.ReleaseTexture(), this._wrappedText.Clear(), this._wrappedText = null, this._renderer = null, this._wasReleased = true, allRendererTexts.delete(this);
    }
    _SetDrawChanged() {
      this._drawChanged = true;
    }
    _SetTextLayoutChanged() {
      this._SetDrawChanged(), this._textLayoutChanged = true;
    }
    _SetWordWrapChanged() {
      this._SetTextLayoutChanged(), this._wordWrapChanged = true;
    }
    SetBBCodeEnabled(t) {
      if (t = !!t, this._isBBcodeEnabled === t) return;
      this._isBBcodeEnabled = t;
      const e = this._isBBcodeEnabled ? "alphabetic" : "top";
      this._textContext && (this._textContext.textBaseline = e), this._measureContext && (this._measureContext.textBaseline = e), this._ClearMeasurementCache(), this._SetWordWrapChanged();
    }
    IsBBCodeEnabled() {
      return this._isBBcodeEnabled;
    }
    SetIconSet(t) {
      this._iconSet !== t && (this._iconSet = t, this._wrappedText.SetIconSet(t), this._iconSet && this._iconSet.IsLoading() && this._iconSet.LoadContent().then(() => this._SetDrawChanged()), this._SetWordWrapChanged());
    }
    SetIconSmoothing(t) {
      t = !!t, this._iconSmoothing !== t && (this._iconSmoothing = t, this._SetDrawChanged());
    }
    SetFontName(t) {
      t || (t = "serif"), this._fontName !== t && (this._fontName = t, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetFontName() {
      return this._fontName;
    }
    SetFontSize(t) {
      t < 0.1 && (t = 0.1), this._fontSize !== t && (this._fontSize = t, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetFontSize() {
      return this._fontSize;
    }
    SetFontSizeScale(t) {
      this._fontSizeScale !== t && (this._fontSizeScale = t, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    SetLineHeight(t) {
      this._lineHeight !== t && (this._lineHeight = t, this._SetTextLayoutChanged());
    }
    GetLineHeight() {
      return this._lineHeight;
    }
    SetBold(t) {
      t = !!t, this._isBold !== t && (this._isBold = t, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    IsBold() {
      return this._isBold;
    }
    SetItalic(t) {
      t = !!t, this._isItalic !== t && (this._isItalic = t, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    IsItalic() {
      return this._isItalic;
    }
    SetDrawMaxCharacterCount(t) {
      t = Math.floor(t), this._drawMaxCharCount !== t && (this._drawMaxCharCount = t, this._SetDrawChanged());
    }
    GetDrawMaxCharacterCount() {
      return this._drawMaxCharCount;
    }
    _GetFontString(t, e) {
      let i = [];
      (this._isBold || e.HasStyleTag("b")) && i.push("bold"), (this._isItalic || e.HasStyleTag("i")) && i.push("italic");
      const s = e.GetStyleTag("size"), a = (s ? parseFloat(s.param) : this._fontSize) * this._fontSizeScale;
      t ? i.push(a + "pt") : i.push(a * this.GetDrawScale() + "pt");
      let n = this._fontName;
      const h = e.GetStyleTag("font");
      return h && h.param && (n = h.param, this.onloadfont && !this._alreadyLoadedFonts.has(n) && (this.onloadfont(n), this._alreadyLoadedFonts.add(n))), n && (GENERIC_FONT_FAMILIES.has(n) ? i.push(n) : i.push('"' + n + '"')), i.join(" ");
    }
    SetColor(t) {
      t instanceof C32.Color && (t = t.getCssRgb()), this._colorStr !== t && (this._colorStr = t, this._SetDrawChanged());
    }
    SetColorRgb(t, e, i) {
      tempColor.setRgb(t, e, i), this.SetColor(tempColor);
    }
    SetHorizontalAlignment(t) {
      if (!VALID_HORIZ_ALIGNMENTS.has(t)) throw new Error("invalid horizontal alignment");
      this._horizontalAlign !== t && (this._horizontalAlign = t, this._SetTextLayoutChanged());
    }
    GetHorizontalAlignment() {
      return this._horizontalAlign;
    }
    SetVerticalAlignment(t) {
      if (!VALID_VERT_ALIGNMENTS.has(t)) throw new Error("invalid vertical alignment");
      this._verticalAlign !== t && (this._verticalAlign = t, this._SetTextLayoutChanged());
    }
    GetVerticalAlignment() {
      return this._verticalAlign;
    }
    SetWordWrapMode(t) {
      if (!VALID_WORD_WRAP_MODES.has(t)) throw new Error("invalid word wrap mode");
      this._wrapMode !== t && (this._wrapMode = t, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetWordWrapMode() {
      return this._wrapMode;
    }
    SetTextDirection(t) {
      if (!VALID_TEXT_DIRECTIONS.has(t)) throw new Error("invalid text direction");
      this._textDirection !== t && (this._textDirection = t, this._textContext && (this._textContext.direction = this._textDirection), this._measureContext && (this._measureContext.direction = this._textDirection), this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetTextDirection() {
      return this._textDirection;
    }
    SetText(t) {
      this._text !== t && (this._text = t, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetText() {
      return this._text;
    }
    GetDrawScale() {
      return this._scaleFactor * this._zoom * self.devicePixelRatio;
    }
    SetMipMapEnabled(t) {
      t = !!t, this._enableMipMap !== t && (this._enableMipMap = t, this._forceRecreateTexture = true);
    }
    IsMipMapEnabled() {
      return this._enableMipMap;
    }
    SetSize(t, e, i) {
      if (void 0 === i && (i = 1), t <= 0 || t <= 0) return;
      if (this._cssWidth === t && this._cssHeight === e && this._zoom === i) return;
      const s = this._cssWidth;
      this._cssWidth = t, this._cssHeight = e, this._zoom = i;
      const a = self.devicePixelRatio;
      this._width = this._cssWidth * this._zoom * a, this._height = this._cssHeight * this._zoom * a;
      const n = Math.max(this._width, this._height), h = Math.min(this._renderer.GetMaxTextureSize(), 4096);
      let r = 1;
      n > h && (r = h / n, this._width = Math.min(this._width * r, h), this._height = Math.min(this._height * r, h)), this._scaleFactor = r, this._cssWidth !== s ? this._SetWordWrapChanged() : this._SetTextLayoutChanged();
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetZoom() {
      return this._zoom;
    }
    GetTextWidth() {
      return this._UpdateTextMeasurements(), this._wrappedText.GetMaxLineWidth();
    }
    GetTextHeight() {
      return this._UpdateTextMeasurements(), this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight;
    }
    GetLengthInGraphemes() {
      this._UpdateTextMeasurements();
      let t = 0;
      for (const e of this._wrappedText.GetLines()) for (const i of e.fragments()) t += i.GetLength();
      return t;
    }
    GetTexture() {
      return this._textureTimeout.Reset(), this._MaybeUpdate(), this._texture;
    }
    HitTestFragment(t, e) {
      this._UpdateTextMeasurements();
      const i = this.GetDrawScale(), s = this._wrappedText.GetLines();
      for (const a of s) {
        const s2 = a.GetFontBoundingBoxDescent() * i;
        if (e >= a.GetPosY() - a.GetHeight() * i + s2 && e < a.GetPosY() + s2) {
          for (const e2 of a.fragments()) if (t >= e2.GetPosX() && t < e2.GetPosX() + e2.GetWidth() * i) return e2;
        }
      }
      return null;
    }
    *fragmentsWithTag(t) {
      this._UpdateTextMeasurements();
      const e = this._wrappedText.GetLines();
      for (const i of e) for (const e2 of i.fragments()) {
        const i2 = e2.GetStyleTag("tag");
        i2 && C32.equalsNoCase(i2.param, t) && (yield e2);
      }
    }
    FindFragmentWithTag(t, e) {
      for (const i of this.fragmentsWithTag(t)) {
        if (0 === e) return i;
        --e;
      }
      return null;
    }
    CountFragmentsWithTag(t) {
      let e = 0;
      for (const i of this.fragmentsWithTag(t)) ++e;
      return e;
    }
    _MaybeUpdate() {
      (!this._texture || this._drawChanged || this._textLayoutChanged || this._wordWrapChanged || this._forceRecreateTexture) && (this._wasReleased || this._width <= 0 || this._height <= 0 || this._DoUpdate());
    }
    _DoUpdate() {
      this._wasReleased || (this._UpdateTextMeasurements(), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset());
    }
    _SetTextCanvasSize(t, e) {
      this._textCanvas || (this._textCanvas = C32.CreateCanvas(16, 16));
      let i = false;
      this._lastCanvasWidth === t && this._lastCanvasHeight === e || (this._lastCanvasWidth = t, this._lastCanvasHeight = e, this._textCanvas.width = t, this._textCanvas.height = e, i = true), this._textContext || (this._textContext = this._textCanvas.getContext("2d"), i = true), i ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._textContext.direction = this._textDirection, this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, t, e);
    }
    _MaybeCreateMeasureContext() {
      this._measureContext || (this._measureContext = C32.CreateCanvas(16, 16).getContext("2d"), this._measureContextTop = C32.CreateCanvas(16, 16).getContext("2d"), this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._measureContextTop.textBaseline = "top", this._measureContext.direction = this._textDirection, this._measureContextTop.direction = this._textDirection);
    }
    _SetMeasureFontString(t) {
      this._lastMeasureCanvasFont !== t && (this._lastMeasureCanvasFont = t, this._measureContext.font = t, this._measureContextTop.font = t);
    }
    _SupportsFontBoundingBoxMeasurements() {
      if (!didCheckFoundBoundingBoxSupport) {
        didCheckFoundBoundingBoxSupport = true, this._MaybeCreateMeasureContext();
        const t = this._measureContext.measureText("test");
        supportsFontBoundingBoxMeasurements = "number" == typeof t["fontBoundingBoxAscent"] && "number" == typeof t["fontBoundingBoxDescent"];
      }
      return supportsFontBoundingBoxMeasurements;
    }
    _UpdateTextMeasurements() {
      this._UpdateWordWrap(), this._UpdateTextLayout();
    }
    _UpdateWordWrap() {
      this._wordWrapChanged && (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C32.BBString(this._text, { noEscape: true })), this._measurementCacheIdleTimeout.Reset(), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._wordWrapChanged = false);
    }
    _UpdateTextLayout() {
      this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged = false);
    }
    _ClearMeasurementCache(t) {
      this._measurementCache.clear(), t || this._measurementCacheIdleTimeout.Cancel();
    }
    _AddToMeasurementCache(t, e) {
      const i = this._measurementCache;
      if (i.set(t, e), i.size > 1e3) {
        let t2 = 0;
        for (const e2 of i.keys()) if (i.delete(e2), t2++, t2 >= 10) break;
      }
    }
    _MeasureText(t) {
      const e = t.IsText() ? t.GetCharacterArray().join("") : " ", i = this._GetFontString(true, t), s = i + "|" + e, a = this._measurementCache;
      let n = a.get(s);
      if (n) return a.delete(s), a.set(s, n), n;
      this._SetMeasureFontString(i);
      const h = this._measureContext.measureText(e);
      let r = 0;
      if (this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements()) {
        const t2 = this._measureContextTop.measureText(e);
        r = h["fontBoundingBoxAscent"] - t2["fontBoundingBoxAscent"];
      }
      const o = t.GetStyleTag("size"), _ = (o ? parseFloat(o.param) : this._fontSize) * this._fontSizeScale;
      return n = { width: h.width, height: ptToPx(_), fontBoundingBoxAscent: h["fontBoundingBoxAscent"] || 0, fontBoundingBoxDescent: h["fontBoundingBoxDescent"] || 0, topToAlphabeticDistance: r }, this._AddToMeasurementCache(s, n), n;
    }
    _SetDrawFontString(t) {
      this._lastTextCanvasFont !== t && (this._lastTextCanvasFont = t, this._textContext.font = t);
    }
    _SetDrawCanvasColor(t) {
      this._lastTextCanvasFillStyle !== t && (this._lastTextCanvasFillStyle = t, this._textContext.fillStyle = t, this._textContext.strokeStyle = t);
    }
    _SetDrawCanvasOpacity(t) {
      this._lastTextCanvasOpacity !== t && (this._lastTextCanvasOpacity = t, this._textContext.globalAlpha = t);
    }
    _SetDrawCanvasLineWith(t) {
      this._lastTextCanvasLineWidth !== t && (this._lastTextCanvasLineWidth = t, this._textContext.lineWidth = t);
    }
    _LayoutText() {
      const t = this.GetDrawScale(), e = (4 + this._lineHeight) * t;
      let i = 0;
      const s = this._wrappedText.GetLines();
      if (0 === s.length) return;
      for (const t2 of s) {
        t2.SetPosX(NaN), t2.SetPosY(NaN);
        for (const e2 of t2.fragments()) e2.SetPosX(NaN), e2.SetPosY(NaN);
      }
      const a = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();
      let n = s[0].GetHeight() * t;
      if ("center" === this._verticalAlign) {
        const h = s.reduce((i2, s2) => i2 + s2.GetHeight() * t + e, 0) - e;
        i = Math.max(this._height / 2 - h / 2, 0), a && (n = s[0].GetTopToAlphabeticDistance() * t);
      } else if ("bottom" === this._verticalAlign) {
        const n2 = s.reduce((i2, s2) => i2 + s2.GetHeight() * t + e, 0) - this._lineHeight * t, h = a ? s.at(-1).GetFontBoundingBoxDescent() * t : 0;
        i = this._height - n2 - h - 2;
      }
      for (let a2 = 0, h = s.length; a2 < h; ++a2) {
        const h2 = s[a2], r = h2.GetHeight() * t, o = i;
        if (this._isBBcodeEnabled) {
          if (i += 0 === a2 ? n : r, a2 > 0 && i > this._height - 4 * t) break;
        } else if (a2 > 0 && i >= this._height - r) break;
        o >= 0 && this._LayoutTextLine(h2, i, t), this._isBBcodeEnabled || (i += r), i += e;
      }
    }
    _LayoutTextLine(t, e, i) {
      let s = 0;
      "center" === this._horizontalAlign ? s = Math.floor((this._width - t.GetWidth() * i) / 2) : "right" === this._horizontalAlign && (s = this._width - t.GetWidth() * i), t.SetPosX(s), t.SetPosY(e);
      for (const a of "ltr" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._LayoutFragment(a, s, e, i), s += a.GetWidth() * i;
    }
    _LayoutFragment(t, e, i, s) {
      const a = t.GetStyleTag("offsetx");
      e += a ? getOffsetParam(a.param, t.GetHeight()) * s : 0;
      const n = t.GetStyleTag("offsety");
      if (i += n ? getOffsetParam(n.param, t.GetHeight()) * s : 0, t.IsIcon()) {
        const e2 = t.GetStyleTag("iconoffsety");
        i += e2 ? getOffsetParam(e2.param, t.GetHeight()) * s : 0.2 * t.GetHeight() * s;
      }
      t.SetPosX(e), t.SetPosY(i);
    }
    _DrawTextToCanvas() {
      if (!this._drawChanged) return;
      this._SetTextCanvasSize(Math.max(C32.nextHighestPowerOfTwo(Math.ceil(this._width)), 128), Math.max(C32.nextHighestPowerOfTwo(Math.ceil(this._height)), 64)), this._textContext.imageSmoothingEnabled = this._iconSmoothing, this._textContext.imageSmoothingQuality = "high", this._drawCharCount = 0;
      const t = this.GetDrawScale(), e = this._wrappedText.GetLines();
      for (const i of e) this._DrawTextLine(i, t);
      this._drawChanged = false;
    }
    _DrawTextLine(t, e) {
      const i = t.GetPosX(), s = t.GetPosY();
      if (Number.isFinite(i) && Number.isFinite(s)) for (const i2 of "ltr" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._DrawFragment(i2, e, t.GetHeight());
    }
    _DrawFragment(t, e, i) {
      const s = this._textContext, a = t.GetPosX(), n = t.GetPosY();
      if (!Number.isFinite(a) || !Number.isFinite(n)) return;
      const h = i / 16;
      let r = t.GetWidth() * e;
      const o = t.GetHeight() * e, _ = t.GetHeight() / 16, l = (4 + this._lineHeight) * e;
      let d = t.IsText() ? t.GetCharacterArray() : null;
      if (-1 !== this._drawMaxCharCount) {
        if (this._drawCharCount >= this._drawMaxCharCount) return;
        t.IsText() && this._drawCharCount + d.length > this._drawMaxCharCount && (d = d.slice(0, this._drawMaxCharCount - this._drawCharCount), r = this._MeasureText(t).width * e), this._drawCharCount += t.GetLength();
      }
      const x = t.GetStyleTag("background"), C = t.HasStyleTag("u"), u = t.HasStyleTag("s");
      if (t.IsText() && C32.IsCharArrayAllWhitespace(d) && !x && !C && !u || t.HasStyleTag("hide")) return;
      const c = t.GetStyleTag("color"), g = t.GetStyleTag("opacity");
      this._SetDrawCanvasOpacity(g ? parseFloat(g.param) / 100 : 1), x && (this._SetDrawCanvasColor(x.param), s.fillRect(a, n - o, r, o + l));
      const S = t.GetStyleTag("linethickness"), T = S ? parseFloat(S.param) : 1, m = t.HasStyleTag("stroke");
      if (m && this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale()), t.IsText()) {
        const e2 = d.join("");
        if (this._SetDrawFontString(this._GetFontString(false, t)), !m) {
          this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale());
          const i2 = t.GetStyleTag("outlineback");
          i2 && (this._SetDrawCanvasColor(i2.param), this._FillOrStrokeText(true, e2, a, n, r));
        }
        if (this._SetDrawCanvasColor(c ? c.param : this._colorStr), this._FillOrStrokeText(m, e2, a, n, r), !m) {
          this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale());
          const i2 = t.GetStyleTag("outline");
          i2 && (this._SetDrawCanvasColor(i2.param), this._FillOrStrokeText(true, e2, a, n, r));
        }
      } else if (t.IsIcon() && t.GetWidth() > 0) {
        const e2 = t.GetDrawable(this._iconSet);
        e2 && s.drawImage(e2, a, n - o, r, o);
      }
      if (this._SetDrawCanvasColor(c ? c.param : this._colorStr), C && fillOrStrokeRect(s, m, a, n + e * h, r, e * h * T), u) {
        const t2 = e * _, i2 = n - o / 4 + t2 / 2;
        s.fillRect(a, i2 - t2 * T / 2, r, t2 * T);
      }
    }
    _FillOrStrokeText(t, e, i, s, a) {
      "rtl" === this._textDirection && (i += a), t ? "Gecko" === C32.Platform.BrowserEngine ? this._textContext.strokeText(e, i, s, a) : this._textContext.strokeText(e, i, s) : "Gecko" === C32.Platform.BrowserEngine ? this._textContext.fillText(e, i, s, a) : this._textContext.fillText(e, i, s);
    }
    _UpdateTexture() {
      this._renderer.IsContextLost() || (this._texture && !this._forceRecreateTexture || (this.ReleaseTexture(), this._texture = this._renderer.CreateDynamicTexture(this._textCanvas.width, this._textCanvas.height, { mipMap: this._enableMipMap, mipMapQuality: "high" }), this._forceRecreateTexture = false), this._renderer.UpdateTexture(this._textCanvas, this._texture), this._rcTex.set(0, 0, this._width / this._texture.GetWidth(), this._height / this._texture.GetHeight()), this.ontextureupdate && this.ontextureupdate());
    }
    GetTexRect() {
      return this._rcTex;
    }
    ReleaseTexture() {
      this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null);
    }
    static OnContextLost() {
      for (const t of allRendererTexts) t.ReleaseTexture();
    }
    static GetAll() {
      return allRendererTexts.values();
    }
  };
}
var fillOrStrokeRect2;
var ptToPx2;
var getOffsetParam2;
{
  const C32 = self.C3;
  class WebGLRealTimeElapsedQuery {
    constructor(e) {
      this._gl = e.GetContext(), this._version = e.GetWebGLVersionNumber(), this._timerExt = e._GetDisjointTimerQueryExtension(), this._query = null, this._isActive = false, this._hasResult = false, this._result = 0, 1 === this._version ? this._query = this._timerExt["createQueryEXT"]() : this._query = this._gl["createQuery"]();
    }
    Release() {
      this._DeleteQueryObject(), this._gl = null, this._timerExt = null, this._hasResult = false;
    }
    _DeleteQueryObject() {
      this._query && (1 === this._version ? this._timerExt["deleteQueryEXT"](this._query) : this._gl["deleteQuery"](this._query), this._query = null);
    }
    BeginTimeElapsed() {
      if (this._isActive) throw new Error("query already active");
      1 === this._version ? this._timerExt["beginQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"], this._query) : this._gl["beginQuery"](this._timerExt["TIME_ELAPSED_EXT"], this._query), this._isActive = true;
    }
    EndTimeElapsed() {
      if (!this._isActive) throw new Error("query not active");
      1 === this._version ? this._timerExt["endQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"]) : this._gl["endQuery"](this._timerExt["TIME_ELAPSED_EXT"]), this._isActive = false;
    }
    CheckForResult() {
      if (!this._query || this._hasResult || this._isActive) return;
      let e = false;
      e = 1 === this._version ? this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_AVAILABLE_EXT"]) : this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT_AVAILABLE"]);
      const t = this._gl.getParameter(this._timerExt["GPU_DISJOINT_EXT"]);
      e && !t && (1 === this._version ? this._result = this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_EXT"]) : this._result = this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT"]), this._result /= 1e9, this._hasResult = true), (e || t) && this._DeleteQueryObject();
    }
    HasResult() {
      return this._hasResult;
    }
    GetResult() {
      if (!this._hasResult) throw new Error("no result available");
      return this._result;
    }
  }
  C32.Gfx.WebGLTimeElapsedQuery = class {
    constructor(e) {
      this._renderer = e, this._frameNumber = e.GetFrameNumber(), this._isActive = false, this._parentQuery = null, this._isNested = false, this._realQuery = null, this._queries = [];
    }
    Release() {
      for (const e of this._queries) e instanceof WebGLRealTimeElapsedQuery && e.Release();
      C32.clearArray(this._queries), this._parentQuery = null, this._realQuery = null, this._renderer = null;
    }
    BeginTimeElapsed() {
      if (this._isActive) throw new Error("query already active");
      const e = this._renderer._GetTimeQueryStack();
      e.length > 0 ? (this._isNested = true, this._parentQuery = e.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = false, this._parentQuery = null), this._isActive = true, e.push(this), this._StartReal();
    }
    EndTimeElapsed() {
      if (!this._isActive) throw new Error("query not active");
      if (this._renderer._GetTimeQueryStack().pop() !== this) throw new Error("can only end most nested query");
      this._isActive = false, this._EndReal(), this._parentQuery && (this._parentQuery._StartReal(), this._parentQuery = null);
    }
    _StartReal() {
      this._realQuery = C32.New(WebGLRealTimeElapsedQuery, this._renderer), this._queries.push(this._realQuery), this._realQuery.BeginTimeElapsed();
    }
    _EndReal() {
      this._realQuery.EndTimeElapsed(), this._realQuery = null;
    }
    CheckForResult() {
      for (const e of this._queries) e.CheckForResult();
    }
    IsNested() {
      return this._isNested;
    }
    HasResult() {
      return this._queries.every((e) => e.HasResult());
    }
    GetResult() {
      return this._queries.reduce((e, t) => e + t.GetResult(), 0);
    }
    GetFrameNumber() {
      return this._frameNumber;
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.WebGLQueryResultBuffer = class {
    constructor(e, r = 1e3) {
      this._renderer = e, this._maxQueries = r, this._buffer = [], this._renderer._AddQueryResultBuffer(this);
    }
    Release() {
      this.Clear(), this._renderer._RemoveQueryResultBuffer(this), this._renderer = null;
    }
    Clear() {
      for (const e of this._buffer) e.Release();
      C32.clearArray(this._buffer);
    }
    AddTimeElapsedQuery() {
      const e = new C32.Gfx.WebGLTimeElapsedQuery(this._renderer);
      if (this._buffer.push(e), this._buffer.length > this._maxQueries) {
        this._buffer.shift().Release();
      }
      return e;
    }
    CheckForResults(e) {
      for (const r of this._buffer) {
        if (r.GetFrameNumber() >= e) return;
        if (r.IsNested()) return;
        r.CheckForResult();
      }
    }
    GetFrameRangeResultSum(e, r) {
      if (r <= e) return NaN;
      let t = 0;
      for (const s of this._buffer) {
        if (s.GetFrameNumber() >= r) break;
        if (!(s.GetFrameNumber() < e)) {
          if (!s.HasResult()) return NaN;
          t += s.GetResult();
        }
      }
      return t;
    }
    DeleteAllBeforeFrameNumber(e) {
      for (let r = 0, t = this._buffer.length; r < t; ++r) {
        const t2 = this._buffer[r];
        if (!(t2.GetFrameNumber() < e)) return void (r > 0 && this._buffer.splice(0, r));
        t2.Release();
      }
    }
  };
}
{
  let CheckPendingPolls = function() {
    pollRafId = -1;
    for (const t of pendingPolls) t.checkFunc() && (t.resolve(), pendingPolls.delete(t));
    pendingPolls.size > 0 && (pollRafId = self.requestAnimationFrame(CheckPendingPolls));
  };
  CheckPendingPolls2 = CheckPendingPolls;
  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, DEFAULT_WEBGLRENDERER_OPTS = { powerPreference: "default", enableGpuProfiling: true, alpha: false, depth: false, canSampleDepth: false, maxWebGLVersion: 2, failIfMajorPerformanceCaveat: false }, VALID_POWER_PREFERENCES = /* @__PURE__ */ new Set(["default", "low-power", "high-performance"]), MAX_VERTICES = 65535, MAX_INDICES = 393210, MAX_POINTS = 8e3, LAST_POINT = 7996, defaultTexCoordsQuad = new C32.Quad(0, 0, 1, 0, 1, 1, 0, 1), tmpProjection = mat4.create(), tmpModelView = mat4.create(), tmpQuad = new C32.Quad(), tmpRect = new C32.Rect();
  let loseContextExtension = null;
  C32.isDebug && (self.debug_lose_webgl_context = function() {
    loseContextExtension ? loseContextExtension.loseContext() : console.warn("WEBGL_lose_context not supported");
  }, self.debug_restore_webgl_context = function() {
    loseContextExtension ? loseContextExtension.restoreContext() : console.warn("WEBGL_lose_context not supported");
  });
  const pendingPolls = /* @__PURE__ */ new Set();
  let pollRafId = -1;
  C32.Gfx.WebGLRenderer = class extends C32.Gfx.RendererBase {
    constructor(t, e) {
      if (super(e), e = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, e), !VALID_POWER_PREFERENCES.has(e.powerPreference)) throw new Error("invalid power preference");
      const r = { "alpha": !!e.alpha, "depth": false, "antialias": false, "powerPreference": e.powerPreference, "failIfMajorPerformanceCaveat": !!e.failIfMajorPerformanceCaveat };
      let i = null, s = 0;
      if (e.maxWebGLVersion >= 2 && (i = t.getContext("webgl2", r), s = 2), i || (i = t.getContext("webgl", r), s = 1), !i) throw new Error("renderer-unavailable (could not get WebGL context)");
      this._gl = i, this._attribs = i.getContextAttributes(), this._versionString = i.getParameter(i.VERSION), this._version = s, this._viewport = vec4.create(), this._didChangeTransform = false, this._bbProjectionMatrix = mat4.create(), this._usesDepthBuffer = !!e.depth, this._canSampleDepth = !(!e.depth || !e.canSampleDepth), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._depthBuffer = null, this._isAutoSizeDepthBuffer = true, this._depthBufferWidth = 0, this._depthBufferHeight = 0, this._vertexBuffer = null, this._texcoordBuffer = null, this._colorBuffer = null, this._indexBuffer = null, this._pointBuffer = null, this._isColorDataF16 = this._version >= 2 && void 0 !== globalThis["Float16Array"], this._vertexData = new Float32Array(196605), this._indexData = new Uint16Array(393210), this._texcoordData = new Float32Array(131070), this._colorData = this._isColorDataF16 ? new globalThis["Float16Array"](262140) : new Float32Array(262140), this._pointData = new Float32Array(32e3), this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._batch = [], this._batchPtr = 0, this._topOfBatch = 0, this._currentRenderTarget = null, this._lastPointZ = 0, this._batchState = C32.New(C32.Gfx.BatchState, this), this._lastColor = C32.New(C32.Color, 1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._lastBlendMode = 0, this._lastPointTexCoords = new C32.Rect(), this._lastScissorRect = C32.New(C32.Rect, 0, 0, -1, -1), this._coplanarMode = 0, this._lastCullFace = 0, this._lastFrontFaceWinding = 0, this._maxTextureSize = -1, this._minPointSize = 0, this._maxPointSize = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._extensions = [], this._isInitialisingAfterContextRestored = false, this._parallelShaderCompileExt = null, this._anisotropicExt = null, this._conservativeDepthExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._blendMinMaxExt = null, this._maxAnisotropy = 0, this._isGpuProfilingEnabled = !!e.enableGpuProfiling, this._timerExt = null, this._allQueryResultBuffers = /* @__PURE__ */ new Set(), this._timeQueryStack = [];
    }
    IsWebGL() {
      return true;
    }
    async InitState() {
      super.InitState();
      const t = this._gl;
      this._lastColor.setRgba(1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, C32.clearArray(this._batch), this._batchPtr = 0, this._topOfBatch = 0, this._lastProgram = null, this._currentRenderTarget = null, this._lastPointTexCoords.set(0, 0, 1, 1), this._lastPointZ = 0;
      const e = this._batchState;
      e.currentShader = null, e.currentFramebuffer = null, e.currentFramebufferNoDepth = null, e.clearColor.setRgba(0, 0, 0, 0), e.pointTexCoords.set(0, 0, 1, 1), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), this._lastBlendMode = 0, 1 === this._version ? this._blendMinMaxExt = t.getExtension("EXT_blend_minmax") : this._blendMinMaxExt = null, this._InitBlendModes(t), t.cullFace(t.BACK), t.disable(t.CULL_FACE), this._lastCullFace = 0, t.frontFace(t.CW), this._lastFrontFaceWinding = 0, t.disable(t.STENCIL_TEST), t.disable(t.DITHER), this._usesDepthBuffer ? (t.enable(t.DEPTH_TEST), t.depthMask(true), t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST), t.depthMask(false)), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._pointBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferData(t.ARRAY_BUFFER, this._pointData.byteLength, t.DYNAMIC_DRAW), this._vertexBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this._vertexData.byteLength, t.DYNAMIC_DRAW), this._texcoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferData(t.ARRAY_BUFFER, this._texcoordData.byteLength, t.DYNAMIC_DRAW), this._colorBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._colorBuffer), t.bufferData(t.ARRAY_BUFFER, this._colorData.byteLength, t.DYNAMIC_DRAW), this._indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indexData.byteLength, t.DYNAMIC_DRAW), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, null), this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);
      const r = t.getParameter(t.ALIASED_POINT_SIZE_RANGE);
      this._minPointSize = r[0], this._maxPointSize = r[1], this._maxPointSize > 2048 && (this._maxPointSize = 2048), this._extensions = t.getSupportedExtensions();
      const i = t.getExtension("WEBGL_debug_renderer_info");
      if (i && (this._unmaskedVendor = t.getParameter(i["UNMASKED_VENDOR_WEBGL"]), this._unmaskedRenderer = t.getParameter(i["UNMASKED_RENDERER_WEBGL"])), this._parallelShaderCompileExt = t.getExtension("KHR_parallel_shader_compile"), this._version >= 2 && ("Chromium" !== C32.Platform.BrowserEngine || C32.Platform.BrowserVersionNumber >= 135) && (this._conservativeDepthExt = t.getExtension("EXT_conservative_depth")), C32.isDebug && (loseContextExtension = t.getExtension("WEBGL_lose_context")), this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? this._timerExt = t.getExtension("EXT_disjoint_timer_query") : this._timerExt = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")), this._anisotropicExt = t.getExtension("EXT_texture_filter_anisotropic"), this._anisotropicExt ? this._maxAnisotropy = t.getParameter(this._anisotropicExt["MAX_TEXTURE_MAX_ANISOTROPY_EXT"]) : this._maxAnisotropy = 0, this.GetWebGLVersionNumber() < 2 && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = t.getExtension("WEBGL_depth_texture"), !this._depthTextureExt)) throw new Error("no depth texture support");
      this.GetWebGLVersionNumber() < 2 && (this._fragDepthExt = t.getExtension("EXT_frag_depth"), this._stdDerivativesExt = t.getExtension("OES_standard_derivatives"), this._textureLodExt = t.getExtension("EXT_shader_texture_lod"));
      const s = C32.Gfx.WebGLShaderProgram, a = s.GetDefaultVertexShaderSource(false);
      let h = s.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth(), n = a, o = s.GetPointFragmentShaderSource_WebGL1_NoFragDepth(), l = s.GetPointVertexShaderSource_WebGL1(), _ = s.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth(), u = s.GetDefaultVertexShaderSource(true), d = false;
      this._usesDepthBuffer && (this.GetWebGLVersionNumber() < 2 ? this._fragDepthExt && (h = s.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(), o = s.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(), _ = s.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(), d = true) : (n = s.GetDefaultVertexShaderSource_WebGL2(), h = s.GetTextureFillFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), o = s.GetPointFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), l = s.GetPointVertexShaderSource_WebGL2(), _ = s.GetTilemapFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), u = s.GetDefaultVertexShaderSource_WebGL2(true)));
      const c = s.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), d, this._stdDerivativesExt && this._textureLodExt, this._SupportsConservativeDepth()), f = this.GetWebGLVersionNumber() >= 2 ? s.GetDefaultVertexShaderSource_WebGL2() : a, p = [[h, n, "<default>"], [h, n, "<default-device-transform>"], [o, l, "<point>"], [s.GetColorFillFragmentShaderSource(), a, "<fill>"], [s.GetLinearGradientFillFragmentShaderSource(), a, "<lineargradient>"], [s.GetPenumbraFillFragmentShaderSource(), a, "<penumbra>"], [s.GetHardEllipseFillFragmentShaderSource(), a, "<hardellipse>"], [s.GetHardEllipseOutlineFragmentShaderSource(), a, "<hardellipseoutline>"], [s.GetSmoothEllipseFillFragmentShaderSource(), a, "<smoothellipse>"], [s.GetSmoothEllipseOutlineFragmentShaderSource(), a, "<smoothellipseoutline>"], [s.GetSmoothLineFillFragmentShaderSource(), a, "<smoothline>"], [_, u, "<tilemap>"], [c, f, "<tilerandomization>"]], x = await Promise.all(p.map((t2) => this.CreateShaderProgram({ src: t2[0], vertexSrc: t2[1], name: t2[2] })));
      this._spTextureFill = x[0], this._spDeviceTransformTextureFill = x[1], this._spPoints = x[2], this._spColorFill = x[3], this._spLinearGradientFill = x[4], this._spPenumbraFill = x[5], this._spHardEllipseFill = x[6], this._spHardEllipseOutline = x[7], this._spSmoothEllipseFill = x[8], this._spSmoothEllipseOutline = x[9], this._spSmoothLineFill = x[10], this._spTilemapFill = x[11], this._spTileRandomization = x[12], this.SetTextureFillMode();
    }
    async CreateShaderProgram(t) {
      const e = await C32.Gfx.WebGLShaderProgram.Create(this, t);
      return this._AddShaderProgram(e), e;
    }
    ResetLastProgram() {
      this._lastProgram = null;
    }
    SetSize(t, e, r) {
      if (this._width === t && this._height === e && !r) return;
      this.EndBatch();
      const i = this._gl, s = this._batchState;
      this._width = t, this._height = e, this._SetViewport(0, 0, t, e), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, t / e), this.SetProjectionMatrix(this._bbProjectionMatrix), this._spDeviceTransformTextureFill && (i.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE0), this._lastTexture0 = null, this._lastTexture1 = null, this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height), this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), i.bindFramebuffer(i.FRAMEBUFFER, null), this._currentRenderTarget = null, s.currentFramebuffer = null, s.currentFramebufferNoDepth = null;
    }
    _SetDepthBufferSize(t, e) {
      const r = this._gl;
      this._depthBuffer && this._depthBufferWidth === t && this._depthBufferHeight === e || (this._canSampleDepth ? (this._depthBuffer && r.deleteTexture(this._depthBuffer), this._depthBuffer = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this._depthBuffer), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), this.GetWebGLVersionNumber() >= 2 ? r.texImage2D(r.TEXTURE_2D, 0, r.DEPTH24_STENCIL8, t, e, 0, r.DEPTH_STENCIL, r.UNSIGNED_INT_24_8, null) : this._depthTextureExt && r.texImage2D(r.TEXTURE_2D, 0, r.DEPTH_STENCIL, t, e, 0, r.DEPTH_STENCIL, this._depthTextureExt["UNSIGNED_INT_24_8_WEBGL"], null), r.bindTexture(r.TEXTURE_2D, null)) : (this._depthBuffer && r.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, this._depthBuffer), r.renderbufferStorage(r.RENDERBUFFER, this._version >= 2 ? r.DEPTH24_STENCIL8 : r.DEPTH_STENCIL, t, e), r.bindRenderbuffer(r.RENDERBUFFER, null)), this._depthBufferWidth = t, this._depthBufferHeight = e);
    }
    SetFixedSizeDepthBuffer(t, e) {
      this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = false, this._SetDepthBufferSize(t, e));
    }
    SetAutoSizeDepthBuffer() {
      this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = true, this._SetDepthBufferSize(this._width, this._height));
    }
    _SetViewport(t, e, r, i) {
      const s = this._viewport;
      if (s[0] === t && s[1] === e && s[2] === r && s[3] === i) return;
      this.PushBatch().InitSetViewport(t, e, r, i), vec4.set(s, t, e, r, i), this._topOfBatch = 0;
    }
    SetFovY(t) {
      super.SetFovY(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
    }
    SetNearZ(t) {
      super.SetNearZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
    }
    SetFarZ(t) {
      super.SetFarZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
    }
    SetProjectionMatrix(t) {
      if (mat4.exactEquals(this._matP, t)) return;
      this.PushBatch().InitSetProjection(t), mat4.copy(this._matP, t), this._topOfBatch = 0, this._didChangeTransform = true;
    }
    SetDefaultRenderTargetProjectionState() {
      let t, e, r;
      const i = this._currentRenderTarget;
      null === i ? (t = this._bbProjectionMatrix, e = this.GetWidth(), r = this.GetHeight()) : (t = i.GetProjectionMatrix(), e = i.GetWidth(), r = i.GetHeight()), this.SetProjectionMatrix(t), this._SetViewport(0, 0, e, r);
    }
    SetModelViewMatrix(t) {
      if (mat4.exactEquals(this._matMV, t)) return;
      this.PushBatch().InitSetModelView(t), mat4.copy(this._matMV, t), this._topOfBatch = 0, this._didChangeTransform = true;
    }
    ResetDidChangeTransformFlag() {
      this._didChangeTransform = false;
    }
    DidChangeTransform() {
      return this._didChangeTransform;
    }
    GetBatchState() {
      return this._batchState;
    }
    PushBatch() {
      const t = this._batch;
      return this._batchPtr === t.length && t.push(new C32.Gfx.WebGLBatchJob(this._batchState)), t[this._batchPtr++];
    }
    EndBatch() {
      0 !== this._batchPtr && (this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._batchPtr = 0, this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, this._topOfBatch = 0));
    }
    _WriteBuffers() {
      const t = this._gl;
      this._vertexPtr > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._vertexData.subarray(0, 3 * this._vertexPtr)), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, 2 * this._vertexPtr)), t.bindBuffer(t.ARRAY_BUFFER, this._colorBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._colorData.subarray(0, 4 * this._vertexPtr))), this._indexPtr > 0 && (t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, this._indexData.subarray(0, this._indexPtr))), this._pointPtr > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)));
    }
    _ExecuteBatch() {
      const t = this._batch;
      for (let e = 0, r = this._batchPtr; e < r; ++e) t[e].Run();
    }
    GetOpacity() {
      return this._lastColor.getA();
    }
    SetColorRgba(t, e, r, i) {
      const s = this._lastColor;
      s.equalsRgba(t, e, r, i) || (s.setRgba(t, e, r, i), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
    }
    SetOpacity(t) {
      const e = this._lastColor;
      e.getA() !== t && (e.setA(t), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
    }
    SetColor(t) {
      const e = this._lastColor;
      e.equals(t) || (e.set(t), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
    }
    ResetColor() {
      this.SetColorRgba(1, 1, 1, 1);
    }
    GetColor() {
      return this._lastColor;
    }
    SetTexture(t) {
      if (t === this._lastTexture0) return;
      this.PushBatch().InitSetTexture(t), this._lastTexture0 = t, this._topOfBatch = 0;
    }
    _ResetLastTexture() {
      this._lastTexture0 = null;
    }
    SetBlendMode(t) {
      this._lastBlendMode !== t && (this._lastBlendMode = t, this._SetBlend(this._GetBlendParametersByIndex(t)));
    }
    SetNamedBlendMode(t) {
      this.SetBlendMode(this.NamedBlendToNumber(t));
    }
    _SetBlend(t) {
      this.PushBatch().InitSetBlend(t), this._topOfBatch = 0, this._currentStateGroup = null;
    }
    IsPremultipliedAlphaBlend() {
      return 0 === this._lastBlendMode;
    }
    SetAlphaBlend() {
      this.SetBlendMode(0);
    }
    SetCullFaceMode(t) {
      if (this._lastCullFace === t) return;
      this.PushBatch().InitSetCullFaceMode(t), this._lastCullFace = t, this._topOfBatch = 0, this._currentStateGroup = null;
    }
    GetCullFaceMode() {
      return this._lastCullFace;
    }
    SetFrontFaceWinding(t) {
      if (this._lastFrontFaceWinding === t) return;
      this.PushBatch().InitSetFrontFaceWinding(t), this._lastFrontFaceWinding = t, this._topOfBatch = 0, this._currentStateGroup = null;
    }
    GetFrontFaceWinding() {
      return this._lastFrontFaceWinding;
    }
    SetCopyBlend() {
      this.SetBlendMode(3);
    }
    Rect(t) {
      this.Rect2(t.getLeft(), t.getTop(), t.getRight(), t.getBottom());
    }
    Rect2(t, e, r, i) {
      this.Quad2(t, e, r, e, r, i, t, i);
    }
    _AddToDrawBatch(t, e) {
      if ((this._vertexPtr + t > 65535 || this._indexPtr + e > 393210) && this.EndBatch(), 1 === this._topOfBatch) this._batch[this._batchPtr - 1]._indexCount += e;
      else {
        this.PushBatch().InitDraw(2 * this._indexPtr, e), this._topOfBatch = 1;
      }
    }
    _AddIndicesForQuad() {
      const t = this._vertexPtr;
      let e = this._indexPtr;
      this._indexPtr += 6;
      const r = this._indexData;
      r[e++] = t, r[e++] = t + 1, r[e++] = t + 2, r[e++] = t, r[e++] = t + 2, r[e] = t + 3;
    }
    Quad(t) {
      this.Quad4(t, defaultTexCoordsQuad);
    }
    Quad2(t, e, r, i, s, a, h, n) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const o = this._vertexData, l = this._vertexPtr;
      this._vertexPtr += 4;
      let _ = 3 * l;
      const u = this._baseZ + this._currentZ;
      o[_++] = t, o[_++] = e, o[_++] = u, o[_++] = r, o[_++] = i, o[_++] = u, o[_++] = s, o[_++] = a, o[_++] = u, o[_++] = h, o[_++] = n, o[_] = u, defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, 2 * l), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * l);
    }
    Quad3(t, e) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const r = this._vertexPtr;
      this._vertexPtr += 4, t.writeToTypedArray3D(this._vertexData, 3 * r, this._baseZ + this._currentZ), e.writeAsQuadToTypedArray(this._texcoordData, 2 * r), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * r);
    }
    Quad4(t, e) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const r = this._vertexPtr;
      this._vertexPtr += 4, t.writeToTypedArray3D(this._vertexData, 3 * r, this._baseZ + this._currentZ), e.writeToTypedArray(this._texcoordData, 2 * r), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * r);
    }
    Quad5(t, e, r) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const i = this._vertexPtr;
      this._vertexPtr += 4, t.writeToTypedArray3D(this._vertexData, 3 * i, this._baseZ + this._currentZ), e.writeToTypedArray(this._texcoordData, 2 * i), this._colorData.set(r, 4 * i);
    }
    Quad3D(t, e, r, i, s, a, h, n, o, l, _, u, d) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const c = this._vertexData, f = this._vertexPtr;
      this._vertexPtr += 4;
      let p = 3 * f;
      const x = this._baseZ + this._currentZ;
      c[p++] = t, c[p++] = e, c[p++] = x + r, c[p++] = i, c[p++] = s, c[p++] = x + a, c[p++] = h, c[p++] = n, c[p++] = x + o, c[p++] = l, c[p++] = _, c[p] = x + u, d.writeAsQuadToTypedArray(this._texcoordData, 2 * f), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * f);
    }
    Quad3D2(t, e, r, i, s, a, h, n, o, l, _, u, d) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const c = this._vertexData, f = this._vertexPtr;
      this._vertexPtr += 4;
      let p = 3 * f;
      const x = this._baseZ + this._currentZ;
      c[p++] = t, c[p++] = e, c[p++] = x + r, c[p++] = i, c[p++] = s, c[p++] = x + a, c[p++] = h, c[p++] = n, c[p++] = x + o, c[p++] = l, c[p++] = _, c[p] = x + u, d.writeToTypedArray(this._texcoordData, 2 * f), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * f);
    }
    Quad3D3(t, e, r, i, s, a, h, n, o, l, _, u, d, c) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const f = this._vertexData, p = this._vertexPtr;
      this._vertexPtr += 4;
      let x = 3 * p;
      const E = this._baseZ + this._currentZ;
      f[x++] = t, f[x++] = e, f[x++] = E + r, f[x++] = i, f[x++] = s, f[x++] = E + a, f[x++] = h, f[x++] = n, f[x++] = E + o, f[x++] = l, f[x++] = _, f[x] = E + u, d.writeToTypedArray(this._texcoordData, 2 * p), this._colorData.set(c, 4 * p);
    }
    DrawMesh(t, e, r, i) {
      if (t.length % 3 != 0) throw new Error("vertex buffer length not multiple of 3");
      if (t.length > 196605) throw new Error(`too many vertices (${t.length / 3}, limit 65535)`);
      if (r.length % 3 != 0) throw new Error("index buffer length not multiple of 3");
      if (r.length > 393210) throw new Error(`too many indices (${r.length}, limit 393210)`);
      this._AddToDrawBatch(t.length, r.length);
      const s = this._vertexPtr;
      this._vertexData.set(t, 3 * s), this._texcoordData.set(e, 2 * s);
      const a = this._indexData;
      if (0 === s) a.set(r, this._indexPtr);
      else {
        let t2 = this._indexPtr;
        for (let e2 = 0, i2 = r.length; e2 < i2; ++e2) a[t2++] = r[e2] + s;
      }
      const h = this._colorData;
      if (null != i) h.set(i, 4 * s);
      else {
        const e2 = this._lastColor, r2 = e2.getR(), i2 = e2.getG(), a2 = e2.getB(), n = e2.getA();
        let o = 4 * s;
        for (let e3 = 0, s2 = t.length; e3 < s2; ++e3) h[o++] = r2, h[o++] = i2, h[o++] = a2, h[o++] = n;
      }
      this._vertexPtr += t.length / 3, this._indexPtr += r.length;
    }
    FullscreenQuad(t, e) {
      this.SetCurrentZ(0), mat4.copy(tmpProjection, this._matP), mat4.copy(tmpModelView, this._matMV), this.SetDefaultRenderTargetProjectionState();
      const [r, i] = this.GetRenderTargetSize(this._currentRenderTarget), s = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(i), 0, 0, 0, i);
      if (this.SetModelViewMatrix(s), "crop" === t && this._currentRenderTarget && e) {
        const t2 = this._width / 2, r2 = this._height / 2, i2 = e.GetWidth(), s2 = e.GetHeight(), a = this._currentRenderTarget.GetWidth(), h = this._currentRenderTarget.GetHeight(), n = Math.min(a, i2), o = Math.min(h, s2), l = Math.max(s2 - h, 0), _ = Math.max(h - s2, 0);
        tmpRect.set(-t2, r2 - _, -t2 + n, r2 - o - _), tmpQuad.setFromRect(tmpRect), tmpRect.set(0, l, n, o + l), tmpRect.divide(i2, s2), this.Quad3(tmpQuad, tmpRect);
      } else {
        const t2 = r / 2, e2 = i / 2;
        this.Rect2(-t2, e2, t2, -e2);
      }
      this.SetProjectionMatrix(tmpProjection), this.SetModelViewMatrix(tmpModelView);
    }
    StartRenderingPoints(t) {
      if (this._lastPointTexCoords.equals(t)) return;
      this._lastPointTexCoords.copy(t);
      this.PushBatch().InitSetPointTexCoords(t), this._topOfBatch = 0;
    }
    FinishRenderingPoints() {
    }
    Point(t, e, r, i) {
      this._pointPtr >= 7996 && this.EndBatch();
      let s = this._pointPtr;
      const a = this._baseZ + this._currentZ;
      if (2 === this._topOfBatch && this._lastPointZ === a) this._batch[this._batchPtr - 1]._indexCount++;
      else {
        this.PushBatch().InitPoints(s, a, this._lastColor), this._topOfBatch = 2, this._lastPointZ = a;
      }
      const h = this._pointData;
      h[s++] = t, h[s++] = e, h[s++] = r, h[s++] = i, this._pointPtr = s;
    }
    SetProgram(t) {
      if (this._lastProgram === t) return;
      this.PushBatch().InitSetProgram(t), this._lastProgram = t, this._topOfBatch = 0, this._currentStateGroup = null;
    }
    GetProgram() {
      return this._lastProgram;
    }
    SetDeviceTransformTextureFillMode() {
      this.SetProgram(this._spDeviceTransformTextureFill);
    }
    SetGradientColor(t) {
      this.PushBatch().InitSetGradientColor(t), this._topOfBatch = 0;
    }
    SetEllipseParams(t, e, r = 1) {
      this.PushBatch().InitSetEllipseParams(t, e, r), this._topOfBatch = 0;
    }
    SetTilemapInfo(t, e, r, i, s, a, h) {
      if (this._lastProgram !== this._spTilemapFill) throw new Error("must set tilemap fill mode first");
      this.PushBatch().InitSetTilemapInfo(t, e, r, i, s, a, h), this._topOfBatch = 0;
    }
    SetTileRandomizationInfo(t, e, r, i, s, a, h) {
      if (this._lastProgram !== this._spTileRandomization) throw new Error("must set tile randomization mode first");
      this.PushBatch().InitSetTileRandomizationInfo(t, e, r, i, s, a, h), this._topOfBatch = 0;
    }
    SetProgramParameters(t, e, r, i, s, a, h, n, o, l, _) {
      const u = this._lastProgram;
      if (_ %= 10800, !u._hasAnyOptionalUniforms || u.AreOptionalUniformsAlreadySetInBatch(e, r, i, s, a, h, n, o, l, _)) return;
      const d = this.PushBatch();
      d.InitSetProgramParameters(), u.SetOptionalUniformsInBatch(e, r, i, s, a, h, n, o, l, _);
      const c = d._mat4param;
      c[0] = a, c[1] = h, e.writeToTypedArray(c, 2), c[6] = o, c[7] = l, r.writeToTypedArray(c, 12);
      const f = d._colorParam;
      s.writeToTypedArray(f, 0);
      const p = f[1];
      f[1] = f[3], f[3] = p, i.writeToTypedArray(d._srcOriginRect, 0), d._startIndex = _, d._indexCount = n, u._uSamplerBack.IsUsed() ? d._texParam = t ? t.GetTexture() : null : d._texParam = null, this._topOfBatch = 0;
    }
    SetProgramCustomParameters(t) {
      const e = this._lastProgram;
      if (0 === t.length || e.AreCustomParametersAlreadySetInBatch(t)) return;
      const r = this.PushBatch();
      r.InitSetProgramCustomParameters(), e.SetCustomParametersInBatch(t), C32.shallowAssignArray(r._shaderParams, t), this._topOfBatch = 0;
    }
    ClearRgba(t, e, r, i) {
      this.PushBatch().InitClearSurface2(t, e, r, i), this._topOfBatch = 0;
    }
    Clear(t) {
      this.PushBatch().InitClearSurface(t), this._topOfBatch = 0;
    }
    Start() {
    }
    Finish() {
      super.Finish(), this._gl.flush();
    }
    ClearDepth() {
      if (!this._usesDepthBuffer || !this._currentRenderTarget || !this._currentRenderTarget.HasDepthBuffer()) return;
      this.PushBatch().InitClearDepth(this._isDepthEnabled), this._topOfBatch = 0;
    }
    SetDepthEnabled(t) {
      if (t = !!t, this._isDepthEnabled === t) return;
      if (!this._usesDepthBuffer) return;
      this._isDepthEnabled = t;
      this.PushBatch().InitSetDepthEnabled(t), this._topOfBatch = 0;
    }
    IsDepthEnabled() {
      return this._isDepthEnabled;
    }
    _GetDepthBuffer() {
      return this._depthBuffer;
    }
    _CanSampleDepth() {
      return this._canSampleDepth;
    }
    SetDepthSamplingEnabled(t) {
      if (t = !!t, !this._canSampleDepth) return;
      if (this._isDepthSamplingEnabled === t) return;
      if (t && this.IsDepthEnabled()) throw new Error("depth still enabled");
      this._isDepthSamplingEnabled = t;
      this.PushBatch().InitSetDepthSamplingEnabled(t), this._topOfBatch = 0;
    }
    SetScissorRect(t, e, r, i, s = 0) {
      if (t = Math.floor(t), e = Math.floor(e), r = Math.floor(r), i = Math.floor(i), this._lastScissorRect.equalsWH(t, e, r, i)) return;
      this._lastScissorRect.setWH(t, e, r, i);
      e = (s || this.GetRenderTargetSize(this.GetRenderTarget())[1]) - e - i;
      this.PushBatch().InitSetScissor(true, t, e, r, i), this._topOfBatch = 0;
    }
    RemoveScissorRect() {
      if (-1 === this._lastScissorRect.getRight()) return;
      this._lastScissorRect.set(0, 0, -1, -1);
      this.PushBatch().InitSetScissor(false, 0, 0, 0, 0), this._topOfBatch = 0;
    }
    CheckForQueryResults() {
      for (const t of this._allQueryResultBuffers) t.CheckForResults(this._frameNumber);
    }
    IsContextLost() {
      return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored;
    }
    OnContextLost() {
      super.OnDeviceOrContextLost(), C32.Gfx.WebGLRendererTexture.OnContextLost(), C32.Gfx.WebGLRenderTarget.OnContextLost(), C32.Gfx.RendererText.OnContextLost();
      for (const t of this._allQueryResultBuffers) t.Clear();
      this._extensions = [], this._timerExt = null, this._parallelShaderCompileExt = null, this._conservativeDepthExt = null, this._anisotropicExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._depthBuffer = null;
      for (const t of this._stateGroups.values()) t.OnContextLost();
    }
    async OnContextRestored() {
      this._isInitialisingAfterContextRestored = true, await this.InitState(), this._isInitialisingAfterContextRestored = false;
      for (const t of this._stateGroups.values()) t.OnContextRestored(this);
      this.SetSize(this._width, this._height, true);
    }
    CreateStaticTexture(t, e) {
      if (this.IsContextLost()) throw new Error("context lost");
      this.EndBatch();
      const r = C32.New(C32.Gfx.WebGLRendererTexture, this);
      return r._CreateStatic(t, e), r;
    }
    async CreateStaticTextureAsync(t, e) {
      if (this.IsContextLost()) throw new Error("context lost");
      if (e = Object.assign({}, e), C32.Supports.ImageBitmapOptions) {
        let r = await createImageBitmap(t, { "premultiplyAlpha": "premultiply" });
        const i = e.wrapX && "clamp-to-edge" !== e.wrapX || e.wrapY && "clamp-to-edge" !== e.wrapY, s = C32.isPOT(r.width) && C32.isPOT(r.height);
        return this.SupportsNPOTTextures() || s || !i ? e.premultiplyAlpha = false : C32.Supports.ImageBitmapOptionsResize ? (r = await createImageBitmap(t, { "premultiplyAlpha": "premultiply", "resizeWidth": C32.nextHighestPowerOfTwo(r.width), "resizeHeight": C32.nextHighestPowerOfTwo(r.height) }), e.premultiplyAlpha = false) : r = await createImageBitmap(t, { "premultiplyAlpha": "none" }), await C32.Asyncify(() => this.CreateStaticTexture(r, e));
      }
      if (t instanceof Blob) {
        if ("undefined" == typeof Image) throw new Error("texture upload variant not supported in worker");
        const e2 = await C32.BlobToImage(t);
        t = e2;
      }
      return await C32.Asyncify(() => this.CreateStaticTexture(t, e));
    }
    CreateDynamicTexture(t, e, r) {
      this.EndBatch();
      const i = C32.New(C32.Gfx.WebGLRendererTexture, this);
      return i._CreateDynamic(t, e, r), i;
    }
    UpdateTexture(t, e, r) {
      this.EndBatch(), e._Update(t, r);
    }
    DeleteTexture(t) {
      t && (t.SubtractReference(), t.GetReferenceCount() > 0 || (this.EndBatch(), t === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), t === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete()));
    }
    CreateRenderTarget(t) {
      let e = this._width, r = this._height, i = true;
      if (t && ("number" == typeof t.width && (e = Math.floor(t.width), i = false), "number" == typeof t.height && (r = Math.floor(t.height), i = false)), e <= 0 || r <= 0) throw new Error("invalid size");
      this.EndBatch();
      const s = C32.New(C32.Gfx.WebGLRenderTarget, this);
      return s._Create(e, r, Object.assign({ isDefaultSize: i }, t)), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, s;
    }
    SetRenderTarget(t, e = true) {
      if (t === this._currentRenderTarget) return;
      t && t.IsDefaultSize() && t._Resize(this._width, this._height);
      this.PushBatch().InitSetRenderTarget(t), this._currentRenderTarget = t, this._topOfBatch = 0, e && this.SetDefaultRenderTargetProjectionState();
    }
    GetRenderTarget() {
      return this._currentRenderTarget;
    }
    GetRenderTargetSize(t) {
      return t ? [t.GetWidth(), t.GetHeight()] : [this._width, this._height];
    }
    CopyRenderTarget(t, e = "stretch") {
      if (this._version < 2 || this._currentRenderTarget && this._currentRenderTarget.GetMultisampling() > 0) this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(t, e);
      else {
        this.PushBatch().InitBlitFramebuffer(t, this._currentRenderTarget, e), this._topOfBatch = 0;
      }
    }
    DrawRenderTarget(t, e = "stretch") {
      const r = t.GetTexture();
      if (!r) throw new Error("not a texture-backed render target");
      this.SetTexture(r), this.FullscreenQuad(e, r);
    }
    InvalidateRenderTarget(t) {
      if (this._version < 2) return;
      this.PushBatch().InitInvalidateFramebuffer(t._GetFramebuffer()), this._topOfBatch = 0;
    }
    DeleteRenderTarget(t) {
      this.SetRenderTarget(null), this.EndBatch();
      const e = t.GetTexture();
      e === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), e === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete();
    }
    async ReadBackRenderTargetToImageData(t, e, r) {
      this.EndBatch();
      const i = this._currentRenderTarget;
      let s, a, h;
      t ? (s = t.GetWidth(), a = t.GetHeight(), h = t._GetFramebuffer()) : (s = this.GetWidth(), a = this.GetHeight(), h = null);
      let n = 0, o = 0, l = s, _ = a;
      if (r) {
        n = C32.clamp(Math.floor(r.getLeft()), 0, s - 1), o = C32.clamp(Math.floor(r.getTop()), 0, a - 1);
        let t2 = r.width();
        t2 = 0 === t2 ? s - n : C32.clamp(Math.floor(t2), 0, s - n);
        let e2 = r.height();
        e2 = 0 === e2 ? a - o : C32.clamp(Math.floor(e2), 0, a - o), l = t2, _ = e2, o = a - (o + _);
      }
      const u = this._gl;
      u.bindFramebuffer(u.FRAMEBUFFER, h);
      const d = () => {
        u.bindFramebuffer(u.FRAMEBUFFER, null), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, this.SetRenderTarget(i);
      };
      let c;
      if (!e && this.GetWebGLVersionNumber() >= 2) {
        u.bindFramebuffer(u.READ_FRAMEBUFFER, h);
        const t2 = u.createBuffer(), e2 = l * _ * 4, r2 = u["PIXEL_PACK_BUFFER"];
        u.bindBuffer(r2, t2), u.bufferData(r2, e2, u["STREAM_READ"]), u.readPixels(n, o, l, _, u.RGBA, u.UNSIGNED_BYTE, 0), u.bindFramebuffer(u.READ_FRAMEBUFFER, null), u.bindBuffer(r2, null), d();
        const i2 = u["fenceSync"](u["SYNC_GPU_COMMANDS_COMPLETE"], 0);
        await this._WaitForObjectReady(() => u["getSyncParameter"](i2, u["SYNC_STATUS"]) === u["SIGNALED"]), u["deleteSync"](i2), c = new ImageData(l, _), u.bindBuffer(r2, t2), u["getBufferSubData"](r2, 0, new Uint8Array(c.data.buffer), 0, e2), u.bindBuffer(r2, null), u.deleteBuffer(t2);
      } else c = new ImageData(l, _), u.readPixels(n, o, l, _, u.RGBA, u.UNSIGNED_BYTE, new Uint8Array(c.data.buffer)), d();
      return c;
    }
    CoplanarStartStencilPass() {
      this.SetDepthEnabled(true);
      this.PushBatch().InitCoplanarStartStencilPass(), this._topOfBatch = 0, this._coplanarMode = 1;
    }
    CoplanarStartColorPass(t = false) {
      this.SetDepthEnabled(t);
      this.PushBatch().InitCoplanarStartColorPass(), this._topOfBatch = 0, this._coplanarMode = 2;
    }
    IsCoplanarColorPass() {
      return 2 === this._coplanarMode;
    }
    CoplanarRestoreStandardRendering(t = true) {
      this.SetDepthEnabled(t);
      this.PushBatch().InitCoplanarRestore(), this._topOfBatch = 0, this._coplanarMode = 0;
    }
    StartQuery(t) {
      if (!this.SupportsGPUProfiling()) return;
      this.PushBatch().InitStartQuery(t), this._topOfBatch = 0;
    }
    EndQuery(t) {
      if (!this.SupportsGPUProfiling()) return;
      this.PushBatch().InitEndQuery(t), this._topOfBatch = 0;
    }
    _WaitForObjectReady(t) {
      const e = new Promise((e2) => pendingPolls.add({ resolve: e2, checkFunc: t }));
      return -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls)), e;
    }
    GetEstimatedBackBufferMemoryUsage() {
      return this._width * this._height * (this._attribs["alpha"] ? 4 : 3);
    }
    GetEstimatedRenderBufferMemoryUsage() {
      let t = 0;
      for (const e of C32.Gfx.WebGLRenderTarget.allRenderTargets()) e.GetTexture() || (t += e.GetEstimatedMemoryUsage());
      return t;
    }
    GetEstimatedTextureMemoryUsage() {
      let t = 0;
      for (const e of C32.Gfx.WebGLRendererTexture.allTextures()) t += e.GetEstimatedMemoryUsage();
      return t;
    }
    GetWebGLVersionString() {
      return this._versionString;
    }
    GetWebGLVersionNumber() {
      return this._version;
    }
    IsColorDataF16() {
      return this._isColorDataF16;
    }
    GetDisplayName() {
      return "webgl" + this.GetWebGLVersionNumber();
    }
    SupportsNPOTTextures() {
      return this.GetWebGLVersionNumber() >= 2;
    }
    GetMaxTextureSize() {
      return this._maxTextureSize;
    }
    GetMinPointSize() {
      return this._minPointSize;
    }
    GetMaxPointSize() {
      return this._maxPointSize;
    }
    GetUnmaskedVendor() {
      return this._unmaskedVendor;
    }
    GetUnmaskedRenderer() {
      return this._unmaskedRenderer;
    }
    GetWebGLExtensionsAnalyticsString() {
      if (this.GetWebGLVersionNumber() >= 2) return "webgl2";
      {
        const t = [];
        return this._fragDepthExt && t.push("EXT_frag_depth"), this._stdDerivativesExt && t.push("OES_standard_derivatives"), this._textureLodExt && t.push("EXT_shader_texture_lod"), t.length > 0 ? "webgl1:" + t.join(",") : "webgl1:none";
      }
    }
    GetExtensions() {
      return this._extensions;
    }
    SupportsGPUProfiling() {
      return !!this._timerExt;
    }
    _GetDisjointTimerQueryExtension() {
      return this._timerExt;
    }
    _GetParallelShaderCompileExtension() {
      return this._parallelShaderCompileExt;
    }
    _SupportsConservativeDepth() {
      return !!this._conservativeDepthExt;
    }
    _GetAnisotropicExtension() {
      return this._anisotropicExt;
    }
    _GetMaxAnisotropy() {
      return this._maxAnisotropy;
    }
    _AddQueryResultBuffer(t) {
      this._allQueryResultBuffers.add(t);
    }
    _RemoveQueryResultBuffer(t) {
      this._allQueryResultBuffers.delete(t);
    }
    _GetTimeQueryStack() {
      return this._timeQueryStack;
    }
    GetContext() {
      return this._gl;
    }
    _InitBlendModes(t) {
      let e = t.FUNC_ADD, r = t.FUNC_ADD;
      this._version >= 2 ? (e = t.MAX, r = t.MIN) : this._blendMinMaxExt && (e = this._blendMinMaxExt["MAX_EXT"], r = this._blendMinMaxExt["MIN_EXT"]), this._InitBlendModeData([["normal", [t.ONE, t.ONE_MINUS_SRC_ALPHA]], ["additive", [t.ONE, t.ONE]], ["xor", [t.ONE, t.ONE_MINUS_SRC_ALPHA]], ["copy", [t.ONE, t.ZERO]], ["destination-over", [t.ONE_MINUS_DST_ALPHA, t.ONE]], ["source-in", [t.DST_ALPHA, t.ZERO]], ["destination-in", [t.ZERO, t.SRC_ALPHA]], ["source-out", [t.ONE_MINUS_DST_ALPHA, t.ZERO]], ["destination-out", [t.ZERO, t.ONE_MINUS_SRC_ALPHA]], ["source-atop", [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]], ["destination-atop", [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]], ["lighten", [t.ONE, t.ONE, t.ONE, t.ONE, e, e]], ["darken", [t.ONE, t.ONE, t.ONE, t.ONE, r, r]], ["multiply", [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA]], ["screen", [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA]]]);
    }
    CreateWebGLText() {
      return this.CreateRendererText();
    }
  };
}
var CheckPendingPolls2;
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, assert = self.assert, GPUBufferUsage = self["GPUBufferUsage"], GPUShaderStage = self["GPUShaderStage"], GPUMapMode = self["GPUMapMode"], GPUTextureUsage = self["GPUTextureUsage"], DEFAULT_WEBGPURENDERER_OPTS = { powerPreference: "default", depth: false, failIfMajorPerformanceCaveat: false, canSampleBackbuffer: false, backTextureSampling: "bilinear", usesBackgroundBlending: false, canSampleDepth: false, isMultiTexturingAllowed: true }, MAX_VERTICES = 65535, MAX_INDICES = 393210, MAX_POINTS = Math.floor(65535 / 4), MAX_COLORS = 65535, LAST_POINT_PTR = 4 * MAX_POINTS - 16, FLAG_IN_DRAW = 1, FLAG_DRAWING_POINTS = 2, FLAG_SCISSOR_ENABLED = 4, FLAG_SCISSOR_CHANGED = 8, FLAG_DRAW_STATE_CHANGED = 16, FLAG_PIPELINE_CHANGED = 32, FLAG_TEX_BINDGROUP_CHANGED = 64, FLAG_BACKTEX_BINDGROUP_CHANGED = 128, FLAG_DEPTHTEX_BINDGROUP_CHANGED = 256, FLAG_TRANSFORM_CHANGED = 512, FLAG_VERTEX_UNIFORM_CHANGED = 1024, FLAG_FRAG_UNIFORM_CHANGED = 2048, FLAG_FRAG_C3PARAMS_CHANGED = 4096, FLAG_BUFFER_BINDGROUP_CHANGED = 8192, FLAG_DID_ADD_COMMAND = 16384, FLAG_CONTEXT_LOST = 32768, FLAG_MULTITEXTURE_ALLOWED = 65536, FLAG_MULTITEXTURE_ENABLED = 1 << 17, FLAG_MULTITEXTURE_ACTIVE = 1 << 18, FLAG_USE_DEPTH_BUFFER = 1 << 19, FLAG_DEPTH_ENABLED = 1 << 20, FLAG_RENDERTARGET_HAS_DEPTH = 1 << 21, FLAG_CLEAR_DEPTH = 1 << 22, FLAG_COPLANAR_STENCIL_PASS = 1 << 23, FLAG_COPLANAR_COLOR_PASS = 1 << 24, FLAG_CLEAR_STENCIL = 1 << 25, FLAG_AUTOSIZE_DEPTH_BUFFER = 1 << 26, FLAG_SUPPORTS_TIMESTAMP_QUERY = 1 << 27, FLAG_SUPPORTS_F16 = 1 << 28, FLAG_COLOR_DATA_F16 = 1 << 29, FLAG_USE_NORMALIZED_COORDS = 1 << 30, FLAG_DID_CHANGE_TRANSFORM = 1, CHANGED_FLAGS_MASK = 8688, END_DRAW_FLAGS_MASK = 8697, NEW_RENDERPASS_FLAGS = 25072, CHANGED_UNIFORM_BUFFER_MASK = 7680, SIZEOF_U16 = 2, SIZEOF_U32 = 4, SIZEOF_F16 = 2, SIZEOF_F32 = 4, defaultTexCoordsQuad = new C32.Quad(0, 0, 1, 0, 1, 1, 0, 1), tempVec2 = C32.New(C32.Vector2), tempRect = C32.New(C32.Rect), tempRect2 = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);
  C32.Gfx.WebGPURenderer = class extends C32.Gfx.RendererBase {
    constructor(e) {
      super(e), this._adapterOpts = null, this._adapter = null, this._adapterInfo = null, this._device = null, this._canvas = null, this._presentCtx = null, this._swapChainFormat = "", this._swapChainTexture = null, this._swapChainTexView = null, this._viewportWidth = 0, this._viewportHeight = 0, this._matTransform = mat4.create(), this._depthBuffer = null, this._nullDepthBuffer = null, this._depthBufferView = null, this._nullDepthBufferView = null, this._depthBufferBindGroup = null, this._nullDepthBufferBindGroup = null, this._depthBufferWidth = 0, this._depthBufferHeight = 0, this._vertexUniformBuffer = null, this._fragmentUniformBuffer = null, this._fragmentC3ParamsBuffer = null, this._fragmentDefaultCustomParamsBuffer = null, this._vertexBuffer = null, this._texcoordBuffer = null, this._texIndexBuffer = null, this._colorBuffer = null, this._indexBuffer = null, this._pointsIndexBuffer = null, this._pointBuffer = null, this._vertexUniformBufferLayout = C32.Gfx.WebGPUShaderProgram.GetVertexUniformBufferLayout(), this._vertexUniformBufferSize = C32.Gfx.WebGPUShaderProgram.GetVertexUniformBufferSize(), this._vertexUniformArrayBuffer = null, this._vertexUniformf32 = null, this._fragUniformBufferLayout = C32.Gfx.WebGPUShaderProgram.GetFragmentUniformBufferLayout(), this._fragUniformBufferSize = C32.Gfx.WebGPUShaderProgram.GetFragmentUniformBufferSize(), this._fragUniformArrayBuffer = null, this._fragUniformf32 = null, this._fragC3ParamsLayout = C32.Gfx.WebGPUShaderProgram.GetFragmentC3ParamsBufferLayout(), this._fragC3ParamsSize = C32.Gfx.WebGPUShaderProgram.GetFragmentC3ParamsBufferSize(), this._fragC3ParamsArrayBuffer = null, this._fragC3Paramsf32 = null, this._fragC3Paramsu32 = null, this._vertexData = new Float32Array(196605), this._texcoordData = new Float32Array(131070), this._texIndexData = new Uint32Array(65535), this._colorData = null, this._indexData = new Uint16Array(393210), this._pointData = new Float32Array(4 * MAX_POINTS), this._vertexPtr = 0, this._indexPtr = 0, this._currentMultiTextureIndex = 0, this._currentColor = C32.New(C32.Color, 1, 1, 1, 1), this._pointPtr = 0, this._bufferManager = C32.New(C32.Gfx.WebGPUBufferManager, this), this._flags = 32768, this._flags2 = 0, this._drawFirstIndex = 0, this._drawIndexCount = 0, this._vertexUniformUpdateStart = 0, this._vertexUniformUpdateEnd = 0, this._fragUniformUpdateStart = 0, this._fragUniformUpdateEnd = 0, this._fragC3ParamsUpdateStart = 0, this._fragC3ParamsUpdateEnd = 0, this._scissorRect = C32.New(C32.Rect, 0, 0, 0, 0), this._currentColor2 = C32.New(C32.Color, 1, 1, 1, 1), this._currentPointColor = C32.New(C32.Color, 1, 1, 1, 1), this._currentPointTexCoords = C32.New(C32.Rect, 0, 0, 0, 0), this._currentVertexZElevation = 0, this._textureFormat = "", this._bufferBindGroupLayout = null, this._defaultBufferBindGroup = null, this._textureBindGroupLayout = null, this._backTextureBindGroupLayout = null, this._depthTextureBindGroupLayout = null, this._nullTexture = null, this._currentTexture = null, this._currentTextureBindGroup = null, this._currentBackTexture = null, this._currentBackTextureBindGroup = null, this._currentDepthTextureBindGroup = null, this._currentBufferBindGroup = null, this._mipmapGeneratorPipeline = null, this._availableMultiTextures = /* @__PURE__ */ new Set(), this._nonFullMultiTexGroups = /* @__PURE__ */ new Set(), this._maxTextureSize = 8192, this._pipelineLayout = null, this._defaultVertexModule = null, this._normVertexModule = null, this._currentProgram = null, this._currentBlendMode = 0, this._currentMultisampleCount = 0, this._currentCullFace = 0, this._currentFrontFaceWinding = 0, this._mipmapGeneratorProgram = null, this._spSingleTextureFill = null, this._samplerMap = /* @__PURE__ */ new Map(), this._commandEncoder = null, this._currentRenderPass = null, this._commandBuffers = [], this._backbufferRenderTarget = null, this._currentRenderTarget = null, this._canSampleBackbuffer = false, this._backTextureSampling = "bilinear", this._usesBackgroundBlending = false, this._canSampleDepth = false, this._frameTimeQuerySet = null, this._timestampIsMeasuring = false, this._timestampStartIndex = -1, this._timestampEndIndex = -1, this._timestampStartedIndices = /* @__PURE__ */ new Set(), this.ondevicelost = null, this.ondevicerestored = null, this._InitBlendModes();
    }
    IsWebGPU() {
      return true;
    }
    _SetFlag(e, t) {
      t ? this._flags |= e : this._flags &= ~e;
    }
    _IsFlagSet(e) {
      return 0 !== (this._flags & e);
    }
    _SetFlag2(e, t) {
      t ? this._flags2 |= e : this._flags2 &= ~e;
    }
    _IsFlagSet2(e) {
      return 0 !== (this._flags2 & e);
    }
    async Create(e, t) {
      if (t = Object.assign({}, DEFAULT_WEBGPURENDERER_OPTS, t), !navigator["gpu"]) throw new Error("renderer-unavailable (WebGPU not supported)");
      t.depth && (this._flags |= 524288), t.isMultiTexturingAllowed && (this._flags |= 65536), this._canSampleBackbuffer = !!t.canSampleBackbuffer, this._backTextureSampling = t.backTextureSampling, this._usesBackgroundBlending = !!t.usesBackgroundBlending, this._adapterOpts = {}, this._canSampleDepth = !(!t.depth || !t.canSampleDepth), "default" !== t.powerPreference && (this._adapterOpts["powerPreference"] = t.powerPreference), this._canvas = e, await this._InitDevice(t.failIfMajorPerformanceCaveat);
    }
    async _InitDevice(e) {
      for (this._device = null, await this._TryGetDeviceOnCurrentAdapter(e); !this._device; ) this._adapter = null, await this._TryGetDeviceOnCurrentAdapter(e);
      await this.InitState();
    }
    async _TryGetDeviceOnCurrentAdapter(e) {
      if (!this._adapter) {
        if (this._adapter = await navigator["gpu"]["requestAdapter"](this._adapterOpts), !this._adapter) throw new Error("renderer-unavailable (no WebGPU adapter available)");
        const t2 = this._adapter["info"];
        if (e && t2["isFallbackAdapter"]) throw new Error("renderer-unavailable (WebGPU provided fallback adapter)");
        if ("adreno-7xx" === t2["architecture"]) throw new Error("WebGPU disabled on adreno-7xx devices - see https://issues.chromium.org/issues/329702056");
        if ("intel" === t2["vendor"] && ("gen-7" === t2["architecture"] || "gen7" === t2["architecture"])) throw new Error("WebGPU disabled on Intel Gen7 GPUs - see https://issues.chromium.org/issues/462468373");
      }
      const t = [];
      if (this._adapter["features"].has("timestamp-query") && t.push("timestamp-query"), this._adapter["features"].has("shader-f16") && t.push("shader-f16"), this._device = await this._adapter["requestDevice"]({ "requiredFeatures": t, "requiredLimits": { "maxTextureDimension2D": this._adapter["limits"]["maxTextureDimension2D"] } }), !this._device) return null;
      this._maxTextureSize = this._device["limits"]["maxTextureDimension2D"], this._SetFlag(134217728, this._device["features"].has("timestamp-query")), this._SetFlag(268435456, this._device["features"].has("shader-f16")), this._SetFlag(536870912, this._IsFlagSet(268435456) && void 0 !== globalThis["Float16Array"]), this._device["lost"].then((e2) => this._OnDeviceLost(e2)), this._SetFlag(32768, false);
    }
    async _OnDeviceLost(e) {
      console.log("[WebGPU] Device lost: ", e), super.OnDeviceOrContextLost(), this._bufferManager.OnContextLost(), C32.Gfx.WebGPURendererTexture.OnContextLost(), C32.Gfx.WebGPURenderTarget.OnContextLost(), C32.Gfx.RendererText.OnContextLost(), this._swapChainFormat = "", this._swapChainTexture = null, this._swapChainTexView = null, this._depthBuffer = null, this._depthBufferView = null, this._nullDepthBuffer = null, this._nullDepthBufferView = null, this._depthBufferBindGroup = null, this._nullDepthBufferBindGroup = null, this._vertexBuffer = null, this._texcoordBuffer = null, this._texIndexBuffer = null, this._colorBuffer = null, this._indexBuffer = null, this._pointsIndexBuffer = null, this._pointBuffer = null, this._vertexUniformBuffer = null, this._fragmentUniformBuffer = null, this._fragmentC3ParamsBuffer = null, this._fragmentDefaultCustomParamsBuffer = null, this._defaultBufferBindGroup = null, this._bufferBindGroupLayout = null, this._currentBufferBindGroup = null, this._textureBindGroupLayout = null, this._backTextureBindGroupLayout = null, this._depthTextureBindGroupLayout = null, this._pipelineLayout = null, this._currentProgram = null, this._nullTexture = null, this._currentTexture = null, this._currentTextureBindGroup = null, this._currentBackTexture = null, this._currentBackTextureBindGroup = null, this._currentDepthTextureBindGroup = null, this._defaultVertexModule = null, this._normVertexModule = null, this._backbufferRenderTarget = null, this._currentRenderTarget = null, this._mipmapGeneratorPipeline = null, this._frameTimeQuerySet = null, this._mipmapGeneratorProgram = null, this._spSingleTextureFill = null, this._availableMultiTextures.clear(), this._nonFullMultiTexGroups.clear(), this._samplerMap.clear();
      for (const e2 of this._stateGroups.values()) e2.OnContextLost();
      this._device = null, this._adapter = null, this._adapterInfo = null, this._flags |= 32768, this.ondevicelost && this.ondevicelost(), await this._InitDevice();
      for (const e2 of this._stateGroups.values()) e2.OnContextRestored(this);
      this.SetSize(this._width, this._height, true), this.ondevicerestored && this.ondevicerestored();
    }
    async InitState() {
      super.InitState();
      const e = this._device;
      this._swapChainFormat = navigator["gpu"]["getPreferredCanvasFormat"](), this._swapChainTexture = null, this._swapChainTexView = null;
      let t = GPUTextureUsage["RENDER_ATTACHMENT"];
      this._canSampleBackbuffer && (t |= GPUTextureUsage["TEXTURE_BINDING"]), this._usesBackgroundBlending && (t |= GPUTextureUsage["COPY_SRC"]), this._swapChainFormat.startsWith("rgba8") || this._swapChainFormat.startsWith("bgra8") ? this._textureFormat = this._swapChainFormat : this._textureFormat = "rgba8unorm", this._flags &= 940113920, this._flags |= 7680, this._flags2 = 0, this._IsFlagSet(524288) && (this._flags |= 70254592), this._vertexPtr = 0, this._indexPtr = 0, this._currentBlendMode = 0, this._currentCullFace = 0, this._currentFrontFaceWinding = 0, this._currentMultisampleCount = 0, this._currentColor.setRgba(1, 1, 1, 1), this._currentColor2.setRgba(1, 1, 1, 1), this._currentPointColor.setRgba(1, 1, 1, 1), this._colorData = this.IsColorDataF16() ? new globalThis["Float16Array"](262140) : new Float32Array(262140), this._vertexUniformArrayBuffer = new ArrayBuffer(this._vertexUniformBufferSize), this._vertexUniformf32 = new Float32Array(this._vertexUniformArrayBuffer), this._fragUniformArrayBuffer = new ArrayBuffer(this._fragUniformBufferSize), this._fragUniformf32 = new Float32Array(this._fragUniformArrayBuffer), this._fragC3ParamsArrayBuffer = new ArrayBuffer(this._fragC3ParamsSize), this._fragC3Paramsf32 = new Float32Array(this._fragC3ParamsArrayBuffer), this._fragC3Paramsu32 = new Uint32Array(this._fragC3ParamsArrayBuffer), this._vertexBuffer = e["createBuffer"]({ "label": "vertexbuffer", "size": this._vertexData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["COPY_DST"] }), this._texcoordBuffer = e["createBuffer"]({ "label": "texcoordbuffer", "size": this._texcoordData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["COPY_DST"] }), this._texIndexBuffer = e["createBuffer"]({ "label": "texindexbuffer", "size": this._texIndexData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["COPY_DST"] }), this._colorBuffer = e["createBuffer"]({ "label": "colorbuffer", "size": this._colorData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["COPY_DST"] }), this._indexBuffer = e["createBuffer"]({ "label": "indexbuffer", "size": this._indexData.byteLength, "usage": GPUBufferUsage["INDEX"] | GPUBufferUsage["COPY_DST"] }), this._pointsIndexBuffer = e["createBuffer"]({ "label": "pointsindexbuffer", "size": 6 * MAX_POINTS * 2, "usage": GPUBufferUsage["INDEX"], "mappedAtCreation": true });
      const r = this._pointsIndexBuffer["getMappedRange"]();
      this._FillPointsIndexBuffer(r), this._pointsIndexBuffer["unmap"](), this._pointBuffer = e["createBuffer"]({ "label": "pointbuffer", "size": this._pointData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["STORAGE"] | GPUBufferUsage["COPY_DST"] }), this._bufferBindGroupLayout = e["createBindGroupLayout"]({ "label": "bufferbindgrouplayout", "entries": [{ "binding": 0, "visibility": GPUShaderStage["VERTEX"], "buffer": { "type": "uniform", "minBindingSize": this._vertexUniformBufferSize } }, { "binding": 1, "visibility": GPUShaderStage["FRAGMENT"], "buffer": { "type": "uniform", "minBindingSize": this._fragUniformBufferSize } }, { "binding": 3, "visibility": GPUShaderStage["VERTEX"], "buffer": { "type": "read-only-storage", "minBindingSize": this._pointData.byteLength } }, { "binding": 4, "visibility": GPUShaderStage["FRAGMENT"], "buffer": { "type": "uniform", "minBindingSize": this._fragC3ParamsSize } }, { "binding": 5, "visibility": GPUShaderStage["FRAGMENT"], "buffer": { "type": "uniform" } }] });
      const i = [], a = C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit();
      for (let e2 = 0; e2 < a; ++e2) i.push({ "binding": 2 * e2, "visibility": GPUShaderStage["FRAGMENT"], "sampler": { "type": "filtering" } }, { "binding": 2 * e2 + 1, "visibility": GPUShaderStage["FRAGMENT"], "texture": { "sampleType": "float", "viewDimension": "2d" } });
      this._textureBindGroupLayout = e["createBindGroupLayout"]({ "label": "texturebindgrouplayout", "entries": i }), this._backTextureBindGroupLayout = e["createBindGroupLayout"]({ "label": "backtexturebindgrouplayout", "entries": [{ "binding": 0, "visibility": GPUShaderStage["FRAGMENT"], "sampler": { "type": "nearest" === this._backTextureSampling ? "non-filtering" : "filtering" } }, { "binding": 1, "visibility": GPUShaderStage["FRAGMENT"], "texture": { "sampleType": "float", "viewDimension": "2d" } }] }), this._depthTextureBindGroupLayout = e["createBindGroupLayout"]({ "label": "depthtexturebindgrouplayout", "entries": [{ "binding": 0, "visibility": GPUShaderStage["FRAGMENT"], "sampler": { "type": "non-filtering" } }, { "binding": 1, "visibility": GPUShaderStage["FRAGMENT"], "texture": { "sampleType": "depth", "viewDimension": "2d" } }] }), this._pipelineLayout = e["createPipelineLayout"]({ "bindGroupLayouts": [this._bufferBindGroupLayout, this._textureBindGroupLayout, this._backTextureBindGroupLayout, this._depthTextureBindGroupLayout] });
      const s = C32.Gfx.WebGPUShaderProgram, n = this.SupportsF16(), u = this.IsColorDataF16();
      this._defaultVertexModule = e["createShaderModule"]({ "label": "<default vertex module>", "code": s._PreprocessVertexShaderCode(s.GetDefaultVertexShaderSource(u), n) }), this._defaultVertexModule["getCompilationInfo"]().then((e2) => s.ReportShaderCompilationInfo("<default>", "vertex", e2)), this._normVertexModule = e["createShaderModule"]({ "label": "<normalized vertex module>", "code": s._PreprocessVertexShaderCode(s.GetNormalizedVertexShaderSource(u), n) }), this._normVertexModule["getCompilationInfo"]().then((e2) => s.ReportShaderCompilationInfo("<normalized>", "vertex", e2));
      const h = await Promise.all([s.Create(this, { name: "<default>", src: s.GetMultiTextureFillFragmentShaderSource(false, u), srcFragDepth: s.GetMultiTextureFillFragmentShaderSource(true, u), vertexSrc: s.GetTextureFillVertexShaderSource(u), normVertexSrc: s.GetNormalizedTextureFillVertexShaderSource(u) }), s.Create(this, { name: "<single-texture-fill>", src: s.GetSingleTextureFillFragmentShaderSource(false, u), srcFragDepth: s.GetSingleTextureFillFragmentShaderSource(true, u), vertexSrc: s.GetTextureFillVertexShaderSource(u), normVertexSrc: s.GetNormalizedTextureFillVertexShaderSource(u) }), s.Create(this, { name: "<generate-mipmap>", src: s._GetMipmapGeneratorFragmentSource(), vertexSrc: s._GetMipmapGeneratorVertexSource() }), s.Create(this, { name: "<point>", src: s._GetPointFragmentSource(false), srcFragDepth: s._GetPointFragmentSource(true), vertexSrc: s._GetPointVertexSource() }), s.Create(this, { name: "<tilemap>", src: s._GetTilemapFragmentShaderSource(false), srcFragDepth: s._GetTilemapFragmentShaderSource(true) }), s.Create(this, { name: "<fill>", src: s._GetColorFillFragmentShaderSource() }), s.Create(this, { name: "<lineargradient>", src: s._GetLinearGradientFillFragmentShaderSource() }), s.Create(this, { name: "<penumbra>", src: s._GetPenumbraFillFragmentShaderSource() }), s.Create(this, { name: "<hardellipse>", src: s._GetHardEllipseFillFragmentShaderSource() }), s.Create(this, { name: "<hardellipseoutline>", src: s._GetHardEllipseOutlineFragmentShaderSource() }), s.Create(this, { name: "<smoothellipse>", src: s._GetSmoothEllipseFillFragmentShaderSource() }), s.Create(this, { name: "<smoothellipseoutline>", src: s._GetSmoothEllipseOutlineFragmentShaderSource() }), s.Create(this, { name: "<tilerandomization>", src: s.GetTileRandomizationFragmentShaderSource(false), srcFragDepth: s.GetTileRandomizationFragmentShaderSource(true) }), s.Create(this, { name: "<smoothline>", src: s._GetSmoothLineFillFragmentShaderSource() })]);
      this._spTextureFill = h[0], this._spSingleTextureFill = h[1], this._mipmapGeneratorProgram = h[2], this._spPoints = h[3], this._spTilemapFill = h[4], this._spColorFill = h[5], this._spLinearGradientFill = h[6], this._spPenumbraFill = h[7], this._spHardEllipseFill = h[8], this._spHardEllipseOutline = h[9], this._spSmoothEllipseFill = h[10], this._spSmoothEllipseOutline = h[11], this._spTileRandomization = h[12], this._spSmoothLineFill = h[13];
      for (const e2 of h) this._AddShaderProgram(e2);
      65536 & this._flags ? (this._flags |= 393216, this._currentProgram = this._spTextureFill) : this._currentProgram = this._spSingleTextureFill, this._mipmapGeneratorPipeline = this._mipmapGeneratorProgram._GetMipmapGeneratorPipeline(), this._vertexUniformBuffer = e["createBuffer"]({ "label": "vertexuniformbuffer", "size": this._vertexUniformBufferSize, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._fragmentUniformBuffer = e["createBuffer"]({ "label": "fragmentuniformbuffer", "size": this._fragUniformBufferSize, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._fragmentC3ParamsBuffer = e["createBuffer"]({ "label": "fragmentc3paramsuniformbuffer", "size": this._fragC3ParamsSize, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._fragmentDefaultCustomParamsBuffer = e["createBuffer"]({ "label": "fragmentdefaultcustomparamsbuffer", "size": 16, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._vertexUniformUpdateStart = 0, this._vertexUniformUpdateEnd = this._vertexUniformBufferSize, this._UpdateTransformUniform(), this._UpdatePointTexCoordsUniform(), this._UpdateZElevationUniform(), this._fragUniformUpdateStart = 0, this._fragUniformUpdateEnd = this._fragUniformBufferSize, this._UpdateColor2Uniform(), this._UpdatePointColorUniform(), this._defaultBufferBindGroup = this._CreateBufferBindGroup(this._fragmentDefaultCustomParamsBuffer), this._currentBufferBindGroup = this._defaultBufferBindGroup;
      const o = C32.CreateCanvas(32, 32);
      o.getContext("2d"), this._nullTexture = await this.CreateStaticTextureAsync(o), this._currentTexture = null, this._currentTextureBindGroup = this._nullTexture._GetOwnTextureBindGroup(), this._currentMultiTextureIndex = 0, this._currentBackTexture = null, this._currentBackTextureBindGroup = this._nullTexture._GetBackTextureBindGroup(), this._nullTexture._DisableMultiTexture(), this._nullDepthBuffer = this._device["createTexture"]({ "label": "nulldepthbuffer", "size": [8, 8, 1], "format": this._GetDepthBufferFormat(), "usage": GPUTextureUsage["TEXTURE_BINDING"] }), this._nullDepthBufferView = this._nullDepthBuffer["createView"]({ "label": "nulldepthbufferview", "aspect": "depth-only" }), this._nullDepthBufferBindGroup = this._device["createBindGroup"]({ "label": "nulldepthbufferbindgroup", "layout": this._depthTextureBindGroupLayout, "entries": [{ "binding": 0, "resource": this._GetSampler({ sampling: "nearest" }) }, { "binding": 1, "resource": this._nullDepthBufferView }] }), this._currentDepthTextureBindGroup = this._nullDepthBufferBindGroup, this._backbufferRenderTarget = C32.New(C32.Gfx.WebGPURenderTarget, this, true), this._backbufferRenderTarget.GetTexture()._BackbufferTextureSetProperties(t, this._swapChainFormat), this._currentRenderTarget = this._backbufferRenderTarget, this._CreateCommandEncoder(), this._adapterInfo = this._adapter["info"], this._presentCtx || (this._presentCtx = this._canvas.getContext("webgpu")), this._presentCtx["configure"]({ "device": e, "format": this._swapChainFormat, "usage": t, "alphaMode": "premultiplied" });
    }
    _CreateBufferBindGroup(e) {
      return this._device["createBindGroup"]({ "layout": this._bufferBindGroupLayout, "entries": [{ "binding": 0, "resource": { "buffer": this._vertexUniformBuffer } }, { "binding": 1, "resource": { "buffer": this._fragmentUniformBuffer } }, { "binding": 3, "resource": { "buffer": this._pointBuffer } }, { "binding": 4, "resource": { "buffer": this._fragmentC3ParamsBuffer } }, { "binding": 5, "resource": { "buffer": e } }] });
    }
    _FillPointsIndexBuffer(e) {
      const t = new Uint16Array(e);
      let r = 0, i = t.length, a = 0;
      for (; r < i; ) t[r++] = a, t[r++] = a + 1, t[r++] = a + 2, t[r++] = a, t[r++] = a + 2, t[r++] = a + 3, a += 4;
    }
    _GetDevice() {
      return this._device;
    }
    _GetDefaultVertexModule() {
      return this._defaultVertexModule;
    }
    _GetNormalizedVertexModule() {
      return this._normVertexModule;
    }
    async CreateShaderProgram(e) {
      const t = await C32.Gfx.WebGPUShaderProgram.Create(this, e);
      return this._AddShaderProgram(t), t;
    }
    GetDisplayName() {
      return "webgpu";
    }
    GetSwapChainFormat() {
      return this._swapChainFormat;
    }
    _GetDepthBufferFormat() {
      return "depth24plus-stencil8";
    }
    _GetSwapChainTexture() {
      return this._swapChainTexture;
    }
    _GetSwapChainTexView() {
      return this._swapChainTexView;
    }
    _CanSampleBackbuffer() {
      return this._canSampleBackbuffer;
    }
    UsesBackgroundBlending() {
      return this._usesBackgroundBlending;
    }
    _GetPipelineLayout() {
      return this._pipelineLayout;
    }
    _GetTextureBindGroupLayout() {
      return this._textureBindGroupLayout;
    }
    _GetBackTextureBindGroupLayout() {
      return this._backTextureBindGroupLayout;
    }
    _GetBackTextureSampling() {
      return this._backTextureSampling;
    }
    GetTextureFormat() {
      return this._textureFormat;
    }
    GetMaxTextureSize() {
      return this._maxTextureSize;
    }
    IsContextLost() {
      return this._IsFlagSet(32768);
    }
    SupportsGPUProfiling() {
      return this._IsFlagSet(134217728);
    }
    SupportsF16() {
      return this._IsFlagSet(268435456);
    }
    IsColorDataF16() {
      return this._IsFlagSet(536870912);
    }
    GetEstimatedBackBufferMemoryUsage() {
      const e = this.GetWidth() * this.GetHeight();
      let t = e * C32.Gfx.WebGPURendererTexture.GetFormatByteSize(this._swapChainFormat);
      return this.UsesDepthBuffer() && (t += e * C32.Gfx.WebGPURendererTexture.GetFormatByteSize(this._GetDepthBufferFormat())), t;
    }
    GetEstimatedRenderBufferMemoryUsage() {
      let e = 0;
      for (const t of C32.Gfx.WebGPURenderTarget.allRenderTargets()) t.IsBackBuffer() || (e += t.GetTexture().GetEstimatedMemoryUsage());
      return e;
    }
    GetEstimatedTextureMemoryUsage() {
      let e = 0;
      for (const t of C32.Gfx.WebGPURendererTexture.allTextures()) t.IsRenderTarget() || (e += t.GetEstimatedMemoryUsage());
      return e;
    }
    SupportsNPOTTextures() {
      return true;
    }
    GetBufferManager() {
      return this._bufferManager;
    }
    SetSize(e, t, r) {
      (this._width !== e || this._height !== t || r) && (this.EndBatch(), this._width = e, this._height = t, this._viewportWidth = e, this._viewportHeight = t, this._backbufferRenderTarget._CalculateProjection(), this.SetProjectionMatrix(this._backbufferRenderTarget.GetProjectionMatrix()), this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), this._IsFlagSet(524288) && this._IsFlagSet(67108864) && this._SetDepthBufferSize(e, t));
    }
    _SetDepthBufferSize(e, t) {
      if (this._depthBuffer) {
        if (this._depthBufferWidth === e && this._depthBufferHeight === t) return;
        this._depthBuffer["destroy"]();
      }
      let r = GPUTextureUsage["RENDER_ATTACHMENT"];
      this._canSampleDepth && (r |= GPUTextureUsage["TEXTURE_BINDING"]), this._depthBuffer = this._device["createTexture"]({ "label": "depthbuffer", "size": [e, t, 1], "format": this._GetDepthBufferFormat(), "usage": r }), this._depthBufferView = this._depthBuffer["createView"]({ "label": "depthbufferview" }), this._canSampleDepth && (this._depthBufferBindGroup = this._device["createBindGroup"]({ "label": "depthbufferbindgroup", "layout": this._depthTextureBindGroupLayout, "entries": [{ "binding": 0, "resource": this._GetSampler({ sampling: "nearest" }) }, { "binding": 1, "resource": this._depthBuffer["createView"]({ "label": "depthbufferview", "aspect": "depth-only" }) }] })), this._depthBufferWidth = e, this._depthBufferHeight = t;
    }
    SetFixedSizeDepthBuffer(e, t) {
      this.UsesDepthBuffer() && (this._SetFlag(67108864, false), this._SetDepthBufferSize(e, t));
    }
    SetAutoSizeDepthBuffer() {
      this.UsesDepthBuffer() && (this._SetFlag(67108864, true), this._SetDepthBufferSize(this._width, this._height));
    }
    SetProjectionMatrix(e) {
      mat4.exactEquals(this._matP, e) || (mat4.copy(this._matP, e), this._UpdateTransformUniform());
    }
    SetDefaultRenderTargetProjectionState() {
      this.SetProjectionMatrix(this._currentRenderTarget.GetProjectionMatrix());
    }
    SetModelViewMatrix(e) {
      mat4.exactEquals(this._matMV, e) || (mat4.copy(this._matMV, e), this._UpdateTransformUniform());
    }
    ResetDidChangeTransformFlag() {
      this._SetFlag2(1, false);
    }
    DidChangeTransform() {
      return this._IsFlagSet2(1);
    }
    CreateStaticTexture(e, t) {
      if (e && !C32.Gfx.WebGPURendererTexture.IsGPUImageCopyExternalImageSource(e)) {
        const t2 = e.width || e.videoWidth, r2 = e.height || e.videoHeight, i = C32.CreateCanvas(t2, r2);
        i.getContext("2d").drawImage(e, 0, 0, t2, r2), e = i;
      }
      this.EndBatch();
      const r = C32.New(C32.Gfx.WebGPURendererTexture, this);
      return r._Create(e, t), r;
    }
    async CreateStaticTextureAsync(e, t) {
      if (C32.Gfx.WebGPURendererTexture.IsGPUImageCopyExternalImageSource(e)) return this.CreateStaticTexture(e, t);
      {
        if (!C32.Supports.ImageBitmapOptions) throw new Error("no support for ImageBitmapOptions");
        const r = await createImageBitmap(e, { "premultiplyAlpha": "premultiply" });
        return this.CreateStaticTexture(r, t);
      }
    }
    _GetSampler(e) {
      const t = e.wrapX || "clamp-to-edge", r = e.wrapY || "clamp-to-edge", i = e.sampling;
      let a = e.anisotropy || 0;
      "trilinear" !== i && (a = 0);
      const s = `${t},${r},${i},${a}`;
      let n = this._samplerMap.get(s);
      if (n) return n;
      const u = { "addressModeU": t, "addressModeV": r, "magFilter": "nearest", "minFilter": "nearest", "mipmapFilter": "nearest" };
      return "bilinear" !== i && "trilinear" !== i || (u["magFilter"] = "linear", u["minFilter"] = "linear"), "trilinear" === i && (u["mipmapFilter"] = "linear", a > 1 && (u["maxAnisotropy"] = a)), n = this._device["createSampler"](u), this._samplerMap.set(s, n), n;
    }
    _GetMipmapGeneratorPipeline() {
      return this._mipmapGeneratorPipeline;
    }
    CreateDynamicTexture(e, t, r) {
      this.EndBatch();
      const i = C32.New(C32.Gfx.WebGPURendererTexture, this);
      return i._CreateDynamic(e, t, r), i;
    }
    UpdateTexture(e, t, r) {
      return t._Update(e, r);
    }
    DeleteTexture(e) {
      e && (e.SubtractReference(), e.GetReferenceCount() > 0 || (this.IsContextLost() || (this.EndBatch(), this._currentTexture === e && this.SetTexture(null), this._currentBackTexture === e && this.SetBackTexture(null)), e._Delete()));
    }
    _SetMultiTextureAvailable(e, t) {
      this.IsContextLost() || (t ? this._availableMultiTextures.add(e) : this._availableMultiTextures.delete(e));
    }
    _SetMultiTextureGroupNonFull(e, t) {
      t ? this._nonFullMultiTexGroups.add(e) : this._nonFullMultiTexGroups.delete(e);
    }
    _TryCreateMultiTextureGroup(e) {
      const t = [e], r = C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit();
      for (const e2 of this._nonFullMultiTexGroups) e2.Release();
      for (const i of this._availableMultiTextures) {
        if (t.length >= r) break;
        i !== e && t.push(i);
      }
      t.length < 2 || C32.New(C32.Gfx.WebGPUMultiTextureGroup, this, t);
    }
    Start() {
      this._UpdateSwapChainTexture();
    }
    Restart() {
      this._UpdateSwapChainTexture();
    }
    _UpdateSwapChainTexture() {
      this._swapChainTexture = this._presentCtx["getCurrentTexture"](), this._swapChainTexView = this._swapChainTexture["createView"]({ "label": "swapchaintextureview" }), this._backbufferRenderTarget.GetTexture()._BackbufferTextureStartFrame();
    }
    Finish() {
      null === this._currentRenderPass && this._backbufferRenderTarget._IsAwaitingClear() && this._BeginRenderPass(), super.Finish(), this._bufferManager.MaybeCollectUnusedBuffers(this._frameNumber), this._backbufferRenderTarget.GetTexture()._BackbufferTextureEndFrame(), this._swapChainTexture = null, this._swapChainTexView = null;
    }
    _CreateCommandEncoder() {
      this._commandEncoder = this._device["createCommandEncoder"](), this._flags &= -16385;
    }
    StartFrameTiming(e) {
      if (!this.SupportsGPUProfiling()) throw new Error("GPU profiling not supported");
      if (this._frameTimeQuerySet) throw new Error("already started frame timing");
      return this._timestampIsMeasuring = false, this._timestampStartedIndices.clear(), this._frameTimeQuerySet = C32.New(C32.Gfx.WebGPUTimeQuerySet, this, e), this._frameTimeQuerySet;
    }
    StartMeasuringRenderPassTime(e, t) {
      if (this.SupportsGPUProfiling()) {
        if (!this._frameTimeQuerySet) throw new Error("not started frame timing");
        if (e < 0 || t < 0 || e === t) throw new Error("invalid timestamp index");
        this._MaybeEndRenderPass(), this._timestampIsMeasuring = true, this._timestampStartIndex = e, this._timestampEndIndex = t;
      }
    }
    StopMeasuringRenderPassTime() {
      this._timestampIsMeasuring && (this._MaybeEndRenderPass(), this._timestampIsMeasuring = false);
    }
    _AddToDrawBatch(e, t) {
      if (this._vertexPtr + e > 65535 || this._indexPtr + t > 393210) this.EndBatch();
      else if (1 & this._flags) return void (this._drawIndexCount += t);
      null === this._currentRenderPass && this._BeginRenderPass(), this._flags |= 1, this._drawFirstIndex = this._indexPtr, this._drawIndexCount = t;
    }
    _AddIndicesForQuad() {
      const e = this._vertexPtr;
      let t = this._indexPtr;
      this._indexPtr += 6;
      const r = this._indexData;
      r[t++] = e, r[t++] = e + 1, r[t++] = e + 2, r[t++] = e, r[t++] = e + 2, r[t] = e + 3;
    }
    _MaybeEndDrawBatch() {
      const e = this._flags;
      if (!(1 & e)) return;
      const t = this._currentRenderPass;
      if (16 & e) {
        const r = this._currentRenderTarget;
        t["setViewport"](0, 0, r.GetWidth(), r.GetHeight(), 0, 1), 2 & e ? t["setIndexBuffer"](this._pointsIndexBuffer, "uint16") : t["setIndexBuffer"](this._indexBuffer, "uint16"), t["setVertexBuffer"](0, this._vertexBuffer), t["setVertexBuffer"](1, this._texcoordBuffer), t["setVertexBuffer"](2, this._colorBuffer), t["setVertexBuffer"](3, this._texIndexBuffer), 25165824 & e && t["setStencilReference"](1), 4 & e && this._DoSetRenderPassScissorRect(t, this._scissorRect, r);
      }
      if (32 & e) {
        let r = 0;
        1073741824 & e ? r = 4 : 8388608 & e ? r = 2 : 16777216 & e ? r = 3 : 3145728 & ~e || (r = 1), t["setPipeline"](this._currentProgram.GetRenderPipelineForState(this._currentBlendMode, r, this._currentCullFace, this._currentFrontFaceWinding, this._currentMultisampleCount));
      }
      if (8192 & e && t["setBindGroup"](0, this._currentBufferBindGroup), 64 & e && t["setBindGroup"](1, this._currentTextureBindGroup), 128 & e && t["setBindGroup"](2, this._currentBackTextureBindGroup), 256 & e && t["setBindGroup"](3, this._currentDepthTextureBindGroup), 8 & e) {
        const r = this._currentRenderTarget;
        4 & e ? this._DoSetRenderPassScissorRect(t, this._scissorRect, r) : t["setScissorRect"](0, 0, r.GetWidth(), r.GetHeight());
      }
      t["drawIndexed"](this._drawIndexCount, 1, this._drawFirstIndex, 0, 0), this._flags &= -8698;
    }
    _DoSetRenderPassScissorRect(e, t, r) {
      const i = r.GetWidth(), a = r.GetHeight();
      let s = C32.clamp(t.getLeft(), 0, i), n = C32.clamp(t.getTop(), 0, a), u = C32.clamp(t.getRight(), s, i), h = C32.clamp(t.getBottom(), n, a);
      Number.isNaN(s) && (s = 0), Number.isNaN(n) && (n = 0), Number.isNaN(u) && (u = i), Number.isNaN(h) && (h = a), e["setScissorRect"](s, n, u - s, h - n);
    }
    _BeginRenderPass() {
      const e = this._flags;
      7680 & e && this._WriteUniformBuffers();
      let t = null;
      t = 8388608 & e ? this._GetCoplanarStencilRenderPassOpts() : 16777216 & e ? this._GetCoplanarColorRenderPassOpts() : this._GetStandardRenderPassOpts(), this._currentRenderPass = this._commandEncoder["beginRenderPass"](t), this._flags |= 25072;
    }
    _GetStandardRenderPassOpts() {
      const e = this._flags, t = this._currentRenderTarget, r = { "colorAttachments": [{ "view": t._GetTextureView(), "loadOp": t._IsAwaitingClear() ? "clear" : "load", "clearValue": t._GetClearColor().toJSON(), "storeOp": "store" }] };
      return this._MaybeSetTimestampRenderPassOption(r), t._SetIsAwaitingClear(false), 3145728 & ~e || (r["depthStencilAttachment"] = { "view": this._depthBufferView, "depthLoadOp": 4194304 & e ? "clear" : "load", "depthClearValue": 1, "depthStoreOp": "store", "stencilLoadOp": "clear", "stencilClearValue": 0, "stencilStoreOp": "discard" }, this._flags &= -4194305), r;
    }
    _GetCoplanarStencilRenderPassOpts() {
      const e = this._flags, t = { "colorAttachments": [], "depthStencilAttachment": { "view": this._depthBufferView, "depthLoadOp": 4194304 & e ? "clear" : "load", "depthClearValue": 1, "depthStoreOp": "store", "stencilLoadOp": 33554432 & e ? "clear" : "load", "stencilClearValue": 0, "stencilStoreOp": "store" } };
      return this._MaybeSetTimestampRenderPassOption(t), this._flags &= -37748737, t;
    }
    _GetCoplanarColorRenderPassOpts() {
      const e = this._currentRenderTarget, t = { "colorAttachments": [{ "view": e._GetTextureView(), "loadOp": e._IsAwaitingClear() ? "clear" : "load", "clearValue": e._GetClearColor().toJSON(), "storeOp": "store" }], "depthStencilAttachment": { "view": this._depthBufferView, "depthReadOnly": true, "stencilReadOnly": true } };
      return this._MaybeSetTimestampRenderPassOption(t), e._SetIsAwaitingClear(false), t;
    }
    _MaybeSetTimestampRenderPassOption(e) {
      if (!this._timestampIsMeasuring) return;
      const t = { "querySet": this._frameTimeQuerySet._GetQuerySet(), "endOfPassWriteIndex": this._timestampEndIndex };
      this._timestampStartedIndices.has(this._timestampStartIndex) || (t["beginningOfPassWriteIndex"] = this._timestampStartIndex, this._timestampStartedIndices.add(this._timestampStartIndex)), e["timestampWrites"] = t;
    }
    _MaybeDoPendingClearRenderPass(e) {
      if (!e._IsAwaitingClear()) return;
      this._MaybeEndRenderPass();
      this._commandEncoder["beginRenderPass"]({ "colorAttachments": [{ "view": e._GetTextureView(), "loadOp": "clear", "clearValue": e._GetClearColor().toJSON(), "storeOp": "store" }] })["end"](), this._flags |= 16384, e._SetIsAwaitingClear(false);
    }
    _MaybeEndRenderPass() {
      null !== this._currentRenderPass && (this._MaybeEndDrawBatch(), this._currentRenderPass["end"](), this._currentRenderPass = null);
    }
    EndBatch(e = false) {
      this._MaybeEndRenderPass(), this._frameTimeQuerySet && e && (this._frameTimeQuerySet.Resolve(this._commandEncoder), this._flags |= 16384), 16384 & this._flags && (this._commandBuffers.push(this._commandEncoder["finish"]()), this._CreateCommandEncoder()), 0 !== this._commandBuffers.length && (this._WriteBuffers(), this._device["queue"]["submit"](this._commandBuffers), C32.clearArray(this._commandBuffers), this._bufferManager.AfterSubmit(), this._frameTimeQuerySet && e && (this._frameTimeQuerySet.ReadResult(), this._frameTimeQuerySet = null));
    }
    _WriteBuffers() {
      const e = this._device["queue"];
      if (this._vertexPtr > 0) {
        const t = this._vertexPtr;
        e["writeBuffer"](this._vertexBuffer, 0, this._vertexData.buffer, 0, 3 * t * 4), e["writeBuffer"](this._texcoordBuffer, 0, this._texcoordData.buffer, 0, 2 * t * 4), 65536 & this._flags && e["writeBuffer"](this._texIndexBuffer, 0, this._texIndexData.buffer, 0, 4 * t);
        const r = this.IsColorDataF16() ? 2 : 4;
        e["writeBuffer"](this._colorBuffer, 0, this._colorData.buffer, 0, 4 * t * r), this._vertexPtr = 0;
      }
      this._indexPtr > 0 && (this._indexPtr % 2 != 0 && (this._indexData[this._indexPtr++] = 0), e["writeBuffer"](this._indexBuffer, 0, this._indexData.buffer, 0, 2 * this._indexPtr), this._indexPtr = 0), this._pointPtr > 0 && (e["writeBuffer"](this._pointBuffer, 0, this._pointData.buffer, 0, 4 * this._pointPtr), this._pointPtr = 0);
    }
    _UpdateTransformUniform() {
      this._flags |= 512, this._flags2 |= 1, this._MarkVertexUniformBufferRangeChanged(this._vertexUniformBufferLayout.transform);
    }
    _UpdatePointTexCoordsUniform() {
      const e = this._vertexUniformBufferLayout.pointTex;
      this._currentPointTexCoords.writeToTypedArray(this._vertexUniformf32, e.offset / 4), this._MarkVertexUniformBufferRangeChanged(e);
    }
    _UpdateZElevationUniform() {
      const e = this._vertexUniformBufferLayout.zElevation;
      this._vertexUniformf32[e.offset / 4] = this._currentVertexZElevation, this._MarkVertexUniformBufferRangeChanged(e);
    }
    _MarkVertexUniformBufferRangeChanged(e) {
      const t = e.offset, r = e.end;
      1024 & this._flags ? (this._vertexUniformUpdateStart = Math.min(this._vertexUniformUpdateStart, t), this._vertexUniformUpdateEnd = Math.max(this._vertexUniformUpdateEnd, r)) : (this._flags |= 1024, this._vertexUniformUpdateStart = t, this._vertexUniformUpdateEnd = r, this._MaybeEndRenderPass());
    }
    _UpdateColor2Uniform() {
      this._UpdateFragmentUniformColor(this._currentColor2, this._fragUniformBufferLayout.color2);
    }
    _UpdatePointColorUniform() {
      this._UpdateFragmentUniformColor(this._currentPointColor, this._fragUniformBufferLayout.pointColor);
    }
    _UpdateFragmentUniformColor(e, t) {
      e.writeToTypedArray(this._fragUniformf32, t.offset / 4), this._MarkFragUniformBufferRangeChanged(t);
    }
    _UpdateFragmentUniformVec2(e, t) {
      e.writeToTypedArray(this._fragUniformf32, t.offset / 4), this._MarkFragUniformBufferRangeChanged(t);
    }
    _MarkFragUniformBufferRangeChanged(e) {
      const t = e.offset, r = e.end;
      2048 & this._flags ? (this._fragUniformUpdateStart = Math.min(this._fragUniformUpdateStart, t), this._fragUniformUpdateEnd = Math.max(this._fragUniformUpdateEnd, r)) : (this._flags |= 2048, this._fragUniformUpdateStart = t, this._fragUniformUpdateEnd = r, this._MaybeEndRenderPass());
    }
    _MaybeUpdateFragmentC3ParamsFloat(e, t) {
      this._fragC3Paramsf32[t.offset / 4] !== Math.fround(e) && (this._fragC3Paramsf32[t.offset / 4] = e, this._MarkFragC3ParamsRangeChanged(t));
    }
    _MaybeUpdateFragmentC3ParamsUint(e, t) {
      this._fragC3Paramsu32[t.offset / 4] !== e && (this._fragC3Paramsu32[t.offset / 4] = e, this._MarkFragC3ParamsRangeChanged(t));
    }
    _MaybeUpdateFragmentC3ParamsRect(e, t) {
      e.equalsF32Array(this._fragC3Paramsf32, t.offset / 4) || (e.writeToTypedArray(this._fragC3Paramsf32, t.offset / 4), this._MarkFragC3ParamsRangeChanged(t));
    }
    _MarkFragC3ParamsRangeChanged(e) {
      const t = e.offset, r = e.end;
      4096 & this._flags ? (this._fragC3ParamsUpdateStart = Math.min(this._fragC3ParamsUpdateStart, t), this._fragC3ParamsUpdateEnd = Math.max(this._fragC3ParamsUpdateEnd, r)) : (this._flags |= 4096, this._fragC3ParamsUpdateStart = t, this._fragC3ParamsUpdateEnd = r, this._MaybeEndRenderPass());
    }
    _WriteUniformBuffers() {
      const e = this._flags;
      512 & e && (mat4.multiply(this._matTransform, this._matP, this._matMV), this._vertexUniformf32.set(this._matTransform, this._vertexUniformBufferLayout.transform.offset / 4)), 1024 & e && this._bufferManager.UpdateBufferSubData(this._commandEncoder, this._vertexUniformBuffer, this._vertexUniformArrayBuffer, this._vertexUniformUpdateStart, this._vertexUniformUpdateEnd - this._vertexUniformUpdateStart), 2048 & e && this._bufferManager.UpdateBufferSubData(this._commandEncoder, this._fragmentUniformBuffer, this._fragUniformArrayBuffer, this._fragUniformUpdateStart, this._fragUniformUpdateEnd - this._fragUniformUpdateStart), 4096 & e && this._bufferManager.UpdateBufferSubData(this._commandEncoder, this._fragmentC3ParamsBuffer, this._fragC3ParamsArrayBuffer, this._fragC3ParamsUpdateStart, this._fragC3ParamsUpdateEnd - this._fragC3ParamsUpdateStart), this._flags = -7681 & e | 16384;
    }
    CreateRenderTarget(e) {
      let t = this._width, r = this._height, i = true;
      if (e && ("number" == typeof e.width && (t = Math.floor(e.width), i = false), "number" == typeof e.height && (r = Math.floor(e.height), i = false)), t <= 0 || r <= 0) throw new Error("invalid size");
      this.EndBatch();
      const a = C32.New(C32.Gfx.WebGPURenderTarget, this);
      return a._Create(t, r, Object.assign({ isDefaultSize: i }, e)), a;
    }
    SetRenderTarget(e, t = true) {
      null === e && (e = this._backbufferRenderTarget), this._currentRenderTarget !== e && (this._MaybeEndRenderPass(), this._currentRenderTarget = e, this._SetFlag(2097152, e.HasDepthBuffer()), e.IsDefaultSize() && !e.IsBackBuffer() && e._Resize(this._width, this._height), t && this.SetDefaultRenderTargetProjectionState());
    }
    InvalidateRenderTarget(e) {
    }
    GetRenderTarget() {
      return this._currentRenderTarget === this._backbufferRenderTarget ? null : this._currentRenderTarget;
    }
    GetRenderTargetSize(e) {
      return null === e ? [this._width, this._height] : [e.GetWidth(), e.GetHeight()];
    }
    GetBackbufferRenderTarget() {
      return this._backbufferRenderTarget;
    }
    DeleteRenderTarget(e) {
      this.EndBatch(), this._currentRenderTarget === e && this.SetRenderTarget(null);
      const t = e.GetTexture();
      this._currentTexture === t && this.SetTexture(null), this._currentBackTexture === t && this.SetBackTexture(null), e._Delete();
    }
    async ReadBackRenderTargetToImageData(e, t, r) {
      this._MaybeDoPendingClearRenderPass(e), this.EndBatch(), null === e && (e = this._backbufferRenderTarget);
      const i = this._device, a = e.GetWidth(), s = e.GetHeight();
      let n = 0, u = 0, h = a, o = s;
      if (r) {
        n = C32.clamp(Math.floor(r.getLeft()), 0, a - 1), u = C32.clamp(Math.floor(r.getTop()), 0, s - 1);
        let e2 = r.width();
        e2 = 0 === e2 ? a - n : C32.clamp(Math.floor(e2), 0, a - n);
        let t2 = r.height();
        t2 = 0 === t2 ? s - u : C32.clamp(Math.floor(t2), 0, s - u), h = e2, o = t2;
      }
      const l = i["createCommandEncoder"](), _ = e.GetTexture();
      let f = _._GetTexture(), d = null;
      "rgba8unorm" === _._GetFormat() ? _.CanReadPixels() || C32.NotYetImplemented() : (d = this._ConvertTextureFormat(_, "rgba8unorm", l), f = d);
      const c = 4 * h, p = 256 * Math.ceil(c / 256), m = i["createBuffer"]({ "size": p * o, "usage": GPUBufferUsage["MAP_READ"] | GPUBufferUsage["COPY_DST"] });
      l["copyTextureToBuffer"]({ "texture": f, "origin": [n, u, 0] }, { "buffer": m, "bytesPerRow": p }, [h, o, 1]);
      const g = l["finish"]();
      i["queue"]["submit"]([g]), d && d["destroy"](), await m["mapAsync"](self["GPUMapMode"]["READ"]);
      const x = m["getMappedRange"]().slice(0);
      let T;
      if (p === c) T = new ImageData(new Uint8ClampedArray(x), h, o);
      else {
        const e2 = new ArrayBuffer(c * o), t2 = new Uint8Array(e2);
        for (let e3 = 0; e3 < o; ++e3) {
          const r2 = e3 * p, i2 = e3 * c;
          t2.set(new Uint8Array(x, r2, c), i2);
        }
        T = new ImageData(new Uint8ClampedArray(e2), h, o);
      }
      return m["destroy"](), T;
    }
    _ConvertTextureFormat(e, t, r) {
      const i = this._device, a = e.GetWidth(), s = e.GetHeight();
      if (e._GetFormat() === t) throw new Error("no conversion necessary");
      e.IsSampled() || C32.NotYetImplemented();
      const n = i["createTexture"]({ "size": [a, s, 1], "format": t, "usage": GPUTextureUsage["COPY_SRC"] | GPUTextureUsage["RENDER_ATTACHMENT"] }), u = this._mipmapGeneratorProgram._GetMipmapGeneratorPipeline(t), h = u["getBindGroupLayout"](0), o = this._GetSampler({ sampling: "nearest" }), l = e._GetTexture()["createView"]({ "baseMipLevel": 0, "mipLevelCount": 1 }), _ = n["createView"]({ "baseMipLevel": 0, "mipLevelCount": 1 }), f = r["beginRenderPass"]({ "colorAttachments": [{ "view": _, "loadOp": "clear", "clearValue": [0, 0, 0, 0], "storeOp": "store" }] }), d = i["createBindGroup"]({ "layout": h, "entries": [{ "binding": 0, "resource": o }, { "binding": 1, "resource": l }] });
      return f["setPipeline"](u), f["setBindGroup"](0, d), f["draw"](4), f["end"](), n;
    }
    SetDepthEnabled(e) {
      524288 & this._flags && (e = !!e, !!(1048576 & this._flags) !== e && (2097152 & this._flags && this._MaybeEndRenderPass(), this._SetFlag(1048576, e)));
    }
    IsDepthEnabled() {
      return this._IsFlagSet(1048576);
    }
    UsesDepthBuffer() {
      return this._IsFlagSet(524288);
    }
    SetDepthSamplingEnabled(e) {
      if (!this._canSampleDepth) return;
      if (e && this.IsDepthEnabled()) throw new Error("depth still enabled");
      const t = e ? this._depthBufferBindGroup : this._nullDepthBufferBindGroup;
      this._currentDepthTextureBindGroup !== t && (this._MaybeEndDrawBatch(), this._currentDepthTextureBindGroup = t, this._flags |= 256);
    }
    Clear(e) {
      this._MaybeEndRenderPass(), this._currentRenderTarget._SetIsAwaitingClear(true), this._currentRenderTarget._GetClearColor().set(e);
    }
    ClearRgba(e, t, r, i) {
      this._MaybeEndRenderPass(), this._currentRenderTarget._SetIsAwaitingClear(true), this._currentRenderTarget._GetClearColor().setRgba(e, t, r, i);
    }
    ClearDepth() {
      2621440 & ~this._flags || (this._MaybeEndRenderPass(), this._flags |= 4194304);
    }
    SetScissorRect(e, t, r, i) {
      e = Math.floor(e), t = Math.floor(t), r = Math.floor(r), i = Math.floor(i), 4 & this._flags && this._scissorRect.equalsWH(e, t, r, i) || (this._MaybeEndDrawBatch(), this._flags |= 12, this._scissorRect.setWH(e, t, r, i));
    }
    RemoveScissorRect() {
      4 & this._flags && (this._MaybeEndDrawBatch(), this._flags &= -5, this._flags |= 8);
    }
    GetTextureFillShaderProgram() {
      return 65536 & this._flags ? this._spTextureFill : this._spSingleTextureFill;
    }
    SetTextureFillMode() {
      this.SetProgram(this.GetTextureFillShaderProgram());
    }
    SetProgram(e) {
      if (this._currentProgram !== e) {
        if (e === this._spTextureFill && !(65536 & this._flags)) throw new Error("cannot set multitexture fill program when multitexturing not allowed");
        this._MaybeEndDrawBatch(), this._currentProgram = e, this._currentStateGroup = null, this._flags |= 32, this._SetMultiTexturingEnabled(e === this._spTextureFill);
      }
    }
    GetProgram() {
      return this._currentProgram;
    }
    _SetMultiTexturingEnabled(e) {
      if (e = !!e, !!(131072 & this._flags) === e) return;
      this._SetFlag(131072, e);
      const t = null === this._currentTexture ? this._nullTexture : this._currentTexture;
      this._ApplyTextureBindGroup(t);
    }
    _SetMultiTexturingActive(e) {
      e = !!e, !!(262144 & this._flags) !== e && (this._MaybeEndDrawBatch(), this._SetFlag(262144, e), this._SetFlag(32, true));
    }
    SetNormalizedCoordsProgramVariant(e) {
      e = !!e, !!(1073741824 & this._flags) !== e && (this._MaybeEndDrawBatch(), this._SetFlag(1073741824, e), this._flags |= 32);
    }
    IsNormalizedCoordsProgramVariant() {
      return this._IsFlagSet(1073741824);
    }
    SetTexture(e) {
      e !== this._currentTexture && (this._currentTexture = e, null === e && (e = this._nullTexture), this._ApplyTextureBindGroup(e));
    }
    _ApplyTextureBindGroup(e) {
      if (131072 & this._flags) {
        const t = e._GetMultiTextureBindGroup();
        if (null !== t) return this._SetTextureBindGroup(t), this._currentMultiTextureIndex = e._GetMultiTextureIndex(), void this._SetMultiTexturingActive(true);
      }
      this._SetTextureBindGroup(e._GetOwnTextureBindGroup()), this._currentMultiTextureIndex = 0, this._SetMultiTexturingActive(false);
    }
    _SetTextureBindGroup(e) {
      e !== this._currentTextureBindGroup && (this._MaybeEndDrawBatch(), this._currentTextureBindGroup = e, this._flags |= 64);
    }
    _OnTextureBindGroupChanged(e) {
      this._currentTexture === e && (this._MaybeEndDrawBatch(), this._currentTextureBindGroup = e._GetOwnTextureBindGroup(), this._flags |= 64);
    }
    _OnMultiTextureBindGroupReleased(e) {
      if (this._currentTextureBindGroup !== e) return;
      this._MaybeEndDrawBatch();
      const t = null === this._currentTexture ? this._nullTexture : this._currentTexture;
      this._currentTextureBindGroup = t._GetOwnTextureBindGroup(), this._currentMultiTextureIndex = 0, this._flags |= 64;
    }
    SetBackTexture(e) {
      e !== this._currentBackTexture && (this._currentBackTexture = e, null === e && (e = this._nullTexture), this._MaybeEndDrawBatch(), this._currentBackTextureBindGroup = e._GetBackTextureBindGroup(), this._flags |= 128);
    }
    CopyTextureToTexture(e, t, r, i, a, s) {
      const n = e._GetUsage(), u = t._GetUsage();
      if (0 === (n & GPUTextureUsage["COPY_SRC"])) throw new Error("source texture missing COPY_SRC usage");
      if (0 === (u & GPUTextureUsage["COPY_DST"])) throw new Error("destination texture missing COPY_DST usage");
      if (e === t) throw new Error("invalid destination");
      const h = Math.min(e.GetWidth(), t.GetWidth()), o = Math.min(e.GetHeight(), t.GetHeight());
      a = Math.min(a, h - r), s = Math.min(s, o - i), a <= 0 || s <= 0 || (this._MaybeEndRenderPass(), this._commandEncoder["copyTextureToTexture"]({ "texture": e._GetTexture(), "origin": [r, i] }, { "texture": t._GetTexture(), "origin": [r, i] }, [a, s]), this._flags |= 16384);
    }
    _ClampToSupportedMultisampleValues(e) {
      return e >= 2 ? 4 : 1;
    }
    SetRenderingToMultisampleCount(e) {
      e = this._ClampToSupportedMultisampleValues(e), this._currentMultisampleCount !== e && (this._MaybeEndDrawBatch(), this._currentMultisampleCount = e, this._flags |= 32);
    }
    SetBlendMode(e) {
      e !== this._currentBlendMode && (this._MaybeEndDrawBatch(), this._currentBlendMode = e, this._currentStateGroup = null, this._flags |= 32);
    }
    SetNamedBlendMode(e) {
      this.SetBlendMode(this.NamedBlendToNumber(e));
    }
    SetAlphaBlend() {
      this.SetBlendMode(0);
    }
    SetCopyBlend() {
      this.SetBlendMode(3);
    }
    SetColorRgba(e, t, r, i) {
      const a = this._currentColor;
      a.equalsRgba(e, t, r, i) || (a.setRgba(e, t, r, i), this._currentStateGroup = null);
    }
    SetOpacity(e) {
      const t = this._currentColor;
      t.getA() !== e && (t.setA(e), this._currentStateGroup = null);
    }
    GetOpacity() {
      return this._currentColor.getA();
    }
    SetColor(e) {
      const t = this._currentColor;
      t.equals(e) || (t.set(e), this._currentStateGroup = null);
    }
    ResetColor() {
      this.SetColorRgba(1, 1, 1, 1);
    }
    GetColor() {
      return this._currentColor;
    }
    SetCullFaceMode(e) {
      e !== this._currentCullFace && (this._MaybeEndDrawBatch(), this._currentCullFace = e, this._currentStateGroup = null, this._flags |= 32);
    }
    GetCullFaceMode() {
      return this._currentCullFace;
    }
    SetFrontFaceWinding(e) {
      e !== this._currentFrontFaceWinding && (this._MaybeEndDrawBatch(), this._currentFrontFaceWinding = e, this._currentStateGroup = null, this._flags |= 32);
    }
    GetFrontFaceWinding() {
      return this._currentFrontFaceWinding;
    }
    Rect(e) {
      this.Rect2(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());
    }
    Rect2(e, t, r, i) {
      this.Quad2(e, t, r, t, r, i, e, i);
    }
    _WriteQuadTexIndices(e) {
      const t = this._texIndexData, r = this._currentMultiTextureIndex;
      t[e++] = r, t[e++] = r, t[e++] = r, t[e] = r;
    }
    Quad(e) {
      this.Quad4(e, defaultTexCoordsQuad);
    }
    Quad2(e, t, r, i, a, s, n, u) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const h = this._vertexData, o = this._vertexPtr;
      this._vertexPtr += 4;
      let l = 3 * o;
      const _ = this._baseZ + this._currentZ;
      h[l++] = e, h[l++] = t, h[l++] = _, h[l++] = r, h[l++] = i, h[l++] = _, h[l++] = a, h[l++] = s, h[l++] = _, h[l++] = n, h[l++] = u, h[l] = _, defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, 2 * o), 262144 & this._flags && this._WriteQuadTexIndices(o), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * o);
    }
    Quad3(e, t) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const r = this._vertexPtr;
      this._vertexPtr += 4, e.writeToTypedArray3D(this._vertexData, 3 * r, this._baseZ + this._currentZ), t.writeAsQuadToTypedArray(this._texcoordData, 2 * r), 262144 & this._flags && this._WriteQuadTexIndices(r), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * r);
    }
    Quad4(e, t) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const r = this._vertexPtr;
      this._vertexPtr += 4, e.writeToTypedArray3D(this._vertexData, 3 * r, this._baseZ + this._currentZ), t.writeToTypedArray(this._texcoordData, 2 * r), 262144 & this._flags && this._WriteQuadTexIndices(r), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * r);
    }
    Quad5(e, t, r) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const i = this._vertexPtr;
      this._vertexPtr += 4, e.writeToTypedArray3D(this._vertexData, 3 * i, this._baseZ + this._currentZ), t.writeToTypedArray(this._texcoordData, 2 * i), 262144 & this._flags && this._WriteQuadTexIndices(i), this._colorData.set(r, 4 * i);
    }
    Quad3D(e, t, r, i, a, s, n, u, h, o, l, _, f) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const d = this._vertexData, c = this._vertexPtr;
      this._vertexPtr += 4;
      let p = 3 * c;
      const m = this._baseZ + this._currentZ;
      d[p++] = e, d[p++] = t, d[p++] = m + r, d[p++] = i, d[p++] = a, d[p++] = m + s, d[p++] = n, d[p++] = u, d[p++] = m + h, d[p++] = o, d[p++] = l, d[p] = m + _, f.writeAsQuadToTypedArray(this._texcoordData, 2 * c), 262144 & this._flags && this._WriteQuadTexIndices(c), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * c);
    }
    Quad3D2(e, t, r, i, a, s, n, u, h, o, l, _, f) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const d = this._vertexData, c = this._vertexPtr;
      this._vertexPtr += 4;
      let p = 3 * c;
      const m = this._baseZ + this._currentZ;
      d[p++] = e, d[p++] = t, d[p++] = m + r, d[p++] = i, d[p++] = a, d[p++] = m + s, d[p++] = n, d[p++] = u, d[p++] = m + h, d[p++] = o, d[p++] = l, d[p] = m + _, f.writeToTypedArray(this._texcoordData, 2 * c), 262144 & this._flags && this._WriteQuadTexIndices(c), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * c);
    }
    Quad3D3(e, t, r, i, a, s, n, u, h, o, l, _, f, d) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const c = this._vertexData, p = this._vertexPtr;
      this._vertexPtr += 4;
      let m = 3 * p;
      const g = this._baseZ + this._currentZ;
      c[m++] = e, c[m++] = t, c[m++] = g + r, c[m++] = i, c[m++] = a, c[m++] = g + s, c[m++] = n, c[m++] = u, c[m++] = g + h, c[m++] = o, c[m++] = l, c[m] = g + _, f.writeToTypedArray(this._texcoordData, 2 * p), 262144 & this._flags && this._WriteQuadTexIndices(p), this._colorData.set(d, 4 * p);
    }
    DrawMesh(e, t, r, i) {
      if (e.length % 3 != 0) throw new Error("vertex buffer length not multiple of 3");
      if (e.length > 196605) throw new Error(`too many vertices (${e.length / 3}, limit 65535)`);
      if (r.length % 3 != 0) throw new Error("index buffer length not multiple of 3");
      if (r.length > 393210) throw new Error(`too many indices (${r.length}, limit 393210)`);
      this._AddToDrawBatch(e.length, r.length);
      const a = this._vertexPtr;
      this._vertexData.set(e, 3 * a), this._texcoordData.set(t, 2 * a), 262144 & this._flags && this._texIndexData.fill(this._currentMultiTextureIndex, a, a + e.length);
      const s = this._indexData;
      if (0 === a) s.set(r, this._indexPtr);
      else {
        let e2 = this._indexPtr;
        for (let t2 = 0, i2 = r.length; t2 < i2; ++t2) s[e2++] = r[t2] + a;
      }
      const n = this._colorData;
      if (null != i) n.set(i, 4 * a);
      else {
        const t2 = this._currentColor, r2 = t2.getR(), i2 = t2.getG(), s2 = t2.getB(), u = t2.getA();
        let h = 4 * a;
        for (let t3 = 0, a2 = e.length; t3 < a2; ++t3) n[h++] = r2, n[h++] = i2, n[h++] = s2, n[h++] = u;
      }
      this._vertexPtr += e.length / 3, this._indexPtr += r.length;
    }
    StartRenderingPoints(e) {
      this._currentPointTexCoords.equals(e) || (this._currentPointTexCoords.copy(e), this._UpdatePointTexCoordsUniform());
      const t = this._baseZ + this._currentZ;
      this._currentVertexZElevation !== t && (this._currentVertexZElevation = t, this._UpdateZElevationUniform()), this._currentPointColor.equals(this._currentColor) || (this._currentPointColor.copy(this._currentColor), this._UpdatePointColorUniform()), this.SetProgram(this.GetPointsRenderingProgram()), this._drawIndexCount = 0, this._flags |= 18;
    }
    FinishRenderingPoints() {
      this._drawIndexCount > 0 && this._MaybeEndDrawBatch(), this._flags &= -3, this._flags |= 16;
    }
    Point(e, t, r, i) {
      let a = this._pointPtr;
      a > LAST_POINT_PTR && (this.EndBatch(), a = 0), 1 & this._flags ? this._drawIndexCount += 6 : (null === this._currentRenderPass && this._BeginRenderPass(), this._flags |= 1, this._drawFirstIndex = a / 4 * 6, this._drawIndexCount = 6);
      const s = this._pointData;
      s[a++] = e, s[a++] = t, s[a++] = r, s[a++] = i, this._pointPtr = a;
    }
    SetGradientColor(e) {
      this._currentColor2.equals(e) || (this._currentColor2.copy(e), this._UpdateColor2Uniform());
    }
    SetEllipseParams(e, t, r = 1) {
      const i = this._fragUniformBufferLayout, a = this._fragUniformf32;
      tempVec2.set(e, t), tempVec2.equalsF32Array(a, i.pixelSize.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, i.pixelSize), a[i.outlineThickness.offset / 4] !== Math.fround(r) && (a[i.outlineThickness.offset / 4] = r, this._MarkFragUniformBufferRangeChanged(i.outlineThickness));
    }
    SetTilemapInfo(e, t, r, i, a, s, n) {
      const u = this._fragUniformBufferLayout, h = this._fragUniformf32;
      e.equalsF32Array(h, u.srcRect.offset / 4) || (e.writeToTypedArray(h, u.srcRect.offset / 4), this._MarkFragUniformBufferRangeChanged(u.srcRect)), tempVec2.set(i / t, a / r), tempVec2.equalsF32Array(h, u.tileSize.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, u.tileSize), tempVec2.set(s / t, n / r), tempVec2.equalsF32Array(h, u.tileSpacing.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, u.tileSpacing);
    }
    SetTileRandomizationInfo(e, t, r, i, a, s, n) {
      const u = this._fragUniformBufferLayout, h = this._fragUniformf32;
      tempVec2.set(r, i), tempVec2.equalsF32Array(h, u.tileSize.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, u.tileSize), h[u.outlineThickness.offset / 4] !== Math.fround(a) && (h[u.outlineThickness.offset / 4] = a, this._MarkFragUniformBufferRangeChanged(u.outlineThickness)), tempVec2.set(s, n), tempVec2.equalsF32Array(h, u.tileSpacing.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, u.tileSpacing);
    }
    SetProgramParameters(e, t, r, i, a, s, n, u, h, o, l) {
      const _ = this._fragC3ParamsLayout, f = this._currentProgram;
      l %= 10800, f.BlendsBackground() && this.SetBackTexture(e), f.UsesAnyC3ParamRect() && (this._MaybeUpdateFragmentC3ParamsRect(t, _.destRect), this._MaybeUpdateFragmentC3ParamsRect(r, _.srcRect), this._MaybeUpdateFragmentC3ParamsRect(i, _.srcOriginRect), this._MaybeUpdateFragmentC3ParamsRect(a, _.layoutRect)), this._MaybeUpdateFragmentC3ParamsFloat(u, _.devicePixelRatio), this._MaybeUpdateFragmentC3ParamsFloat(h, _.layerScale), this._MaybeUpdateFragmentC3ParamsFloat(o, _.layerAngle), this._MaybeUpdateFragmentC3ParamsFloat(l, _.seconds), this._MaybeUpdateFragmentC3ParamsFloat(this.GetNearZ(), _.zNear), this._MaybeUpdateFragmentC3ParamsFloat(this.GetFarZ(), _.zFar);
    }
    SetProgramCustomParameters(e) {
      e && (e.IsChanged() && (this._MaybeEndRenderPass(), e.UpdateBuffer(this._commandEncoder)), this._SetBufferBindGroup(e.GetBufferBindGroup()));
    }
    SetProgramParameter_IsSrcTexRotated(e) {
      this._MaybeUpdateFragmentC3ParamsUint(e ? 1 : 0, this._fragC3ParamsLayout.isSrcTexRotated);
    }
    _SetBufferBindGroup(e) {
      e !== this._currentBufferBindGroup && (this._MaybeEndDrawBatch(), this._currentBufferBindGroup = e, this._flags |= 8192);
    }
    _OnBufferBindGroupDestroyed(e) {
      this._currentBufferBindGroup === e && this._SetBufferBindGroup(this._defaultBufferBindGroup);
    }
    CopyRenderTarget(e) {
      if (e._IsAwaitingClear()) return this._currentRenderTarget._SetIsAwaitingClear(true), void this._currentRenderTarget._GetClearColor().set(e._GetClearColor());
      e.GetMultisampling() >= 2 && this._currentRenderTarget.GetMultisampling() < 2 ? this._ResolveMultisampledRenderTarget(e) : (this.ClearRgba(0, 0, 0, 0), this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(e));
    }
    DrawRenderTarget(e) {
      this._MaybeDoPendingClearRenderPass(e);
      const t = e.GetTexture();
      this.SetTexture(t), this.FullscreenQuad();
    }
    FullscreenQuad() {
      const e = this.IsNormalizedCoordsProgramVariant();
      e || this.SetNormalizedCoordsProgramVariant(true), this.SetCurrentZ(0);
      const t = tempQuad, r = tempRect;
      t.set(0, -1, 0, -1, 2, 1, 0, 1), r.set(0, -1, 2, 1), this.Quad3(t, r), e || this.SetNormalizedCoordsProgramVariant(false);
    }
    _ResolveMultisampledRenderTarget(e) {
      this._MaybeDoPendingClearRenderPass(e), this._MaybeEndRenderPass();
      this._commandEncoder["beginRenderPass"]({ "colorAttachments": [{ "view": e.GetTexture()._GetTextureView(), "resolveTarget": this._currentRenderTarget.GetTexture()._GetTextureView(), "loadOp": "load", "storeOp": "store" }] })["end"](), this._flags |= 16384;
    }
    CoplanarStartStencilPass() {
      this._MaybeEndRenderPass(), this.SetDepthEnabled(true), this._flags |= 41943040;
    }
    CoplanarStartColorPass(e = false) {
      this._MaybeEndRenderPass(), this.SetDepthEnabled(e), this._flags &= -8388609, this._flags |= 16777216;
    }
    IsCoplanarColorPass() {
      return this._IsFlagSet(16777216);
    }
    CoplanarRestoreStandardRendering(e = true) {
      this._MaybeEndRenderPass(), this.SetDepthEnabled(e), this._flags &= -16777217;
    }
    _InitBlendModes() {
      this._InitBlendModeData([["normal", ["one", "one-minus-src-alpha"]], ["additive", ["one", "one"]], ["xor", ["one", "one-minus-src-alpha"]], ["copy", ["one", "zero"]], ["destination-over", ["one-minus-dst-alpha", "one"]], ["source-in", ["dst-alpha", "zero"]], ["destination-in", ["zero", "src-alpha"]], ["source-out", ["one-minus-dst-alpha", "zero"]], ["destination-out", ["zero", "one-minus-src-alpha"]], ["source-atop", ["dst-alpha", "one-minus-src-alpha"]], ["destination-atop", ["one-minus-dst-alpha", "src-alpha"]], ["lighten", ["one", "one", "one", "one", "max", "max"]], ["darken", ["one", "one", "one", "one", "min", "min"]], ["multiply", ["dst", "one-minus-src-alpha", "one", "one-minus-src-alpha"]], ["screen", ["one", "one-minus-src", "one", "one-minus-src-alpha"]]]);
    }
    GetAvailableAdapterFeatures() {
      return this._adapter ? [...this._adapter["features"]] : [];
    }
    GetAdapterInfo() {
      return this._adapterInfo;
    }
    GetAdapterInfoString() {
      const e = this._adapterInfo;
      if (!e) return "unknown/unknown";
      const t = e["vendor"] || "unknown", r = e["architecture"] || "unknown", i = [];
      e["device"] && i.push(e["device"]), e["description"] && i.push(e["description"]), e["type"] && i.push(e["type"]), e["backend"] && i.push(e["backend"]);
      return t + "/" + r + (i.length > 0 ? ` (${i.join(", ")})` : "");
    }
  };
}
{
  const C32 = self.C3, ENABLE_RECYCLING = true;
  C32.Gfx.WebGPUBufferManager = class {
    constructor(e) {
      this._renderer = e, this._buffers = /* @__PURE__ */ new Map(), this._recycleAfterSubmit = [], this._releaseAfterSubmit = [], this._destroyAfterSubmit = [], this._totalBufferCount = 0, this._totalBufferSize = 0, this._totalCreated = 0, this._totalReleased = 0, this._totalReturned = 0, this._totalRecycled = 0;
    }
    GetRenderer() {
      return this._renderer;
    }
    OnContextLost() {
      this._buffers.clear(), C32.clearArray(this._recycleAfterSubmit), C32.clearArray(this._releaseAfterSubmit), C32.clearArray(this._destroyAfterSubmit);
    }
    _RoundBufferSizeClass(e) {
      return Math.max(C32.nextHighestPowerOfTwo(e), 16);
    }
    GetRecyclableBuffer(e) {
      this._totalReturned++;
      const t = this._RoundBufferSizeClass(e);
      {
        const e2 = this._buffers.get(t);
        if (void 0 !== e2 && e2.length > 0) {
          const r = e2.pop();
          return r.MarkInUse(), 0 === e2.length && this._buffers.delete(t), r;
        }
      }
      return this._totalBufferCount++, this._totalBufferSize += t, this._totalCreated++, C32.New(C32.Gfx.WebGPURecyclableBuffer, this, t);
    }
    _AddRecycledBuffer(e) {
      this._totalRecycled++;
      const t = e.GetSize(), r = this._buffers.get(t);
      void 0 === r ? this._buffers.set(t, [e]) : r.push(e);
    }
    _DestroyAfterSubmit(e) {
      this._destroyAfterSubmit.push(e);
    }
    AfterSubmit() {
      for (const e of this._recycleAfterSubmit) e.Recycle();
      C32.clearArray(this._recycleAfterSubmit);
      for (const e of this._releaseAfterSubmit) this._totalBufferCount--, this._totalBufferSize -= e.GetSize(), e.Release();
      C32.clearArray(this._releaseAfterSubmit);
      for (const e of this._destroyAfterSubmit) e["destroy"]();
      C32.clearArray(this._destroyAfterSubmit);
    }
    MaybeCollectUnusedBuffers(e) {
      e % 30 == 0 && this._CollectUnusedBuffers(e);
    }
    _CollectUnusedBuffers(e) {
      for (const [t, r] of this._buffers.entries()) {
        let s = 0;
        for (let t2 = 0, f = r.length; t2 < f; ++t2) {
          const f2 = r[t2];
          f2._ShouldCollect(e) ? (this._totalBufferCount--, this._totalBufferSize -= f2.GetSize(), f2.Release(), this._totalReleased++) : (r[s] = f2, ++s);
        }
        0 === s ? this._buffers.delete(t) : C32.truncateArray(r, s);
      }
      this._DebugLogBufferMap();
    }
    UpdateBufferSubData(e, t, r, s, f) {
      const i = this.GetRecyclableBuffer(f), u = i.GetBuffer(), l = u["getMappedRange"](0, f);
      new Uint8Array(l).set(new Uint8Array(r, s, f)), u["unmap"](), e["copyBufferToBuffer"](u, 0, t, s, f), this._recycleAfterSubmit.push(i);
    }
    _DebugLogBufferMap() {
      this._totalCreated = 0, this._totalReleased = 0, this._totalReturned = 0, this._totalRecycled = 0;
    }
  };
}
{
  const C32 = self.C3, GPUBufferUsage = self["GPUBufferUsage"], GPUMapMode = self["GPUMapMode"], assert = self.assert, STATE_AVAILABLE = 0, STATE_IN_USE = 1, STATE_RECYCLING = 2;
  C32.Gfx.WebGPURecyclableBuffer = class {
    constructor(e, t) {
      this._bufferManager = e, this._state = 1, this._size = t, this._buffer = this.GetRenderer()._GetDevice()["createBuffer"]({ "mappedAtCreation": true, "size": t, "usage": GPUBufferUsage["COPY_SRC"] | GPUBufferUsage["MAP_WRITE"] }), this._recycledFrameNumber = 0;
    }
    GetRenderer() {
      return this._bufferManager.GetRenderer();
    }
    GetState() {
      return this._state;
    }
    GetSize() {
      return this._size;
    }
    GetBuffer() {
      return this._buffer;
    }
    MarkInUse() {
      this._state = 1;
    }
    async Recycle() {
      this._state = 2;
      try {
        await this._buffer["mapAsync"](GPUMapMode["WRITE"]);
      } catch (e) {
        return void console.warn("[WebGPU] Error recycling buffer, assuming device was lost: ", e);
      }
      this.GetRenderer().IsContextLost() || (this._state = 0, this._recycledFrameNumber = this.GetRenderer().GetFrameNumber(), this._bufferManager._AddRecycledBuffer(this));
    }
    Discard() {
      this._state = 0;
    }
    _ShouldCollect(e) {
      return this._recycledFrameNumber <= e - 25;
    }
    Release() {
      this._buffer["destroy"](), this._buffer = null, this._bufferManager = null;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert, GPUBufferUsage = self["GPUBufferUsage"];
  C32.Gfx.WebGPUEffectCustomParamsBuffer = class {
    constructor(e) {
      const r = e.GetRenderer();
      this._shaderProgram = e, this._byteSize = e.GetCustomParametersByteSize(), this._arrayBuffer = new ArrayBuffer(this._byteSize), this._f32arr = new Float32Array(this._arrayBuffer), this._isChanged = false, this._buffer = r._GetDevice()["createBuffer"]({ "size": this._byteSize, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._bufferBindGroup = r._CreateBufferBindGroup(this._buffer);
    }
    Release() {
      this.GetRenderer()._OnBufferBindGroupDestroyed(this._bufferBindGroup), this.GetRenderer().GetBufferManager()._DestroyAfterSubmit(this._buffer), this._buffer = null, this._shaderProgram = null, this._arrayBuffer = null, this._f32arr = null, this._bufferBindGroup = null;
    }
    GetRenderer() {
      return this._shaderProgram.GetRenderer();
    }
    GetShaderProgram() {
      return this._shaderProgram;
    }
    GetBufferBindGroup() {
      return this._bufferBindGroup;
    }
    SetParameterValue(e, r) {
      const t = this._shaderProgram._GetCustomParameterInfo(e), s = t.type, f = t.offset / 4, a = this._f32arr;
      if ("color" === s) {
        if (r.equalsRGBF32Array(a, f)) return;
        r.writeRGBToTypedArray(a, f), this._isChanged = true;
      } else {
        if ("float" !== s && "percent" !== s) throw new Error(`unexpected shader param type '${s}'`);
        if (a[f] === Math.fround(r)) return;
        a[f] = r, this._isChanged = true;
      }
    }
    IsChanged() {
      return this._isChanged;
    }
    UpdateBuffer(e) {
      this.GetRenderer().GetBufferManager().UpdateBufferSubData(e, this._buffer, this._arrayBuffer, 0, this._byteSize), this._isChanged = false;
    }
  };
}
{
  let UpdateLayoutEndValues = function(t) {
    for (const e of Object.values(t)) e.end = e.offset + e.size;
  }, makeNullFilledArray = function(t) {
    const e = [];
    for (let n = 0; n < t; ++n) e.push(null);
    return e;
  }, GetFragmentInputStructDeclaration = function(t) {
    return `
struct FragmentInput {
	@location(1) fragUV : vec2<f32>,
	@location(2) fragColor : vec4<${t ? "f16" : "f32"}>,
	@builtin(position) fragPos : vec4<f32>
};

fn c3_getBackUV(fragPos : vec2<f32>, texBack : texture_2d<f32>) -> vec2<f32>
{
	return fragPos / vec2<f32>(textureDimensions(texBack));
}

fn c3_getDepthUV(fragPos : vec2<f32>, texDepth : texture_depth_2d) -> vec2<f32>
{
	return fragPos / vec2<f32>(textureDimensions(texDepth));
}
`;
  }, HashPipelineState = function(t, e, n, r, a) {
    return t << 10 | e << 7 | n << 5 | r << 4 | a;
  };
  UpdateLayoutEndValues2 = UpdateLayoutEndValues, makeNullFilledArray2 = makeNullFilledArray, GetFragmentInputStructDeclaration2 = GetFragmentInputStructDeclaration, HashPipelineState2 = HashPipelineState;
  const C32 = self.C3, SIZEOF_F32 = 4, SIZEOF_F16 = 2, SIZEOF_U32 = 4, SIZEOF_VEC2_F32 = 8, SIZEOF_VEC4_F32 = 16, SIZEOF_MAT4_F32 = 64;
  const vertexUniformBufferDeclaration = "\nstruct Uniforms {\n	transform		: mat4x4<f32>,\n	pointTexStart	: vec2<f32>,\n	pointTexEnd		: vec2<f32>,\n	zElevation		: f32\n};\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n", vubLayout = { transform: { offset: 0, size: 64, end: 0 }, pointTex: { offset: 64, size: 16, end: 0 }, pointTexStart: { offset: 64, size: 8, end: 0 }, pointTexEnd: { offset: 72, size: 8, end: 0 }, zElevation: { offset: 80, size: 4, end: 0 } };
  UpdateLayoutEndValues(vubLayout);
  const vubSize = vubLayout.zElevation.end, fragmentUniformBufferDeclaration = "\nstruct Uniforms {\n	color2				: vec4<f32>,\n	pointColor 			: vec4<f32>,\n	tileSize			: vec2<f32>,\n	tileSpacing			: vec2<f32>,\n	srcRectStart		: vec2<f32>,\n	srcRectEnd			: vec2<f32>,\n	pixelSize			: vec2<f32>,\n	outlineThickness	: f32\n};\n@binding(1) @group(0) var<uniform> uniforms : Uniforms;\n", fubLayout = { color2: { offset: 0, size: 16, end: 0 }, pointColor: { offset: 16, size: 16, end: 0 }, tileSize: { offset: 32, size: 8, end: 0 }, tileSpacing: { offset: 40, size: 8, end: 0 }, srcRect: { offset: 48, size: 16, end: 0 }, srcRectStart: { offset: 48, size: 8, end: 0 }, srcRectEnd: { offset: 56, size: 8, end: 0 }, pixelSize: { offset: 64, size: 8, end: 0 }, outlineThickness: { offset: 72, size: 4, end: 0 } };
  UpdateLayoutEndValues(fubLayout);
  const fubSize = fubLayout.outlineThickness.end, c3ParamsUniformBufferDeclaration = "\nstruct C3Params {\n	srcStart			: vec2<f32>,\n	srcEnd				: vec2<f32>,\n	srcOriginStart		: vec2<f32>,\n	srcOriginEnd		: vec2<f32>,\n	layoutStart			: vec2<f32>,\n	layoutEnd			: vec2<f32>,\n	destStart			: vec2<f32>,\n	destEnd				: vec2<f32>,\n	devicePixelRatio	: f32,\n	layerScale			: f32,\n	layerAngle			: f32,\n	seconds				: f32,\n	zNear				: f32,\n	zFar				: f32,\n	isSrcTexRotated		: u32\n};\n@binding(4) @group(0) var<uniform> c3Params : C3Params;\n\nfn c3_srcToNorm(p : vec2<f32>) -> vec2<f32>\n{\n	return (p - c3Params.srcStart) / (c3Params.srcEnd - c3Params.srcStart);\n}\n\nfn c3_normToSrc(p : vec2<f32>) -> vec2<f32>\n{\n	return fma(p, c3Params.srcEnd - c3Params.srcStart, c3Params.srcStart);\n}\n\nfn c3_clampToSrc(p : vec2<f32>) -> vec2<f32>\n{\n	return clamp(p, min(c3Params.srcStart, c3Params.srcEnd), max(c3Params.srcStart, c3Params.srcEnd));\n}\n\nfn c3_srcOriginToNorm(p : vec2<f32>) -> vec2<f32>\n{\n	return (p - c3Params.srcOriginStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart);\n}\n\nfn c3_normToSrcOrigin(p : vec2<f32>) -> vec2<f32>\n{\n	return fma(p, c3Params.srcOriginEnd - c3Params.srcOriginStart, c3Params.srcOriginStart);\n}\n\nfn c3_clampToSrcOrigin(p : vec2<f32>) -> vec2<f32>\n{\n	return clamp(p, min(c3Params.srcOriginStart, c3Params.srcOriginEnd), max(c3Params.srcOriginStart, c3Params.srcOriginEnd));\n}\n\nfn c3_getLayoutPos(p : vec2<f32>) -> vec2<f32>\n{\n	return fma(p - c3Params.srcOriginStart, (c3Params.layoutEnd - c3Params.layoutStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart), c3Params.layoutStart);\n}\n\nfn c3_srcToDest(p : vec2<f32>) -> vec2<f32>\n{\n	return fma(p - c3Params.srcStart, (c3Params.destEnd - c3Params.destStart) / (c3Params.srcEnd - c3Params.srcStart), c3Params.destStart);\n}\n\nfn c3_clampToDest(p : vec2<f32>) -> vec2<f32>\n{\n	return clamp(p, min(c3Params.destStart, c3Params.destEnd), max(c3Params.destStart, c3Params.destEnd));\n}\n\nfn c3_linearizeDepth(depthSample : f32) -> f32\n{\n	return c3Params.zNear * c3Params.zFar / (c3Params.zFar + depthSample * (c3Params.zNear - c3Params.zFar));\n}\n", C3PARAMS_TERMS_REFERENCING_SRC_RECTS = ["srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "c3_srcToNorm", "c3_normToSrc", "c3_clampToSrc", "c3_srcOriginToNorm", "c3_normToSrcOrigin", "c3_clampToSrcOrigin", "c3_getLayoutPos", "c3_srcToDest"], C3PARAMS_TERMS_REFERENCING_OTHER_RECTS = ["layoutStart", "layoutEnd", "destStart", "destEnd", "c3_clampToDest"], c3ParamsLayout = { srcRect: { offset: 0, size: 16, end: 0 }, srcStart: { offset: 0, size: 8, end: 0 }, srcEnd: { offset: 8, size: 8, end: 0 }, srcOriginRect: { offset: 16, size: 16, end: 0 }, srcOriginStart: { offset: 16, size: 8, end: 0 }, srcOriginEnd: { offset: 24, size: 8, end: 0 }, layoutRect: { offset: 32, size: 16, end: 0 }, layoutStart: { offset: 32, size: 8, end: 0 }, layoutEnd: { offset: 40, size: 8, end: 0 }, destRect: { offset: 48, size: 16, end: 0 }, destStart: { offset: 48, size: 8, end: 0 }, destEnd: { offset: 56, size: 8, end: 0 }, devicePixelRatio: { offset: 64, size: 4, end: 0 }, layerScale: { offset: 68, size: 4, end: 0 }, layerAngle: { offset: 72, size: 4, end: 0 }, seconds: { offset: 76, size: 4, end: 0 }, zNear: { offset: 80, size: 4, end: 0 }, zFar: { offset: 84, size: 4, end: 0 }, isSrcTexRotated: { offset: 88, size: 4, end: 0 } };
  UpdateLayoutEndValues(c3ParamsLayout);
  const c3ParamsSize = c3ParamsLayout.isSrcTexRotated.end;
  const fragmentOutputStructDeclaration = "\nstruct FragmentOutput {\n	@location(0) color : vec4<f32>\n};\n", shaderCustomParamSizes = /* @__PURE__ */ new Map([["float", 4], ["percent", 4], ["color", 12]]), shaderCustomParamAlignSizes = /* @__PURE__ */ new Map([["float", 4], ["percent", 4], ["color", 16]]), c3WGSLUtilityFunctionsLib = "\nfn c3_premultiply(c : vec4<f32>) -> vec4<f32>\n{\n	return vec4<f32>(c.rgb * c.a, c.a);\n}\n\nfn c3_unpremultiply(c : vec4<f32>) -> vec4<f32>\n{\n	if (c.a == 0.0)\n	{\n		return vec4<f32>(0.0);\n	}\n	\n	return vec4<f32>(c.rgb / c.a, c.a);\n}\n\nfn c3_grayscale(rgb : vec3<f32>) -> f32\n{\n	return dot(rgb, vec3<f32>(0.299, 0.587, 0.114));\n}\n\nfn c3_getPixelSize(t : texture_2d<f32>) -> vec2<f32>\n{\n	return vec2<f32>(1.0) / vec2<f32>(textureDimensions(t));\n}\n\nfn c3_clamp2(v : vec2<f32>, l : f32, u : f32) -> vec2<f32>\n{\n	return clamp(v, vec2<f32>(l), vec2<f32>(u));\n}\n\nfn c3_mod(x : f32, y : f32) -> f32\n{\n	return x - y * floor(x / y);\n}\n\nfn c3_mod2(x : vec2<f32>, y : vec2<f32>) -> vec2<f32>\n{\n	return x - y * floor(x / y);\n}\n\nfn c3_RGBtoHSL(color : vec3<f32>) -> vec3<f32>\n{\n	var hsl : vec3<f32> = vec3<f32>(0.0);\n	\n	var fmin : f32 = min(min(color.r, color.g), color.b);\n	var fmax : f32 = max(max(color.r, color.g), color.b);\n	var delta : f32 = fmax - fmin;\n\n	hsl.z = (fmax + fmin) / 2.0;\n\n	if (delta == 0.0)\n	{\n		hsl.x = 0.0;\n		hsl.y = 0.0;\n	}\n	else \n	{\n		if (hsl.z < 0.5)\n		{\n			hsl.y = delta / (fmax + fmin);\n		}\n		else\n		{\n			hsl.y = delta / (2.0 - fmax - fmin);\n		}\n		\n		var dR : f32 = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n		var dG : f32 = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n		var dB : f32 = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n		if (color.r == fmax)\n		{\n			hsl.x = dB - dG;\n		}\n		else if (color.g == fmax)\n		{\n			hsl.x = (1.0 / 3.0) + dR - dB;\n		}\n		else if (color.b == fmax)\n		{\n			hsl.x = (2.0 / 3.0) + dG - dR;\n		}\n\n		if (hsl.x < 0.0)\n		{\n			hsl.x = hsl.x + 1.0;\n		}\n		else if (hsl.x > 1.0)\n		{\n			hsl.x = hsl.x - 1.0;\n		}\n	}\n\n	return hsl;\n}\n\nfn c3_hueToRGB(f1 : f32, f2 : f32, hue_ : f32) -> f32\n{\n	var hue : f32 = hue_;\n	if (hue < 0.0)\n	{\n		hue = hue + 1.0;\n	}\n	else if (hue > 1.0)\n	{\n		hue = hue - 1.0;\n	}\n		\n	var ret : f32;\n	\n	if ((6.0 * hue) < 1.0)\n	{\n		ret = f1 + (f2 - f1) * 6.0 * hue;\n	}\n	else if ((2.0 * hue) < 1.0)\n	{\n		ret = f2;\n	}\n	else if ((3.0 * hue) < 2.0)\n	{\n		ret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n	}\n	else\n	{\n		ret = f1;\n	}\n	\n	return ret;\n}\n\nfn c3_HSLtoRGB(hsl : vec3<f32>) -> vec3<f32>\n{\n	var rgb : vec3<f32> = vec3<f32>(hsl.z);\n	\n	if (hsl.y != 0.0)\n	{\n		var f2 : f32;\n		\n		if (hsl.z < 0.5)\n		{\n			f2 = hsl.z * (1.0 + hsl.y);\n		}\n		else\n		{\n			f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n		}\n			\n		var f1 : f32 = 2.0 * hsl.z - f2;\n		\n		rgb.r = c3_hueToRGB(f1, f2, hsl.x + (1.0 / 3.0));\n		rgb.g = c3_hueToRGB(f1, f2, hsl.x);\n		rgb.b = c3_hueToRGB(f1, f2, hsl.x - (1.0 / 3.0));\n	}\n	\n	return rgb;\n}\n";
  C32.Gfx.WebGPUShaderProgram = class extends C32.Gfx.ShaderProgramBase {
    constructor(t, e) {
      if (super(t, e), this._fragmentModule = e.fragmentModule, this._fragmentModuleFragDepth = e.fragmentModuleFragDepth, this._vertexModule = e.vertexModule, this._normVertexModule = e.normVertexModule, this._renderPipelineMap = /* @__PURE__ */ new Map(), this._mipmapPipelineMap = /* @__PURE__ */ new Map(), this._usesAnyC3ParamRect = false, this._usesIsSrcTexRotated = false, this._parameters = [], this._customParamsByteSize = 0, e.parameters) {
        let t2 = 0;
        for (const n of e.parameters) {
          const e2 = n[2];
          if (!shaderCustomParamSizes.has(e2)) throw new Error(`unrecognized effect param type '${e2}'`);
          const r = shaderCustomParamSizes.get(e2), a = shaderCustomParamAlignSizes.get(e2), i = t2 % a;
          0 !== i && (t2 += a - i), this._parameters.push({ type: e2, offset: t2, size: r, end: t2 + r }), t2 += r;
        }
        this._customParamsByteSize = 16 * Math.ceil(t2 / 16);
      }
    }
    static async Create(t, e) {
      const n = t._GetDevice(), r = e.name, a = t.SupportsF16(), i = t.IsColorDataF16(), o = e.src, u = C32.Gfx.WebGPUShaderProgram._PreprocessFragmentShaderCode(o, a, i), f = n["createShaderModule"]({ "label": r, "code": u });
      let c, s = null;
      if (e.srcFragDepth) {
        const t2 = C32.Gfx.WebGPUShaderProgram._PreprocessFragmentShaderCode(e.srcFragDepth, a, i);
        s = n["createShaderModule"]({ "label": r, "code": t2 });
      }
      f["getCompilationInfo"]().then((t2) => C32.Gfx.WebGPUShaderProgram.ReportShaderCompilationInfo(r, "fragment", t2));
      const l = C32.Gfx.WebGPUShaderProgram._PreprocessVertexShaderCode(e.vertexSrc, a);
      let p;
      l ? (c = n["createShaderModule"]({ "label": r, "code": l }), c["getCompilationInfo"]().then((t2) => C32.Gfx.WebGPUShaderProgram.ReportShaderCompilationInfo(r, "vertex", t2))) : c = t._GetDefaultVertexModule();
      const d = C32.Gfx.WebGPUShaderProgram._PreprocessVertexShaderCode(e.normVertexSrc, a);
      d ? (p = n["createShaderModule"]({ "label": r, "code": d }), p["getCompilationInfo"]().then((t2) => C32.Gfx.WebGPUShaderProgram.ReportShaderCompilationInfo(r, "vertex (norm)", t2))) : p = t._GetNormalizedVertexModule();
      const m = C32.New(C32.Gfx.WebGPUShaderProgram, t, Object.assign({ fragmentModule: f, fragmentModuleFragDepth: s, vertexModule: c, normVertexModule: p }, e));
      if (m._usesAnySrcRectOrPixelSize = o.includes("%%C3PARAMS_STRUCT%%") && C3PARAMS_TERMS_REFERENCING_SRC_RECTS.some((t2) => o.includes(t2)), m._usesAnyC3ParamRect = m._usesAnySrcRectOrPixelSize || o.includes("%%C3PARAMS_STRUCT%%") && C3PARAMS_TERMS_REFERENCING_OTHER_RECTS.some((t2) => o.includes(t2)), m._usesIsSrcTexRotated = o.includes("%%C3PARAMS_STRUCT%%") && o.includes("isSrcTexRotated"), "<generate-mipmap>" !== r) {
        const e2 = m._CreateRenderPipelineAsync(0, 0, 0, 0, 0);
        let n2 = null;
        t.UsesDepthBuffer() && (n2 = m._CreateRenderPipelineAsync(0, 1, 0, 0, 0));
        const [r2, a2] = await Promise.all([e2, n2]);
        m._renderPipelineMap.set(HashPipelineState(0, 0, 0, 0, 0), r2), a2 && m._renderPipelineMap.set(HashPipelineState(0, 1, 0, 0, 0), a2);
      }
      return m;
    }
    static _PreprocessShaderCode(t, e) {
      if (!t) return t;
      let n = "";
      return n = e ? "enable f16;\nalias f16or32 = f16;\n" : "alias f16or32 = f32;\n", n + t;
    }
    static _PreprocessFragmentShaderCode(t, e, n) {
      return t = C32.Gfx.WebGPUShaderProgram._PreprocessShaderCode(t, e), C32.StringSubstituteMap(t, { "%%SAMPLERFRONT_BINDING%%": "@binding(0) @group(1)", "%%TEXTUREFRONT_BINDING%%": "@binding(1) @group(1)", "%%SAMPLERBACK_BINDING%%": "@binding(0) @group(2)", "%%TEXTUREBACK_BINDING%%": "@binding(1) @group(2)", "%%SAMPLERDEPTH_BINDING%%": "@binding(0) @group(3)", "%%TEXTUREDEPTH_BINDING%%": "@binding(1) @group(3)", "%%SHADERPARAMS_BINDING%%": "@binding(5) @group(0)", "%%FRAGMENTINPUT_STRUCT%%": GetFragmentInputStructDeclaration(n), "%%FRAGMENTOUTPUT_STRUCT%%": fragmentOutputStructDeclaration, "%%C3PARAMS_STRUCT%%": c3ParamsUniformBufferDeclaration, "%%C3_UTILITY_FUNCTIONS%%": c3WGSLUtilityFunctionsLib });
    }
    static _PreprocessVertexShaderCode(t, e) {
      return C32.Gfx.WebGPUShaderProgram._PreprocessShaderCode(t, e);
    }
    static ReportShaderCompilationInfo(t, e, n) {
      for (const r of n["messages"]) {
        const n2 = `[WebGPU] Message (${r["type"]}) compiling ${e} shader '${t}': ${r["message"]} (line ${r["lineNum"]}, pos ${r["linePos"]})`;
        "error" === r.type ? console.error(n2) : "warning" === r.type ? console.warn(n2) : console.log(n2);
      }
    }
    Release() {
      this._fragmentModule = null, this._fragmentModuleFragDepth = null, this._vertexModule = null, this._normVertexModule = null, this._renderPipelineMap.clear(), this._mipmapPipelineMap.clear(), super.Release();
    }
    _GetDevice() {
      return this._renderer._GetDevice();
    }
    _GetPipelineLayout() {
      return this._renderer._GetPipelineLayout();
    }
    GetRenderer() {
      return this._renderer;
    }
    UsesAnyC3ParamRect() {
      return this._usesAnyC3ParamRect;
    }
    UsesIsSrcTexRotated() {
      return this._usesIsSrcTexRotated;
    }
    GetParameterCount() {
      return this._parameters.length;
    }
    GetParameterType(t) {
      return t < 0 || t >= this._parameters.length ? null : this._parameters[t].type;
    }
    GetCustomParametersByteSize() {
      return this._customParamsByteSize;
    }
    _GetCustomParameterInfo(t) {
      return this._parameters[t];
    }
    _GetRenderPipelineDescriptor(t, e, n, r, a) {
      const i = this._renderer, o = i.IsColorDataF16(), u = i._GetBlendParametersByIndex(t);
      let f = u[0], c = u[1], s = f, l = c, p = "add", d = "add";
      u.length >= 4 && (s = u[2], l = u[3]), 6 === u.length && (p = u[4], d = u[5]);
      let m = "none";
      switch (n) {
        case 1:
          m = "back";
          break;
        case 2:
          m = "front";
      }
      const g = { "label": `${this.GetName()} blendMode ${t} variant ${e} multisampleCount ${a}`, "layout": this._GetPipelineLayout(), "primitive": { "cullMode": m, "frontFace": 0 === r ? "cw" : "ccw" }, "vertex": { "module": 4 === e ? this._normVertexModule : this._vertexModule, "entryPoint": "main", "buffers": [{ "arrayStride": 12, "attributes": [{ "shaderLocation": 0, "offset": 0, "format": "float32x3" }] }, { "arrayStride": 8, "attributes": [{ "shaderLocation": 1, "offset": 0, "format": "float32x2" }] }, { "arrayStride": 4 * (o ? 2 : 4), "attributes": [{ "shaderLocation": 2, "offset": 0, "format": o ? "float16x4" : "float32x4" }] }, { "arrayStride": 4, "attributes": [{ "shaderLocation": 3, "offset": 0, "format": "uint32" }] }] }, "fragment": { "module": this._fragmentModule, "entryPoint": "main", "targets": [{ "format": i.GetSwapChainFormat(), "blend": { "color": { "srcFactor": f, "dstFactor": c, "operation": p }, "alpha": { "srcFactor": s, "dstFactor": l, "operation": d } } }] } };
      if (a >= 2 && (g["multisample"] = { "count": a }), 1 === e) g["fragment"]["module"] = this._fragmentModuleFragDepth || this._fragmentModule, g["depthStencil"] = { "format": i._GetDepthBufferFormat(), "depthWriteEnabled": true, "depthCompare": "less-equal" };
      else if (2 === e) {
        g["fragment"]["module"] = this._fragmentModuleFragDepth || this._fragmentModule, g["fragment"]["targets"] = [];
        const t2 = { "compare": "always", "failOp": "keep", "depthFailOp": "keep", "passOp": "replace" };
        g["depthStencil"] = { "format": i._GetDepthBufferFormat(), "depthWriteEnabled": true, "depthCompare": "less-equal", "stencilFront": t2, "stencilBack": t2, "stencilReadMask": 1, "stencilWriteMask": 1 };
      } else if (3 === e) {
        g["fragment"]["module"] = this._fragmentModuleFragDepth || this._fragmentModule;
        const t2 = { "compare": "equal", "failOp": "keep", "depthFailOp": "keep", "passOp": "keep" };
        g["depthStencil"] = { "format": i._GetDepthBufferFormat(), "depthWriteEnabled": false, "depthCompare": "always", "stencilFront": t2, "stencilBack": t2, "stencilReadMask": 1, "stencilWriteMask": 0 };
      }
      return g;
    }
    _CreateRenderPipeline(t, e, n, r, a) {
      return this._GetDevice()["createRenderPipeline"](this._GetRenderPipelineDescriptor(t, e, n, r, a));
    }
    _CreateRenderPipelineAsync(t, e, n, r, a) {
      return this._GetDevice()["createRenderPipelineAsync"](this._GetRenderPipelineDescriptor(t, e, n, r, a));
    }
    GetRenderPipelineForState(t, e, n, r, a) {
      const i = HashPipelineState(t, e, n, r, a);
      let o = this._renderPipelineMap.get(i);
      return o || (o = this._CreateRenderPipeline(t, e, n, r, a), this._renderPipelineMap.set(i, o), o);
    }
    static GetVertexUniformBufferLayout() {
      return vubLayout;
    }
    static GetVertexUniformBufferSize() {
      return 16 * Math.ceil(vubSize / 16);
    }
    static GetFragmentUniformBufferLayout() {
      return fubLayout;
    }
    static GetFragmentUniformBufferSize() {
      return 16 * Math.ceil(fubSize / 16);
    }
    static GetFragmentC3ParamsBufferLayout() {
      return c3ParamsLayout;
    }
    static GetFragmentC3ParamsBufferSize() {
      return 16 * Math.ceil(c3ParamsSize / 16);
    }
    static GetDefaultVertexShaderSource(t) {
      const e = t ? "f16" : "f32";
      return `
		${vertexUniformBufferDeclaration}

		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) uv : vec2<f32>,
			@location(2) color : vec4<${e}>,
			@location(3) texIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e}>,
			@location(3) @interpolate(flat, either) texIndex : u32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			output.Position = uniforms.transform * vec4<f32>(input.position, 1.0);
			output.fragUV = input.uv;
			output.fragColor = input.color;
			output.texIndex = input.texIndex;
			return output;
		}`;
    }
    static GetNormalizedVertexShaderSource(t) {
      const e = t ? "f16" : "f32";
      return `
		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) uv : vec2<f32>,
			@location(2) color : vec4<${e}>,
			@location(3) texIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e}>,
			@location(3) @interpolate(flat, either) texIndex : u32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			var p = input.position;
			p.y = 1.0 - p.y;
			output.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);
			output.fragUV = input.uv;
			output.texIndex = input.texIndex;
			output.fragColor = input.color;
			return output;
		}`;
    }
    static GetTextureFillVertexShaderSource(t) {
      const e = t ? "f16" : "f32";
      return `
		${vertexUniformBufferDeclaration}

		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) uv : vec2<f32>,
			@location(2) color : vec4<${e}>,
			@location(3) texIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e}>,
			@location(3) @interpolate(flat, either) texIndex : u32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			output.Position = uniforms.transform * vec4<f32>(input.position, 1.0);
			output.fragUV = input.uv;
			output.fragColor = input.color;
			output.texIndex = input.texIndex;
			return output;
		}`;
    }
    static GetNormalizedTextureFillVertexShaderSource(t) {
      const e = t ? "f16" : "f32";
      return `
		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) uv : vec2<f32>,
			@location(2) color : vec4<${e}>,
			@location(3) texIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e}>,
			@location(3) @interpolate(flat, either) texIndex : u32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			var p = input.position;
			p.y = 1.0 - p.y;
			output.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);
			output.fragUV = input.uv;
			output.fragColor = input.color;
			output.texIndex = input.texIndex;
			return output;
		}`;
    }
    static GetMultiTextureFillFragmentShaderSource(t, e) {
      return `
		@binding(0) @group(1) var sampler0 : sampler;
		@binding(1) @group(1) var texture0 : texture_2d<f32>;
		@binding(2) @group(1) var sampler1 : sampler;
		@binding(3) @group(1) var texture1 : texture_2d<f32>;
		@binding(4) @group(1) var sampler2 : sampler;
		@binding(5) @group(1) var texture2 : texture_2d<f32>;
		@binding(6) @group(1) var sampler3 : sampler;
		@binding(7) @group(1) var texture3 : texture_2d<f32>;
		@binding(8) @group(1) var sampler4 : sampler;
		@binding(9) @group(1) var texture4 : texture_2d<f32>;
		@binding(10) @group(1) var sampler5 : sampler;
		@binding(11) @group(1) var texture5 : texture_2d<f32>;
		@binding(12) @group(1) var sampler6 : sampler;
		@binding(13) @group(1) var texture6 : texture_2d<f32>;
		@binding(14) @group(1) var sampler7 : sampler;
		@binding(15) @group(1) var texture7 : texture_2d<f32>;
		@binding(16) @group(1) var sampler8 : sampler;
		@binding(17) @group(1) var texture8 : texture_2d<f32>;
		@binding(18) @group(1) var sampler9 : sampler;
		@binding(19) @group(1) var texture9 : texture_2d<f32>;
		@binding(20) @group(1) var sampler10 : sampler;
		@binding(21) @group(1) var texture10 : texture_2d<f32>;
		@binding(22) @group(1) var sampler11 : sampler;
		@binding(23) @group(1) var texture11 : texture_2d<f32>;
		@binding(24) @group(1) var sampler12 : sampler;
		@binding(25) @group(1) var texture12 : texture_2d<f32>;
		@binding(26) @group(1) var sampler13 : sampler;
		@binding(27) @group(1) var texture13 : texture_2d<f32>;

		struct FragmentInput {
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e ? "f16" : "f32"}>,
			@location(3) @interpolate(flat, either) texIndex : u32,
			${t ? "@builtin(position) fragPos: vec4<f32>" : ""}
		};

		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var texXy : vec2<f32> = input.fragUV.xy;
			var texIndex : u32 = input.texIndex;
			var c : vec4<f32>;

			let dx = dpdx(texXy);
			let dy = dpdy(texXy);
			
			if (texIndex <= 6)
			{
				if (texIndex <= 2)
				{
					if (texIndex == 0)			{	c = textureSampleGrad(texture0, sampler0, texXy, dx, dy);	}
					else
					{
						if (texIndex == 1)		{	c = textureSampleGrad(texture1, sampler1, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture2, sampler2, texXy, dx, dy);	}
					}						
				}
				else
				{
					if (texIndex <= 4)
					{
						if (texIndex == 3)		{	c = textureSampleGrad(texture3, sampler3, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture4, sampler4, texXy, dx, dy);	}
					}
					else
					{
						if (texIndex <= 5)		{	c = textureSampleGrad(texture5, sampler5, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture6, sampler6, texXy, dx, dy);	}
					}
				}
			}
			else
			{
				if (texIndex <= 9)
				{
					if (texIndex == 7)			{	c = textureSampleGrad(texture7, sampler7, texXy, dx, dy);	}
					else
					{
						if (texIndex == 8)		{	c = textureSampleGrad(texture8, sampler8, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture9, sampler9, texXy, dx, dy);	}
					}						
				}
				else
				{
					if (texIndex <= 11)
					{
						if (texIndex == 10)		{	c = textureSampleGrad(texture10, sampler10, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture11, sampler11, texXy, dx, dy);	}
					}
					else
					{
						if (texIndex == 12)		{	c = textureSampleGrad(texture12, sampler12, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture13, sampler13, texXy, dx, dy);	}
					}
				}
			}

			output.color = c * vec4<f32>(input.fragColor);
			${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
    }
    static GetSingleTextureFillFragmentShaderSource(t, e) {
      return `
		@binding(0) @group(1) var sampler0 : sampler;
		@binding(1) @group(1) var texture0 : texture_2d<f32>;

		struct FragmentInput {
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e ? "f16" : "f32"}>,
			${t ? "@builtin(position) fragPos: vec4<f32>" : ""}
		};

		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			output.color = textureSample(texture0, sampler0, input.fragUV) * vec4<f32>(input.fragColor);
			${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
    }
    static _GetMipmapGeneratorVertexSource() {
      return "\n		struct VertexInput {\n			@builtin(vertex_index) VertexIndex : u32\n		};\n		\n		struct VertexOutput {\n			@builtin(position) Position : vec4<f32>,\n			@location(0) fragUV : vec2<f32>\n		};\n\n		@vertex\n		fn main(input : VertexInput) -> VertexOutput {\n\n			var pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n				vec2<f32>(-1.0, 1.0),\n				vec2<f32>(1.0, 1.0),\n				vec2<f32>(-1.0, -1.0),\n				vec2<f32>(1.0, -1.0));\n			\n			var output : VertexOutput;\n			var p : vec2<f32> = pos[input.VertexIndex];\n			output.Position = vec4<f32>(p, 0.0, 1.0);\n			output.fragUV = p / 2.0 + 0.5;\n			return output;\n		}";
    }
    static _GetMipmapGeneratorFragmentSource() {
      return "\n		@binding(0) @group(0) var sampler0 : sampler;\n		@binding(1) @group(0) var texture0 : texture_2d<f32>;\n\n		struct FragmentInput {\n			@location(0) fragUV : vec2<f32>\n		};\n\n		struct FragmentOutput {\n			@location(0) color : vec4<f32>\n		};\n\n		@fragment\n		fn main(input : FragmentInput) -> FragmentOutput {\n			var output : FragmentOutput;\n			output.color = textureSample(texture0, sampler0, vec2<f32>(input.fragUV.x, 1.0 - input.fragUV.y));\n			return output;\n		}";
    }
    _GetMipmapGeneratorPipeline(t) {
      t || (t = this._renderer.GetTextureFormat());
      let e = this._mipmapPipelineMap.get(t);
      return e || (e = this._GetDevice()["createRenderPipeline"]({ "label": "<mipmap generator>", "layout": "auto", "vertex": { "module": this._vertexModule, "entryPoint": "main" }, "primitive": { "topology": "triangle-strip", "stripIndexFormat": "uint16" }, "fragment": { "module": this._fragmentModule, "entryPoint": "main", "targets": [{ "format": t, "blend": { "color": { "srcFactor": "one", "dstFactor": "zero" }, "alpha": { "srcFactor": "one", "dstFactor": "zero" } } }] } }), this._mipmapPipelineMap.set(t, e)), e;
    }
    static _GetPointVertexSource() {
      return `
		${vertexUniformBufferDeclaration}

		struct PointData {
			data : array<vec4<f32>>
		};
		@binding(3) @group(0) var<storage> pointBuffer : PointData;

		struct VertexInput {
			@builtin(vertex_index) VertexIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(0) fragUV : vec2<f32>,
			@location(1) pointOpacity : f32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {

			var normPos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
				vec2<f32>(-0.5, -0.5),
				vec2<f32>(0.5, -0.5),
				vec2<f32>(0.5, 0.5),
				vec2<f32>(-0.5, 0.5));
			
			var output : VertexOutput;
			var p : vec2<f32> = normPos[input.VertexIndex % u32(4)];
			var pointData : vec4<f32> = pointBuffer.data[input.VertexIndex / u32(4)];

			var size : f32 = pointData.z;
			output.Position = uniforms.transform * vec4<f32>(p * size + pointData.xy, uniforms.zElevation, 1.0);
			output.pointOpacity = pointData.w;

			var pointTexMin : vec2<f32> = min(uniforms.pointTexStart, uniforms.pointTexEnd);
			var pointTexMax : vec2<f32> = max(uniforms.pointTexStart, uniforms.pointTexEnd);
			var pn : vec2<f32> = p + vec2<f32>(0.5, 0.5);
			var pointCoord : vec2<f32> = select(vec2<f32>(1.0 - pn.y, pn.x), pn, uniforms.pointTexEnd.x > uniforms.pointTexStart.x);

			output.fragUV = mix(pointTexMin, pointTexMax, pointCoord);
			return output;
		}`;
    }
    static _GetPointFragmentSource(t) {
      return `
		${fragmentUniformBufferDeclaration}

		%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
		%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

		struct FragmentInput {
			@location(0) fragUV : vec2<f32>,
			@location(1) pointOpacity : f32,
			@builtin(position) fragPos : vec4<f32>
		};
		
		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			output.color = textureSample(texture0, sampler0, input.fragUV) * uniforms.pointColor * input.pointOpacity;
			${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
    }
    static _GetTilemapFragmentShaderSource(t) {
      return `
		${fragmentUniformBufferDeclaration}

		%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
		%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

		%%FRAGMENTINPUT_STRUCT%%
		
		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var halfPixelSize : vec2<f32> = vec2<f32>(0.5, 0.5) / vec2<f32>(textureDimensions(texture0));

			var tile : vec2<f32> = floor(input.fragUV);
			var tex : vec2<f32> = fract(input.fragUV);
			var tileOrigin : vec2<f32> = uniforms.srcRectStart + tile * (uniforms.tileSize + uniforms.tileSpacing);
			var lowerBound : vec2<f32> = tileOrigin + halfPixelSize;
			var upperBound : vec2<f32> = tileOrigin + uniforms.tileSize - halfPixelSize;

			output.color = textureSampleLevel(texture0, sampler0, clamp(tex, lowerBound, upperBound), 0.0) * vec4<f32>(input.fragColor);
			${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
    }
    static GetTileRandomizationFragmentShaderSource(t) {
      return `
${fragmentUniformBufferDeclaration}

%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

%%FRAGMENTINPUT_STRUCT%%

struct FragmentOutput {
	@location(0) color : vec4<f32>,
	${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
};

%%C3_UTILITY_FUNCTIONS%%

const PI : f32 = 3.1415926;

fn cospVec4(a : vec4<f32>, b : vec4<f32>, x : f32) -> vec4<f32>
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

fn randVec3(seed : vec2<f32>) -> vec3<f32>
{
	return vec3<f32>(
		fract(sin(dot(seed.xy, vec2<f32>(12.9898,78.233))) * 43758.5453),
		fract(sin(dot(seed.yx, vec2<f32>(12.9898,-78.233))) * 43758.5453),
		fract(sin(dot(seed.xy, vec2<f32>(-12.9898,-78.233))) * 43758.5453));
}

fn sampleTile(tile : vec2<f32>, uv : vec2<f32>, ddx : vec2<f32>, ddy : vec2<f32>) -> vec4<f32>
{
	var posRandom = uniforms.tileSize;
	var angleRandom = uniforms.outlineThickness;
	var pixelSize = c3_getPixelSize(texture0);
	
	var rand = (randVec3(round(tile)) - 0.5) * 2.0;
	
	var angle = angleRandom * rand.z * PI;
	var sin_a = sin(angle);
	var cos_a = cos(angle);
	var aspect = pixelSize.x / pixelSize.y;

	var mid = tile + vec2<f32>(0.5, 0.5);
	var dp = uv - mid;
	dp.x /= aspect;
	var r = vec2<f32>(dp.x * cos_a - dp.y * sin_a,
					  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	var p = mid + r + (posRandom * rand.xy / 2.0);
	
	return textureSampleGrad(texture0, sampler0, p, ddx, ddy);
}

@fragment
fn main(input : FragmentInput) -> FragmentOutput
{
	var output : FragmentOutput;
	
	var blendMarginX = uniforms.tileSpacing.x;
	var blendMarginY = uniforms.tileSpacing.y;
	
	var tile = floor(input.fragUV);
	var tex = fract(input.fragUV);
	var ddx = dpdx(input.fragUV);
	var ddy = dpdy(input.fragUV);
	
	var curTile = sampleTile(tile, input.fragUV, ddx, ddy);
	
	var inLeftMargin = (tex.x < blendMarginX);
	var inRightMargin = (tex.x > 1.0 - blendMarginX);
	var inTopMargin = (tex.y < blendMarginY);
	var inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		var leftTile = sampleTile(tile + vec2<f32>(-1.0, 0.0), input.fragUV, ddx, ddy);
		var leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		var leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			var topTile =     sampleTile(tile + vec2<f32>(0.0,  -1.0), input.fragUV, ddx, ddy);
			var topLeftTile = sampleTile(tile + vec2<f32>(-1.0, -1.0), input.fragUV, ddx, ddy);
			var topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			output.color = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			var bottomTile =     sampleTile(tile + vec2<f32>(0.0,  1.0), input.fragUV, ddx, ddy);
			var bottomLeftTile = sampleTile(tile + vec2<f32>(-1.0, 1.0), input.fragUV, ddx, ddy);
			var bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			output.color = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			output.color = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		var rightTile = sampleTile(tile + vec2(1.0, 0.0), input.fragUV, ddx, ddy);
		var rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		var rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			var topTile =      sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);
			var topRightTile = sampleTile(tile + vec2<f32>(1.0, -1.0), input.fragUV, ddx, ddy);
			var topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			output.color = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			var bottomTile =      sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);
			var bottomRightTile = sampleTile(tile + vec2<f32>(1.0, 1.0), input.fragUV, ddx, ddy);
			var bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			output.color = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			output.color = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		var topTile = sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);
		output.color = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		var bottomTile = sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);
		output.color = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		output.color = curTile;
	}
	
	output.color *= vec4<f32>(input.fragColor);
	${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
	return output;
}
`;
    }
    static _GetColorFillFragmentShaderSource() {
      return "\n		%%FRAGMENTINPUT_STRUCT%%\n		%%FRAGMENTOUTPUT_STRUCT%%\n\n		@fragment\n		fn main(input : FragmentInput) -> FragmentOutput {\n			var output : FragmentOutput;\n			output.color = vec4<f32>(input.fragColor);\n			return output;\n		}";
    }
    static _GetLinearGradientFillFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		fn fromLinear(linearRGB : vec3<f32>) -> vec3<f32>
		{
			var cutoff : vec3<bool> = (linearRGB < vec3<f32>(0.0031308));
			var higher : vec3<f32> = vec3<f32>(1.055) * pow(abs(linearRGB), vec3<f32>(1.0/2.4)) - 0.055;
			var lower : vec3<f32> = linearRGB * 12.92;
			return select(higher, lower, cutoff);
		}

		fn toLinear(sRGB : vec3<f32>) -> vec3<f32>
		{
			var cutoff : vec3<bool> = (sRGB < vec3<f32>(0.04045));
			var higher : vec3<f32> = pow(abs((sRGB + 0.055) / 1.055), vec3<f32>(2.4));
			var lower : vec3<f32> = sRGB / 12.92;
			return select(higher, lower, cutoff);
		}

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var linearGrad : vec3<f32> = mix(toLinear(vec3<f32>(input.fragColor.rgb)), toLinear(uniforms.color2.rgb), vec3<f32>(input.fragUV.x));

			var a : f32 = mix(f32(input.fragColor.a), uniforms.color2.a, input.fragUV.x);
			output.color = vec4<f32>(fromLinear(linearGrad) * a, a);
			return output;
		}
		`;
    }
    static _GetPenumbraFillFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var grad : f32 = input.fragUV.x / (1.0 - input.fragUV.y);
			output.color = vec4<f32>(input.fragColor) * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);
			return output;
		}
		`;
    }
    static _GetHardEllipseFillFragmentShaderSource() {
      return "\n		%%FRAGMENTINPUT_STRUCT%%\n		%%FRAGMENTOUTPUT_STRUCT%%\n\n		@fragment\n		fn main(input : FragmentInput) -> FragmentOutput {\n			var output : FragmentOutput;\n			var diff : vec2<f32> = input.fragUV - 0.5;\n			var diffSq : vec2<f32> = diff * diff;\n\n			var f : f32 = step(diffSq.x + diffSq.y, 0.25);\n\n			output.color = vec4<f32>(input.fragColor) * f;\n			return output;\n		}";
    }
    static _GetHardEllipseOutlineFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var distSq : f32 = diffSq.x + diffSq.y;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;

			var innerF : f32 = step(distSq, 0.25);

			var innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm * uniforms.outlineThickness;
			var innerEdgeSq : vec2<f32> = innerEdge * innerEdge;
			var outerF : f32 = step(innerEdgeSq.x + innerEdgeSq.y, distSq);
			
			output.color = vec4<f32>(input.fragColor) * innerF * outerF;
			return output;
		}`;
    }
    static _GetSmoothEllipseFillFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;
			var halfNormSq : vec2<f32> = halfNorm * halfNorm;

			var innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm;
			var innerEdgeSq : vec2<f32> = innerEdge * innerEdge;

			var f : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);

			output.color = vec4<f32>(input.fragColor) * f;
			return output;
		}`;
    }
    static _GetSmoothEllipseOutlineFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var distSq : f32 = diffSq.x + diffSq.y;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;
			var halfNormSq : vec2<f32> = halfNorm * halfNorm;

			var pxNorm : vec2<f32> = uniforms.pixelSize * norm;
			var innerEdge1 : vec2<f32> = halfNorm - pxNorm;
			var innerEdge1Sq : vec2<f32> = innerEdge1 * innerEdge1;

			var innerF : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);

			var innerEdge2 : vec2<f32> = halfNorm - pxNorm * uniforms.outlineThickness;
			var innerEdge2Sq : vec2<f32> = innerEdge2 * innerEdge2;
			var innerEdge3 : vec2<f32> = halfNorm - pxNorm * (uniforms.outlineThickness + 1.0);
			var innerEdge3Sq : vec2<f32> = innerEdge3 * innerEdge3;

			var outerF : f32 = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);
			
			output.color = vec4<f32>(input.fragColor) * innerF * outerF;
			return output;
		}`;
    }
    static _GetSmoothLineFillFragmentShaderSource() {
      return "\n		%%FRAGMENTINPUT_STRUCT%%\n		%%FRAGMENTOUTPUT_STRUCT%%\n\n		@fragment\n		fn main(input : FragmentInput) -> FragmentOutput {\n			var output : FragmentOutput;\n			var f : f32 = 1.0 - abs(input.fragUV.y - 0.5) * 2.0;\n			output.color = vec4<f32>(input.fragColor) * f;\n			return output;\n		}";
    }
  };
}
var UpdateLayoutEndValues2;
var makeNullFilledArray2;
var GetFragmentInputStructDeclaration2;
var HashPipelineState2;
{
  const C32 = self.C3, VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), VALID_WRAP_MODES = /* @__PURE__ */ new Set(["clamp-to-edge", "repeat", "mirror-repeat"]), GPUTextureUsage = self["GPUTextureUsage"], DEFAULT_CREATE_OPTIONS = { wrapX: "clamp-to-edge", wrapY: "clamp-to-edge", sampling: "trilinear", anisotropy: 0, mipMap: true, isRenderTarget: false, isSampled: false, canReadPixels: false, canUpdate: false, multisampling: 0, width: -1, height: -1 }, TEXTURE_FORMAT_SIZE_DATA = [[1, ["r8unorm", "r8snorm", "r8uint", "r8sint", "stencil8"]], [2, ["r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "depth16unorm"]], [3, ["depth24plus"]], [4, ["r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm-srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm-srgb", "rgb9e5ufloat", "rgb10a2uint", "rgb10a2unorm", "rg11b10ufloat", "depth24plus-stencil8", "depth32float"]], [8, ["rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float"]], [16, ["rgba32uint", "rgba32sint", "rgba32float"]], [5, ["depth32float-stencil8"]]], TEXTURE_FORMAT_SIZE_MAP = /* @__PURE__ */ new Map();
  for (const [e, t] of TEXTURE_FORMAT_SIZE_DATA) for (const r of t) TEXTURE_FORMAT_SIZE_MAP.set(r, e);
  const allTextures = /* @__PURE__ */ new Set(), UPDATE_DEFAULT_OPTIONS = { premultiplyAlpha: true, flipY: false };
  C32.Gfx.WebGPURendererTexture = class {
    constructor(e, t) {
      this._renderer = e, this._texture = null, this._format = "", this._textureView = null, this._sampler = null, this._ownTextureBindGroup = null, this._backTextureBindGroup = null, this._width = 0, this._height = 0, this._isStatic = true, this._wrapX = "clamp-to-edge", this._wrapY = "clamp-to-edge", this._sampling = "trilinear", this._anisotropy = 0, this._isMipMapped = false, this._refCount = 0, this._isRenderTarget = false, this._isSampled = false, this._canReadPixels = false, this._canUpdate = false, this._multisampling = 0, this._usage = 0, this._multiTextureEnabled = true, this._multiTextureGroup = null, this._multiTextureIndex = 0, this._isForBackbuffer = !!t, this._isForBackbuffer && (this._format = this._renderer.GetSwapChainFormat(), this._isRenderTarget = true, this._isSampled = this._renderer._CanSampleBackbuffer(), this._sampling = this._renderer._GetBackTextureSampling(), this._sampler = this._renderer._GetSampler({ sampling: this._sampling }));
    }
    _InitFromOpts(e) {
      if (this._wrapX = e.wrapX, this._wrapY = e.wrapY, this._sampling = e.sampling, this._anisotropy = e.anisotropy, this._isMipMapped = !!e.mipMap && this._renderer.AreMipmapsEnabled() && "nearest" !== e.sampling, this._isRenderTarget = !!e.isRenderTarget, this._isSampled = !!e.isSampled, this._canReadPixels = !!e.canReadPixels, this._canUpdate = !!e.canUpdate, this._multisampling = this._renderer._ClampToSupportedMultisampleValues(e.multisampling), !VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
      if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
      if (this._multisampling >= 2 && this._isSampled) throw new Error("invalid use of multisampling");
      "nearest" === this._sampling && (this._anisotropy = 0), this._sampler = this._renderer._GetSampler({ wrapX: this._wrapX, wrapY: this._wrapY, sampling: this._sampling, anisotropy: this._anisotropy }), this._CreateGPUResources(), this._refCount = 1;
    }
    _CreateGPUResources() {
      const e = this._renderer, t = e._GetDevice();
      this._usage = 0, this._isRenderTarget ? (this._usage = GPUTextureUsage["RENDER_ATTACHMENT"], this._isSampled && (this._usage |= GPUTextureUsage["TEXTURE_BINDING"]), this._canUpdate && (this._usage |= GPUTextureUsage["COPY_DST"]), this._format = this._renderer.GetSwapChainFormat()) : (this._usage = GPUTextureUsage["COPY_DST"] | GPUTextureUsage["TEXTURE_BINDING"], this._format = this._renderer.GetTextureFormat()), this._canReadPixels && (this._usage |= GPUTextureUsage["COPY_SRC"]), this._texture = t["createTexture"]({ "size": [this._width, this._height, 1], "mipLevelCount": this._GetMipLevelCount(), "format": this._format, "usage": this._usage, "sampleCount": this._multisampling >= 2 ? this._multisampling : 1 }), this._textureView = this._texture["createView"]();
      const r = [], i = C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit();
      for (let e2 = 0; e2 < i; ++e2) r.push({ "binding": 2 * e2, "resource": this._sampler }, { "binding": 2 * e2 + 1, "resource": this._textureView });
      this._isRenderTarget && !this._isSampled || (this._ownTextureBindGroup = t["createBindGroup"]({ "layout": e._GetTextureBindGroupLayout(), "entries": r }), this._backTextureBindGroup = t["createBindGroup"]({ "layout": e._GetBackTextureBindGroupLayout(), "entries": [{ "binding": 0, "resource": this._renderer._GetSampler({ sampling: this._renderer._GetBackTextureSampling() }) }, { "binding": 1, "resource": this._textureView }] })), this._CanMultiTexture() && this._SetMultiTextureAvailable(true), allTextures.add(this);
    }
    _DeleteGPUResources() {
      allTextures.delete(this), this._multiTextureGroup && this._multiTextureGroup.Release(), this._SetMultiTextureAvailable(false), this._texture["destroy"](), this._texture = null, this._textureView = null, this._ownTextureBindGroup = null, this._backTextureBindGroup = null;
    }
    static IsGPUImageCopyExternalImageSource(e) {
      return e instanceof ImageBitmap || "undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas;
    }
    static IsCreateImageBitmapDataSource(e) {
      return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || e instanceof ImageData;
    }
    _GetDataSize(e) {
      return [e.width || e.videoWidth, e.height || e.videoHeight];
    }
    _Create(e, t) {
      if (e && !C32.Gfx.WebGPURendererTexture.IsGPUImageCopyExternalImageSource(e)) throw new TypeError("invalid texture source");
      if (t = Object.assign({}, DEFAULT_CREATE_OPTIONS, t), this._texture) throw new Error("already created texture");
      if (this._isStatic = true, e) {
        const [t2, r] = this._GetDataSize(e);
        this._width = t2, this._height = r;
      } else if (this._width = t.width, this._height = t.height, this._width <= 0 || this._height <= 0) throw new Error("invalid texture size");
      if (this._InitFromOpts(t), this._isRenderTarget || this._isSampled) throw new Error("static texture cannot be render target");
      e && this._UploadImage(e);
    }
    _UploadImage(e, t = true) {
      if (this._isMipMapped) this._GenerateMipmaps(e, this._GetMipLevelCount(), t);
      else {
        const r = this._renderer._GetDevice(), i = r["createCommandEncoder"](), s = r["createTexture"]({ "size": [this._width, this._height, 1], "mipLevelCount": 1, "format": this._format, "usage": GPUTextureUsage["COPY_SRC"] | GPUTextureUsage["COPY_DST"] | GPUTextureUsage["RENDER_ATTACHMENT"] });
        this._CopyImageToMipLevel(s, e, 0, t), i["copyTextureToTexture"]({ "texture": s, "mipLevel": 0 }, { "texture": this._texture, "mipLevel": 0 }, [this._width, this._height, 1]), r["queue"]["submit"]([i["finish"]()]), s["destroy"]();
      }
    }
    _CopyImageToMipLevel(e, t, r, i = true) {
      const [s, a] = this._GetDataSize(t);
      this._renderer._GetDevice()["queue"]["copyExternalImageToTexture"]({ "source": t }, { "texture": e, "mipLevel": r, "premultipliedAlpha": !!i }, [s, a, 1]);
    }
    _GetMipLevelCount() {
      return this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1;
    }
    _GenerateMipmaps(e, t, r = true) {
      const i = this._renderer._GetDevice(), s = i["createTexture"]({ "size": [this._width, this._height, 1], "mipLevelCount": this._GetMipLevelCount(), "format": this._format, "usage": GPUTextureUsage["COPY_DST"] | GPUTextureUsage["COPY_SRC"] | GPUTextureUsage["TEXTURE_BINDING"] | GPUTextureUsage["RENDER_ATTACHMENT"] }), a = this._renderer._GetMipmapGeneratorPipeline(), n = a["getBindGroupLayout"](0), u = this._renderer._GetSampler({ sampling: "bilinear" }), h = i["createCommandEncoder"]();
      this._CopyImageToMipLevel(s, e, 0, r), h["copyTextureToTexture"]({ "texture": s, "mipLevel": 0 }, { "texture": this._texture, "mipLevel": 0 }, [this._width, this._height, 1]);
      const _ = [];
      for (let e2 = 0; e2 < t; ++e2) _.push(s["createView"]({ "baseMipLevel": e2, "mipLevelCount": 1 }));
      let l = this._width, o = this._height;
      for (let e2 = 1; e2 < t; ++e2) {
        l /= 2, o /= 2;
        const t2 = Math.max(Math.floor(l), 1), r2 = Math.max(Math.floor(o), 1), p = h["beginRenderPass"]({ "colorAttachments": [{ "view": _[e2], "loadOp": "clear", "clearValue": [0, 0, 0, 0], "storeOp": "store" }] }), d = i["createBindGroup"]({ "layout": n, "entries": [{ "binding": 0, "resource": u }, { "binding": 1, "resource": _[e2 - 1] }] });
        p["setPipeline"](a), p["setBindGroup"](0, d), p["draw"](4), p["end"](), h["copyTextureToTexture"]({ "texture": s, "mipLevel": e2 }, { "texture": this._texture, "mipLevel": e2 }, [t2, r2, 1]);
      }
      i["queue"]["submit"]([h["finish"]()]), s["destroy"]();
    }
    _CreateDynamic(e, t, r) {
      if (r = Object.assign({}, DEFAULT_CREATE_OPTIONS, r), this._texture) throw new Error("already created texture");
      this._isStatic = false, this._width = e, this._height = t, this._InitFromOpts(r);
    }
    async _Update(e, t) {
      if (!C32.Gfx.WebGPURendererTexture.IsGPUImageCopyExternalImageSource(e) && !C32.Gfx.WebGPURendererTexture.IsCreateImageBitmapDataSource(e)) throw new Error("invalid texture source");
      if (!this._texture || this._refCount <= 0) throw new Error("texture not created");
      if (this._isStatic) throw new Error("cannot update static texture");
      if (t = Object.assign({}, UPDATE_DEFAULT_OPTIONS, t), (C32.Gfx.WebGPURendererTexture.IsCreateImageBitmapDataSource(e) || t.flipY || !t.premultiplyAlpha) && (e = await createImageBitmap(e, { "premultiplyAlpha": t.premultiplyAlpha ? "premultiply" : "none", "imageOrientation": t.flipY ? "flipY" : "none" }), !this._texture)) return;
      this._renderer.EndBatch();
      const [r, i] = this._GetDataSize(e);
      this._width === r && this._height === i || (this._DeleteGPUResources(), this._width = r, this._height = i, this._CreateGPUResources(), this._renderer._OnTextureBindGroupChanged(this)), this._UploadImage(e, t.premultiplyAlpha);
    }
    _Delete() {
      if (this._refCount > 0) throw new Error("texture still has references");
      if (!this._texture) throw new Error("already deleted texture");
      this._DeleteGPUResources();
    }
    _DisableMultiTexture() {
      this._multiTextureEnabled = false, this._SetMultiTextureAvailable(false);
    }
    _CanMultiTexture() {
      return this._isStatic && this._multiTextureEnabled && !this._isRenderTarget;
    }
    _SetMultiTextureAvailable(e) {
      this._renderer._SetMultiTextureAvailable(this, e);
    }
    _SetMultiTextureGroup(e, t) {
      if (this._multiTextureGroup) throw new Error("already in a group");
      this._multiTextureGroup = e, this._multiTextureIndex = t, this._SetMultiTextureAvailable(false);
    }
    _ClearMultiTextureGroup() {
      this._multiTextureGroup = null, this._multiTextureIndex = 0, this._CanMultiTexture() && this._SetMultiTextureAvailable(true);
    }
    _GetOwnTextureBindGroup() {
      return this._ownTextureBindGroup;
    }
    _GetBackTextureBindGroup() {
      return this._backTextureBindGroup;
    }
    _GetMultiTextureBindGroup() {
      return null !== this._multiTextureGroup ? this._multiTextureGroup._GetBindGroup() : this._CanMultiTexture() ? (this._renderer._TryCreateMultiTextureGroup(this), null !== this._multiTextureGroup ? this._multiTextureGroup._GetBindGroup() : null) : null;
    }
    _GetMultiTextureIndex() {
      return this._multiTextureIndex;
    }
    GetWidth() {
      return this._isForBackbuffer ? this._renderer.GetWidth() : this._width;
    }
    GetHeight() {
      return this._isForBackbuffer ? this._renderer.GetHeight() : this._height;
    }
    GetRenderer() {
      return this._renderer;
    }
    _GetTexture() {
      return this._texture;
    }
    _GetTextureView() {
      return this._textureView;
    }
    _GetFormat() {
      return this._format;
    }
    _GetSampler() {
      return this._sampler;
    }
    GetSampling() {
      return this._sampling;
    }
    IsLinearSampling() {
      return "nearest" !== this._sampling;
    }
    IsRenderTarget() {
      return this._isRenderTarget;
    }
    IsSampled() {
      return this._isSampled;
    }
    CanReadPixels() {
      return this._canReadPixels;
    }
    AddReference() {
      this._refCount++;
    }
    SubtractReference() {
      if (this._refCount <= 0) throw new Error("no more references");
      this._refCount--;
    }
    GetReferenceCount() {
      return this._refCount;
    }
    _GetUsage() {
      return this._usage;
    }
    _BackbufferTextureSetProperties(e, t) {
      this._usage = e, this._format = t;
    }
    _BackbufferTextureStartFrame() {
      const e = this._renderer, t = e._GetDevice();
      this._texture = e._GetSwapChainTexture(), this._textureView = e._GetSwapChainTexView(), e._CanSampleBackbuffer() && (this._backTextureBindGroup = t["createBindGroup"]({ "layout": e._GetBackTextureBindGroupLayout(), "entries": [{ "binding": 0, "resource": this._sampler }, { "binding": 1, "resource": this._textureView }] }));
    }
    _BackbufferTextureEndFrame() {
      this._texture = null, this._textureView = null, this._backTextureBindGroup = null;
    }
    GetEstimatedMemoryUsage() {
      let e = this.GetWidth() * this.GetHeight() * C32.Gfx.WebGPURendererTexture.GetFormatByteSize(this._GetFormat());
      return this._isMipMapped && (e += Math.floor(e / 3)), e;
    }
    static OnContextLost() {
    }
    static allTextures() {
      return allTextures.values();
    }
    static GetFormatByteSize(e) {
      const t = TEXTURE_FORMAT_SIZE_MAP.get(e);
      return "number" == typeof t ? t : NaN;
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.WebGPUMultiTextureGroup = class {
    constructor(e, t) {
      if (t.length < 2) throw new Error("invalid multi-texture group");
      this._renderer = e, this._textures = t, this._multiTextureBindGroup = null;
      for (let e2 = 0, r = t.length; e2 < r; ++e2) t[e2]._SetMultiTextureGroup(this, e2);
      t.length < C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit() && this._renderer._SetMultiTextureGroupNonFull(this, true), this._CreateBindGroup();
    }
    Release() {
      this._renderer._SetMultiTextureGroupNonFull(this, false);
      for (const e of this._textures) e._ClearMultiTextureGroup();
      this._DeleteBindGroup(), C32.clearArray(this._textures), this._renderer = null;
    }
    _CreateBindGroup() {
      this._DeleteBindGroup();
      const e = this._renderer._GetDevice(), t = [], r = C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit();
      for (let e2 = 0; e2 < r; ++e2) {
        const r2 = this._textures[Math.min(e2, this._textures.length - 1)];
        t.push({ "binding": 2 * e2, "resource": r2._GetSampler() }, { "binding": 2 * e2 + 1, "resource": r2._GetTextureView() });
      }
      this._multiTextureBindGroup = e["createBindGroup"]({ "layout": this._renderer._GetTextureBindGroupLayout(), "entries": t });
    }
    _DeleteBindGroup() {
      null !== this._multiTextureBindGroup && this._renderer._OnMultiTextureBindGroupReleased(this._multiTextureBindGroup), this._multiTextureBindGroup = null;
    }
    _GetBindGroup() {
      return this._multiTextureBindGroup;
    }
    static GetMultiTextureLimit() {
      return 14;
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, DEFAULT_RENDERTARGET_OPTIONS = { sampling: "trilinear", alpha: true, depth: false, isSampled: true, canReadPixels: false, canUpdate: false, isDefaultSize: true, multisampling: 0 }, allRenderTargets = /* @__PURE__ */ new Set();
  C32.Gfx.WebGPURenderTarget = class {
    constructor(e, t) {
      this._renderer = e, this._isBackBuffer = !!t, this._depth = !!t && e.UsesDepthBuffer(), this._rendererTexture = null, this._isDefaultSize = true, this._multisampling = 0, this._isAwaitingClear = false, this._clearColor = C32.New(C32.Color), this._projectionMatrix = mat4.create(), this._lastFov = 0, this._lastNearZ = 0, this._lastFarZ = 0, this._isBackBuffer && (this._rendererTexture = C32.New(C32.Gfx.WebGPURendererTexture, e, true));
    }
    _Create(e, t, r) {
      if (r = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, r), this._rendererTexture) throw new Error("already created render target");
      if (this._depth = !!r.depth, this._isDefaultSize = !!r.isDefaultSize, this._multisampling = this._renderer._ClampToSupportedMultisampleValues(r.multisampling), this._multisampling >= 2 && r.isSampled) throw new Error("invalid use of multisampling");
      this._rendererTexture = this._renderer.CreateDynamicTexture(e, t, { sampling: r.sampling, mipMap: false, isRenderTarget: true, isSampled: r.isSampled, canReadPixels: r.canReadPixels, canUpdate: r.canUpdate, multisampling: this._multisampling }), this._CalculateProjection(), allRenderTargets.add(this);
    }
    _Delete() {
      allRenderTargets.delete(this), this._rendererTexture._DeleteGPUResources(), this._rendererTexture = null, this._renderer = null;
    }
    _Resize(e, t) {
      if (e === this.GetWidth() && t === this.GetHeight()) return;
      const r = this._rendererTexture.GetSampling(), i = this._rendererTexture.IsSampled(), s = this._rendererTexture.CanReadPixels();
      this._rendererTexture._DeleteGPUResources(), this._rendererTexture = null, this._rendererTexture = this._renderer.CreateDynamicTexture(e, t, { sampling: r, mipMap: false, isRenderTarget: true, isSampled: i, canReadPixels: s }), this._CalculateProjection();
    }
    _GetTextureView() {
      return this._isBackBuffer ? this._renderer._GetSwapChainTexView() : this._rendererTexture._GetTextureView();
    }
    _CalculateProjection() {
      this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this.GetWidth() / this.GetHeight()), this._lastFov = this._renderer.GetFovY(), this._lastNearZ = this._renderer.GetNearZ(), this._lastFarZ = this._renderer.GetFarZ();
    }
    IsDefaultSize() {
      return this._isDefaultSize;
    }
    IsBackBuffer() {
      return this._isBackBuffer;
    }
    HasDepthBuffer() {
      return this._depth;
    }
    GetWidth() {
      return this._isBackBuffer ? this._renderer.GetWidth() : this._rendererTexture.GetWidth();
    }
    GetHeight() {
      return this._isBackBuffer ? this._renderer.GetHeight() : this._rendererTexture.GetHeight();
    }
    GetTexture() {
      if (this._rendererTexture) return this._rendererTexture;
      throw new Error("no texture");
    }
    GetRenderer() {
      return this._renderer;
    }
    GetMultisampling() {
      return this._multisampling;
    }
    GetProjectionMatrix() {
      return this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection(), this._projectionMatrix;
    }
    IsLinearSampling() {
      return this._rendererTexture.IsLinearSampling();
    }
    IsSampled() {
      return this._rendererTexture.IsSampled();
    }
    CanReadPixels() {
      return this._rendererTexture.CanReadPixels();
    }
    IsCompatibleWithOptions(e) {
      return "nearest" !== (e = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, e)).sampling === this.IsLinearSampling() && (!!e.isSampled === this.IsSampled() && (!!e.canReadPixels === this.CanReadPixels() && (!!e.depth === this.HasDepthBuffer() && ("number" == typeof e.width || "number" == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(e.width) && this.GetHeight() === Math.floor(e.height) : this.IsDefaultSize()))));
    }
    _SetIsAwaitingClear(e) {
      this._isAwaitingClear = !!e;
    }
    _IsAwaitingClear() {
      return this._isAwaitingClear;
    }
    _GetClearColor() {
      return this._clearColor;
    }
    static OnContextLost() {
    }
    static allRenderTargets() {
      return allRenderTargets.values();
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.WebGPUTimeQuerySet = class {
    constructor(e, t) {
      this._renderer = e, this._frameNumber = this._renderer.GetFrameNumber(), this._queryCount = t;
      const r = this._renderer._GetDevice();
      this._querySet = r["createQuerySet"]({ "count": this._queryCount, "type": "timestamp" });
      const s = self["GPUBufferUsage"];
      this._resolveBuffer = r["createBuffer"]({ "size": this._GetBufferSize(), "usage": s["QUERY_RESOLVE"] | s["COPY_SRC"] }), this._readbackBuffer = r["createBuffer"]({ "size": this._GetBufferSize(), "usage": s["COPY_DST"] | s["MAP_READ"] }), this._result = null;
    }
    _GetBufferSize() {
      return 8 * this._queryCount;
    }
    _GetQuerySet() {
      return this._querySet;
    }
    Resolve(e) {
      e["resolveQuerySet"](this._querySet, 0, this._queryCount, this._resolveBuffer, 0), e["copyBufferToBuffer"](this._resolveBuffer, 0, this._readbackBuffer, 0, this._GetBufferSize());
    }
    async ReadResult() {
      const e = this._GetBufferSize();
      await this._readbackBuffer["mapAsync"](self["GPUMapMode"]["READ"], 0, e);
      const t = this._readbackBuffer["getMappedRange"](0, e);
      this._result = new BigUint64Array(t.slice(0)), this._readbackBuffer["destroy"](), this._readbackBuffer = null, this._resolveBuffer["destroy"](), this._resolveBuffer = null, this._querySet["destroy"](), this._querySet = null;
    }
    HasResult() {
      return null !== this._result;
    }
    GetResult() {
      if (!this._result) throw new Error("not yet got result");
      return this._result;
    }
    GetFrameNumber() {
      return this._frameNumber;
    }
  };
}
{
  const C32 = self.C3, DEFAULT_CTOR_OPTS = { getDrawSize: null, getRenderTarget: null, releaseRenderTarget: null, getTime: null, redraw: null };
  C32.Gfx.EffectChainManager = class {
    constructor(e) {
      e = Object.assign({}, DEFAULT_CTOR_OPTS, e), this._cbGetDrawSize = e.getDrawSize, this._cbGetRenderTarget = e.getRenderTarget, this._cbReleaseRenderTarget = e.releaseRenderTarget, this._cbGetTime = e.getTime, this._cbRedraw = e.redraw, this._webgpuBackTexture = null, this._allEffectChains = /* @__PURE__ */ new Set();
    }
    _AddEffectChain(e) {
      this._allEffectChains.add(e);
    }
    _RemoveEffectChain(e) {
      this._allEffectChains.delete(e);
    }
    OnContextLost() {
      this._webgpuBackTexture = null;
      for (const e of this._allEffectChains) e.OnContextLost();
    }
    GetDrawSize(e) {
      return this._cbGetDrawSize ? this._cbGetDrawSize(e) : [e.GetWidth(), e.GetHeight()];
    }
    GetRenderTarget(e) {
      return this._cbGetRenderTarget(e);
    }
    ReleaseRenderTarget(e, t) {
      this._cbReleaseRenderTarget(e, t);
    }
    GetTime() {
      return this._cbGetTime();
    }
    Redraw(e) {
      this._cbRedraw(e);
    }
    _GetWebGPUBackTexture(e, t, r) {
      return t = Math.floor(t), r = Math.floor(r), !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === t && this._webgpuBackTexture.GetHeight() === r || (e.DeleteTexture(this._webgpuBackTexture), this._webgpuBackTexture = null), null === this._webgpuBackTexture && (this._webgpuBackTexture = e.CreateStaticTexture(null, { width: t, height: r, sampling: "nearest", mipMap: false })), this._webgpuBackTexture;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, mat4 = glMatrix.mat4, tempRect = C32.New(C32.Rect), tempRect2 = C32.New(C32.Rect), tempRect3 = C32.New(C32.Rect), tempRect4 = C32.New(C32.Rect), tempMat4a = mat4.create(), tempMat4b = mat4.create(), DEFAULT_CTOR_OPTS = { drawContent: null, getSourceTextureInfo: null, getShaderParameters: null, invalidateRenderTargets: false }, DEFAULT_BUILDSTEPS_OPTS = { indexMap: null, forcePreDraw: false, forcePostDraw: false, is3D: false, isSourceTextureRotated: false, isRotatedOrNegativeSizeInstance: false, useFullSurface: false };
  C32.Gfx.EffectChain = class {
    constructor(e, t) {
      t = Object.assign({}, DEFAULT_CTOR_OPTS, t), this._manager = e, this._cbDrawContent = t.drawContent, this._cbGetSourceTextureInfo = t.getSourceTextureInfo, this._cbGetShaderParameters = t.getShaderParameters, this._cbDrawContentHook = null, this._shaderProgramList = [], this._shaderProgramIndices = [], this._steps = [], this._needsRebuild = false, this._blendMode = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._didChangeTransform = false, this._depthEnabledAtStart = false, this._coplanarColorPassAtStart = false, this._canUseFastPath = false, this._useFullSurface = false, this._isSourceTextureRotated = false, this._numTempSurfacesRequired = 0, this._renderTargets = [null, null, null], this._invalidateRenderTargets = !!t.invalidateRenderTargets, this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._drawWidth = 0, this._drawHeight = 0, this._contentObject = null, this._contextObject = null, this._layoutRect = C32.New(C32.Rect), this._drawSurfaceRect = C32.New(C32.Rect), this._rcTexOriginal = C32.New(C32.Rect), this._rcTexBounce = C32.New(C32.Rect), this._rcTexDest = C32.New(C32.Rect), this._devicePixelRatio = 1, this._layerScale = 1, this._layerAngle = 0, this._time = 0, this._destRenderTarget = null, this._backTex = null, this._compositOffX = 0, this._compositOffY = 0, this._compositRtWidth = 0, this._compositRtHeight = 0, this._updateOwnProjection = false, this._projectionMatrix = mat4.create(), this._modelViewMatrix = mat4.create(), this._manager._AddEffectChain(this);
    }
    Release() {
      this._manager._RemoveEffectChain(this), C32.clearArray(this._steps), C32.clearArray(this._shaderProgramList), C32.clearArray(this._shaderProgramIndices), this._contentObject = null, this._contextObject = null, this._cbDrawContent = null, this._cbGetSourceTextureInfo = null, this._cbGetShaderParameters = null;
    }
    OnContextLost() {
      this._needsRebuild = true, C32.clearArray(this._steps), C32.clearArray(this._shaderProgramList), C32.clearArray(this._shaderProgramIndices);
    }
    NeedsRebuild() {
      return this._needsRebuild;
    }
    BuildSteps(e, t) {
      if (t = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, t), C32.clearArray(this._steps), this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._numTempSurfacesRequired = 0, this._isSourceTextureRotated = !!t.isSourceTextureRotated, this._useFullSurface = !!t.useFullSurface, this._needsRebuild = false, C32.shallowAssignArray(this._shaderProgramList, e), 0 === e.length) return;
      if (t.indexMap) {
        if (t.indexMap.length !== e.length) throw new Error("incorrect indexMap length");
        C32.shallowAssignArray(this._shaderProgramIndices, t.indexMap);
      } else {
        C32.clearArray(this._shaderProgramIndices);
        for (let t2 = 0, r2 = e.length; t2 < r2; ++t2) this._shaderProgramIndices.push(t2);
      }
      for (const t2 of e) this._boxExtendHorizontal += t2.GetBoxExtendHorizontal(), this._boxExtendVertical += t2.GetBoxExtendVertical(), t2.IsAnimated() && (this._isAnyShaderAnimated = true), t2.UsesDepth() && (this._isAnyShaderDepthSampling = true), t2.BlendsBackground() && (this._isAnyShaderBackgroundBlending = true), t2.UsesCrossSampling() && (this._isAnyShaderCrossSampling = true), t2.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = true);
      this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(e[0].GetRenderer());
      const r = this._ShouldPreDraw(e[0], t), s = this._ShouldPostDraw(e.at(-1), t);
      if (1 === e.length && !r && !s) return void (this._canUseFastPath = true);
      this._canUseFastPath = false;
      let i = 0;
      r && (this._numTempSurfacesRequired = 1, this._steps.push(C32.New(C32.Gfx.EffectChain.Step.PreDraw, this, -1, 1)), i = 1);
      for (let t2 = 0, a = e.length; t2 < a; ++t2) if (0 !== t2 || r) {
        let e2 = 1 === i ? 2 : 1;
        t2 !== a - 1 || s || (e2 = 0), this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, e2), this._steps.push(C32.New(C32.Gfx.EffectChain.Step.Bounce, this, i, e2, t2)), i = e2;
      } else this._numTempSurfacesRequired = 1, this._steps.push(C32.New(C32.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, t2)), i = 1;
      s && this._steps.push(C32.New(C32.Gfx.EffectChain.Step.PostDraw, this, i, 0));
    }
    _ShouldPreDraw(e, t) {
      return !!(t.forcePreDraw || e.MustPreDraw() || t.is3D && !e.Supports3DDirectRendering() || e.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical) || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() && (t.isRotatedOrNegativeSizeInstance || t.isSourceTextureRotated) || e.UsesAnySrcRectOrPixelSize() && t.isSourceTextureRotated : e.BlendsBackground() && !this._useCopyTextureBackgroundSampling && t.isRotatedOrNegativeSizeInstance);
    }
    _ShouldPostDraw(e, t) {
      return !!t.forcePostDraw || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() || e.UsesCrossSampling() : (e.BlendsBackground() || e.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling());
    }
    _ShouldUseCopyTextureBackgroundSampling(e) {
      return e.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling;
    }
    Render(e, t, r) {
      e.IsWebGPU() && null === t && (t = e.GetBackbufferRenderTarget()), this._destRenderTarget = t, this._contentObject = r.contentObject || null, this._contextObject = r.contextObject || null, this._blendMode = r.blendMode || 0, this._devicePixelRatio = r.devicePixelRatio || 1, this._layerScale = r.layerScale || 1, this._layerAngle = r.layerAngle || 0, this._time = "number" == typeof r.time ? r.time : this._manager.GetTime(), this._didChangeTransform = false, e.ResetDidChangeTransformFlag(), this._isAnyShaderAnimated && this._Redraw();
      let s = false;
      if (this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(e, r), s = true, this._backTex = this._manager._GetWebGPUBackTexture(e, this._drawWidth, this._drawHeight), tempRect.copy(this._drawSurfaceRect), tempRect.roundOuter(), e.IsWebGPU() && e._MaybeDoPendingClearRenderPass(this._destRenderTarget), e.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height())), this._canUseFastPath) this._Render_FastPath(e, r);
      else if (s || this._CalculateDrawSizeAndRectangles(e, r), 0 !== this._rcTexOriginal.width() || 0 !== this._rcTexOriginal.height()) {
        e.SetAlphaBlend(), e.ResetCullState(), e.ResetColor(), e.SetBaseZ(0), e.SetCurrentZ(0), this._cbDrawContentHook = r.drawContentHook || null, this._compositOffX = r.compositOffX || 0, this._compositOffY = r.compositOffY || 0, this._compositRtWidth = r.compositRtWidth || 0, this._compositRtHeight = r.compositRtHeight || 0, this._updateOwnProjection = !!r.updateOwnProjection, this._OnBeforeStartEffectChain(e), this._renderTargets[0] = t, this._renderTargets[1] = this._numTempSurfacesRequired >= 1 ? this._GetRenderTarget() : null, this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
        for (const t2 of this._steps) {
          const r2 = this._GetRenderTargetForId(t2.GetSrcTargetId()), s2 = this._GetRenderTargetForId(t2.GetDestTargetId());
          e.IsWebGPU() ? t2.Run_WebGPU(e, r2, s2) : t2.Run_WebGL(e, r2, s2);
        }
        e.SetTexture(null), this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]), this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]), this._renderTargets.fill(null), this._OnAfterEndEffectChain(e), this._destRenderTarget = null, this._backTex = null, this._contentObject = null, this._contextObject = null, this._cbDrawContentHook = null;
      }
    }
    _CalculateDrawSizeAndRectangles(e, t) {
      const [r, s] = this._manager.GetDrawSize(e);
      this._SetDrawSize(e, r, s), this._CalculateRectangles(t);
    }
    _SetDrawSize(e, t, r) {
      if (t <= 0 || r <= 0) throw new Error("invalid draw size");
      this._drawWidth === t && this._drawHeight === r || this._CalculateDeviceTransformMatrices(e, t, r, 0, 0, this._projectionMatrix, this._modelViewMatrix), this._drawWidth = t, this._drawHeight = r;
    }
    _CalculateDeviceTransformMatrices(e, t, r, s, i, a, n) {
      const h = t / 2 + s, c = r / 2 + i;
      e.CalculatePerspectiveMatrix(a, t / r);
      const o = e.CalculateLookAtModelView2(h, c, e.GetDefaultCameraZ(r), h, c, 0, r);
      mat4.copy(n, o);
    }
    _CalculateRectangles(e) {
      if (this._layoutRect.copy(e.layoutRect), e.drawSurfaceRect ? this._drawSurfaceRect.copy(e.drawSurfaceRect) : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight), this._canUseFastPath) {
        const t2 = e.compositOffX ?? 0, r = e.compositOffY ?? 0;
        this._drawSurfaceRect.offset(-t2, -r);
      }
      this._rcTexOriginal.copy(this._drawSurfaceRect), this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
      const t = this._layerScale * this._devicePixelRatio;
      this._drawSurfaceRect.inflate(this._boxExtendHorizontal * t, this._boxExtendVertical * t), this._rcTexDest.copy(this._drawSurfaceRect), this._rcTexDest.divide(this._drawWidth, this._drawHeight), this._drawSurfaceRect.clampBoth(0, 0, this._drawWidth, this._drawHeight), this._rcTexBounce.copy(this._drawSurfaceRect), this._rcTexBounce.divide(this._drawWidth, this._drawHeight);
    }
    _OnBeforeStartEffectChain(e) {
      if (this._depthEnabledAtStart = e.IsDepthEnabled(), this._coplanarColorPassAtStart = e.IsCoplanarColorPass(), this._useFullSurface) e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true);
      else {
        if (tempRect.copy(this._drawSurfaceRect), e.IsWebGL()) {
          const e2 = this._layerScale * this._devicePixelRatio;
          tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * e2, Math.max(this._boxExtendVertical, 1) * e2), tempRect.roundOuter(), tempRect.clamp(0, 0, this._drawWidth, this._drawHeight);
        } else tempRect.roundOuter();
        e.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight);
      }
    }
    _OnAfterEffectChainDrawContent(e) {
      e.ResetColor(), this._useFullSurface || (this._coplanarColorPassAtStart ? e.CoplanarRestoreStandardRendering(false) : e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true)), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(true);
    }
    _OnAfterEndEffectChain(e) {
      e.SetDepthSamplingEnabled(false), this._coplanarColorPassAtStart ? e.CoplanarStartColorPass(this._depthEnabledAtStart) : e.SetDepthEnabled(this._depthEnabledAtStart), this._useFullSurface || e.RemoveScissorRect(), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(false), this._didChangeTransform = e.DidChangeTransform();
    }
    _ClampRcTexDest() {
      this._rcTexDest.clamp(0, 0, 1, 1);
    }
    _GetRenderTargetForId(e) {
      return e < 0 ? null : this._renderTargets[e];
    }
    _GetRenderTarget() {
      return this._manager.GetRenderTarget(this);
    }
    _GetDestRenderTarget() {
      return this._destRenderTarget;
    }
    _ReleaseRenderTarget(e) {
      this._manager.ReleaseRenderTarget(e, this);
    }
    _GetShaderProgramAt(e) {
      return this._shaderProgramList[e];
    }
    _DrawContent(e) {
      this._cbDrawContentHook ? this._cbDrawContentHook(this, e, () => this._cbDrawContent(e, this)) : this._cbDrawContent(e, this), this._canUseFastPath || this._OnAfterEffectChainDrawContent(e);
    }
    _IsRenderTargetSameSizeAndOffset(e) {
      if (this._useFullSurface) return true;
      if (0 !== this._compositOffX || 0 !== this._compositOffY || 0 !== this._compositRtWidth || 0 !== this._compositRtHeight) return false;
      const [t, r] = e.GetRenderTargetSize(e.GetRenderTarget());
      return t === this._drawWidth && r === this._drawHeight;
    }
    _SetDeviceTransform(e, t) {
      let r = this._projectionMatrix, s = this._modelViewMatrix;
      if (t && !this._IsRenderTargetSameSizeAndOffset(e)) {
        let t2, i;
        r = tempMat4a, s = tempMat4b, 0 !== this._compositRtWidth && 0 !== this._compositRtHeight ? [t2, i] = [this._compositRtWidth, this._compositRtHeight] : [t2, i] = e.GetRenderTargetSize(e.GetRenderTarget()), this._CalculateDeviceTransformMatrices(e, t2, i, this._compositOffX, this._compositOffY, r, s), this._useFullSurface || e.RemoveScissorRect();
      }
      e.SetProjectionMatrix(r), e.SetModelViewMatrix(s);
    }
    _Redraw() {
      this._manager.Redraw(this);
    }
    _GetShaderParameters(e, t) {
      return this._cbGetShaderParameters(this._shaderProgramIndices[e], t);
    }
    _SetProgramParameters(e, t) {
      let r = this._rcTexDest, s = this._rcTexBounce, i = this._rcTexOriginal;
      e.IsWebGL() && (tempRect2.copy(r), tempRect2.flipAround(1), r = tempRect2, tempRect3.copy(s), tempRect3.flipAround(1), s = tempRect3, tempRect4.copy(i), tempRect4.flipAround(1), i = tempRect4), this._DoSetProgramParameters(e, t, s, i, r, 1 / this._drawWidth, 1 / this._drawHeight);
    }
    _SetFirstBounceProgramParameters(e, t) {
      let r = this._rcTexBounce, s = this._rcTexOriginal, i = 1 / this._drawWidth, a = 1 / this._drawHeight;
      if (this._cbGetSourceTextureInfo) {
        let { srcTexRect: e2, srcWidth: t2, srcHeight: n2 } = this._cbGetSourceTextureInfo(this._contentObject);
        e2 || (tempRect.set(0, 0, 0, 0), e2 = tempRect), t2 || (t2 = this._drawWidth), n2 || (n2 = this._drawHeight), r = e2, s = e2, i = 1 / t2, a = 1 / n2;
      } else e.IsWebGL() && (tempRect3.copy(r), tempRect3.flipAround(1), r = tempRect3, tempRect4.copy(s), tempRect4.flipAround(1), s = tempRect4);
      let n = this._rcTexDest;
      e.IsWebGL() && (n = tempRect2, n.copy(this._rcTexDest), n.flipAround(1)), this._DoSetProgramParameters(e, t, r, s, n, i, a), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
    }
    _GetBackTex(e) {
      return this._isAnyShaderBackgroundBlending ? e.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null;
    }
    _DoSetProgramParameters(e, t, r, s, i, a, n) {
      e.SetProgramParameters(this._GetBackTex(e), i, r, s, this._layoutRect, a, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(t, e));
    }
    _Render_FastPath(e, t) {
      const r = this._shaderProgramList[0], s = e.IsDepthEnabled(), i = r.UsesDepth();
      i && (e.SetDepthEnabled(false), e.SetDepthSamplingEnabled(true), this._rcTexDest.set(0, 0, 1, 1), this._rcTexOriginal.set(0, 0, 1, 1)), e.SetProgram(r), e.SetBlendMode(this._blendMode), e.SetRenderTarget(this._destRenderTarget), e.ResetCullState();
      let a = 0, n = 1;
      if (this._rcTexOriginal.set(0, 0, 1, 1), r.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
        const { srcTexRect: e2, srcWidth: t2, srcHeight: r2 } = this._cbGetSourceTextureInfo(this._contentObject);
        e2 && this._rcTexOriginal.copy(e2), a = Number.isFinite(t2) ? 1 / t2 : 0, n = Number.isFinite(r2) ? 1 / r2 : 0;
      } else {
        const [t2, r2] = this._manager.GetDrawSize(e);
        a = 1 / t2, n = 1 / r2;
      }
      t.layoutRect ? this._layoutRect.copy(t.layoutRect) : this._layoutRect.set(0, 0, 0, 0), e.SetProgramParameters(this._GetBackTex(e), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, a, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(0, e)), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated), e.SetBaseZ(0), this._DrawContent(e), i && (e.SetDepthSamplingEnabled(false), e.SetDepthEnabled(s));
    }
    _UseCopyTextureBackgroundSampling() {
      return this._useCopyTextureBackgroundSampling;
    }
    _UseRenderTargetBackgroundSampling() {
      return !this._useCopyTextureBackgroundSampling;
    }
    IsAnyShaderBackgroundBlending() {
      return this._isAnyShaderBackgroundBlending;
    }
    CanSkipCalculatingDrawSurfaceRect() {
      return !!this._canUseFastPath && !this._UseCopyTextureBackgroundSampling();
    }
    UseFullSurface() {
      return this._useFullSurface;
    }
    GetContentObject() {
      return this._contentObject;
    }
    GetContextObject() {
      return this._contextObject;
    }
    _GetBlendMode() {
      return this._blendMode;
    }
    _UpdateOwnProjection() {
      return this._updateOwnProjection;
    }
    DidChangeTransform() {
      return this._didChangeTransform;
    }
    _GetDrawSurfaceRect() {
      return this._drawSurfaceRect;
    }
    _GetRcTexBounce() {
      return this._rcTexBounce;
    }
    _ShouldInvalidateRenderTargets() {
      return this._invalidateRenderTargets;
    }
    async DebugLogRenderTargetContents(e, t, r) {
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.EffectChain.Step = class {
    constructor(t, e, r, s = -1) {
      this._effectChain = t, this._srcTargetId = e, this._destTargetId = r, this._index = s;
    }
    GetEffectChain() {
      return this._effectChain;
    }
    GetSrcTargetId() {
      return this._srcTargetId;
    }
    GetDestTargetId() {
      return this._destTargetId;
    }
    GetIndex() {
      return this._index;
    }
    GetShaderProgram() {
      return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex());
    }
    Run_WebGL(t, e, r) {
    }
    Run_WebGPU(t, e, r) {
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.EffectChain.Step.PreDraw = class extends C32.Gfx.EffectChain.Step {
    constructor(e, t, a, n) {
      super(e, t, a, n);
    }
    Run_WebGL(e, t, a) {
      const n = this.GetEffectChain();
      e.SetAlphaBlend(), e.ResetCullState(), e.SetTextureFillMode(), e.SetRenderTarget(a, n._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), n._DrawContent(e), n._ClampRcTexDest();
    }
    Run_WebGPU(e, t, a) {
      const n = this.GetEffectChain();
      e.SetAlphaBlend(), e.ResetCullState(), e.SetTextureFillMode(), e.SetRenderTarget(a, false), e.ClearRgba(0, 0, 0, 0), n._DrawContent(e), n._ClampRcTexDest();
    }
  };
}
{
  const C32 = self.C3, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);
  C32.Gfx.EffectChain.Step.PostDraw = class extends C32.Gfx.EffectChain.Step {
    constructor(e, t, r, a) {
      super(e, t, r, a);
    }
    Run_WebGL(e, t, r) {
      const a = this.GetEffectChain();
      e.SetTextureFillMode(), e.SetRenderTarget(r), a._SetDeviceTransform(e, true), e.SetBlendMode(a._GetBlendMode()), e.SetTexture(t.GetTexture()), tempQuad.setFromRect(a._GetDrawSurfaceRect()), tempRect.copy(a._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);
    }
    Run_WebGPU(e, t, r) {
      const a = this.GetEffectChain();
      e.SetTextureFillMode(), e.SetRenderTarget(r, false), a._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a._SetDeviceTransform(e, true), tempQuad.setFromRect(a._GetDrawSurfaceRect())), e.SetBackTexture(null), e.SetBlendMode(a._GetBlendMode()), e.SetTexture(t.GetTexture()), a.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a._GetRcTexBounce());
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.EffectChain.Step.FirstBounce = class extends C32.Gfx.EffectChain.Step {
    constructor(e, t, r, a) {
      super(e, t, r, a);
    }
    Run_WebGL(e, t, r) {
      const a = this.GetEffectChain();
      e.SetRenderTarget(r, a._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a._SetFirstBounceProgramParameters(e, this.GetIndex()), a._DrawContent(e), a._ClampRcTexDest();
    }
    Run_WebGPU(e, t, r) {
      const a = this.GetEffectChain();
      e.SetRenderTarget(r, false), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a._SetFirstBounceProgramParameters(e, this.GetIndex()), a._DrawContent(e), a._ClampRcTexDest();
    }
  };
}
{
  const C32 = self.C3, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);
  C32.Gfx.EffectChain.Step.Bounce = class extends C32.Gfx.EffectChain.Step {
    constructor(e, t, r, a) {
      super(e, t, r, a);
    }
    Run_WebGL(e, t, r) {
      const a = this.GetEffectChain();
      e.SetRenderTarget(r);
      const d = 0 === this.GetDestTargetId();
      d ? e.SetBlendMode(a._GetBlendMode()) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend()), e.SetProgram(this.GetShaderProgram()), a._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a._SetDeviceTransform(e, d), tempQuad.setFromRect(a._GetDrawSurfaceRect()), tempRect.copy(a._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);
    }
    Run_WebGPU(e, t, r) {
      const a = this.GetEffectChain();
      e.SetRenderTarget(r, false);
      0 === this.GetDestTargetId() ? (e.SetBlendMode(a._GetBlendMode()), e.SetBackTexture(null), a._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a._SetDeviceTransform(e, true), tempQuad.setFromRect(a._GetDrawSurfaceRect()))) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), tempQuad.setFromRect(a._GetRcTexBounce())), e.SetProgram(this.GetShaderProgram()), a._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a._GetRcTexBounce());
    }
  };
}
{
  let SortZOrderList = function(e, t) {
    const r = e[0] - t[0];
    if (0 !== r) return r;
    return e[1] - t[1];
  };
  SortZOrderList2 = SortZOrderList;
  const C32 = self.C3, C3X = self.C3X;
  let runtime = null;
  const keysDownByKey = /* @__PURE__ */ new Set();
  const tempZOrderList = [], tempInstances = [];
  let didWarnInAlertPolyfill = false, didWarnFpsDeprecated = false, didWarnCreateWorkerDeprecated = false;
  const VALID_FRAMERATE_MODES = /* @__PURE__ */ new Set(["vsync", "unlimited-tick", "unlimited-frame"]);
  self.IRuntime = class {
    constructor(e) {
      runtime = e, Object.defineProperties(this, { assets: { value: runtime.GetAssetManager().GetIAssetManager(), writable: false }, collisions: { value: runtime.GetCollisionEngine().GetICollisionEngine(), writable: false }, objects: { value: {}, writable: false }, globalVars: { value: {}, writable: false }, projectName: { value: runtime.GetProjectName(), writable: false }, projectVersion: { value: runtime.GetProjectVersion(), writable: false }, projectId: { value: runtime.GetAppId(), writable: false }, projectUniqueId: { value: runtime.GetProjectUniqueId(), writable: false }, exportDate: { value: new Date(runtime.GetExportTimestamp()), writable: false }, storage: { value: new self.IStorage(runtime), writable: false }, isInWorker: { value: runtime.IsInWorker(), writable: false }, viewportWidth: { value: runtime.GetOriginalViewportWidth(), writable: false }, viewportHeight: { value: runtime.GetOriginalViewportHeight(), writable: false }, sampling: { value: runtime.GetSampling(), writable: false }, platformInfo: { value: new self.IPlatformInfo(e), writable: false }, sdk: { value: new self.ISDKUtils(e), writable: false } }), runtime.UserScriptDispatcher().addEventListener("keydown", (e2) => {
        keysDownByKey.has(e2["key"]) ? e2.stopPropagation() : keysDownByKey.add(e2["key"]);
      }), runtime.UserScriptDispatcher().addEventListener("keyup", (e2) => keysDownByKey.delete(e2["key"])), runtime.Dispatcher().addEventListener("window-blur", () => keysDownByKey.clear()), runtime.IsInWorker() && (self["alert"] = (e2) => (didWarnInAlertPolyfill || (didWarnInAlertPolyfill = true, console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")), this.alert(e2)));
    }
    _InitObjects(e) {
      Object.defineProperties(this.objects, e);
    }
    _InitGlobalVars(e) {
      Object.defineProperties(this.globalVars, e);
    }
    addEventListener(e, t) {
      runtime.UserScriptDispatcher().addEventListener(e, t);
    }
    removeEventListener(e, t) {
      runtime.UserScriptDispatcher().removeEventListener(e, t);
    }
    callFunction(e, ...t) {
      C3X.RequireString(e);
      const r = runtime.GetEventSheetManager(), n = r.GetFunctionBlockByName(e);
      if (!n) throw new Error(`cannot find function name '${e}'`);
      if (!n.IsEnabled()) return n.GetDefaultReturnValue();
      if (t.length < n.GetFunctionParameterCount()) throw new Error(`not enough function parameters passed for '${e}' (${t.length} passed, ${n.GetFunctionParameterCount()} expected)`);
      const i = n.GetEventBlock();
      let a = i.GetSolModifiersIncludingParents();
      const o = r.GetCurrentEvent();
      if (o) {
        a = a.slice(0);
        const e2 = new Set(a);
        for (const t2 of o.GetSolModifiersIncludingParents()) e2.has(t2) || (a.push(t2), e2.add(t2));
        for (const t2 of r.GetDynamicSolModifiersSet()) e2.has(t2) || (a.push(t2), e2.add(t2));
      }
      return i.RunAsExpressionOrJSFunctionCall(a, n.IsCopyPicked(), n.GetReturnType(), n.GetDefaultReturnValue(), null, ...t);
    }
    setReturnValue(e) {
      const t = runtime.GetEventStack().GetCurrentExpFuncStackFrame();
      if (!t) throw new Error("not in a function which returns a value");
      switch (t.GetFunctionReturnType()) {
        case 1:
          "number" == typeof e && t.SetFunctionReturnValue(e);
          break;
        case 2:
          "string" == typeof e && t.SetFunctionReturnValue(e);
          break;
        case 3:
          "number" != typeof e && "string" != typeof e || t.SetFunctionReturnValue(e);
      }
    }
    signal(e) {
      C3X.RequireString(e), runtime.GetEventSheetManager().Signal(e);
    }
    waitForSignal(e) {
      return C3X.RequireString(e), runtime.GetEventSheetManager().WaitForSignal(e);
    }
    getViewportSize() {
      return [runtime.GetOriginalViewportWidth(), runtime.GetOriginalViewportHeight()];
    }
    get isSuspended() {
      return runtime.IsSuspended();
    }
    get dt() {
      return runtime.GetDt();
    }
    get dtRaw() {
      return runtime.GetDtRaw();
    }
    get gameTime() {
      return runtime.GetGameTime();
    }
    get tickCount() {
      return runtime.GetTickCount();
    }
    get wallTime() {
      return runtime.GetWallTime();
    }
    get timeScale() {
      return runtime.GetTimeScale();
    }
    set timeScale(e) {
      C3X.RequireFiniteNumber(e), runtime.SetTimeScale(e);
    }
    get fps() {
      return didWarnFpsDeprecated || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."), didWarnFpsDeprecated = true), runtime.GetFramesPerSecond();
    }
    get framesPerSecond() {
      return runtime.GetFramesPerSecond();
    }
    get ticksPerSecond() {
      return runtime.GetTicksPerSecond();
    }
    get cpuUtilisation() {
      return runtime.GetMainThreadTime();
    }
    get gpuUtilisation() {
      return runtime.GetGPUUtilisation();
    }
    get framerateMode() {
      return runtime.GetFramerateMode();
    }
    set framerateMode(e) {
      if (!VALID_FRAMERATE_MODES.has(e)) throw new Error("invalid framerate mode");
      runtime._SetFramerateMode(e);
    }
    get minDt() {
      return runtime.GetMinDt();
    }
    set minDt(e) {
      C3X.RequireFiniteNumber(e), runtime.SetMinDt(e);
    }
    get maxDt() {
      return runtime.GetMaxDt();
    }
    set maxDt(e) {
      runtime.SetMaxDt(e);
    }
    set isPixelRoundingEnabled(e) {
      runtime.SetPixelRoundingEnabled(!!e);
    }
    get isPixelRoundingEnabled() {
      return runtime.IsPixelRoundingEnabled();
    }
    get loadingProgress() {
      return runtime.GetAssetManager().GetLoadProgress();
    }
    get imageLoadingProgress() {
      return runtime.GetAssetManager().GetImageLoadProgress();
    }
    random() {
      return runtime.Random();
    }
    get layout() {
      const e = runtime.GetMainRunningLayout();
      if (!e) throw new Error("no layout is running - make sure a layout is loaded before accessing");
      return e.GetILayout();
    }
    getLayout(e) {
      const t = runtime.GetLayoutManager();
      let r = null;
      if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
      if (r = t.GetLayout(e), !r) throw new Error("invalid layout");
      return r.GetILayout();
    }
    getAllLayouts() {
      return runtime.GetLayoutManager().GetAllLayouts().map((e) => e.GetILayout());
    }
    goToLayout(e) {
      const t = runtime.GetLayoutManager();
      let r = null;
      if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
      if (r = t.GetLayout(e), !r) throw new Error("invalid layout");
      t.IsPendingChangeMainLayout() || t.ChangeMainLayout(r);
    }
    get keyboard() {
      const e = runtime._GetCommonScriptInterfaces().keyboard;
      if (!e) throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
      return e;
    }
    get mouse() {
      const e = runtime._GetCommonScriptInterfaces().mouse;
      if (!e) throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");
      return e;
    }
    get touch() {
      const e = runtime._GetCommonScriptInterfaces().touch;
      if (!e) throw new Error("runtime.touch used but Touch object missing - add it to your project first");
      return e;
    }
    get timelineController() {
      const e = runtime._GetCommonScriptInterfaces().timelineController;
      if (!e) throw new Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
      return e;
    }
    get renderer() {
      return runtime.GetCanvasManager().GetIRenderer();
    }
    invokeDownload(e, t) {
      C3X.RequireString(e), C3X.RequireString(t), runtime.InvokeDownload(e, t);
    }
    getInstanceByUid(e) {
      C3X.RequireFiniteNumber(e);
      const t = runtime.GetInstanceByUID(e);
      return t ? t.GetInterfaceClass() : null;
    }
    sortZOrder(e, t) {
      C3X.RequireFunction(t);
      const r = runtime.GetCurrentLayout();
      for (const t2 of e) {
        const e2 = runtime._UnwrapIWorldInstance(t2), r2 = e2.GetWorldInfo();
        r2.IsDestroyed() || (tempZOrderList.push([r2.GetLayer().GetIndex(), r2.GetZIndex()]), tempInstances.push(e2));
      }
      if (0 === tempZOrderList.length) return;
      tempZOrderList.sort(SortZOrderList), tempInstances.sort((e2, r2) => t(e2.GetInterfaceClass(), r2.GetInterfaceClass()));
      let n = false;
      for (let e2 = 0, t2 = tempZOrderList.length; e2 < t2; ++e2) {
        const t3 = tempInstances[e2], i = r.GetLayerByIndex(tempZOrderList[e2][0]), a = tempZOrderList[e2][1], o = i._GetInstances();
        o[a] !== t3 && (o[a] = t3, t3.GetWorldInfo()._SetLayer(i, true), i.SetZIndicesChanged(t3), n = true);
      }
      n && runtime.UpdateRender(), C32.clearArray(tempZOrderList), C32.clearArray(tempInstances);
    }
    destroyMultiple(e) {
      for (const t of e) {
        const e2 = runtime._UnwrapIWorldInstance(t);
        runtime.DestroyInstance(e2);
      }
      runtime.GetEventSheetManager().IsInEventEngine() || runtime.GetLayoutManager().IsEndingLayout() || runtime.GetEventSheetManager().IsFlushingBlocked() || runtime.FlushPendingInstances();
    }
    async createWorker(e, t) {
      didWarnCreateWorkerDeprecated || (console.warn("IRuntime.createWorker() is deprecated. All modern browsers now support nested workers so this method is no longer needed."), didWarnCreateWorkerDeprecated = true);
      const r = new MessageChannel(), n = r.port1, i = r.port2;
      return await runtime.PostComponentMessageToDOMAsync("runtime", "script-create-worker", { "url": e, "opts": t, "port2": i }, [i]), n;
    }
    alert(e) {
      return runtime.PostComponentMessageToDOMAsync("runtime", "alert", { "message": e + (runtime.IsInWorker() ? " [via Web Worker]" : "") });
    }
    getHTMLLayer(e) {
      return C3X.RequireFiniteNumber(e), runtime._GetHTMLLayerWrapElement(e);
    }
    addLoadPromise(e) {
      runtime.AddLoadPromise(e);
    }
    async saveCanvasImage(e, t, r) {
      C3X.RequireOptionalString(e), C3X.RequireOptionalNumber(t), C3X.RequireOptionalInstanceOf(r, DOMRect), r || (r = new DOMRect(0, 0, 0, 0));
      const n = runtime.GetCanvasManager();
      if (!n) return;
      runtime.UpdateRender();
      const i = await n.SnapshotCanvas(e || "image/png", t, r.x, r.y, r.width, r.height);
      return await runtime.TriggerAsync(C32.Plugins.System.Cnds.OnCanvasSnapshot, null), i;
    }
  };
}
var SortZOrderList2;
{
  const C32 = self.C3, C3X = self.C3X;
  let assetManager = null;
  self.IAssetManager = class {
    constructor(e) {
      assetManager = e, Object.defineProperties(this, { isWebMOpusSupported: { value: true, writable: false } });
    }
    loadImageAsset(e) {
      const r = self.IImageInfo._Unwrap(e);
      if (!r) throw new Error("invalid IImageInfo");
      r.LoadAsset(assetManager.GetRuntime());
    }
    fetchText(e) {
      return assetManager.FetchText(e);
    }
    fetchJson(e) {
      return assetManager.FetchJson(e);
    }
    fetchBlob(e) {
      return assetManager.FetchBlob(e);
    }
    fetchArrayBuffer(e) {
      return assetManager.FetchArrayBuffer(e);
    }
    getProjectFileUrl(e) {
      return Promise.resolve(assetManager.GetProjectFileUrl(e));
    }
    getMediaFileUrl(e) {
      return assetManager.GetMediaFileUrl(e);
    }
    get mediaFolder() {
      return assetManager.GetMediaSubfolder();
    }
    async decodeWebMOpus(e, r) {
      throw new Error("decodeWebMOpus() is no longer supported - use Web Audio's decodeAudioData() directly as all supported platforms now support WebM Opus");
    }
    loadScripts(...e) {
      return assetManager.LoadScripts(...e);
    }
    compileWebAssembly(e) {
      return assetManager.CompileWebAssembly(e);
    }
    loadStyleSheet(e) {
      return assetManager.LoadStyleSheet(e);
    }
    get projectFileList() {
      return assetManager.GetExportedFileList();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  let collisionEngine = null;
  self.ICollisionEngine = class {
    constructor(n) {
      collisionEngine = n, Object.defineProperties(this, { runtime: { value: collisionEngine.GetRuntime(), writable: false } });
    }
    testOverlap(n, e) {
      const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n), t = l._UnwrapIWorldInstance(e);
      return collisionEngine.TestOverlap(i, t);
    }
    testOverlapAny(n, e) {
      const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n);
      for (const n2 of e) {
        const e2 = l._UnwrapIWorldInstance(n2);
        if (collisionEngine.TestOverlap(i, e2)) return n2;
      }
      return null;
    }
    testOverlapSolid(n) {
      const e = collisionEngine.GetRuntime()._UnwrapIWorldInstance(n), l = collisionEngine.TestOverlapSolid(e);
      return l ? l.GetInterfaceClass() : null;
    }
    setCollisionCellSize(n, e) {
      if (C3X.RequireFiniteNumber(n), C3X.RequireFiniteNumber(e), n = Math.floor(n), e = Math.floor(e), n <= 0 || e <= 0) throw new Error("invalid cell size");
      collisionEngine.SetCollisionCellSize(n, e);
    }
    getCollisionCellSize() {
      return collisionEngine.GetCollisionCellSize();
    }
    getCollisionCandidates(n, e) {
      const l = collisionEngine.GetRuntime();
      let i;
      i = Array.isArray(n) ? n.map((n2) => l._UnwrapIObjectClass(n2)) : [l._UnwrapIObjectClass(n)];
      const t = C32.Rect.FromObject(e), o = [];
      return collisionEngine.GetObjectClassesCollisionCandidates(null, i, t, o), o.map((n2) => n2.GetInterfaceClass());
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  let runtime = null;
  const osMap = /* @__PURE__ */ new Map([["Windows", "windows"], ["macOS", "macos"], ["Linux", "linux"], ["Chrome OS", "chrome-os"], ["Android", "android"], ["iOS", "ios"]]), browserMap = /* @__PURE__ */ new Map([["Chrome", "chrome"], ["Chromium", "chromium"], ["Edge", "edge"], ["Opera", "opera"], ["Firefox", "firefox"], ["Safari", "safari"]]), browserEngineMap = /* @__PURE__ */ new Map([["Chromium", "chromium"], ["Gecko", "gecko"], ["WebKit", "webkit"]]);
  self.IPlatformInfo = class {
    constructor(e) {
      runtime = e, Object.defineProperties(this, { isMobile: { value: C32.Platform.IsMobile, writable: false }, os: { value: osMap.get(C32.Platform.OS) || "unknown", writable: false }, osVersion: { value: C32.Platform.OSVersion, writable: false }, browser: { value: browserMap.get(C32.Platform.Browser) || "unknown", writable: false }, browserVersion: { value: C32.Platform.BrowserVersion, writable: false }, browserEngine: { value: browserEngineMap.get(C32.Platform.BrowserEngine) || "unknown", writable: false } });
    }
    get exportType() {
      let e = runtime.GetExportType();
      return runtime.IsWindowsWebView2() ? e = "windows-webview2" : "cordova" === e ? e = "Android" === C32.Platform.OS ? "cordova-android" : "cordova-ios" : "playable-ad-single-file" !== e && "playable-ad-zip" !== e || (e = "playable-ad"), e;
    }
    get renderer() {
      return runtime.GetCanvasManager().GetRendererString();
    }
    get rendererDetail() {
      return runtime.GetCanvasManager().GetRendererDetailString();
    }
    get canvasClientX() {
      return runtime.GetCanvasManager().GetCanvasClientX();
    }
    get canvasClientY() {
      return runtime.GetCanvasManager().GetCanvasClientY();
    }
    get canvasCssWidth() {
      return runtime.GetCanvasManager().GetCssWidth();
    }
    get canvasCssHeight() {
      return runtime.GetCanvasManager().GetCssHeight();
    }
    get canvasDeviceWidth() {
      return runtime.GetCanvasManager().GetDeviceWidth();
    }
    get canvasDeviceHeight() {
      return runtime.GetCanvasManager().GetDeviceHeight();
    }
    get devicePixelRatio() {
      return runtime.GetDevicePixelRatio();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.IStorage = class {
    constructor(e) {
      this._storage = e._GetProjectStorage();
    }
    getItem(e) {
      return C3X.RequireString(e), this._storage.getItem(e);
    }
    setItem(e, t) {
      return C3X.RequireString(e), this._storage.setItem(e, t);
    }
    removeItem(e) {
      return C3X.RequireString(e), this._storage.removeItem(e);
    }
    clear() {
      return this._storage.clear();
    }
    keys() {
      return this._storage.keys();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.IPlugin = class {
    #e;
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e, Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, id: { value: e.GetID(), writable: false }, isSingleGlobal: { value: e.IsSingleGlobal(), writable: false }, isWorldType: { value: e.IsWorldType(), writable: false }, isHTMLElementType: { value: e.IsHTMLElementType(), writable: false }, isRotatable: { value: e.IsRotatable(), writable: false }, hasEffects: { value: e.HasEffects(), writable: false }, is3d: { value: e.Is3D(), writable: false }, supportsHierarchies: { value: e.SupportsSceneGraph(), writable: false }, supportsMesh: { value: e.SupportsMesh(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
    }
    static getByConstructor(e) {
      if (!e) return null;
      const t = C32.AddonManager.GetPluginByConstructorFunction(e);
      return t ? t.GetIPlugin() : null;
    }
    getSingleGlobalObjectType() {
      return this.#e.GetSingleGlobalObjectClass().GetIObjectClass();
    }
    getSingleGlobalInstance() {
      return this.#e.GetSingleGlobalInstance().GetInterfaceClass();
    }
  };
}
{
  const C32 = globalThis.C3, C3X = globalThis.C3X, internalApiToken = C32._GetInternalAPIToken();
  globalThis.IObjectClass = class {
    #e;
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
    }
    addEventListener(e, t) {
      C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().addEventListener(e, t);
    }
    removeEventListener(e, t) {
      C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().removeEventListener(e, t);
    }
    getAllInstances() {
      return [...this.instances()];
    }
    getFirstInstance() {
      return C32.first(this.instances());
    }
    getPickedInstances() {
      return [...this.pickedInstances()];
    }
    getFirstPickedInstance() {
      return C32.first(this.pickedInstances());
    }
    getPairedInstance(e) {
      const t = this.#e, n = t.GetRuntime()._UnwrapIInstance(e), s = t.GetPairedInstance(n);
      return s ? s.GetInterfaceClass() : null;
    }
    *instances() {
      for (const e of this.#e.instancesIncludingPendingCreate()) yield e.GetInterfaceClass();
    }
    *pickedInstances() {
      for (const e of this.#e.GetCurrentSol().GetInstances()) yield e.GetInterfaceClass();
    }
    callCustomAction(e, t, ...n) {
      C3X.RequireString(e);
      const s = this.#e, i = s.GetRuntime(), r = i.GetEventSheetManager(), a = r.GetCustomActionBlockByName(s, e);
      if (!a) throw new Error(`cannot find '${this.name}' custom action '${e}'`);
      if (!a.IsEnabled()) return null;
      if (n.length < a.GetFunctionParameterCount()) throw new Error(`not enough function parameters passed for '${this.name}' custom action '${e}' (${n.length} passed, ${a.GetFunctionParameterCount()} expected)`);
      const c = a.GetEventBlock();
      let o = c.GetSolModifiersIncludingParents();
      const l = r.GetCurrentEvent();
      if (l) {
        o = o.slice(0);
        const e2 = new Set(o);
        for (const t2 of l.GetSolModifiersIncludingParents()) e2.has(t2) || (o.push(t2), e2.add(t2));
        for (const t2 of r.GetDynamicSolModifiersSet()) e2.has(t2) || (o.push(t2), e2.add(t2));
      }
      if (s.IsFamily() && a.HasCustomACEOverrides()) {
        const r2 = /* @__PURE__ */ new Map(), l2 = [];
        for (const n2 of t) {
          const t2 = i._UnwrapIInstance(n2), s2 = t2.GetObjectClass();
          if (s2.HasOwnCustomActionByName(e)) {
            const e2 = r2.get(s2);
            Array.isArray(e2) ? e2.push(t2) : r2.set(s2, [t2]);
          } else l2.push(t2);
        }
        const u = [];
        if (l2.length > 0) {
          const e2 = { pickObjectClass: s, pickInstances: l2 }, t2 = c.RunAsExpressionOrJSFunctionCall(o, a.IsCopyPicked(), 0, null, e2, ...n);
          u.push(t2);
        }
        if (r2.size > 0) for (const [t2, s2] of r2) {
          const i2 = t2.GetOwnCustomActionByName(e).GetEventBlock(), r3 = [.../* @__PURE__ */ new Set([...o, ...i2.GetSolModifiers()])], c2 = { pickObjectClass: t2, pickInstances: s2 }, l3 = i2.RunAsExpressionOrJSFunctionCall(r3, a.IsCopyPicked(), 0, null, c2, ...n);
          u.push(l3);
        }
        return Promise.all(u);
      }
      {
        const e2 = { pickObjectClass: a.GetObjectClass(), pickInstances: (Array.isArray(t) ? t : [...t]).map((e3) => i._UnwrapIInstance(e3)) }, s2 = c.RunAsExpressionOrJSFunctionCall(o, a.IsCopyPicked(), 0, null, e2, ...n);
        return s2 instanceof Promise ? s2 : Promise.resolve();
      }
    }
  };
}
{
  const C32 = globalThis.C3, C3X = globalThis.C3X, internalApiToken = C32._GetInternalAPIToken();
  globalThis.IObjectType = class extends globalThis.IObjectClass {
    #e;
    constructor() {
      super();
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e;
    }
    setInstanceClass(e) {
      C3X.RequireFunction(e);
      const t = this.#e;
      if (t.GetInstanceCount() > 0) throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
      t._SetUserScriptInstanceClass(e);
    }
    createInstance(e, t, n, a, s) {
      if (C3X.RequireNumber(t), C3X.RequireNumber(n), "number" != typeof e && "string" != typeof e) throw new TypeError("invalid layer parameter");
      const r = this.#e, i = r.GetRuntime(), l = i.GetMainRunningLayout().GetLayer(e);
      if (!l) throw new Error("invalid layer");
      const c = i.CreateInstance(r, l, t, n, a, s);
      a && l.SortAndAddInstancesByZIndex(c);
      const o = i.GetEventSheetManager();
      return o.BlockFlushingInstances(true), c._TriggerOnCreatedOnSelfAndRelated(), o.BlockFlushingInstances(false), o.IsInEventEngine() || i.GetLayoutManager().IsEndingLayout() || i.FlushPendingInstances(), c.GetInterfaceClass();
    }
    getAllFamilies() {
      return this.#e.GetFamilies().map((e) => e.GetIObjectClass());
    }
    *families() {
      for (const e of this.#e.GetFamilies()) yield e.GetIObjectClass();
    }
    isInFamily(e) {
      return C3X.RequireInstanceOf(e, globalThis.IFamily), e.hasObjectType(this);
    }
  };
}
{
  const C32 = globalThis.C3, C3X = globalThis.C3X, IObjectType = globalThis.IObjectType, internalApiToken = C32._GetInternalAPIToken();
  globalThis.IFamily = class extends globalThis.IObjectClass {
    #e;
    constructor() {
      super();
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e;
    }
    getAllObjectTypes() {
      return this.#e.GetFamilyMembers().map((e) => e.GetIObjectClass());
    }
    *objectTypes() {
      for (const e of this.#e.GetFamilyMembers()) yield e.GetIObjectClass();
    }
    hasObjectType(e) {
      C3X.RequireInstanceOf(e, IObjectType);
      const t = this.#e, s = t.GetRuntime()._UnwrapIObjectClass(e);
      return t.FamilyHasMember(s);
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, VALID_WHERE_STRINGS = ["above", "below", "top-sublayer", "bottom-sublayer"];
  self.ILayout = class {
    #e;
    constructor(e) {
      this.#e = e;
      const t = [], r = e.GetEffectList(), i = r.GetAllEffectTypes().length;
      for (let e2 = 0; e2 < i; ++e2) t.push(new self.IEffectInstance(r, e2));
      Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, name: { value: e.GetName(), writable: false }, index: { value: e.GetIndex(), writable: false }, effects: { value: t, writable: false } });
    }
    addEventListener(e, t) {
      C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().addEventListener(e, t);
    }
    removeEventListener(e, t) {
      C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().removeEventListener(e, t);
    }
    get width() {
      return this.#e.GetWidth();
    }
    set width(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetWidth(e);
    }
    get height() {
      return this.#e.GetHeight();
    }
    set height(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetHeight(e);
    }
    setSize(e, t) {
      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t);
      const r = this.#e;
      r.SetWidth(e), r.SetHeight(t);
    }
    getSize() {
      const e = this.#e;
      return [e.GetWidth(), e.GetHeight()];
    }
    set scale(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetScale(e);
    }
    get scale() {
      return this.#e.GetScale();
    }
    set angle(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetAngle(e);
    }
    get angle() {
      return this.#e.GetAngle();
    }
    set scrollX(e) {
      C3X.RequireNumber(e), this.#e.SetScrollX(e);
    }
    get scrollX() {
      return this.#e.GetScrollX();
    }
    set scrollY(e) {
      C3X.RequireNumber(e), this.#e.SetScrollY(e);
    }
    get scrollY() {
      return this.#e.GetScrollY();
    }
    scrollTo(e, t) {
      C3X.RequireNumber(e), C3X.RequireNumber(t);
      const r = this.#e;
      r.SetScrollX(e), r.SetScrollY(t);
    }
    getScrollPosition() {
      const e = this.#e;
      return [e.GetScrollX(), e.GetScrollY()];
    }
    get isUnboundedScrolling() {
      return this.#e.IsUnboundedScrolling();
    }
    getLayer(e) {
      const t = this.#e;
      let r = null;
      if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
      return r = t.GetLayer(e), r ? r.GetILayer() : null;
    }
    getAllLayers() {
      return this.#e.GetLayers().map((e) => e.GetILayer());
    }
    *allLayers() {
      for (const e of this.#e.allLayers()) yield e.GetILayer();
    }
    addLayer(e, t, r) {
      const i = this.#e, n = self.ILayer;
      C3X.RequireString(e), C3X.RequireOptionalInstanceOf(t, n);
      const s = t ? i.GetRuntime()._UnwrapScriptInterface(t) : null, a = VALID_WHERE_STRINGS.indexOf(r);
      if (a < 0) throw new Error("invalid location");
      i.AddLayer(e, s, a);
    }
    moveLayer(e, t, r) {
      const i = this.#e, n = i.GetRuntime(), s = self.ILayer;
      C3X.RequireInstanceOf(e, s);
      const a = n._UnwrapScriptInterface(e);
      if (!a) throw new Error("invalid layer");
      C3X.RequireOptionalInstanceOf(t, s);
      const o = t ? n._UnwrapScriptInterface(t) : null, l = VALID_WHERE_STRINGS.indexOf(r);
      if (l < 0) throw new Error("invalid location");
      i.MoveLayer(a, o, l);
    }
    removeLayer(e) {
      const t = this.#e, r = self.ILayer;
      C3X.RequireInstanceOf(e, r);
      const i = t.GetRuntime()._UnwrapScriptInterface(e);
      if (!i) throw new Error("invalid layer");
      const n = i.GetRuntime();
      t.RemoveLayer(i), n.GetEventSheetManager().IsInEventEngine() || n.FlushPendingInstances();
    }
    removeAllDynamicLayers() {
      const e = this.#e, t = e.GetRuntime();
      e.RemoveAllDynamicLayers(), t.GetEventSheetManager().IsInEventEngine() || t.FlushPendingInstances();
    }
    setVanishingPoint(e, t) {
      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t), this.#e.SetVanishingPointXY(e, t);
    }
    getVanishingPoint() {
      return this.#e.GetVanishingPoint();
    }
    set projection(e) {
      C3X.RequireString(e);
      const t = this.#e;
      if ("perspective" === e) t.SetPerspectiveProjection();
      else {
        if ("orthographic" !== e) throw new Error("invalid projection");
        t.SetOrthographicProjection();
      }
    }
    get projection() {
      return this.#e.IsOrthographicProjection() ? "orthographic" : "perspective";
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10], ["lighten", 11], ["darken", 12], ["multiply", 13], ["screen", 14]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), VALID_RENDERING_MODES = /* @__PURE__ */ new Set(["2d", "3d"]), tempColor = C32.New(C32.Color);
  self.ILayer = class {
    #e;
    constructor(e) {
      this.#e = e;
      const t = [], r = e.GetEffectList(), i = r.GetAllEffectTypes().length;
      for (let e2 = 0; e2 < i; ++e2) t.push(new self.IEffectInstance(r, e2));
      Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, name: { value: e.GetName(), writable: false }, layout: { value: e.GetLayout().GetILayout(), writable: false }, effects: { value: t, writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
    }
    addEventListener(e, t) {
      this.#e.UserScriptDispatcher().addEventListener(e, t);
    }
    removeEventListener(e, t) {
      this.#e.UserScriptDispatcher().removeEventListener(e, t);
    }
    get parentLayer() {
      const e = this.#e.GetParentLayer();
      return e ? e.GetILayer() : null;
    }
    *parentLayers() {
      for (const e of this.#e.parentLayers()) yield e.GetILayer();
    }
    *subLayers() {
      for (const e of this.#e.GetSubLayers()) yield e.GetILayer();
    }
    *allSubLayers() {
      for (const e of this.#e.GetSubLayers()) for (const t of e.selfAndAllSubLayers()) yield t.GetILayer();
    }
    get index() {
      return this.#e.GetIndex();
    }
    get isVisible() {
      return this.#e._IsVisibleFlagSet();
    }
    set isVisible(e) {
      this.#e.SetVisible(e);
    }
    get isSelfAndParentsVisible() {
      return this.#e.IsVisible();
    }
    get isInteractive() {
      return this.#e.IsInteractive();
    }
    set isInteractive(e) {
      this.#e.SetInteractive(e);
    }
    get isHTMLElementsLayer() {
      return this.#e.IsHTMLElementsLayer();
    }
    set isHTMLElementsLayer(e) {
      this.#e.SetIsHTMLElementsLayer(!!e);
    }
    get isSelfAndParentsInteractive() {
      return this.#e.IsSelfAndParentsInteractive();
    }
    get opacity() {
      return this.#e.GetOpacity();
    }
    set opacity(e) {
      e = C32.clamp(+e, 0, 1), isNaN(e) || this.#e.SetOpacity(e);
    }
    set scale(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetOwnScale(e);
    }
    get scale() {
      return this.#e.GetOwnScale();
    }
    set scaleRate(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetScaleRate(e);
    }
    get scaleRate() {
      return this.#e.GetScaleRate();
    }
    set angle(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetAngle(e);
    }
    get angle() {
      return this.#e.GetOwnAngle();
    }
    set parallaxX(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetParallaxX(e);
    }
    get parallaxX() {
      return this.#e.GetParallaxX();
    }
    set parallaxY(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetParallaxY(e);
    }
    get parallaxY() {
      return this.#e.GetParallaxY();
    }
    set zElevation(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetZElevation(e);
    }
    get zElevation() {
      return this.#e.GetZElevation();
    }
    set renderingMode(e) {
      if (!VALID_RENDERING_MODES.has(e)) throw TypeError("invalid rendering mode");
      this.#e.SetRenderAs3D("3d" === e);
    }
    get renderingMode() {
      return this.#e.IsRenderAs3D() ? "3d" : "2d";
    }
    set isTransparent(e) {
      this.#e.SetTransparent(e);
    }
    get isTransparent() {
      return this.#e.IsTransparent();
    }
    set isForceOwnTexture(e) {
      this.#e.SetForceOwnTexture(e);
    }
    get isForceOwnTexture() {
      return this.#e.IsForceOwnTexture();
    }
    set blendMode(e) {
      C3X.RequireString(e);
      const t = BLEND_MODE_TO_INDEX.get(e);
      if ("number" != typeof t) throw new Error("invalid blend mode");
      this.#e.SetBlendMode(t);
    }
    get blendMode() {
      return INDEX_TO_BLEND_MODE.get(this.#e.GetBlendMode());
    }
    set backgroundColor(e) {
      if (C3X.RequireArray(e), e.length < 3) throw new Error("expected 3 elements");
      tempColor.setRgb(e[0], e[1], e[2]);
      const t = this.#e, r = t.GetBackgroundColor();
      r.equalsIgnoringAlpha(tempColor) || (r.copyRgb(tempColor), t.GetRuntime().UpdateRender());
    }
    get backgroundColor() {
      const e = this.#e.GetBackgroundColor();
      return [e.getR(), e.getG(), e.getB()];
    }
    set scrollX(e) {
      C3X.RequireNumber(e);
      const t = this.#e;
      t.SetOwnScrollPositionEnabled(true), t.SetScrollX(e);
    }
    get scrollX() {
      return this.#e.GetScrollX();
    }
    set scrollY(e) {
      C3X.RequireNumber(e);
      const t = this.#e;
      t.SetOwnScrollPositionEnabled(true), t.SetScrollY(e);
    }
    get scrollY() {
      return this.#e.GetScrollY();
    }
    scrollTo(e, t) {
      C3X.RequireNumber(e), C3X.RequireNumber(t);
      const r = this.#e;
      r.SetOwnScrollPositionEnabled(true), r.SetScrollX(e), r.SetScrollY(t);
    }
    getScrollPosition() {
      const e = this.#e;
      return [e.GetScrollX(), e.GetScrollY()];
    }
    restoreScrollPosition() {
      this.#e.SetOwnScrollPositionEnabled(false);
    }
    getViewport() {
      return this.#e.GetViewport().toDOMRect();
    }
    cssPxToLayer(e, t, r = 0) {
      C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r);
      const i = this.#e, a = i.GetRuntime();
      return i.CanvasCssToLayer(e - a.GetCanvasClientX(), t - a.GetCanvasClientY(), r);
    }
    layerToCssPx(e, t, r = 0) {
      C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r);
      const i = this.#e, a = i.GetRuntime(), [s, n] = i.LayerToCanvasCss(e, t, r);
      return [s + a.GetCanvasClientX(), n + a.GetCanvasClientY()];
    }
    drawSurfaceToLayer(e, t, r = 0) {
      return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r), this.#e.DrawSurfaceToLayer(e, t, r);
    }
    layerToDrawSurface(e, t, r = 0) {
      return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r), this.#e.LayerToDrawSurface(e, t, r);
    }
    get renderScale() {
      return this.#e.GetRenderScale();
    }
  };
}
{
  let GetDispatcher = function(e) {
    let t = dispatchers.get(e);
    return t || (t = C32.New(C32.Event.Dispatcher), dispatchers.set(e, t), t);
  };
  GetDispatcher2 = GetDispatcher;
  const C32 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.IInstance = class {
    #e;
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e;
      const t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, objectType: { value: e.GetObjectClass().GetIObjectClass(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } };
      e._GetInstVarsScriptDescriptor(t), e._GetBehaviorsScriptDescriptor(t), Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);
    }
    static _GetInitInst() {
      return C32.AddonManager._GetInitObject();
    }
    _release() {
      const e = dispatchers.get(this);
      e && (e.Release(), dispatchers.delete(this));
    }
    addEventListener(e, t, i) {
      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).addEventListener(e, t, i);
    }
    removeEventListener(e, t, i) {
      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).removeEventListener(e, t, i);
    }
    dispatchEvent(e) {
      GetDispatcher(this).dispatchEvent(e);
    }
    destroy() {
      const e = this.#e, t = e.GetRuntime();
      t.DestroyInstance(e), t.GetEventSheetManager().IsInEventEngine() || t.GetLayoutManager().IsEndingLayout() || t.GetEventSheetManager().IsFlushingBlocked() || t.FlushPendingInstances();
    }
    getOtherContainerInstances() {
      const e = this.#e.GetSiblings();
      return e ? e.map((e2) => e2.GetInterfaceClass()) : [];
    }
    *otherContainerInstances() {
      const e = this.#e;
      if (e.IsInContainer()) for (const t of e.siblings()) yield t.GetInterfaceClass();
    }
    get uid() {
      return this.#e.GetUID();
    }
    get iid() {
      return this.#e.GetIID();
    }
    get templateName() {
      return this.#e.GetTemplateName();
    }
    set timeScale(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetTimeScale(e);
    }
    get timeScale() {
      return this.#e.GetActiveTimeScale();
    }
    restoreTimeScale() {
      this.#e.RestoreTimeScale();
    }
    get dt() {
      const e = this.#e;
      return e.GetRuntime().GetDt(e);
    }
    hasTag(e) {
      return C3X.RequireString(e), this.#e.HasTag(e);
    }
    hasTags(...e) {
      C3X.RequireArray(e);
      const t = new Set(e.map((e2) => e2.toLowerCase())), i = this.#e.GetLowercaseTagsSet();
      return t.isSubsetOf(i);
    }
    setAllTags(e) {
      e instanceof Set || (e = new Set(e)), this.#e.SetTagsSet(e);
    }
    getAllTags() {
      return new Set(this.#e.GetTagsSet());
    }
    signal(e) {
      C3X.RequireString(e);
      const t = this.#e;
      t.GetRuntime().GetEventSheetManager().InstanceSignal(t, e);
    }
    waitForSignal(e) {
      C3X.RequireString(e);
      const t = this.#e;
      return t.GetRuntime().GetEventSheetManager().WaitForInstanceSignal(t, e);
    }
    callCustomAction(e, ...t) {
      return this.objectType.callCustomAction(e, [this], ...t);
    }
  };
}
var GetDispatcher2;
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.ISDKInstanceBase = class extends self.IInstance {
    #e;
    #t = false;
    #n = null;
    #i = false;
    #r = null;
    #s;
    #o;
    constructor(e) {
      super(), this.#e = C32.AddonManager._GetInitObject2(internalApiToken), this.#t = false, this.#n = null, this.#i = false, this.#r = null, this.#s = e?.domComponentId, this.#o = e?.wrapperComponentId;
    }
    _release() {
      this._setTicking(false), this._setTicking2(false), super._release();
    }
    _getInitProperties() {
      return C32.AddonManager._GetInitProperties();
    }
    _trigger(e) {
      const t = this.#e;
      t.GetRuntime().Trigger(e, t);
    }
    _triggerAsync(e) {
      const t = this.#e;
      return t.GetRuntime().TriggerAsync(e, t);
    }
    _addDOMMessageHandler(e, t) {
      if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#s) throw new Error("no DOM component id set");
      this.#e.GetRuntime().AddDOMComponentMessageHandler(this.#s, e, t);
    }
    _addDOMMessageHandlers(e) {
      C3X.RequireArray(e);
      for (const [t, n] of e) this._addDOMMessageHandler(t, n);
    }
    _postToDOM(e, t) {
      if (C3X.RequireString(e), !this.#s) throw new Error("no DOM component id set");
      this.#e.GetRuntime().PostComponentMessageToDOM(this.#s, e, t);
    }
    _postToDOMAsync(e, t) {
      if (C3X.RequireString(e), !this.#s) throw new Error("no DOM component id set");
      return this.#e.GetRuntime().PostComponentMessageToDOMAsync(this.#s, e, t);
    }
    _postToDOMMaybeSync(e, t) {
      if (!this.#e.GetRuntime().IsInWorker()) return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({ "type": "event", "component": this.#s, "handler": e, "data": t, "responseId": null });
      this._postToDOM(e, t);
    }
    _setTicking(e) {
      if (e = !!e, this.#t === e) return;
      this.#t = e;
      const t = this.#e.GetRuntime();
      if (e) {
        if (!this.#n) if (this.#e.GetRuntime().IsDebug()) {
          const e2 = globalThis.C3Debugger, t2 = this.plugin;
          this.#n = () => {
            const n = performance.now();
            this._tick(), e2.AddIndividualPluginTickTime(t2, performance.now() - n);
          };
        } else this.#n = () => this._tick();
        t.Dispatcher().addEventListener("tick", this.#n);
      } else t.Dispatcher().removeEventListener("tick", this.#n);
    }
    _isTicking() {
      return this.#t;
    }
    _tick() {
    }
    _setTicking2(e) {
      if (e = !!e, this.#i === e) return;
      this.#i = e;
      const t = this.#e.GetRuntime();
      if (e) {
        if (!this.#r) if (this.#e.GetRuntime().IsDebug()) {
          const e2 = globalThis.C3Debugger, t2 = this.plugin;
          this.#r = () => {
            const n = performance.now();
            this._tick2(), e2.AddIndividualPluginTickTime(t2, performance.now() - n);
          };
        } else this.#r = () => this._tick2();
        t.Dispatcher().addEventListener("tick2", this.#r);
      } else t.Dispatcher().removeEventListener("tick2", this.#r);
    }
    _isTicking2() {
      return this.#i;
    }
    _tick2() {
    }
    _getDebuggerProperties() {
      return [];
    }
    _saveToJson() {
      return null;
    }
    _loadFromJson(e) {
    }
    _isWrapperExtensionAvailable() {
      if (!this.#o) throw new Error("no wrapper component id set");
      return this.#e.GetRuntime().HasWrapperComponentId(this.#o);
    }
    _addWrapperExtensionMessageHandler(e, t) {
      if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#o) throw new Error("no wrapper component id set");
      this.#e.GetRuntime().AddWrapperExtensionMessageHandler(this.#o, e, t);
    }
    _addWrapperMessageHandlers(e) {
      C3X.RequireArray(e);
      for (const [t, n] of e) this._addWrapperExtensionMessageHandler(t, n);
    }
    _sendWrapperExtensionMessage(e, t) {
      if (!this.#o) throw new Error("no wrapper component id set");
      this.runtime.sdk.sendWrapperExtensionMessage(this.#o, e, t);
    }
    _sendWrapperExtensionMessageAsync(e, t) {
      if (!this.#o) throw new Error("no wrapper component id set");
      return this.runtime.sdk.sendWrapperExtensionMessageAsync(this.#o, e, t);
    }
  };
}
{
  let MakeIWorldInstanceClass = function(e) {
    return class t extends e {
      #e;
      #t;
      constructor(e2) {
        super(e2);
        const t2 = C32.AddonManager._GetInitObject2(internalApiToken), i = t2.GetWorldInfo();
        this.#e = t2, this.#t = i, map.set(this, t2);
        const n = [], r = i.GetInstanceEffectList();
        if (r) {
          const e3 = i.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
          for (let t3 = 0; t3 < e3; ++t3) n.push(new self.IEffectInstance(r, t3));
        }
        const s = { effects: { value: n, writable: false } };
        Object.defineProperties(this, s);
      }
      get layout() {
        return this.#t.GetLayout().GetILayout();
      }
      get layer() {
        return this.#t.GetLayer().GetILayer();
      }
      get x() {
        return this.#t.GetX();
      }
      set x(e2) {
        e2 = +e2;
        const t2 = this.#t;
        isNaN(e2) || t2.GetX() === e2 || (t2.SetX(e2), t2.SetBboxChanged());
      }
      get y() {
        return this.#t.GetY();
      }
      set y(e2) {
        e2 = +e2;
        const t2 = this.#t;
        isNaN(e2) || t2.GetY() === e2 || (t2.SetY(e2), t2.SetBboxChanged());
      }
      setPosition(e2, t2) {
        e2 = +e2, t2 = +t2;
        const i = this.#t;
        isNaN(e2) || isNaN(t2) || i.GetX() === e2 && i.GetY() === t2 || (i.SetXY(e2, t2), i.SetBboxChanged());
      }
      getPosition() {
        const e2 = this.#t;
        return [e2.GetX(), e2.GetY()];
      }
      offsetPosition(e2, t2) {
        if (e2 = +e2, t2 = +t2, isNaN(e2) || isNaN(t2) || 0 === e2 && 0 === t2) return;
        const i = this.#t;
        i.OffsetXY(e2, t2), i.SetBboxChanged();
      }
      set originX(e2) {
        e2 = +e2;
        const t2 = this.#t;
        isNaN(e2) || t2.GetOriginX() === e2 || (t2.SetOriginX(e2), t2.SetBboxChanged());
      }
      get originX() {
        return this.#t.GetOriginX();
      }
      set originY(e2) {
        e2 = +e2;
        const t2 = this.#t;
        isNaN(e2) || t2.GetOriginY() === e2 || (t2.SetOriginY(e2), t2.SetBboxChanged());
      }
      get originY() {
        return this.#t.GetOriginY();
      }
      setOrigin(e2, t2) {
        e2 = +e2, t2 = +t2;
        const i = this.#t;
        isNaN(e2) || isNaN(t2) || i.GetOriginX() === e2 && i.GetOriginY() === t2 || (i.SetOriginX(e2), i.SetOriginY(t2), i.SetBboxChanged());
      }
      getOrigin() {
        const e2 = this.#t;
        return [e2.GetOriginX(), e2.GetOriginY()];
      }
      get zElevation() {
        return this.#t.GetZElevation();
      }
      set zElevation(e2) {
        e2 = +e2;
        const t2 = this.#e, i = this.#t;
        isNaN(e2) || i.GetZElevation() === e2 || (i.SetZElevation(e2), t2.GetRuntime().UpdateRender());
      }
      get totalZElevation() {
        return this.#t.GetTotalZElevation();
      }
      get width() {
        return this.#t.GetWidth();
      }
      set width(e2) {
        e2 = +e2;
        const t2 = this.#t;
        isNaN(e2) || t2.GetWidth() === e2 || (t2.SetWidth(e2), t2.SetBboxChanged());
      }
      get height() {
        return this.#t.GetHeight();
      }
      set height(e2) {
        e2 = +e2;
        const t2 = this.#t;
        isNaN(e2) || t2.GetHeight() === e2 || (t2.SetHeight(e2), t2.SetBboxChanged());
      }
      setSize(e2, t2) {
        e2 = +e2, t2 = +t2;
        const i = this.#t;
        isNaN(e2) || isNaN(t2) || i.GetWidth() === e2 && i.GetHeight() === t2 || (i.SetSize(e2, t2), i.SetBboxChanged());
      }
      getSize() {
        const e2 = this.#t;
        return [e2.GetWidth(), e2.GetHeight()];
      }
      get angle() {
        return this.#t.GetAngle();
      }
      set angle(e2) {
        e2 = C32.clampAngle(+e2);
        const t2 = this.#t;
        isNaN(e2) || t2.GetAngle() === e2 || (t2.SetAngle(e2), t2.SetBboxChanged());
      }
      get angleDegrees() {
        return C32.toDegrees(this.angle);
      }
      set angleDegrees(e2) {
        this.angle = C32.toRadians(e2);
      }
      getBoundingBox(e2) {
        return e2 ? (this.#t.CalculateBbox(tempRect, tempQuad, false), tempRect.toDOMRect()) : this.#t.GetBoundingBox().toDOMRect();
      }
      getBoundingQuad(e2) {
        return e2 ? (this.#t.CalculateBbox(tempRect, tempQuad, false), tempQuad.toDOMQuad()) : this.#t.GetBoundingQuad().toDOMQuad();
      }
      isOnScreen() {
        return this.#t.IsInViewport2();
      }
      get isVisible() {
        return this.#t.IsVisible();
      }
      set isVisible(e2) {
        e2 = !!e2;
        const t2 = this.#e, i = this.#t;
        i.IsVisible() !== e2 && (i.SetVisible(e2), t2.GetRuntime().UpdateRender());
      }
      get opacity() {
        return this.#t.GetOpacity();
      }
      set opacity(e2) {
        e2 = C32.clamp(+e2, 0, 1);
        const t2 = this.#e, i = this.#t;
        isNaN(e2) || i.GetOpacity() === e2 || (i.SetOpacity(e2), t2.GetRuntime().UpdateRender());
      }
      set colorRgb(e2) {
        if (C3X.RequireArray(e2), e2.length < 3) throw new Error("expected 3 elements");
        tempColor.setRgb(e2[0], e2[1], e2[2]);
        const t2 = this.#e, i = this.#t;
        i.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (i.SetUnpremultipliedColor(tempColor), t2.GetRuntime().UpdateRender());
      }
      get colorRgb() {
        const e2 = this.#t.GetUnpremultipliedColor();
        return [e2.getR(), e2.getG(), e2.getB()];
      }
      set blendMode(e2) {
        C3X.RequireString(e2);
        const t2 = BLEND_MODE_TO_INDEX.get(e2);
        if ("number" != typeof t2) throw new Error("invalid blend mode");
        const i = this.#e;
        this.#t.SetBlendMode(t2), i.GetRuntime().UpdateRender();
      }
      get blendMode() {
        return INDEX_TO_BLEND_MODE.get(this.#t.GetBlendMode());
      }
      moveToTop() {
        this.#t.ZOrderMoveToTop();
      }
      moveToBottom() {
        this.#t.ZOrderMoveToBottom();
      }
      moveToLayer(e2) {
        C3X.RequireInstanceOf(e2, ILayer);
        const t2 = this.#e, i = t2.GetRuntime()._UnwrapScriptInterface(e2);
        if (!i) throw new Error("invalid layer");
        t2.GetWorldInfo().ZOrderMoveToLayer(i);
      }
      moveAdjacentToInstance(e2, i) {
        C3X.RequireInstanceOf(e2, t), this.#t.ZOrderMoveAdjacentToInstance(map.get(e2), i);
      }
      get zIndex() {
        return this.#t.GetZIndex();
      }
      get isCollisionEnabled() {
        return this.#t.IsCollisionEnabled();
      }
      set isCollisionEnabled(e2) {
        this.#t.SetCollisionEnabled(!!e2);
      }
      containsPoint(e2, t2) {
        return C3X.RequireNumber(e2), C3X.RequireNumber(t2), this.#t.ContainsPoint(+e2, +t2);
      }
      testOverlap(e2) {
        C3X.RequireInstanceOf(e2, t);
        const i = this.#e, n = map.get(e2);
        return i.GetRuntime().GetCollisionEngine().TestOverlap(i, n);
      }
      testOverlapSolid() {
        const e2 = this.#e, t2 = e2.GetRuntime().GetCollisionEngine().TestOverlapSolid(e2);
        return t2 ? t2.GetInterfaceClass() : null;
      }
      getParent() {
        const e2 = this.#e.GetParent();
        return e2 ? e2.GetInterfaceClass() : null;
      }
      getTopParent() {
        const e2 = this.#e.GetTopParent();
        return e2 ? e2.GetInterfaceClass() : null;
      }
      *parents() {
        for (const e2 of this.#e.parents()) yield e2.GetInterfaceClass();
      }
      getChildCount() {
        return this.#e.GetChildCount();
      }
      getChildAt(e2) {
        const t2 = this.#e.GetChildAt(e2);
        return t2 ? t2.GetInterfaceClass() : null;
      }
      *children() {
        for (const e2 of this.#e.children()) yield e2.GetInterfaceClass();
      }
      *allChildren() {
        for (const e2 of this.#e.allChildren()) yield e2.GetInterfaceClass();
      }
      addChild(e2, i) {
        C3X.RequireInstanceOf(e2, t), C3X.RequireOptionalObject(i), i || (i = {});
        const n = this.#e, r = map.get(e2);
        n.AddChild(r, i);
      }
      removeChild(e2) {
        C3X.RequireInstanceOf(e2, t);
        const i = this.#e, n = map.get(e2);
        i.RemoveChild(n);
      }
      removeFromParent() {
        const e2 = this.#e;
        if (!e2.HasParent()) return;
        e2.GetParent().RemoveChild(e2);
      }
      getHierarchyOpts() {
        const e2 = this.#t;
        return { transformX: e2.GetTransformWithParentX(), transformY: e2.GetTransformWithParentY(), transformWidth: e2.GetTransformWithParentWidth(), transformHeight: e2.GetTransformWithParentHeight(), transformAngle: e2.GetTransformWithParentAngle(), transformZElevation: e2.GetTransformWithParentZElevation(), transformOpacity: e2.GetTransformWithParentOpacity(), transformVisibility: e2.GetTransformWithParentVisibility(), destroyWithParent: e2.GetDestroyWithParent() };
      }
      createMesh(e2, t2) {
        C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t2), this.#t.CreateMesh(e2, t2);
      }
      releaseMesh() {
        const e2 = this.#t;
        e2.ReleaseMesh(), e2.SetBboxChanged();
      }
      setMeshPoint(e2, t2, i) {
        C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t2), C3X.RequireObject(i);
        const n = this.#t;
        n.SetMeshPoint(e2, t2, i) && n.SetBboxChanged();
      }
      getMeshPoint(e2, t2) {
        let i = NaN, n = NaN, r = NaN, s = NaN, a = NaN;
        const o = this.#t;
        if (o.HasMesh()) {
          const l = o.GetSourceMesh().GetMeshPointAt(e2, t2);
          null !== l && (i = l.GetX(), n = l.GetY(), r = l.GetZElevation(), s = l.GetU(), a = l.GetV());
        }
        return { x: i, y: n, zElevation: r, u: s, v: a };
      }
      getMeshSize() {
        const e2 = this.#t;
        if (!e2.HasMesh()) return [0, 0];
        const t2 = e2.GetSourceMesh();
        return [t2.GetHSize(), t2.GetVSize()];
      }
    };
  };
  MakeIWorldInstanceClass2 = MakeIWorldInstanceClass;
  const C32 = self.C3, C3X = self.C3X, IInstance = self.IInstance, ILayer = self.ILayer, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10], ["lighten", 11], ["darken", 12], ["multiply", 13], ["screen", 14]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), tempColor = C32.New(C32.Color);
  self.IWorldInstance = MakeIWorldInstanceClass(self.IInstance), self.IWorldInstanceSDKBase = MakeIWorldInstanceClass(self.ISDKInstanceBase);
}
var MakeIWorldInstanceClass2;
{
  const C32 = self.C3, C3X = self.C3X;
  self.IDOMInstance = class extends self.IWorldInstance {
    #e;
    constructor() {
      super(), this.#e = self.IInstance._GetInitInst();
    }
    getElement() {
      return this.#e.GetSdkInstance()._GetElementInDOMMode();
    }
    focus() {
      this.#e.GetSdkInstance().FocusElement();
    }
    blur() {
      this.#e.GetSdkInstance().BlurElement();
    }
    setCssStyle(e, t) {
      C3X.RequireString(e), this.#e.GetSdkInstance().SetElementCSSStyle(e, t);
    }
  };
}
{
  let GetDispatcher = function(e) {
    let t = dispatchers.get(e);
    return t || (t = C32.New(C32.Event.Dispatcher), dispatchers.set(e, t), t);
  };
  GetDispatcher2 = GetDispatcher;
  const C32 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.IBehaviorInstance = class {
    #e;
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e;
      const t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, behaviorType: { value: e.GetBehaviorType().GetIBehaviorType(), writable: false } };
      Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);
    }
    static _GetInitInst() {
      return C32.AddonManager._GetInitObject();
    }
    get instance() {
      return this.#e.GetObjectInstance().GetInterfaceClass();
    }
    _release() {
      const e = dispatchers.get(this);
      e && (e.Release(), dispatchers.delete(this));
    }
    addEventListener(e, t, i) {
      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).addEventListener(e, t, i);
    }
    removeEventListener(e, t, i) {
      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).removeEventListener(e, t, i);
    }
    dispatchEvent(e) {
      GetDispatcher(this).dispatchEvent(e);
    }
  };
}
var GetDispatcher2;
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.IBehaviorType = class {
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, name: { value: e.GetName(), writable: false } };
      Object.defineProperties(this, t);
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.IBehavior = class {
    #t;
    constructor() {
      const t = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#t = t;
      const e = { runtime: { value: t.GetRuntime().GetIRuntime(), writable: false }, id: { value: t.GetID(), writable: false } };
      Object.defineProperties(this, e), t.GetRuntime()._MapScriptInterface(this, t);
    }
    getAllInstances() {
      return this.#t.GetInstances().map((t) => t.GetInterfaceClass());
    }
    static getByConstructor(t) {
      if (!t) return null;
      const e = C32.AddonManager.GetBehaviorByConstructorFunction(t);
      return e ? e.GetIBehavior() : null;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, tempColor = C32.New(C32.Color);
  self.IEffectInstance = class {
    #e;
    constructor(e, t) {
      this.#e = e;
      const i = { index: { value: t, writable: false } };
      Object.defineProperties(this, i);
    }
    get name() {
      return this.#e.GetAllEffectTypes()[this.index].GetName();
    }
    get isActive() {
      return this.#e.IsEffectIndexActive(this.index);
    }
    set isActive(e) {
      e = !!e;
      const t = this.#e;
      t.IsEffectIndexActive(this.index) !== e && (t.SetEffectIndexActive(this.index, e), t.UpdateActiveEffects(), t.GetRuntime().UpdateRender());
    }
    setParameter(e, t) {
      C3X.RequireFiniteNumber(e), e = Math.floor(+e);
      const i = this.#e, r = i.GetEffectParameter(this.index, e);
      if (null === r) throw new RangeError("invalid index");
      if (r instanceof C32.Color) {
        if (!Array.isArray(t) || t.length < 3) throw new TypeError("expected array with 3 elements");
        tempColor.setRgb(t[0], t[1], t[2]), t = tempColor;
      } else if ("number" != typeof t) throw new TypeError("expected number");
      i.SetEffectParameter(this.index, e, t) && i.IsEffectIndexActive(this.index) && i.GetRuntime().UpdateRender();
    }
    getParameter(e) {
      C3X.RequireFiniteNumber(e), e = Math.floor(+e);
      const t = this.#e.GetEffectParameter(this.index, e);
      if (null === t) throw new RangeError("invalid index");
      return t instanceof C32.Color ? [t.getR(), t.getG(), t.getB()] : t;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.IAnimation = class {
    #e;
    constructor(e) {
      this.#e = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false } });
    }
    get speed() {
      return this.#e.GetSpeed();
    }
    get isLooping() {
      return this.#e.IsLooping();
    }
    get repeatCount() {
      return this.#e.GetRepeatCount();
    }
    get repeatTo() {
      return this.#e.GetRepeatTo();
    }
    get isPingPong() {
      return this.#e.IsPingPong();
    }
    get frameCount() {
      return this.#e.GetFrameCount();
    }
    getFrames() {
      return this.#e.GetFrames().map((e) => e.GetIAnimationFrame());
    }
    *frames() {
      for (const e of this.#e.GetFrames()) yield e.GetIAnimationFrame();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.IImageInfo = class {
    #t;
    constructor(t) {
      this.#t = t;
    }
    static _Unwrap(t) {
      return t.#t;
    }
    get width() {
      return this.#t.GetWidth();
    }
    get height() {
      return this.#t.GetHeight();
    }
    getSize() {
      const t = this.#t;
      return [t.GetWidth(), t.GetHeight()];
    }
    getTexture(t) {
      return t.getTextureForImageInfo(this);
    }
    getTexRect() {
      return this.#t.GetTexRect().toDOMRect();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.IAnimationFrame = class extends self.IImageInfo {
    #t;
    constructor(t) {
      super(t.GetImageInfo()), this.#t = t, Object.defineProperties(this, { duration: { value: t.GetDuration(), writable: false }, originX: { value: t.GetOriginX(), writable: false }, originY: { value: t.GetOriginY(), writable: false } });
    }
    getOrigin() {
      const t = this.#t;
      return [t.GetOriginX(), t.GetOriginY()];
    }
    getImagePointCount() {
      return this.#t.GetImagePointCount();
    }
    getImagePointX(t) {
      return this.getImagePoint(t)[0];
    }
    getImagePointY(t) {
      return this.getImagePoint(t)[1];
    }
    getImagePoint(t) {
      const e = this.#t;
      let i = null;
      if ("number" == typeof t) i = e.GetImagePointByIndex(Math.floor(t));
      else {
        if ("string" != typeof t) throw new TypeError("expected string or number");
        i = e.GetImagePointByName(t);
      }
      return i ? [i.GetX(), i.GetY()] : this.getOrigin();
    }
    getPolyPointCount() {
      const t = this.#t.GetCollisionPoly();
      return t ? t.pointCount() : 0;
    }
    getPolyPointX(t) {
      return this.getPolyPoint(t)[0];
    }
    getPolyPointY(t) {
      return this.getPolyPoint(t)[1];
    }
    getPolyPoint(t) {
      C3X.RequireFiniteNumber(t), t = Math.floor(t);
      const e = this.#t.GetCollisionPoly();
      if (!e || t < 0 || t >= e.pointCount()) return [0, 0];
      const i = e.pointsArr();
      return [i[2 * t], i[2 * t + 1]];
    }
    get tag() {
      return this.#t.GetTag();
    }
  };
}
{
  let GetTimelineState = function(e) {
    const t = map.get(e);
    if (t.IsReleased()) throw new Error("timeline/tween was released and is no longer valid");
    return t;
  };
  GetTimelineState2 = GetTimelineState;
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
  self.ITimelineStateBase = class {
    constructor(e) {
      map.set(this, e), e.GetRuntime()._MapScriptInterface(this, e);
    }
    pause() {
      GetTimelineState(this).Stop();
    }
    resume() {
      GetTimelineState(this).Resume();
    }
    stop() {
      GetTimelineState(this).Reset();
    }
    hasTags(e) {
      return GetTimelineState(this).HasTags(e);
    }
    set time(e) {
      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetTime(e);
    }
    get time() {
      return GetTimelineState(this).GetTime();
    }
    set totalTime(e) {
      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetTotalTime(e);
    }
    get totalTime() {
      return GetTimelineState(this).GetTotalTime();
    }
    set isLooping(e) {
      GetTimelineState(this).SetLoop(!!e);
    }
    get isLooping() {
      return GetTimelineState(this).GetLoop();
    }
    set isPingPong(e) {
      GetTimelineState(this).SetPingPong(!!e);
    }
    get isPingPong() {
      return GetTimelineState(this).GetPingPong();
    }
    set playbackRate(e) {
      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetPlaybackRate(e);
    }
    get playbackRate() {
      return GetTimelineState(this).GetPlaybackRate();
    }
    get progress() {
      const e = GetTimelineState(this);
      return e.GetTime() / e.GetTotalTime();
    }
    get tags() {
      return GetTimelineState(this).GetTags();
    }
    get finished() {
      return GetTimelineState(this).GetPlayPromise();
    }
    get isPlaying() {
      return GetTimelineState(this).IsPlaying();
    }
    get isPaused() {
      return GetTimelineState(this).IsPaused();
    }
    get isReleased() {
      return map.get(this).IsReleased();
    }
  };
}
var GetTimelineState2;
{
  let GetTimelineState = function(e) {
    const t = map.get(e);
    if (t.IsReleased()) throw new Error("timeline was released and is no longer valid");
    return t;
  };
  GetTimelineState2 = GetTimelineState;
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
  let easeToIndexFunc = null;
  self.ITimelineState = class extends self.ITimelineStateBase {
    constructor(e) {
      super(e), map.set(this, e);
      const t = { name: { value: e.GetName(), writable: false } };
      Object.defineProperties(this, t);
    }
  };
}
var GetTimelineState2;
{
  let GetTweenState = function(e) {
    const t = map.get(e);
    if (t.IsReleased()) throw new Error("tween was released and is no longer valid");
    return t;
  };
  GetTweenState2 = GetTweenState;
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), behInstMap = /* @__PURE__ */ new WeakMap();
  let easeToIndexFunc = null;
  self.ITweenState = class extends self.ITimelineStateBase {
    constructor(e, t, n) {
      super(e), easeToIndexFunc || (easeToIndexFunc = n.easeToIndexFunc), map.set(this, e), t && behInstMap.set(this, t);
    }
    stop() {
      const e = GetTweenState(this);
      behInstMap.get(this).ReleaseTween(e);
    }
    setEase(e) {
      C3X.RequireString(e);
      const t = self.Ease.GetEaseFromIndex(easeToIndexFunc(e));
      GetTweenState(this).SetEase(t);
    }
    get instance() {
      const e = GetTweenState(this).GetInstance();
      return e ? e.GetInterfaceClass() : null;
    }
    get isDestroyOnComplete() {
      return GetTweenState(this).GetDestroyInstanceOnComplete();
    }
    set isDestroyOnComplete(e) {
      GetTweenState(this).SetDestroyInstanceOnComplete(!!e);
    }
    get finished() {
      const e = GetTweenState(this);
      return e.GetPlayPromise().then(() => new Promise((t) => {
        e.IsComplete() && t();
      }));
    }
    get released() {
      return GetTweenState(this).GetReleasePromise();
    }
    get value() {
      const e = GetTweenState(this);
      if ("value" !== e.GetId()) throw new Error("not a value tween");
      return e.GetPropertyTrack("value").GetSourceAdapterValue();
    }
  };
}
var GetTweenState2;
{
  const C32 = self.C3, C3X = self.C3X;
  self.ISDKPluginBase = class extends self.IPlugin {
    constructor() {
      super();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.ISDKDOMPluginBase = class extends self.ISDKPluginBase {
    #e;
    #n;
    #t = 0;
    #s = /* @__PURE__ */ new Map();
    constructor(e) {
      if (super(), this.#e = C32.AddonManager._GetInitObject2(internalApiToken), !e?.domComponentId) throw new Error("no DOM component ID specified");
      this.#n = e.domComponentId, this._addElementMessageHandler("elem-focused", (e2) => e2._onElemFocused()), this._addElementMessageHandler("elem-blurred", (e2) => {
        e2 && e2._onElemBlurred();
      });
    }
    _addElement(e) {
      const n = this.#t++;
      return this.#s.set(n, e), n;
    }
    _removeElement(e) {
      this.#s.delete(e);
    }
    _addElementMessageHandler(e, n) {
      this.#e.GetRuntime().AddDOMComponentMessageHandler(this.#n, e, (e2) => {
        const t = this.#s.get(e2["elementId"]);
        n(t, e2);
      });
    }
    _addElementMessageHandlers(e) {
      C3X.RequireArray(e);
      for (const [n, t] of e) this._addElementMessageHandlers(n, t);
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.ISDKObjectTypeBase = class extends self.IObjectType {
    #e;
    constructor() {
      super(), this.#e = C32.AddonManager._GetInitObject2(internalApiToken);
    }
    _onCreate() {
    }
    getImageInfo() {
      return this.#e.GetImageInfo().GetIImageInfo();
    }
    _loadTextures(e) {
    }
    _releaseTextures(e) {
    }
    _onDynamicTextureLoadComplete() {
    }
    _preloadTexturesWithInstances(e) {
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.ISDKWorldInstanceBase = class extends self.IWorldInstanceSDKBase {
    #e;
    #r = null;
    #t = null;
    constructor(e) {
      super(e), this.#e = C32.AddonManager._GetInitObject2(internalApiToken);
    }
    _release() {
      if (super._release(), this.#r) {
        const e = this.#e.GetRuntime().Dispatcher();
        e.removeEventListener("renderercontextlost", this.#r), e.removeEventListener("renderercontextrestored", this.#t), this.#r = null, this.#t = null;
      }
    }
    _handleRendererContextLoss() {
      if (this.#r) return;
      this.#r = () => this._onRendererContextLost(), this.#t = () => this._onRendererContextRestored();
      const e = this.#e.GetRuntime().Dispatcher();
      e.addEventListener("renderercontextlost", this.#r), e.addEventListener("renderercontextrestored", this.#t);
    }
    _onRendererContextLost() {
    }
    _onRendererContextRestored() {
    }
    _draw(e) {
    }
    _rendersToOwnZPlane() {
      return true;
    }
    _mustPreDraw() {
      return false;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, tempRect = C32.New(C32.Rect), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.ISDKDOMInstanceBase = class extends self.ISDKWorldInstanceBase {
    #e = -1;
    #t = true;
    #s = false;
    #i = false;
    #n = -0.2;
    #o = C32.New(C32.Rect, 0, 0, -1, -1);
    #l = 0;
    #a = 0;
    #h = -1;
    #d = -1;
    #m = false;
    constructor(e) {
      if (!e?.domComponentId) throw new Error("no DOM component ID specified");
      super(e);
      const t = C32.AddonManager._GetInitObject2(internalApiToken);
      map.set(this, t), this.#e = this.plugin._addElement(this);
      const s = t.GetRuntime().GetCanvasManager();
      this.#l = s.GetLastWidth(), this.#a = s.GetLastHeight(), this._setTicking(true);
    }
    _release() {
      super._release(), this.plugin._removeElement(this.#e), this._postToDOMElement("destroy"), this.#e = -1, map.delete(this);
    }
    _getElementInDOMMode() {
      if (map.get(this).GetRuntime().IsInWorker()) throw new Error("not valid in worker mode");
      return this._postToDOMElementMaybeSync("get-element");
    }
    _postToDOMElement(e, t) {
      t || (t = {}), t["elementId"] = this.#e, this._postToDOM(e, t);
    }
    _postToDOMElementMaybeSync(e, t) {
      return t || (t = {}), t["elementId"] = this.#e, this._postToDOMMaybeSync(e, t);
    }
    _postToDOMElementAsync(e, t) {
      return t || (t = {}), t["elementId"] = this.#e, this._postToDOMAsync(e, t);
    }
    _createElement(e) {
      e || (e = {});
      const t = map.get(this).GetWorldInfo();
      e["elementId"] = this.#e, e["isVisible"] = t.IsVisible(), e["htmlIndex"] = t.GetLayer().GetHTMLIndex(), e["htmlZIndex"] = t.GetHTMLZIndex(), Object.assign(e, this._getElementState()), this.#t = !!e["isVisible"], this._postToDOMMaybeSync("create", e), this._updatePosition(true);
    }
    setElementVisible(e) {
      e = !!e, this.#t !== e && (this.#t = e, this._postToDOMElement("set-visible", { "isVisible": e }));
    }
    _tick() {
      this._updatePosition(false);
    }
    _shouldPreserveElement() {
      const e = map.get(this).GetRuntime().GetCanvasManager().GetFullscreenMode();
      return "Android" === C32.Platform.OS && ("scale-inner" === e || "scale-outer" === e || "crop" === e);
    }
    _updatePosition(e) {
      const t = map.get(this);
      if (t.IsDestroyed()) return;
      const s = t.GetWorldInfo(), i = s.GetLayer(), n = s.GetBoundingBox();
      let [o, l] = i.LayerToCanvasCss(n.getLeft(), n.getTop()), [a, h] = i.LayerToCanvasCss(n.getRight(), n.getBottom());
      const d = t.GetRuntime().GetCanvasManager(), m = d.GetCssWidth(), r = d.GetCssHeight();
      if (!s.IsVisible() || !i.IsVisible()) return void this.setElementVisible(false);
      if (!this._shouldPreserveElement() && (a <= 0 || h <= 0 || o >= m || l >= r)) return void this.setElementVisible(false);
      tempRect.set(o, l, a, h);
      const c = d.GetLastWidth(), p = d.GetLastHeight(), u = i.GetHTMLIndex(), M = s.GetHTMLZIndex();
      if (!e && tempRect.equals(this.#o) && this.#l === c && this.#a === p && this.#h === u && this.#d === M) return void this.setElementVisible(true);
      this.#o.copy(tempRect), this.#l = c, this.#a = p, this.#h = u, this.#d = M, this.setElementVisible(true);
      let I = null;
      this.#i && (I = i.GetDisplayScale() + this.#n), this._postToDOMElement("update-position", { "left": Math.round(this.#o.getLeft()), "top": Math.round(this.#o.getTop()), "width": Math.round(this.#o.width()), "height": Math.round(this.#o.height()), "htmlIndex": u, "htmlZIndex": M, "fontSize": I });
    }
    focusElement() {
      this._postToDOMElementMaybeSync("focus", { "focus": true });
    }
    blurElement() {
      this._postToDOMElementMaybeSync("focus", { "focus": false });
    }
    _onElemFocused() {
      this.#s = true;
    }
    _onElemBlurred() {
      this.#s = false;
    }
    isElementFocused() {
      return this.#s;
    }
    setElementCSSStyle(e, t) {
      this.postToDOMElement("set-css-style", { "prop": C32.CSSToCamelCase(e), "val": t });
    }
    setElementAttribute(e, t) {
      this.postToDOMElement("set-attribute", { "name": e, "val": t });
    }
    removeElementAttribute(e) {
      this.postToDOMElement("remove-attribute", { "name": e });
    }
    _updateElementState() {
      this.#m || (this.#m = true, Promise.resolve().then(() => {
        this.#m = false, this._postToDOMElement("update-state", this._getElementState());
      }));
    }
    _getElementState() {
    }
    _getElementId() {
      return this.#e;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.ISDKBehaviorBase = class extends self.IBehavior {
    constructor() {
      super();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.ISDKBehaviorTypeBase = class extends globalThis.IBehaviorType {
    constructor() {
      super();
    }
    _onCreate() {
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.ISDKBehaviorInstanceBase = class extends self.IBehaviorInstance {
    #i = false;
    #t = false;
    #e = false;
    constructor() {
      super(), map.set(this, C32.AddonManager._GetInitObject2(internalApiToken));
    }
    _release() {
      super._release(), this._setTicking(false), this._setTicking2(false), this._setPostTicking(false), map.delete(this);
    }
    _getInitProperties() {
      return C32.AddonManager._GetInitProperties();
    }
    _postCreate() {
    }
    _trigger(i) {
      const t = map.get(this);
      t.GetRuntime().Trigger(i, t.GetObjectInstance(), t.GetBehaviorType());
    }
    _triggerAsync(i) {
      const t = map.get(this);
      return t.GetRuntime().TriggerAsync(i, t.GetObjectInstance(), t.GetBehaviorType());
    }
    _setTicking(i) {
      if (i = !!i, this.#i === i) return;
      this.#i = i;
      const t = map.get(this).GetRuntime();
      i ? t._AddBehInstToTick(this) : t._RemoveBehInstToTick(this);
    }
    _isTicking() {
      return this.#i;
    }
    _tick() {
    }
    _setTicking2(i) {
      if (i = !!i, this.#t === i) return;
      this.#t = i;
      const t = map.get(this).GetRuntime();
      i ? t._AddBehInstToTick2(this) : t._RemoveBehInstToTick2(this);
    }
    _isTicking2() {
      return this.#t;
    }
    _tick2() {
    }
    _setPostTicking(i) {
      if (i = !!i, this.#e === i) return;
      this.#e = i;
      const t = map.get(this).GetRuntime();
      i ? t._AddBehInstToPostTick(this) : t._RemoveBehInstToPostTick(this);
    }
    _isPostTicking() {
      return this.#e;
    }
    _postTick() {
    }
    _getDebuggerProperties() {
      return [];
    }
    _saveToJson() {
      return null;
    }
    _loadFromJson(i) {
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  let runtime = null;
  self.ISDKUtils = class {
    constructor(e) {
      runtime = e, Object.defineProperties(this, { constructVersionCode: { value: runtime.GetConstructVersionCode(), writable: false } });
    }
    updateRender() {
      runtime.UpdateRender();
    }
    addLoadPromise(e) {
      runtime.AddLoadPromise(e);
    }
    isWrapperExtensionAvailable(e) {
      return C3X.RequireString(e), runtime.HasWrapperComponentId(e);
    }
    sendWrapperExtensionMessage(e, n, t) {
      C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessage(e, n, t);
    }
    sendWrapperExtensionMessageAsync(e, n, t) {
      return C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessageAsync(e, n, t);
    }
    createLoopingConditionContext(e) {
      return C3X.RequireOptionalString(e), new self.ILoopingConditionContext(runtime, e);
    }
    set isAutoSuspendEnabled(e) {
      runtime._SetAutoSuspendEnabled(!!e);
    }
    get isAutoSuspendEnabled() {
      return runtime._IsAutoSuspendEnabled();
    }
    setSuspended(e) {
      runtime.SetSuspended(!!e);
    }
    getObjectClassBySid(e) {
      C3X.RequireNumber(e);
      const n = runtime.GetObjectClassBySID(e);
      return n ? n.GetIObjectClass() : null;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.ILoopingConditionContext = class {
    #e;
    #t;
    #o;
    #n;
    #s;
    #r;
    constructor(e, t) {
      this.#e = e;
      const o = e.GetEventSheetManager(), n = e.GetCurrentEvent();
      this.#t = n, this.#o = n.GetSolModifiers();
      const s = e.GetEventStack();
      this.#n = s.GetCurrentStackFrame(), this.#s = s.Push(n);
      const r = o.GetLoopStack().Push();
      this.#r = r, t && r.SetName(t), e.SetDebuggingEnabled(false);
    }
    retrigger() {
      const e = this.#e.GetEventSheetManager(), t = this.#o, o = this.#r;
      e.PushCopySol(t), this.#t.Retrigger(this.#n, this.#s), e.PopSol(t), o.SetIndex(o.GetIndex() + 1);
    }
    get isStopped() {
      return this.#r.IsStopped();
    }
    release() {
      const e = this.#e, t = e.GetEventStack(), o = e.GetEventSheetManager().GetLoopStack();
      e.SetDebuggingEnabled(true), o.Pop(), t.Pop();
    }
  };
}
{
  let IsStaticTextureDataType = function(e) {
    return e instanceof ImageBitmap || "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas;
  };
  IsStaticTextureDataType2 = IsStaticTextureDataType;
  const C32 = self.C3, C3X = self.C3X;
  let renderer = null, runtime = null;
  const CULL_MODE_ARR = ["none", "back", "front"], FRONT_FACE_WINDING_ARR = ["cw", "ccw"];
  self.IRenderer = class {
    constructor(e, r) {
      runtime = e, renderer = r;
    }
    setAlphaBlendMode() {
      renderer.SetAlphaBlend();
    }
    setBlendMode(e) {
      renderer.SetNamedBlendMode(e);
    }
    setColorFillMode() {
      renderer.SetColorFillMode();
    }
    setTextureFillMode() {
      renderer.SetTextureFillMode();
    }
    setSmoothLineFillMode() {
      renderer.SetSmoothLineFillMode();
    }
    setColor(e) {
      renderer.SetColorRgba(e[0], e[1], e[2], e[3]);
    }
    setColorRgba(e, r, n, t) {
      renderer.SetColorRgba(e, r, n, t);
    }
    resetColor() {
      renderer.ResetColor();
    }
    setOpacity(e) {
      renderer.SetOpacity(e);
    }
    setCurrentZ(e) {
      renderer.SetCurrentZ(e);
    }
    getCurrentZ() {
      return renderer.GetCurrentZ();
    }
    setCullFaceMode(e) {
      const r = CULL_MODE_ARR.indexOf(e);
      if (-1 === r) throw new Error("invalid cull mode");
      renderer.SetCullFaceMode(r);
    }
    getCullFaceMode() {
      return CULL_MODE_ARR[renderer.GetCullFaceMode()];
    }
    setFrontFaceWinding(e) {
      const r = FRONT_FACE_WINDING_ARR.indexOf(e);
      if (-1 === r) throw new Error("invalid front face winding");
      renderer.SetFrontFaceWinding(r);
    }
    getFrontFaceWinding() {
      return renderer.GetFrontFaceWinding();
    }
    rect(e) {
      renderer.Rect2(e.left, e.top, e.right, e.bottom);
    }
    rect2(e, r, n, t) {
      renderer.Rect2(e, r, n, t);
    }
    quad(e) {
      renderer.Quad(C32.Quad.fromDOMQuad(e));
    }
    quad2(e, r, n, t, a, d, i, o) {
      renderer.Quad2(e, r, n, t, a, d, i, o);
    }
    quad3(e, r) {
      renderer.Quad3(C32.Quad.fromDOMQuad(e), C32.Rect.fromDOMRect(r));
    }
    quad4(e, r) {
      renderer.Quad4(C32.Quad.fromDOMQuad(e), C32.Quad.fromDOMQuad(r));
    }
    quad5(e, r, n) {
      renderer.Quad5(C32.Quad.fromDOMQuad(e), C32.Quad.fromDOMQuad(r), n);
    }
    quad3D(e, r, n, t, a, d, i, o, u, l, c, s, p) {
      renderer.Quad3D(e, r, n, t, a, d, i, o, u, l, c, s, C32.Rect.fromDOMRect(p));
    }
    quad3D2(e, r, n, t, a, d, i, o, u, l, c, s, p) {
      renderer.Quad3D2(e, r, n, t, a, d, i, o, u, l, c, s, C32.Quad.fromDOMQuad(p));
    }
    quad3D3(e, r, n, t, a, d, i, o, u, l, c, s, p, f) {
      renderer.Quad3D3(e, r, n, t, a, d, i, o, u, l, c, s, C32.Quad.fromDOMQuad(p), f);
    }
    drawMesh(e, r, n, t) {
      renderer.DrawMesh(e, r, n, t);
    }
    convexPoly(e) {
      renderer.ConvexPoly(e);
    }
    line(e, r, n, t) {
      renderer.Line(e, r, n, t);
    }
    texturedLine(e, r, n, t, a, d) {
      renderer.TexturedLine(e, r, n, t, a, d);
    }
    lineRect(e, r, n, t) {
      renderer.LineRect(e, r, n, t);
    }
    lineRect2(e) {
      renderer.LineRect2(C32.Rect.fromDOMRect(e));
    }
    lineQuad(e) {
      renderer.LineQuad(C32.Quad.fromDOMQuad(e));
    }
    pushLineWidth(e) {
      renderer.PushLineWidth(e);
    }
    popLineWidth() {
      renderer.PopLineWidth();
    }
    pushLineCap(e) {
      renderer.PushLineCap(e);
    }
    popLineCap() {
      renderer.PopLineCap();
    }
    setTexture(e) {
      C3X.RequireOptionalInstanceOf(e, self.ITexture);
      const r = e ? runtime._UnwrapScriptInterface(e) : null;
      renderer.SetTexture(r);
    }
    loadTextureForImageInfo(e, r) {
      const n = self.IImageInfo._Unwrap(e);
      if (!n) throw new Error("invalid IImageInfo");
      return n.LoadStaticTexture(renderer, { wrapX: r?.wrapX ?? "clamp-to-edge", wrapY: r?.wrapY ?? "clamp-to-edge", sampling: r?.sampling ?? "trilinear", mipMap: r?.mipMap ?? true });
    }
    releaseTextureForImageInfo(e) {
      const r = self.IImageInfo._Unwrap(e);
      if (!r) throw new Error("invalid IImageInfo");
      r.ReleaseTexture();
    }
    getTextureForImageInfo(e) {
      const r = self.IImageInfo._Unwrap(e);
      if (!r) throw new Error("invalid IImageInfo");
      const n = r.GetTexture();
      return self.ITexture.GetInterface(runtime, n);
    }
    createStaticTexture(e, r) {
      if (!IsStaticTextureDataType(e)) throw new TypeError("invalid texture data");
      const n = renderer.CreateStaticTexture(e, { wrapX: r?.wrapX ?? "clamp-to-edge", wrapY: r?.wrapY ?? "clamp-to-edge", sampling: r?.sampling ?? "trilinear", mipMap: r?.mipMap ?? true });
      return self.ITexture.GetInterface(runtime, n);
    }
    createDynamicTexture(e, r, n) {
      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(r);
      const t = renderer.CreateDynamicTexture(e, r, { wrapX: n?.wrapX ?? "clamp-to-edge", wrapY: n?.wrapY ?? "clamp-to-edge", sampling: n?.sampling ?? "trilinear", mipMap: n?.mipMap ?? true });
      return self.ITexture.GetInterface(runtime, t);
    }
    updateTexture(e, r, n) {
      C3X.RequireInstanceOf(r, self.ITexture);
      const t = runtime._UnwrapScriptInterface(r);
      renderer.UpdateTexture(e, t, { premultiplyAlpha: n?.premultiplyAlpha ?? true });
    }
    deleteTexture(e) {
      C3X.RequireInstanceOf(e, self.ITexture);
      const r = runtime._UnwrapScriptInterface(e);
      renderer.DeleteTexture(r);
    }
    createRendererText() {
      const e = renderer.CreateRendererText();
      return new self.IRendererText(runtime, e);
    }
    setDeviceTransform() {
      runtime.GetCanvasManager().SetDeviceTransform(renderer);
    }
    setLayerTransform(e) {
      C3X.RequireInstanceOf(e, globalThis.ILayer);
      runtime._UnwrapScriptInterface(e)._SetTransform(renderer);
    }
  };
}
var IsStaticTextureDataType2;
{
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), reverseMap = /* @__PURE__ */ new WeakMap();
  self.ITexture = class {
    constructor(e, t) {
      map.set(this, { runtime: e, texture: t }), reverseMap.set(t, this), e._MapScriptInterface(this, t), Object.defineProperties(this, { width: { value: t.GetWidth(), writable: false }, height: { value: t.GetHeight(), writable: false } });
    }
    static GetInterface(e, t) {
      if (!t) return null;
      const r = reverseMap.get(t);
      return r || new self.ITexture(e, t);
    }
  };
}
{
  let getActual = function(t) {
    return map.get(t).rendererText;
  };
  getActual2 = getActual;
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
  self.IRendererText = class {
    constructor(t, e) {
      map.set(this, { runtime: t, rendererText: e }), t._MapScriptInterface(this, e);
    }
    release() {
      getActual(this).Release();
    }
    set fontFace(t) {
      C3X.RequireString(t), getActual(this).SetFontName(t);
    }
    get fontFace() {
      return getActual(this).GetFontName();
    }
    set sizePt(t) {
      C3X.RequireFiniteNumber(t), getActual(this).SetFontSize(t);
    }
    get sizePt() {
      return getActual(this).GetFontSize();
    }
    set lineHeight(t) {
      C3X.RequireFiniteNumber(t), getActual(this).SetLineHeight(t);
    }
    get lineHeight() {
      return getActual(this).GetLineHeight();
    }
    set isBold(t) {
      getActual(this).SetBold(t);
    }
    get isBold() {
      return getActual(this).IsBold();
    }
    set isItalic(t) {
      getActual(this).SetItalic(t);
    }
    get isItalic() {
      return getActual(this).IsItalic();
    }
    setColor(t) {
      C3X.RequireArray(t), this.setColorRgb(t[0], t[1], t[2]);
    }
    setColorRgb(t, e, i) {
      getActual(this).SetColorRgb(t, e, i);
    }
    setCssColor(t) {
      C3X.RequireString(t), getActual(this).SetColor(t);
    }
    set horizontalAlign(t) {
      getActual(this).SetHorizontalAlignment(t);
    }
    get horizontalAlign() {
      return getActual(this).GetHorizontalAlignment();
    }
    set verticalAlign(t) {
      getActual(this).SetVerticalAlignment(t);
    }
    get verticalAlign() {
      return getActual(this).GetVerticalAlignment();
    }
    set wordWrapMode(t) {
      getActual(this).SetWordWrapMode(t);
    }
    get wordWrapMode() {
      return getActual(this).GetWordWrapMode();
    }
    set textDirection(t) {
      getActual(this).SetTextDirection(t);
    }
    get textDirection() {
      return getActual(this).GetTextDirection();
    }
    set text(t) {
      C3X.RequireString(t), getActual(this).SetText(t);
    }
    get text() {
      return getActual(this).GetText();
    }
    setSize(t, e, i) {
      C3X.RequireFiniteNumber(t), C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(i), getActual(this).SetSize(t, e, i);
    }
    getTexture() {
      const { runtime: t, rendererText: e } = map.get(this), i = e.GetTexture();
      return self.ITexture.GetInterface(t, i);
    }
    getTexRect() {
      return getActual(this).GetTexRect().toDOMRect();
    }
    setTextureUpdateCallback(t) {
      C3X.RequireFunction(t), getActual(this).ontextureupdate = t;
    }
    releaseTexture() {
      getActual(this).ReleaseTexture();
    }
    get textWidth() {
      return getActual(this).GetTextWidth();
    }
    get textHeight() {
      return getActual(this).GetTextHeight();
    }
  };
}
var getActual2;
{
  let GetTypeFromFileExtension = function(e) {
    if (!e) return "";
    const t = e.split(".");
    if (t.length < 2) return "";
    const s = t.at(-1).toLowerCase();
    return EXT_TO_TYPE.get(s) || "";
  }, AddScript = function(e) {
    return new Promise((t, s) => {
      const i = document.createElement("script");
      i.onload = t, i.onerror = s, i.async = false, i.type = "module", i.src = e, document.head.appendChild(i);
    });
  };
  GetTypeFromFileExtension2 = GetTypeFromFileExtension, AddScript2 = AddScript;
  const C32 = self.C3, VALID_LOAD_POLICIES = /* @__PURE__ */ new Set(["local", "remote"]), EXT_TO_TYPE = /* @__PURE__ */ new Map([["mp4", "video/mp4"], ["webm", "video/webm"], ["m4a", "audio/mp4"], ["mp3", "audio/mpeg"], ["js", "application/javascript"], ["wasm", "application/wasm"], ["svg", "image/svg+xml"], ["html", "text/html"]]);
  C32.AssetManager = class extends C32.DefendedBase {
    constructor(e, t) {
      super();
      const s = t["exportType"];
      this._runtime = e, this._cordovaBlobUrlCache = /* @__PURE__ */ new Map(), this._isCordova = "cordova" === s, this._isiOSCordova = !!t["isiOSCordova"], this._swClientId = t["swClientId"], this._supportedAudioFormats = t["supportedAudioFormats"] || {}, this._audioFiles = /* @__PURE__ */ new Map(), this._preloadSounds = false, this._scriptSubfolder = t["scriptFolder"], this._mediaSubfolder = "", this._fontsSubfolder = "", this._iconsSubfolder = "", this._fileMap = t["fileMap"] || /* @__PURE__ */ new Map(), this._fileMapBlobUrls = /* @__PURE__ */ new Map(), this._exportedFileList = [];
      const i = "html5" === s || "scirra-arcade" === s || "instant-games" === s;
      this._defaultLoadPolicy = i ? "remote" : "local", this._imageAssetsMap = /* @__PURE__ */ new Map(), this._webFonts = [], this._loadPromises = [], this._hasFinishedInitialLoad = false, this._totalAssetSizeToLoad = 0, this._assetSizeLoaded = 0, this._lastLoadProgress = 0, this._hasHadErrorLoading = false, this._loadingRateLimiter = C32.New(C32.RateLimiter, () => this._FireLoadingProgressEvent(), 50), this._localPromiseThrottle = C32.New(C32.PromiseThrottle, Math.max(C32.hardwareConcurrency, 8)), this._remotePromiseThrottle = C32.New(C32.PromiseThrottle, 20), this._iAssetManager = new self.IAssetManager(this);
    }
    Release() {
      for (const e of this._imageAssetsMap.values()) e.Release();
      this._imageAssetsMap.clear(), C32.clearArray(this._loadPromises), this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetScriptSubfolder() {
      return this._scriptSubfolder;
    }
    _SetMediaSubfolder(e) {
      this._mediaSubfolder = e;
    }
    GetMediaSubfolder() {
      return this._mediaSubfolder;
    }
    _SetFontsSubfolder(e) {
      this._fontsSubfolder = e;
    }
    GetFontsSubfolder() {
      return this._fontsSubfolder;
    }
    _SetIconsSubfolder(e) {
      this._iconsSubfolder = e;
    }
    GetIconsSubfolder() {
      return this._iconsSubfolder;
    }
    _SetExportedFileList(e) {
      this._exportedFileList = e;
    }
    GetExportedFileList() {
      return this._exportedFileList;
    }
    FetchBlob(e, t) {
      return t = t || this._defaultLoadPolicy, C32.IsRelativeURL(e) ? "playable-ad-single-file" === this._runtime.GetExportType() ? self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e) : "local" === t ? this._localPromiseThrottle.Add(() => C32.FetchBlob(e)) : this._remotePromiseThrottle.Add(() => C32.FetchBlob(e)) : C32.FetchBlob(e);
    }
    FetchArrayBuffer(e) {
      return C32.IsRelativeURL(e) ? "playable-ad-single-file" === this._runtime.GetExportType() ? C32.BlobToArrayBuffer(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C32.FetchArrayBuffer(e)) : this._remotePromiseThrottle.Add(() => C32.FetchArrayBuffer(e)) : C32.FetchArrayBuffer(e);
    }
    FetchText(e) {
      return C32.IsRelativeURL(e) ? "playable-ad-single-file" === this._runtime.GetExportType() ? C32.BlobToString(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C32.FetchText(e)) : this._remotePromiseThrottle.Add(() => C32.FetchText(e)) : C32.FetchText(e);
    }
    async FetchJson(e) {
      const t = await this.FetchText(e);
      return JSON.parse(t);
    }
    GetMediaFileUrl(e) {
      let t = this._mediaSubfolder + e;
      return "Gecko" === C32.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() && (t = this._GetLocalBlobURLFromFileMap(t)), t;
    }
    GetProjectFileUrl(e) {
      return "playable-ad-single-file" === this._runtime.GetExportType() && C32.IsRelativeURL(e) ? URL.createObjectURL(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : e;
    }
    GetProjectFileIframeUrl(e) {
      if (C32.IsAbsoluteURL(e) || "preview" !== this._runtime.GetExportType() || !this._swClientId || !e) return e;
      try {
        const t = new URL(e, location.href);
        return t.searchParams.set("__c3_client_id", this._swClientId), t.toString();
      } catch (t) {
        return console.warn("Invalid iframe URL: " + e), e;
      }
    }
    _GetImageAssetKey(e, t) {
      return (t ? "true" : "false") + "|" + e;
    }
    LoadImage(e) {
      const t = !!e.isTiled;
      if (e.loadPolicy && !VALID_LOAD_POLICIES.has(e.loadPolicy)) throw new Error("invalid load policy");
      const s = this._GetImageAssetKey(e.url, t);
      let i = this._imageAssetsMap.get(s);
      return i || (i = C32.New(C32.ImageAsset, this, { url: e.url, size: e.size || 0, loadPolicy: e.loadPolicy || this._defaultLoadPolicy, isTiled: t }), this._imageAssetsMap.set(s, i), this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += i.GetSize(), this._loadPromises.push(i.Load().then(() => this._AddLoadedSize(i.GetSize())))), i);
    }
    _ReleaseImageAsset(e) {
      const t = this._GetImageAssetKey(e.GetURL(), e.IsTiled());
      this._imageAssetsMap.delete(t);
    }
    async WaitForAllToLoad(e) {
      try {
        await Promise.all(this._loadPromises), this._lastLoadProgress = 1, e && 0 === this._totalAssetSizeToLoad && this._FireLoadingProgressEvent();
      } catch (e2) {
        console.error("Error loading: ", e2), this._hasHadErrorLoading = true, this._FireLoadingProgressEvent();
      }
    }
    SetInitialLoadFinished() {
      this._hasFinishedInitialLoad = true;
    }
    HasHadErrorLoading() {
      return this._hasHadErrorLoading;
    }
    _AddLoadedSize(e) {
      this._assetSizeLoaded += e, this._loadingRateLimiter.Call();
    }
    _FireLoadingProgressEvent() {
      const e = C32.New(C32.Event, "loadingprogress");
      0 === this._totalAssetSizeToLoad ? this._lastLoadProgress = 1 : this._lastLoadProgress = C32.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1), e.progress = this._lastLoadProgress, this._runtime.Dispatcher().dispatchEvent(e), this._runtime.DispatchUserScriptEvent(C32.New(C32.Event, "loadingprogress"));
    }
    GetLoadProgress() {
      return this._lastLoadProgress;
    }
    GetImageLoadProgress() {
      return this._runtime.GetSystemPlugin().GetImageLoadingProgress();
    }
    _SetWebFonts(e) {
      C32.shallowAssignArray(this._webFonts, e), this._webFonts.length && this._loadPromises.push(this._LoadWebFonts());
    }
    async _LoadWebFonts() {
      const e = [], t = [];
      for (const [s, i, o] of this._webFonts) this._totalAssetSizeToLoad += o, e.push(this._LoadWebFont(s, i, t).then(() => this._AddLoadedSize(o)));
      await Promise.all(e), this._runtime.IsInWorker() && t.length > 0 && await this._runtime.PostComponentMessageToDOMAsync("runtime", "load-webfonts", { "webfonts": t });
    }
    async _LoadWebFont(e, t, s) {
      try {
        let i = this.GetProjectFileUrl(t);
        "Gecko" === C32.Platform.BrowserEngine && (e = `'${e}'`), ("Gecko" === C32.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() || "playable-ad-single-file" === this._runtime.GetExportType()) && (i = this._GetLocalBlobURLFromFileMap(i));
        const o = new FontFace(e, `url('${i}')`);
        this._runtime.IsInWorker() ? self.fonts.add(o) : document.fonts.add(o), await o.load(), this._runtime.IsInWorker() && s.push({ name: e, url: i });
      } catch (t2) {
        console.warn(`[C3 runtime] Failed to load web font '${e}': `, t2);
      }
    }
    IsAudioFormatSupported(e) {
      return !!this._supportedAudioFormats[e];
    }
    _SetAudioFiles(e, t) {
      this._preloadSounds = !!t;
      for (const [t2, s, i] of e) this._audioFiles.set(t2, { fileName: t2, formats: s.map((e2) => ({ type: e2[0], fileExtension: e2[1], fullName: t2 + e2[1], fileSize: e2[2] })), isMusic: i });
    }
    GetPreferredAudioFile(e) {
      const t = this._audioFiles.get(e);
      if (!t) return null;
      let s = null;
      for (const e2 of t.formats) if (s || "audio/webm; codecs=opus" !== e2.type || (s = e2), this.IsAudioFormatSupported(e2.type)) return e2;
      return s;
    }
    GetProjectAudioFileUrl(e) {
      const t = this.GetPreferredAudioFile(e);
      return t ? { url: this.GetMediaFileUrl(t.fullName), type: t.type } : null;
    }
    GetAudioToPreload() {
      if (this._preloadSounds) {
        const e = [];
        for (const t of this._audioFiles.values()) {
          if (t.isMusic) continue;
          const s = this.GetPreferredAudioFile(t.fileName);
          s && e.push({ originalUrl: t.fileName, url: this.GetMediaFileUrl(s.fullName), type: s.type, fileSize: s.fileSize });
        }
        return e;
      }
      return [];
    }
    _GetLocalBlobFromFileMap(e) {
      return "preview" === this._runtime.GetExportType() && (e = new URL(e, location.href).toString()), this._fileMap.get(e) || null;
    }
    _GetLocalBlobURLFromFileMap(e) {
      let t = this._fileMapBlobUrls.get(e);
      if (t) return t;
      const s = this._GetLocalBlobFromFileMap(e);
      return s ? (t = URL.createObjectURL(s), this._fileMapBlobUrls.set(e, t), t) : e;
    }
    GetIAssetManager() {
      return this._iAssetManager;
    }
    async LoadScripts(...e) {
      const t = e.map((e2) => this.GetProjectFileUrl(e2));
      if (this._runtime.IsInWorker()) if (1 === e.length) {
        const t2 = e[0];
        await import(new URL(t2, location.href).toString());
      } else {
        const t2 = e.map((e2) => `import "${new URL(e2, location.href).toString()}";`).join("\n"), s = URL.createObjectURL(new Blob([t2], { type: "application/javascript" }));
        await import(s);
      }
      else await Promise.all(t.map((e2) => AddScript(e2)));
    }
    async CompileWebAssembly(e) {
      if (WebAssembly.compileStreaming) {
        const t = this.GetProjectFileUrl(e);
        return await WebAssembly.compileStreaming(fetch(t));
      }
      {
        const t = await C32.FetchArrayBuffer(e);
        return await WebAssembly.compile(t);
      }
    }
    async LoadStyleSheet(e) {
      const t = this.GetProjectFileUrl(e);
      return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", { "url": t });
    }
  };
}
var GetTypeFromFileExtension2;
var AddScript2;
{
  const C32 = self.C3;
  C32.Asset = class extends C32.DefendedBase {
    constructor(s, i) {
      super(), this._assetManager = s, this._runtime = s.GetRuntime(), this._url = i.url || "", this._size = i.size, this._loadPolicy = i.loadPolicy, this._blob = i.blob || null, this._isLoaded = !!this._blob, this._loadPromise = null;
    }
    Release() {
      this._loadPromise = null, this._assetManager = null, this._runtime = null, this._blob = null;
    }
    GetURL() {
      return this._url;
    }
    GetSize() {
      return this._size;
    }
    Load() {
      return "local" === this._loadPolicy || this._blob ? (this._isLoaded = true, Promise.resolve()) : (this._loadPromise || (this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then((s) => (this._isLoaded = true, this._loadPromise = null, this._blob = s, s)).catch((s) => {
        console.error("Error loading resource: ", s), this._loadPromise = null;
      })), this._loadPromise);
    }
    IsLoaded() {
      return this._isLoaded;
    }
    GetBlob() {
      return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy);
    }
  };
}
{
  const C32 = self.C3, promiseThrottle = new C32.PromiseThrottle(), allImageAssets = /* @__PURE__ */ new Set();
  C32.ImageAsset = class extends C32.Asset {
    constructor(e, t) {
      super(e, t), this._texturePromise = null, this._webglTexture = null, this._refCount = 0, this._imageWidth = -1, this._imageHeight = -1, this._isTiled = !!t.isTiled, allImageAssets.add(this);
    }
    Release() {
      if (0 !== this._refCount) throw new Error("released image asset which still has references");
      this._assetManager._ReleaseImageAsset(this), this._texturePromise = null, allImageAssets.delete(this), super.Release();
    }
    static OnRendererContextLost() {
      for (const e of allImageAssets) e._texturePromise = null, e._webglTexture = null, e._refCount = 0;
    }
    LoadStaticTexture(e, t) {
      return t = t || {}, this._refCount++, this._webglTexture ? Promise.resolve(this._webglTexture) : (this._texturePromise || (t.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy(), this._texturePromise = this._DoLoadStaticTexture(e, t)), this._texturePromise);
    }
    async _DoLoadStaticTexture(e, t) {
      try {
        const s = await this.GetBlob();
        return 0 === this._refCount ? (this._texturePromise = null, null) : await promiseThrottle.Add(async () => {
          const r = await e.CreateStaticTextureAsync(s, t);
          return this._texturePromise = null, 0 === this._refCount ? (e.DeleteTexture(r), null) : (this._webglTexture = r, this._imageWidth = r.GetWidth(), this._imageHeight = r.GetHeight(), this._webglTexture);
        });
      } catch (e2) {
        throw console.error("Failed to load texture: ", e2), e2;
      }
    }
    ReleaseTexture() {
      if (this._refCount <= 0) throw new Error("texture released too many times");
      if (this._refCount--, 0 === this._refCount && this._webglTexture) {
        this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), this._webglTexture = null;
      }
    }
    IncRefCount() {
      this._refCount++;
    }
    GetRefCount() {
      return this._refCount;
    }
    DecRefCount() {
      this._refCount--;
    }
    GetTexture() {
      return this._webglTexture;
    }
    GetWidth() {
      return this._imageWidth;
    }
    GetHeight() {
      return this._imageHeight;
    }
    IsTiled() {
      return this._isTiled;
    }
    async LoadToDrawable() {
      const e = await this.GetBlob();
      return C32.Supports.ImageBitmap ? await createImageBitmap(e) : await C32.BlobToImage(e);
    }
  };
}
{
  let SortByInstLastCachedZIndex = function(e, s) {
    return e.GetWorldInfo()._GetLastCachedZIndex() - s.GetWorldInfo()._GetLastCachedZIndex();
  };
  SortByInstLastCachedZIndex2 = SortByInstLastCachedZIndex;
  const C32 = self.C3, assert = self.assert;
  C32.RenderCell = class extends C32.DefendedBase {
    constructor(e, s, n) {
      super(), this._grid = e, this._x = s, this._y = n, this._instances = [], this._isSorted = true, this._pendingRemoval = /* @__PURE__ */ new Set(), this._isAnyPendingRemoval = false;
    }
    Release() {
      C32.clearArray(this._instances), this._pendingRemoval.clear(), this._grid = null;
    }
    Reset() {
      C32.clearArray(this._instances), this._isSorted = true, this._pendingRemoval.clear(), this._isAnyPendingRemoval = false;
    }
    SetChanged() {
      this._isSorted = false;
    }
    IsEmpty() {
      return !this._instances.length || !(this._instances.length > this._pendingRemoval.size) && (this._FlushPending(), true);
    }
    Insert(e) {
      if (this._pendingRemoval.has(e)) return this._pendingRemoval.delete(e), void (0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = false));
      this._instances.push(e), this._isSorted = 1 === this._instances.length;
    }
    Remove(e) {
      this._pendingRemoval.add(e), this._isAnyPendingRemoval = true, this._pendingRemoval.size >= 50 && this._FlushPending();
    }
    _FlushPending() {
      this._isAnyPendingRemoval && (this._instances.length !== this._pendingRemoval.size ? (C32.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = false) : this.Reset());
    }
    _EnsureSorted() {
      this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex), this._isSorted = true);
    }
    Dump(e) {
      this._FlushPending(), this._EnsureSorted(), this._instances.length && e.push(this._instances);
    }
  };
}
var SortByInstLastCachedZIndex2;
{
  const C32 = self.C3;
  C32.RenderGrid = class extends C32.DefendedBase {
    constructor(e, t) {
      super(), this._cellWidth = e, this._cellHeight = t, this._cells = C32.New(C32.PairMap);
    }
    Release() {
      this._cells.Release(), this._cells = null;
    }
    GetCell(e, t, l) {
      let o = this._cells.Get(e, t);
      return o || (l ? (o = C32.New(C32.RenderCell, this, e, t), this._cells.Set(e, t, o), o) : null);
    }
    XToCell(e) {
      return Math.floor(e / this._cellWidth);
    }
    YToCell(e) {
      return Math.floor(e / this._cellHeight);
    }
    Update(e, t, l) {
      if (t) for (let o = t.getLeft(), s = t.getRight(); o <= s; ++o) for (let s2 = t.getTop(), i = t.getBottom(); s2 <= i; ++s2) {
        if (l && l.containsPoint(o, s2)) continue;
        const t2 = this.GetCell(o, s2, false);
        t2 && (t2.Remove(e), t2.IsEmpty() && this._cells.Delete(o, s2));
      }
      if (l) for (let o = l.getLeft(), s = l.getRight(); o <= s; ++o) for (let s2 = l.getTop(), i = l.getBottom(); s2 <= i; ++s2) t && t.containsPoint(o, s2) || this.GetCell(o, s2, true).Insert(e);
    }
    QueryRange(e, t) {
      let l = this.XToCell(e.getLeft());
      const o = this.YToCell(e.getTop()), s = this.XToCell(e.getRight()), i = this.YToCell(e.getBottom());
      for (; l <= s; ++l) for (let e2 = o; e2 <= i; ++e2) {
        const o2 = this.GetCell(l, e2, false);
        o2 && o2.Dump(t);
      }
    }
    MarkRangeChanged(e) {
      let t = e.getLeft();
      const l = e.getTop(), o = e.getRight(), s = e.getBottom();
      for (; t <= o; ++t) for (let e2 = l; e2 <= s; ++e2) {
        const l2 = this.GetCell(t, e2, false);
        l2 && l2.SetChanged();
      }
    }
  };
}
{
  let SortByInstLastCachedZIndex = function(e, t) {
    return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex();
  }, SortByInstZElevation = function(e, t) {
    return e.GetWorldInfo().GetZElevation() - t.GetWorldInfo().GetZElevation();
  };
  SortByInstLastCachedZIndex2 = SortByInstLastCachedZIndex, SortByInstZElevation2 = SortByInstZElevation;
  const C32 = self.C3, assert = self.assert, tmpRect = new C32.Rect(), tmpQuad = new C32.Quad(), renderCellArr = [], tmpDestRect = new C32.Rect(), tmpSrcRect = new C32.Rect(), glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempMat4 = mat4.create(), tempVec3 = vec3.create(), tempVec4 = vec4.create(), camVector = vec3.create(), lookVector = vec3.create(), upVector = vec3.create(), tempVec2 = C32.New(C32.Vector2), tempRect = C32.New(C32.Rect);
  const tempInstanceList1 = [], tempInstanceList2 = [], tempInstancesByCameraDist = [], DEFAULT_LAYER_OPTIONS = { name: "", sid: -1, isDynamic: false, isVisible: true, isInteractive: true, isHTMLElementsLayer: false, backgroundColor: [1, 1, 1, 1], isTransparent: true, parallax: [1, 1], opacity: 1, isForceOwnTexture: false, renderAs3d: false, useCameraDistanceDrawOrder: false, useRenderCells: false, scaleRate: 1, blendMode: 0, zElevation: 0, initialInstancesData: [], effectListData: [], subLayersData: [] }, allInitialGlobalInstances = /* @__PURE__ */ new Map(), on_global_instance_destroy = (e) => {
    if (!e.instance.GetObjectClass().IsGlobal()) return;
    const t = e.instance.GetUID();
    allInitialGlobalInstances.has(t) && (allInitialGlobalInstances.delete(t), allInitialGlobalInstances.size || e.instance.GetRuntime().Dispatcher().removeEventListener("instancedestroy", on_global_instance_destroy));
  };
  C32.Layer = class extends C32.DefendedBase {
    constructor(e, t, s) {
      super(), s = Object.assign({}, DEFAULT_LAYER_OPTIONS, s), this._layout = e, this._runtime = e.GetRuntime(), this._parentLayer = t, this._name = s.name, this._index = -1, this._isHTMLElementsLayer = !!s.isHTMLElementsLayer, this._htmlIndex = -1, this._sid = s.sid, this._isDynamic = !!s.isDynamic, this._isVisible = !!s.isVisible, this._isInteractive = !!s.isInteractive, this._backgroundColor = C32.New(C32.Color), this._backgroundColor.setFromJSON(s.backgroundColor), this._isTransparent = !!s.isTransparent, this._parallaxX = s.parallax[0], this._parallaxY = s.parallax[1], this._color = C32.New(C32.Color, 1, 1, 1, s.opacity), this._premultipliedColor = C32.New(C32.Color), this._isForceOwnTexture = !!s.isForceOwnTexture, this._renderAs3d = !!s.renderAs3d, this._useCameraDistanceDrawOrder = !!s.useCameraDistanceDrawOrder, this._useRenderCells = !!s.useRenderCells, this._scaleRate = s.scaleRate, this._blendMode = s.blendMode, this._curRenderTarget = null, this._scale = 1, this._zElevation = s.zElevation, this._angle = 0, this._scrollX = 0, this._scrollY = 0, this._hasOwnScrollPosition = false, this._viewport = C32.New(C32.Rect), this._viewportZ0 = C32.New(C32.Rect), this._viewport3D = C32.New(C32.Rect), this._isViewportChanged = true, this._projectionMatrix = mat4.create(), this._isProjectionMatrixChanged = true, this._modelViewMatrix = mat4.create(), this._isMVMatrixChanged = true, this._viewFrustum = C32.New(C32.Gfx.ViewFrustum), this._isViewFrustumChanged = true, this._startupInitialInstances = [], this._initialInstancesData = s.initialInstancesData, this._initialInstances = [], this._createdGlobalUids = [], this._initialUIDsToInstanceData = /* @__PURE__ */ new Map(), this._instances = [], this._zIndicesUpToDate = false, this._htmlZIndicesUpToDate = false, this._anyInstanceZElevated = false;
      const a = this._runtime.GetCanvasManager();
      this._effectList = C32.New(C32.EffectList, this, s.effectListData), this._effectChain = C32.New(C32.Gfx.EffectChain, a.GetEffectChainManager(), { drawContent: (e2, t2) => {
        const s2 = t2.GetContentObject(), i = s2.GetRenderTarget();
        e2.SetColor(s2.GetPremultipliedColor()), e2.DrawRenderTarget(i), e2.InvalidateRenderTarget(i), a.ReleaseAdditionalRenderTarget(i);
      }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasDefaultColor = true, this._renderGrid = null, this._lastRenderList = [], this._isRenderListUpToDate = false, this._lastRenderCells = C32.New(C32.Rect, 0, 0, -1, -1), this._curRenderCells = C32.New(C32.Rect, 0, 0, -1, -1), this._iLayer = new self.ILayer(this), this._userScriptDispatcher = C32.New(C32.Event.Dispatcher), this._UpdatePremultipliedColor(), this.UsesRenderCells() && (this._renderGrid = C32.New(C32.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight())), this._subLayers = s.subLayersData.map((e2) => C32.Layer.CreateFromExportData(this._layout, this, e2));
    }
    _InitInitialInstances() {
      for (const e of this._initialInstancesData) {
        const t = this._runtime.GetObjectClassByIndex(e[1]);
        this._layout._AddInitialObjectClass(t), t.GetDefaultInstanceData() || (t.SetDefaultInstanceData(e), t._SetDefaultLayerIndex(this._index)), this._initialInstances.push(e), this._initialUIDsToInstanceData.set(e[2], e);
      }
      C32.shallowAssignArray(this._startupInitialInstances, this._initialInstances), this._initialInstancesData = null;
    }
    static CreateFromExportData(e, t, s) {
      return C32.New(C32.Layer, e, t, { name: s[0], sid: s[2], isVisible: s[3], isInteractive: s[13], isHTMLElementsLayer: s[19], backgroundColor: s[4].map((e2) => e2 / 255), isTransparent: s[5], parallax: [s[6], s[7]], opacity: s[8], isForceOwnTexture: s[9], renderAs3d: s[17], useCameraDistanceDrawOrder: s[18], useRenderCells: s[10], scaleRate: s[11], blendMode: s[12], zElevation: s[16], initialInstancesData: s[14], effectListData: s[15], subLayersData: s[20] });
    }
    Release() {
      for (const e of this._subLayers) e.Release();
      C32.clearArray(this._subLayers);
      for (const e of this._instances) this._runtime.DestroyInstance(e);
      C32.clearArray(this._instances), this._effectList.Release(), this._effectList = null, this._effectChain.Release(), this._effectChain = null, this._iLayer = null, this._parentLayer = null, this._layout = null, this._runtime = null;
    }
    WasReleased() {
      return !this._layout;
    }
    GetInitialInstanceData(e) {
      return this._initialUIDsToInstanceData.get(e);
    }
    CreateInitialInstances(e) {
      const t = this._layout.IsFirstVisit(), s = this._initialInstances;
      let a = 0;
      for (let i = 0, r = s.length; i < r; ++i) {
        const r2 = s[i], n = this._runtime.GetObjectClassByIndex(r2[1]);
        let l = true;
        if (!n.HasPersistBehavior() || t) if (n.IsGlobal() && allInitialGlobalInstances.has(r2[2])) l = false;
        else {
          const t2 = this._runtime.CreateInstanceFromData(r2, this, true);
          e.push(t2), n.IsGlobal() && (allInitialGlobalInstances.size || this._runtime.Dispatcher().addEventListener("instancedestroy", on_global_instance_destroy), allInitialGlobalInstances.set(t2.GetUID(), t2), l = false, this._createdGlobalUids.push(t2.GetUID()));
        }
        l && (s[a] = s[i], ++a);
      }
      C32.truncateArray(s, a), this._runtime.FlushPendingInstances(), this.SetZIndicesChanged();
    }
    _AddInstance(e, t) {
      if (!e.GetPlugin().IsWorldType()) throw new Error("instance is not of world type");
      const s = e.GetWorldInfo();
      if (s.GetLayer() !== this) throw new Error("instance added to wrong layer");
      this._instances.push(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged(), this.SetZIndicesChanged(e);
    }
    _MaybeAddInstance(e) {
      this._instances.includes(e) || (this._instances.push(e), 0 !== e.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e));
    }
    _PrependInstance(e, t) {
      const s = e.GetWorldInfo();
      if (s.GetLayer() !== this) throw new Error("instance added to wrong layer");
      this._instances.unshift(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged();
    }
    _RemoveInstance(e, t) {
      const s = this._instances.indexOf(e);
      s < 0 || (t && this.UsesRenderCells() && e.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(s, 1), this.SetZIndicesChanged(e), this._MaybeResetAnyInstanceZElevatedFlag());
    }
    _SetAnyInstanceZElevated() {
      this._anyInstanceZElevated = true;
    }
    _MaybeResetAnyInstanceZElevatedFlag() {
      0 === this._instances.length && (this._anyInstanceZElevated = false);
    }
    _SortInstancesByLastCachedZIndex(e) {
      if (e) {
        const e2 = /* @__PURE__ */ new Set();
        for (const t2 of this._instances) {
          const s = t2.GetWorldInfo()._GetLastCachedZIndex();
          s >= 0 && e2.add(s);
        }
        let t = -1;
        for (const s of this._instances) {
          const a = s.GetWorldInfo();
          if (!(a._GetLastCachedZIndex() >= 0)) {
            for (++t; e2.has(t); ) ++t;
            a._SetZIndex(t);
          }
        }
      }
      this._instances.sort(SortByInstLastCachedZIndex);
    }
    _Start() {
    }
    _End() {
      for (const e of this._instances) e.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(e);
      this._runtime.FlushPendingInstances(), C32.clearArray(this._instances), this._anyInstanceZElevated = false, this.SetZIndicesChanged();
    }
    RecreateInitialObjects(e, t, s, a, i, r) {
      const n = this._runtime.GetEventSheetManager(), l = this._runtime.GetAllObjectClasses(), o = e.IsFamily(), h = [];
      for (const c of this._initialInstances) {
        const d = c[0], _ = d[0], u = d[1];
        if (!t.containsPoint(_, u)) continue;
        const G = l[c[1]];
        if (G !== e) {
          if (!o) continue;
          if (!e.FamilyHasMember(G)) continue;
        }
        let p = i;
        if (!p) {
          const e2 = this._runtime.GetCurrentLayout();
          this.GetLayout() === e2 ? p = this : (p = e2.GetLayerByName(this.GetName()), p || (p = e2.GetLayerByIndex(this.GetIndex())));
        }
        const f = this._runtime.CreateInstanceFromData(c, p, false, void 0, void 0, false, r, void 0, r);
        r && p.SortAndAddInstancesByZIndex(f);
        const I = f.GetWorldInfo();
        I.OffsetXY(s, a), I.SetBboxChanged(), n.BlockFlushingInstances(true), f._TriggerOnCreatedOnSelfAndRelated(), n.BlockFlushingInstances(false), h.push(f);
      }
      return h;
    }
    GetInstanceCount() {
      return this._instances.length;
    }
    GetLayout() {
      return this._layout;
    }
    GetName() {
      return this._name;
    }
    _SetIndex(e) {
      this._index = e;
    }
    GetIndex() {
      return this._index;
    }
    _SetHTMLIndex(e) {
      this._htmlIndex = e;
    }
    GetHTMLIndex() {
      return this._htmlIndex;
    }
    IsHTMLElementsLayer() {
      return this._isHTMLElementsLayer;
    }
    SetIsHTMLElementsLayer(e) {
      e = !!e, this._isHTMLElementsLayer !== e && (this._isHTMLElementsLayer = e, this._layout._ReindexAndUpdateAllLayers(), this._runtime.UpdateRender());
    }
    _GetSiblingIndex() {
      let e = -1;
      const t = this.GetParentLayer();
      return e = t ? t.GetSubLayers().indexOf(this) : this.GetLayout()._GetRootLayers().indexOf(this), e;
    }
    GetSID() {
      return this._sid;
    }
    GetRuntime() {
      return this._runtime;
    }
    IsDynamic() {
      return this._isDynamic;
    }
    HasAnyDynamicParentLayer() {
      for (const e of this.parentLayers()) if (e.IsDynamic()) return true;
      return false;
    }
    GetDevicePixelRatio() {
      return this._runtime.GetDevicePixelRatio();
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      return this._MaybeRebuildEffectChainSteps(), this._effectChain;
    }
    _MaybeRebuildEffectChainSteps() {
      const e = this.HasDefaultColor();
      if (!this._needsRebuildEffectChainSteps && e === this._wasDefaultColor && !this._effectChain.NeedsRebuild()) return;
      const t = this.GetEffectList().GetActiveEffectTypes();
      this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePreDraw: !e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasDefaultColor = e;
    }
    UpdateActiveEffects() {
      this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;
    }
    UsesRenderCells() {
      return this._useRenderCells && !this._useCameraDistanceDrawOrder;
    }
    GetRenderGrid() {
      return this._renderGrid;
    }
    SetRenderListStale() {
      this._isRenderListUpToDate = false;
    }
    IsVisible() {
      for (const e of this.selfAndParentLayers()) if (!e._IsVisibleFlagSet()) return false;
      return true;
    }
    _IsVisibleFlagSet() {
      return this._isVisible;
    }
    SetVisible(e) {
      e = !!e, this._isVisible !== e && (this._isVisible = e, this._runtime.UpdateRender());
    }
    SetInteractive(e) {
      this._isInteractive = !!e;
    }
    IsInteractive() {
      return this._isInteractive;
    }
    IsSelfAndParentsInteractive() {
      for (const e of this.selfAndParentLayers()) if (!e.IsInteractive()) return false;
      return true;
    }
    SetOwnScrollPositionEnabled(e) {
      if (e = !!e, this._hasOwnScrollPosition !== e) {
        if (this._hasOwnScrollPosition = e, e) {
          const e2 = this.GetLayout();
          this._scrollX = e2.GetScrollX(), this._scrollY = e2.GetScrollY();
        }
        this._SetMVMatrixChanged(), this._runtime.UpdateRender();
      }
    }
    IsOwnScrollPositionEnabled() {
      return this._hasOwnScrollPosition;
    }
    SetScrollX(e) {
      const t = this.GetLayout(), s = t.GetScrollLeftBound(), a = t.GetScrollRightBound();
      e > a && (e = a), e < s && (e = s), this._scrollX !== e && (this._scrollX = e, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));
    }
    SetScrollY(e) {
      const t = this.GetLayout(), s = t.GetScrollTopBound(), a = t.GetScrollBottomBound();
      e > a && (e = a), e < s && (e = s), this._scrollY !== e && (this._scrollY = e, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));
    }
    GetScrollX() {
      return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX();
    }
    GetScrollY() {
      return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY();
    }
    GetViewport() {
      return this._MaybeUpdateViewport(), this._viewport;
    }
    _GetViewportZ0() {
      return this._MaybeUpdateViewport(), this._viewportZ0;
    }
    GetViewport3D() {
      return this._MaybeUpdateViewport(), this._viewport3D;
    }
    _GetVanishingPoint() {
      return this.GetLayout().GetVanishingPoint();
    }
    GetDefaultCameraZ(e) {
      return this._runtime.GetDefaultCameraZ(e);
    }
    GetViewportForZ(e, t) {
      const s = this._GetViewportZ0();
      if (0 === e) t.copy(s);
      else {
        let a = s.midX(), i = s.midY();
        const r = this.Get2DScaleFactorToZ(e), n = s.width() / r, l = s.height() / r, [o, h] = this._GetVanishingPoint();
        if (0.5 !== o || 0.5 !== h) {
          const t2 = this.Get2DCameraZ(), s2 = this._runtime, r2 = this.GetDefaultCameraZ() / t2;
          let n2 = (o - 0.5) * s2.GetViewportWidth() / r2, l2 = (h - 0.5) * s2.GetViewportHeight() / r2;
          const c = this.GetAngle();
          0 !== c && (tempVec2.set(n2, l2), tempVec2.rotate(c), n2 = tempVec2.getX(), l2 = tempVec2.getY());
          const d = C32.unlerp(t2, 0, e);
          a += C32.lerp(n2, 0, d), i += C32.lerp(l2, 0, d);
        }
        t.set(a - n / 2, i - l / 2, a + n / 2, i + l / 2);
      }
    }
    GetOpacity() {
      return this._color.getA();
    }
    SetOpacity(e) {
      e = C32.clamp(e, 0, 1), this._color.getA() !== e && (this._color.setA(e), this._UpdatePremultipliedColor(), this._runtime.UpdateRender());
    }
    _UpdatePremultipliedColor() {
      this._premultipliedColor.copy(this._color), this._premultipliedColor.premultiply();
    }
    GetPremultipliedColor() {
      return this._premultipliedColor;
    }
    HasDefaultColor() {
      return this._color.equalsRgba(1, 1, 1, 1);
    }
    GetScaleRate() {
      return this._scaleRate;
    }
    SetScaleRate(e) {
      this._scaleRate !== e && (this._scaleRate = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    GetParallaxX() {
      return this._parallaxX;
    }
    GetParallaxY() {
      return this._parallaxY;
    }
    SetParallax(e, t) {
      this._parallaxX === e && this._parallaxY === t || (this._parallaxX = e, this._parallaxY = t, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    SetParallaxX(e) {
      this.SetParallax(e, this.GetParallaxY());
    }
    SetParallaxY(e) {
      this.SetParallax(this.GetParallaxX(), e);
    }
    SetZElevation(e) {
      this._zElevation !== e && (this._zElevation = e, this._runtime.UpdateRender());
    }
    GetZElevation() {
      return this._zElevation;
    }
    SetAngle(e) {
      e = C32.clampAngle(e), this._angle !== e && (this._angle = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    GetAngle() {
      return C32.clampAngle(this._layout.GetAngle() + this._angle);
    }
    GetOwnAngle() {
      return this._angle;
    }
    HasInstances() {
      return this._instances.length > 0;
    }
    _GetInstances() {
      return this._instances;
    }
    _GetInstancesInDrawOrder() {
      return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C32.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()), tempInstancesByCameraDist.sort((e, t) => this._SortInstancesByCameraDistance(e, t)), tempInstancesByCameraDist) : this._GetInstances();
    }
    _AppendAllInstancesIncludingSubLayersInDrawOrder(e) {
      C32.appendArray(e, this._GetInstancesInDrawOrder());
      for (const t of this._subLayers) t.IsVisible() && t.GetOpacity() > 0 && t._AppendAllInstancesIncludingSubLayersInDrawOrder(e);
    }
    _SortInstancesByCameraDistance(e, t) {
      const s = this.GetLayout().Get3DCameraPosition(), a = s[0], i = s[1], r = s[2], n = e.GetWorldInfo(), l = t.GetWorldInfo(), o = n.GetX() - a, h = n.GetY() - i, c = n.GetZElevation() - r, d = l.GetX() - a, _ = l.GetY() - i, u = l.GetZElevation() - r;
      return d * d + _ * _ + u * u - (o * o + h * h + c * c);
    }
    GetBackgroundColor() {
      return this._backgroundColor;
    }
    IsTransparent() {
      return this._isTransparent;
    }
    SetTransparent(e) {
      e = !!e, this._isTransparent !== e && (this._isTransparent = e, this._runtime.UpdateRender());
    }
    IsForceOwnTexture() {
      return this._isForceOwnTexture;
    }
    SetForceOwnTexture(e) {
      e = !!e, this._isForceOwnTexture !== e && (this._isForceOwnTexture = e, this._runtime.UpdateRender());
    }
    SetRenderAs3D(e) {
      e = !!e, this._renderAs3d !== e && (this._renderAs3d = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    IsRenderAs3D() {
      return this._renderAs3d;
    }
    RendersIn2DMode() {
      return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d;
    }
    RendersIn3DMode() {
      return !this.RendersIn2DMode();
    }
    Has3DCamera() {
      return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled();
    }
    SelfAndAllSubLayersHave3DCamera() {
      if (!this.Has3DCamera()) return false;
      for (const e of this._subLayers) if (!e.SelfAndAllSubLayersHave3DCamera()) return false;
      return true;
    }
    SetBlendMode(e) {
      this._blendMode !== e && (this._blendMode = e, this._runtime.UpdateRender());
    }
    GetBlendMode() {
      return this._blendMode;
    }
    IsRootLayer() {
      return !this._parentLayer;
    }
    GetParentLayer() {
      return this._parentLayer;
    }
    _SetParentLayer(e) {
      this._parentLayer = e;
    }
    GetSubLayers() {
      return this._subLayers;
    }
    HasAnySubLayers() {
      return this._subLayers.length > 0;
    }
    _AddSubLayer(e, t = true) {
      t ? this._subLayers.push(e) : this._subLayers.unshift(e);
    }
    _InsertSubLayer(e, t, s) {
      let a = this._subLayers.indexOf(t);
      if (-1 === a) throw new Error("cannot find layer to insert by");
      s && ++a, this._subLayers.splice(a, 0, e);
    }
    _RemoveSubLayer(e) {
      const t = this._subLayers.indexOf(e);
      if (-1 === t) throw new Error("cannot find layer to remove");
      this._subLayers.splice(t, 1);
    }
    HasAnyVisibleSubLayer() {
      for (const e of this._subLayers) if (e.ShouldDraw()) return true;
      return false;
    }
    *selfAndAllSubLayers() {
      for (const e of this._subLayers) yield* e.selfAndAllSubLayers();
      yield this;
    }
    *parentLayers() {
      let e = this.GetParentLayer();
      for (; e; ) yield e, e = e.GetParentLayer();
    }
    *selfAndParentLayers() {
      yield this, yield* this.parentLayers();
    }
    HasParentLayer(e) {
      for (const t of this.parentLayers()) if (t === e) return true;
      return false;
    }
    IsTransformCompatibleWith(e) {
      return this === e || this._parallaxX === e._parallaxX && this._parallaxY === e._parallaxY && this._scale === e._scale && this._scaleRate === e._scaleRate && this._angle === e._angle && this.GetScrollX() === e.GetScrollX() && this.GetScrollY() === e.GetScrollY();
    }
    SaveTransform() {
      return { "parallaxX": this.GetParallaxX(), "parallaxY": this.GetParallaxY(), "scale": this.GetOwnScale(), "scaleRate": this.GetScaleRate(), "angle": this.GetOwnAngle(), "hasOwnScroll": this.IsOwnScrollPositionEnabled(), "scrollX": this.GetScrollX(), "scrollY": this.GetScrollY() };
    }
    RestoreTransform(e) {
      this.SetParallax(e["parallaxX"], e["parallaxY"]), this.SetOwnScale(e["scale"]), this.SetScaleRate(e["scaleRate"]), this.SetAngle(e["angle"]), this.SetOwnScrollPositionEnabled(e["hasOwnScroll"]), this.SetScrollX(e["scrollX"]), this.SetScrollY(e["scrollY"]), this._MaybeUpdateViewport();
    }
    _RemoveAllInstancesInSet(e) {
      if (0 === e.size) return;
      C32.arrayRemoveAllInSet(this._instances, e) > 0 && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged());
    }
    SetZIndicesChanged(e) {
      this._zIndicesUpToDate = false, this._isRenderListUpToDate = false, e && !e.GetObjectClass().GetPlugin().IsHTMLElementType() || (this._htmlZIndicesUpToDate = false);
    }
    _UpdateZIndices() {
      if (!this._zIndicesUpToDate) {
        if (this._instances.sort(SortByInstZElevation), this.UsesRenderCells()) for (let e = 0, t = this._instances.length; e < t; ++e) {
          const t2 = this._instances[e].GetWorldInfo();
          t2._SetZIndex(e), this._renderGrid.MarkRangeChanged(t2.GetRenderCellRange());
        }
        else for (let e = 0, t = this._instances.length; e < t; ++e) this._instances[e].GetWorldInfo()._SetZIndex(e);
        this._zIndicesUpToDate = true;
      }
    }
    _UpdateHTMLZIndices() {
      if (this._htmlZIndicesUpToDate) return;
      const e = this._layout.GetRootLayersForHTMLLayer(this.GetHTMLIndex()).map((e2) => [...e2.selfAndAllSubLayers()]).flat();
      let t = 0;
      for (const s of e) {
        for (const e2 of s._GetInstances()) e2.GetObjectClass().GetPlugin().IsHTMLElementType() && e2.GetWorldInfo()._SetHTMLZIndex(t++);
        s._SetHTMLZIndicesUpToDate();
      }
    }
    _SetHTMLZIndicesUpToDate() {
      this._htmlZIndicesUpToDate = true;
    }
    _GetHTMLLayerDOMState() {
      return { "isVisible": this.IsVisible(), "opacity": this.GetOpacity(), "isInteractive": this.IsInteractive() };
    }
    MoveInstanceAdjacent(e, t, s) {
      const a = e.GetWorldInfo(), i = t.GetWorldInfo();
      if (a.GetLayer() !== this || i.GetLayer() !== this) throw new Error("can't arrange Z order unless both objects on this layer");
      const r = a.GetZIndex();
      let n = i.GetZIndex();
      return r !== n + (s ? 1 : -1) && (C32.arrayRemove(this._instances, r), r < n && n--, s && n++, n === this._instances.length ? this._instances.push(e) : this._instances.splice(n, 0, e), this.SetZIndicesChanged(e), true);
    }
    _MergeSortedZArrays(e, t) {
      const s = [];
      let a = 0, i = 0, r = e.length, n = t.length;
      for (; a < r && i < n; ) {
        const r2 = e[a], n2 = t[i];
        r2.GetWorldInfo()._GetLastCachedZIndex() < n2.GetWorldInfo()._GetLastCachedZIndex() ? (s.push(r2), ++a) : (s.push(n2), ++i);
      }
      for (; a < r; ++a) s.push(e[a]);
      for (; i < n; ++i) s.push(t[i]);
      return s;
    }
    _MergeAllSortedZArrays_pass(e) {
      const t = [], s = e.length;
      for (let a = 0; a < s - 1; a += 2) {
        const s2 = e[a], i = e[a + 1];
        t.push(this._MergeSortedZArrays(s2, i));
      }
      return s % 2 == 1 && t.push(e[s - 1]), t;
    }
    _MergeAllSortedZArrays(e) {
      for (; e.length > 1; ) e = this._MergeAllSortedZArrays_pass(e);
      return e[0];
    }
    _GetRenderCellInstancesToDraw() {
      return this._UpdateZIndices(), C32.clearArray(renderCellArr), this._renderGrid.QueryRange(this.GetViewport(), renderCellArr), renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : [];
    }
    ShouldDraw() {
      return this.IsVisible() && this.GetOpacity() > 0 && this._DrawsAnyContentInSelfOrSubLayers();
    }
    _DrawsAnyContentInSelfOrSubLayers() {
      if (this.HasInstances() || !this.IsTransparent() || this._userScriptDispatcher.HasAnyHandlerFor("beforedraw") || this._userScriptDispatcher.HasAnyHandlerFor("afterdraw")) return true;
      for (const e of this._subLayers) if (e._DrawsAnyContentInSelfOrSubLayers()) return true;
      return false;
    }
    UsesOwnTexture() {
      return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect();
    }
    SelfOrAnySubLayerUsesOwnTexture() {
      if (this.UsesOwnTexture()) return true;
      for (const e of this._subLayers) if (e.SelfOrAnySubLayerUsesOwnTexture()) return true;
      return false;
    }
    GetRenderTarget() {
      return this._curRenderTarget;
    }
    Get2DScaleFactorToZ(e) {
      if (this._layout.IsOrthographicProjection()) return 1;
      {
        const t = this.Get3DCameraZ();
        return t / (t - e);
      }
    }
    GetResolutionScaleFactorToZ(e) {
      const t = this._runtime.GetRenderScale();
      if (this._layout.IsOrthographicProjection()) return t;
      {
        const s = this.Get3DCameraZ();
        return this.GetDefaultCameraZ() / Math.abs(s - e) * t;
      }
    }
    _SetMVMatrixChanged() {
      this._isMVMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;
    }
    _GetModelViewMatrix(e) {
      return this._isMVMatrixChanged && (this._CalculateModelViewMatrix(e, this._modelViewMatrix, 0, 0, null), this._isMVMatrixChanged = false), this._modelViewMatrix;
    }
    Get2DCameraZ(e) {
      return this.GetDefaultCameraZ(e) / this.GetNormalScale();
    }
    Get3DCameraZ() {
      return this.Has3DCamera() ? this.GetLayout().Get3DCameraPosition()[2] : this.Get2DCameraZ();
    }
    GetCameraPosition() {
      if (this.Has3DCamera()) {
        const e = this.GetLayout().Get3DCameraPosition();
        return [e[0], e[1], e[2]];
      }
      return this._Get2DCameraPosition();
    }
    _Get2DCameraPosition(e = 0, t = 0, s = 0) {
      const a = this._runtime, i = this.GetLayout(), r = a.GetParallaxXOrigin(), n = a.GetParallaxYOrigin();
      let l = (this.GetScrollX() - r) * this._parallaxX + r, o = (this.GetScrollY() - n) * this._parallaxY + n;
      a.IsPixelRoundingEnabled() && (l = Math.round(l), o = Math.round(o));
      let h = l + e, c = o + t;
      const d = i.IsOrthographicProjection() ? this.GetDefaultCameraZ(s) : this.Get2DCameraZ(s), [_, u] = this._GetVanishingPoint();
      if (0.5 !== _ || 0.5 !== u) {
        const e2 = this.GetDefaultCameraZ(s) / d;
        let t2 = (_ - 0.5) * a.GetViewportWidth() / e2, i2 = (u - 0.5) * a.GetViewportHeight() / e2;
        const r2 = this.GetAngle();
        0 !== r2 && (tempVec2.set(t2, i2), tempVec2.rotate(r2), t2 = tempVec2.getX(), i2 = tempVec2.getY()), h += t2, c += i2;
      }
      return [h, c, d];
    }
    _CalculateModelViewMatrix(e, t, s, a, i) {
      const r = this._runtime, n = this.GetLayout();
      if (this.Has3DCamera()) {
        vec3.copy(camVector, n.Get3DCameraPosition()), vec3.copy(lookVector, n.Get3DCameraLookAt()), vec3.copy(upVector, n.Get3DCameraUpVector());
        const e2 = r.GetParallaxXOrigin(), t2 = r.GetParallaxYOrigin(), s2 = lookVector[0] - camVector[0], a2 = lookVector[1] - camVector[1], i2 = lookVector[2] - camVector[2];
        camVector[0] = (camVector[0] - e2) * this._parallaxX + e2, camVector[1] = (camVector[1] - t2) * this._parallaxY + t2, camVector[2] *= Math.max(this._parallaxX, this._parallaxY), lookVector[0] = camVector[0] + s2, lookVector[1] = camVector[1] + a2, lookVector[2] = camVector[2] + i2;
      } else {
        const [e2, t2, r2] = this._Get2DCameraPosition(s, a, i);
        vec3.set(camVector, e2, t2, r2), vec3.set(lookVector, e2, t2, r2 - 100);
        const n2 = this.GetAngle();
        0 === n2 ? vec3.set(upVector, 0, 1, 0) : vec3.set(upVector, Math.sin(n2), Math.cos(n2), 0);
      }
      e.CalculateLookAtModelView(t, camVector, lookVector, upVector, i || r.GetViewportHeight());
    }
    _SetProjectionMatrixChanged() {
      this._isProjectionMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;
    }
    _GetProjectionMatrix(e) {
      return this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(e), this._isProjectionMatrixChanged = false), this._projectionMatrix;
    }
    _CalculateProjectionMatrix(e) {
      const t = this._runtime.GetCanvasManager(), [s, a] = this._GetVanishingPoint();
      if (this._layout.IsOrthographicProjection()) e.CalculateOrthographicMatrix(this._projectionMatrix, t.GetDrawWidth(), t.GetDrawHeight());
      else if (0.5 === s && 0.5 === a) mat4.copy(this._projectionMatrix, t.GetDefaultProjectionMatrix());
      else {
        const i = t.GetDrawWidth(), r = t.GetDrawHeight();
        e.CalculatePerspectiveMatrix(this._projectionMatrix, i / r, s, a);
      }
    }
    _SetTransform(e, t = true, s = 0, a = 0, i = 0) {
      t && e.SetProjectionMatrix(this._GetProjectionMatrix(e));
      let r = null;
      0 === s && 0 === a && 0 === i ? r = this._GetModelViewMatrix(e) : (this._CalculateModelViewMatrix(e, tempMat4, s, a, i), r = tempMat4), e.SetModelViewMatrix(r);
    }
    PrepareForDraw(e) {
      this._SetTransform(e), e.SetBaseZ(this.GetZElevation());
    }
    _MaybeStartWebGLProfiling(e) {
      let t = null;
      if (e.IsWebGL() && this._runtime.IsGPUProfiling()) {
        const s = this._runtime.GetCanvasManager().GetLayerTimingsBuffer(this);
        s && (t = s.AddTimeElapsedQuery(), e.StartQuery(t));
      }
      return t;
    }
    _MaybeStartWebGPUProfiling(e) {
      if (e.IsWebGPU() && this._runtime.IsGPUProfiling()) {
        const t = 2 * (this.GetIndex() + 1);
        e.StartMeasuringRenderPassTime(t, t + 1);
      }
    }
    _FireDrawEvent(e, t) {
      if (this._userScriptDispatcher.HasAnyHandlerFor(t)) {
        e.SetTextureFillMode(), e.SetTexture(null), e.SetAlphaBlend(), e.ResetCullState(), e.SetColorRgba(1, 1, 1, 1), e.SetBaseZ(this.GetZElevation()), e.SetCurrentZ(0);
        const s = new C32.Event(t);
        s.renderer = this._runtime.GetCanvasManager().GetIRenderer(), this.DispatchUserScriptEvent(s);
      }
    }
    Draw(e, t, s) {
      const a = this._runtime.GetCanvasManager(), i = this.UsesOwnTexture();
      let r = null;
      const n = this._MaybeStartWebGLProfiling(e);
      if (this._MaybeStartWebGPUProfiling(e), i) {
        const t2 = { sampling: this._runtime.GetSampling(), isSampled: true, canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };
        "low" === a.GetCurrentFullscreenScalingQuality() && (t2.width = a.GetDrawWidth(), t2.height = a.GetDrawHeight()), r = this._runtime.GetAdditionalRenderTarget(t2), this._curRenderTarget = r, e.SetRenderTarget(r), this.IsTransparent() && e.ClearRgba(0, 0, 0, 0);
      } else this._curRenderTarget = t, e.SetRenderTarget(t);
      if (this.IsTransparent() || e.Clear(this._backgroundColor), this._layout._DrawLayerList(e, this._curRenderTarget, this._subLayers, i && this.IsTransparent()), this._MaybeStartWebGPUProfiling(e), this._SetTransform(e), e.SetBaseZ(this.GetZElevation()), e.SetDepthEnabled(this.RendersIn3DMode()), this._FireDrawEvent(e, "beforedraw"), this.GetNormalScale() > Number.EPSILON) {
        this._UpdateZIndices();
        const t2 = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated;
        this.Has3DCamera() ? this._DrawInstances_3DCamera(e) : t2 ? this._DrawInstances_RenderCells(e) : this._DrawInstances(e, this._GetInstancesInDrawOrder());
      }
      this._FireDrawEvent(e, "afterdraw"), e.SetBaseZ(0), e.SetCurrentZ(0), i && (e.SetDepthEnabled(false), this._DrawLayerOwnTextureToRenderTarget(e, r, t, s)), n && e.EndQuery(n), this._curRenderTarget = null;
    }
    _DrawInstances(e, t) {
      const s = this.GetViewport(), a = this._curRenderTarget, i = this.GetLayout().IsOrthographicProjection(), r = this.GetLayout().HasVanishingPointOutsideViewport();
      let n = null;
      for (let l = 0, o = t.length; l < o; ++l) {
        const o2 = t[l];
        if (o2 === n) continue;
        n = o2;
        const h = o2.GetWorldInfo();
        h.IsVisible() && h.IsInViewport(s, r, i) && this._DrawInstanceMaybeWithEffects(o2, h, e, a);
      }
    }
    _DrawInstances_3DCamera(e) {
      const t = this._curRenderTarget, s = this._GetViewFrustum(), a = tempInstanceList1, i = tempInstanceList2, r = this._GetInstancesInDrawOrder();
      for (let n = 0, l = r.length; n < l; ) {
        const o = r[n], h = o.GetWorldInfo();
        if (!h.IsVisible() || !h.IsInViewport3D(s)) {
          ++n;
          continue;
        }
        (!o.RendersToOwnZPlane() || h.GetDepth() > 0) && i.push(o);
        const c = o.GetWorldInfo().GetTotalZElevation();
        a.push(o);
        let d = n + 1;
        for (; d < l; ++d) {
          const e2 = r[d], t2 = e2.GetWorldInfo();
          if (t2.IsVisible() && t2.IsInViewport3D(s)) {
            if (t2.GetTotalZElevation() !== c) break;
            e2.RendersToOwnZPlane() ? (t2.GetDepth() > 0 && i.push(e2), a.push(e2)) : i.push(e2);
          }
        }
        if (1 !== a.length || a[0].MustMitigateZFighting()) {
          this._DrawCoplanarInstances_3DCamera(e, a);
          for (let s2 = 0, a2 = i.length; s2 < a2; ++s2) {
            const a3 = i[s2], r2 = a3.GetWorldInfo();
            r2._SetDrawNonBackFacesOnly(true), this._DrawInstanceMaybeWithEffects(a3, r2, e, t), r2._SetDrawNonBackFacesOnly(false);
          }
        } else {
          this._DrawInstanceMaybeWithEffects(o, h, e, t);
          for (let s2 = 0, a2 = i.length; s2 < a2; ++s2) {
            const a3 = i[s2];
            if (a3 === o) continue;
            const r2 = a3.GetWorldInfo();
            r2.GetLayer()._DrawInstanceMaybeWithEffects(a3, r2, e, t);
          }
        }
        n = d, C32.clearArray(a), C32.clearArray(i);
      }
    }
    _DrawCoplanarInstances_3DCamera(e, t) {
      const s = this._curRenderTarget;
      e.CoplanarStartStencilPass();
      for (let s2 = 0, a = t.length; s2 < a; ++s2) {
        const a2 = t[s2], i = a2.GetWorldInfo();
        i._SetDrawBackFaceOnly(true), this._DrawInstance(a2, i, e);
      }
      e.CoplanarStartColorPass();
      for (let a = 0, i = t.length; a < i; ++a) {
        const i2 = t[a], r = i2.GetWorldInfo();
        this._DrawInstanceMaybeWithEffects(i2, r, e, s), r._SetDrawBackFaceOnly(false);
      }
      e.CoplanarRestoreStandardRendering();
    }
    _DrawInstances_RenderCells(e) {
      const t = this._renderGrid, s = this._curRenderCells, a = this._lastRenderCells, i = this.GetViewport();
      let r;
      s.set(t.XToCell(i.getLeft()), t.YToCell(i.getTop()), t.XToCell(i.getRight()), t.YToCell(i.getBottom())), this._isRenderListUpToDate && s.equals(a) ? r = this._lastRenderList : (r = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = true, a.copy(s)), this._DrawInstances(e, r), r !== this._lastRenderList && C32.shallowAssignArray(this._lastRenderList, r);
    }
    _DrawInstanceMaybeWithEffects(e, t, s, a) {
      t.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(e, t, s, a) : this._DrawInstance(e, t, s);
    }
    _DrawInstance(e, t, s) {
      const a = t.GetRendererStateGroup();
      s.GetCurrentStateGroup() !== a && a.Apply(), e.Draw(s);
    }
    _DrawInstanceWithEffectsAndRestore(e, t, s, a) {
      this._DrawInstanceWithEffects(e, t, s, a, null) && this._SetTransform(s);
    }
    _DrawInstanceWithEffects(e, t, s, a, i) {
      const r = t.GetInstanceEffectList().GetEffectChain();
      return r.Render(s, a, { contentObject: e, blendMode: t.GetBlendMode(), devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), time: e.GetInstanceGameTime(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: t.GetBoundingBox(), drawSurfaceRect: r.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(t), drawContentHook: i && i.drawContentHook, compositOffX: i && i.compositOffX, compositOffY: i && i.compositOffY, compositRtWidth: i && i.compositRtWidth, compositRtHeight: i && i.compositRtHeight, updateOwnProjection: i && i.updateOwnProjection }), s.SetBaseZ(this.GetZElevation()), r.DidChangeTransform();
    }
    _DrawLayerOwnTextureToRenderTarget(e, t, s, a) {
      const i = this._effectList.GetActiveEffectTypes(), r = this._runtime;
      0 === i.length ? (e.SetRenderTarget(s), e.SetTextureFillMode(), a && 0 === this._blendMode && this.HasDefaultColor() ? e.CopyRenderTarget(t) : (e.SetBlendMode(this._blendMode), e.SetColor(this._premultipliedColor), e.DrawRenderTarget(t)), e.InvalidateRenderTarget(t), r.ReleaseAdditionalRenderTarget(t)) : this.GetEffectChain().Render(e, s, { contentObject: this, blendMode: this.GetBlendMode(), devicePixelRatio: r.GetEffectDevicePixelRatioParam(), layerScale: r.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: this.GetViewport(), drawSurfaceRect: null, invalidateRenderTargets: true });
    }
    GetOwnScale() {
      return this._scale;
    }
    SetOwnScale(e) {
      this._scale !== e && (this._scale = e, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    GetRenderScale() {
      return this.GetNormalScale() * this._runtime.GetRenderScale();
    }
    GetDisplayScale() {
      return this.GetNormalScale() * this._runtime.GetDisplayScale();
    }
    GetNormalScale() {
      return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1;
    }
    _MaybeUpdateViewport() {
      if (!this._isViewportChanged) return;
      this._isViewportChanged = false;
      const e = this._runtime.GetParallaxXOrigin(), t = this._runtime.GetParallaxYOrigin(), s = (this.GetScrollX() - e) * this._parallaxX + e, a = (this.GetScrollY() - t) * this._parallaxY + t, i = this.GetNormalScale(), r = this._runtime.GetViewportWidth() / i, n = this._runtime.GetViewportHeight() / i;
      let l = s - r / 2, o = a - n / 2;
      this._runtime.IsPixelRoundingEnabled() && (l = Math.round(l), o = Math.round(o));
      const h = this._viewportZ0;
      h.set(l, o, l + r, o + n);
      const c = this.GetAngle();
      0 !== c && (tmpRect.copy(h), tmpRect.offset(-h.midX(), -h.midY()), tmpQuad.setFromRotatedRect(tmpRect, c), tmpQuad.getBoundingBox(tmpRect), tmpRect.offset(h.midX(), h.midY()), h.copy(tmpRect));
      const d = this._zElevation;
      this.GetViewportForZ(d, this._viewport), this.Has3DCamera() ? this.CalculateViewport3D(d, this._viewport3D) : this._viewport3D.copy(this._viewport);
    }
    CalculateViewport3D(e, t) {
      const s = this._runtime.GetCanvasManager(), a = s.GetCssWidth(), i = s.GetCssHeight(), [r, n] = this.CanvasCssToLayer(0, 0, e), [l, o] = this.CanvasCssToLayer(a, 0, e), [h, c] = this.CanvasCssToLayer(a, i, e), [d, _] = this.CanvasCssToLayer(0, i, e);
      let u = Math.min(r, l, h, d), G = Math.min(n, o, c, _), p = Math.max(r, l, h, d), f = Math.max(n, o, c, _);
      isFinite(u) || (u = -1 / 0), isFinite(G) || (G = -1 / 0), isFinite(p) || (p = 1 / 0), isFinite(f) || (f = 1 / 0), t.set(u, G, p, f);
    }
    CanvasCssToLayer(e, t, s = 0) {
      return this._CanvasToLayer(e, t, s, this.GetDisplayScale());
    }
    DrawSurfaceToLayer(e, t, s = 0) {
      return this._CanvasToLayer(e, t, s, this.GetRenderScale() * this.GetDevicePixelRatio());
    }
    _CanvasToLayer(e, t, s, a) {
      const i = this._runtime, r = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o = i.GetViewportHeight() / n, h = tempVec4;
      vec4.set(h, 0, 0, l, o), e /= a, t = h[3] - t / a;
      const c = this._GetProjectionMatrix(r), d = this._GetModelViewMatrix(r), _ = tempVec3;
      return C32.Gfx.UnprojectScreenToWorldZ(e, t, s, d, c, h, _) ? [_[0], _[1]] : [NaN, NaN];
    }
    CanvasCssToLayer_DefaultTransform(e, t) {
      const s = this._scale, a = this._scaleRate, i = this._parallaxX, r = this._parallaxY, n = this._angle, l = this.Has3DCamera();
      l && this.GetLayout().Set3DCameraEnabled(false), this._scale = 1, this._scaleRate = 1, this._parallaxX = 1, this._parallaxY = 1, this._angle = 0, this._SetMVMatrixChanged();
      const o = this.CanvasCssToLayer(e, t);
      return this._scale = s, this._scaleRate = a, this._parallaxX = i, this._parallaxY = r, this._angle = n, this._SetMVMatrixChanged(), l && this.GetLayout().Set3DCameraEnabled(true), o;
    }
    LayerToCanvasCss(e, t, s = 0) {
      return this._LayerToCanvas(e, t, s, this.GetDisplayScale());
    }
    LayerToDrawSurface(e, t, s = 0) {
      return this._LayerToCanvas(e, t, s, this.GetRenderScale() * this.GetDevicePixelRatio());
    }
    _LayerToCanvas(e, t, s, a) {
      const i = this._runtime, r = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o = i.GetViewportHeight() / n, h = tempVec4;
      vec4.set(h, 0, 0, l, o);
      const c = this._GetProjectionMatrix(r), d = this._GetModelViewMatrix(r), _ = tempVec3;
      return C32.Gfx.Project(e, t, s, d, c, h, _) ? [_[0] * a, (h[3] - _[1]) * a] : [NaN, NaN];
    }
    _GetLayerToDrawSurfaceScale(e, t) {
      return e *= this.GetRenderScale() * this.GetDevicePixelRatio(), 0 !== t && (e *= this.Get2DScaleFactorToZ(t)), e;
    }
    _InstanceBoxToDrawSurface(e) {
      const t = e.GetBoundingBox(), s = e.GetTotalZElevation(), a = e.GetDepth(), i = s + a, r = t.getLeft(), n = t.getTop(), l = t.getRight(), o = t.getBottom();
      if (this.Has3DCamera()) {
        if (this._IsPointBehindNearPlane(r, n, s) || this._IsPointBehindNearPlane(l, n, s) || this._IsPointBehindNearPlane(l, o, s) || this._IsPointBehindNearPlane(r, o, s)) return null;
        if (a > 0 && (this._IsPointBehindNearPlane(r, n, i) || this._IsPointBehindNearPlane(l, n, i) || this._IsPointBehindNearPlane(l, o, i) || this._IsPointBehindNearPlane(r, o, i))) return null;
      } else if (i >= this.Get2DCameraZ()) return null;
      let [h, c] = this.LayerToDrawSurface(r, n, s), [d, _] = this.LayerToDrawSurface(l, o, s);
      if (0 !== this.GetAngle() || a > 0 || this.Has3DCamera()) {
        const [e2, t2] = this.LayerToDrawSurface(l, n, s), [u, G] = this.LayerToDrawSurface(r, o, s);
        if (a > 0) {
          const [s2, a2] = this.LayerToDrawSurface(r, n, i), [p, f] = this.LayerToDrawSurface(l, n, i), [I, C] = this.LayerToDrawSurface(l, o, i), [m, y] = this.LayerToDrawSurface(r, o, i);
          let S = Math.min(h, d, e2, u, s2, p, I, m);
          d = Math.max(h, d, e2, u, s2, p, I, m), h = S, S = Math.min(c, _, t2, G, a2, f, C, y), _ = Math.max(c, _, t2, G, a2, f, C, y), c = S;
        } else {
          let s2 = Math.min(h, d, e2, u);
          d = Math.max(h, d, e2, u), h = s2, s2 = Math.min(c, _, t2, G), _ = Math.max(c, _, t2, G), c = s2;
        }
      }
      return tmpRect.set(h, c, d, _), tmpRect;
    }
    _GetViewFrustum() {
      return this._isViewFrustumChanged && (this._UpdateViewFrustum(), this._isViewFrustumChanged = false), this._viewFrustum;
    }
    _UpdateViewFrustum() {
      const e = this._runtime.GetRenderer(), t = this._GetProjectionMatrix(e), s = this._GetModelViewMatrix(e);
      this._viewFrustum.CalculatePlanes(s, t);
    }
    _IsPointBehindNearPlane(e, t, s) {
      return this._GetViewFrustum().IsBehindNearPlane(e, t, s);
    }
    _SaveToJson() {
      return { "d": this.IsDynamic(), "s": this.GetOwnScale(), "a": this.GetOwnAngle(), "v": this._IsVisibleFlagSet(), "i": this.IsInteractive(), "html": this.IsHTMLElementsLayer(), "bc": this._backgroundColor.toJSON(), "t": this.IsTransparent(), "sx": this._scrollX, "sy": this._scrollY, "hosp": this._hasOwnScrollPosition, "px": this.GetParallaxX(), "py": this.GetParallaxY(), "c": this._color.toJSON(), "sr": this.GetScaleRate(), "fx": this._effectList.SaveToJson(), "cg": this._createdGlobalUids };
    }
    _LoadFromJson(e) {
      this._isDynamic = !!e["d"], this._scale = e["s"], this._angle = e["a"], this._isVisible = !!e["v"], this._isInteractive = !e.hasOwnProperty("i") || e["i"], this._isHTMLElementsLayer = !!e["html"], this._backgroundColor.setFromJSON(e["bc"]), this._isTransparent = !!e["t"], e.hasOwnProperty("sx") && (this._scrollX = e["sx"]), e.hasOwnProperty("sy") && (this._scrollY = e["sy"]), e.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!e["hosp"]), this._parallaxX = e["px"], this._parallaxY = e["py"], this._color.setFromJSON(e["c"]), this._UpdatePremultipliedColor(), this._scaleRate = e["sr"], C32.shallowAssignArray(this._createdGlobalUids, e["cg"]), C32.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
      const t = new Set(this._createdGlobalUids);
      let s = 0;
      for (let e2 = 0, a = this._initialInstances.length; e2 < a; ++e2) t.has(this._initialInstances[e2][2]) || (this._initialInstances[s] = this._initialInstances[e2], ++s);
      C32.truncateArray(this._initialInstances, s), this._effectList.LoadFromJson(e["fx"]), this._needsRebuildEffectChainSteps = true;
    }
    _LoadFromJsonAfterInstances() {
      this._SortInstancesByLastCachedZIndex(false), this.SetZIndicesChanged(), this._SetMVMatrixChanged(), this._SetProjectionMatrixChanged();
    }
    GetILayer() {
      return this._iLayer;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    DispatchUserScriptEvent(e) {
      e.layer = this.GetILayer(), this._userScriptDispatcher.dispatchEvent(e);
    }
    SortAndAddInstancesByZIndex(e, t = false, s = false) {
      if (this._instances.includes(e)) return t && this._instances.sort((e2, t2) => (e2.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t2.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), void (s && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2)));
      if (e.HasChildren()) {
        const t2 = [...e.allChildren()];
        t2.push(e), t2.sort((e2, t3) => (e2.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0));
        for (const e2 of t2) if (e2.IsInContainer()) for (const s2 of e2.siblings()) {
          if (t2.includes(s2)) continue;
          const e3 = [...s2.allChildren()];
          e3.push(s2), e3.sort((e4, t3) => (e4.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), e3 && e3.length && t2.splice(t2.length, 0, ...e3);
        }
        for (const e2 of t2) e2.GetPlugin().IsWorldType() && this._AddInstance(e2, true);
        s && this._instances.forEach((e2, t3) => e2.GetWorldInfo()._SetZIndex(t3));
      } else {
        if (e.GetPlugin().IsWorldType() && this._AddInstance(e, true), !e.IsInContainer()) return void (s && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2)));
        for (const t2 of e.siblings()) {
          const e2 = [...t2.allChildren()];
          if (e2.push(t2), e2.sort((e3, t3) => (e3.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), e2 && e2.length) for (const t3 of e2) t3.GetPlugin().IsWorldType() && this._AddInstance(t3, true);
        }
        s && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2));
      }
    }
  };
}
var SortByInstLastCachedZIndex2;
var SortByInstZElevation2;
{
  let vec3EqualsXYZ = function(e, t, s, r) {
    return e[0] === Math.fround(t) && e[1] === Math.fround(s) && e[2] === Math.fround(r);
  }, MaybePrepareLayerDraw = function(e, t) {
    lastLayerPreparedForDrawing !== e && (e.PrepareForDraw(t), lastLayerPreparedForDrawing = e);
  };
  vec3EqualsXYZ2 = vec3EqualsXYZ, MaybePrepareLayerDraw2 = MaybePrepareLayerDraw;
  const C32 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, tempDestRect = C32.New(C32.Rect), tempSrcRect = C32.New(C32.Rect), tempLayoutRect = C32.New(C32.Rect), tempColor = C32.New(C32.Color), glMatrix = self.glMatrix, vec3 = glMatrix.vec3, tempRender3dList = [], tempInstanceList1 = [], tempInstanceList2 = [], tempInstanceList3 = [];
  let lastLayerPreparedForDrawing = null;
  C32.Layout = class extends C32.DefendedBase {
    constructor(e, t, s) {
      super(), this._layoutManager = e, this._runtime = e.GetRuntime(), this._name = s[0], this._originalWidth = s[1], this._originalHeight = s[2], this._width = s[1], this._height = s[2], this._isUnboundedScrolling = !!s[3], this._isOrthographicProjection = !!s[4], this._vanishingPointX = s[5], this._vanishingPointY = s[6], this._eventSheetName = s[7], this._eventSheet = null, this._sid = s[8], this._index = t, this._scrollX = 0, this._scrollY = 0, this._scale = 1, this._angle = 0, this._initialObjectClasses = /* @__PURE__ */ new Set(), this._textureLoadedTypes = /* @__PURE__ */ new Set(), this._textureLoadPendingPromises = /* @__PURE__ */ new Set(), this._createdInstances = [], this._createdPersistedInstances = [], this._createdPersistedInstancesToDataMap = /* @__PURE__ */ new Map(), this._createdPersistedIndexToInstanceMap = /* @__PURE__ */ new Map(), this._initialNonWorld = [], this._is3dCameraEnabled = false, this._cam3dposition = vec3.create(), this._cam3dlook = vec3.create(), this._cam3dup = vec3.create(), this._rootLayers = [], this._allLayersFlat = [], this._layersByName = /* @__PURE__ */ new Map(), this._layersBySid = /* @__PURE__ */ new Map(), this._pendingSetHTMLLayerCount = -1;
      const r = this._runtime.GetCanvasManager();
      this._effectList = C32.New(C32.EffectList, this, s[11]), this._effectChain = C32.New(C32.Gfx.EffectChain, r.GetEffectChainManager(), { drawContent: (e2, t2) => {
        const s2 = t2.GetContentObject().GetRenderTarget();
        e2.ResetColor(), e2.DrawRenderTarget(s2), e2.InvalidateRenderTarget(s2), r.ReleaseAdditionalRenderTarget(s2);
      }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasFullScreenQualityLow = false, this._curRenderTarget = null, this._persistData = {}, this._persistedIntances = /* @__PURE__ */ new Map(), this._isFirstVisit = true, this._iLayout = new self.ILayout(this), this._userScriptDispatcher = C32.New(C32.Event.Dispatcher);
      for (const e2 of s[9]) this._rootLayers.push(C32.Layer.CreateFromExportData(this, null, e2));
      this._ReindexLayers();
      for (const e2 of this.allLayers()) e2._InitInitialInstances();
      for (const e2 of s[10]) {
        const t2 = this._runtime.GetObjectClassByIndex(e2[1]);
        if (!t2) throw new Error("missing nonworld object class");
        t2.GetDefaultInstanceData() || t2.SetDefaultInstanceData(e2), this._initialNonWorld.push(e2), this._AddInitialObjectClass(t2);
      }
    }
    Release() {
      for (const e of this._allLayersFlat) e.Release();
      C32.clearArray(this._allLayersFlat), this._textureLoadPendingPromises.clear(), this._eventSheet = null, this._layoutManager = null, this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetIndex() {
      return this._index;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      return this._MaybeRebuildEffectChainSteps(), this._effectChain;
    }
    _MaybeRebuildEffectChainSteps() {
      const e = "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
      if (!this._needsRebuildEffectChainSteps && this._wasFullScreenQualityLow === e && !this._effectChain.NeedsRebuild()) return;
      const t = this.GetEffectList().GetActiveEffectTypes();
      this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePostDraw: e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasFullScreenQualityLow = e;
    }
    UpdateActiveEffects() {
      this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;
    }
    GetMinLayerScale() {
      let e = this._allLayersFlat[0].GetNormalScale();
      for (let t = 1, s = this._allLayersFlat.length; t < s; ++t) {
        const s2 = this._allLayersFlat[t];
        0 === s2.GetParallaxX() && 0 === s2.GetParallaxY() || (e = Math.min(e, s2.GetNormalScale()));
      }
      return e;
    }
    _GetScrollBoundMarginHorizontal() {
      return 0.5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale();
    }
    _GetScrollBoundMarginVertical() {
      return 0.5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale();
    }
    GetScrollLeftBound() {
      return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginHorizontal();
    }
    GetScrollRightBound() {
      return this.IsUnboundedScrolling() ? 1 / 0 : this.GetWidth() - this._GetScrollBoundMarginHorizontal();
    }
    GetScrollTopBound() {
      return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginVertical();
    }
    GetScrollBottomBound() {
      return this.IsUnboundedScrolling() ? 1 / 0 : this.GetHeight() - this._GetScrollBoundMarginVertical();
    }
    SetScrollX(e) {
      const t = this.GetScrollLeftBound(), s = this.GetScrollRightBound();
      e > s && (e = s), e < t && (e = t), this._scrollX !== e && (this._scrollX = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    GetScrollX() {
      return this._scrollX;
    }
    SetScrollY(e) {
      const t = this.GetScrollTopBound(), s = this.GetScrollBottomBound();
      e > s && (e = s), e < t && (e = t), this._scrollY !== e && (this._scrollY = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    GetScrollY() {
      return this._scrollY;
    }
    IsUnboundedScrolling() {
      return this._isUnboundedScrolling;
    }
    BoundScrolling() {
      this.SetScrollX(this.GetScrollX()), this.SetScrollY(this.GetScrollY());
      for (const e of this._allLayersFlat) e.IsOwnScrollPositionEnabled() && (e.SetScrollX(e.GetScrollX()), e.SetScrollY(e.GetScrollY()));
    }
    SetVanishingPointXY(e, t) {
      this._vanishingPointX === e && this._vanishingPointY === t || (this._vanishingPointX = e, this._vanishingPointY = t, this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender()));
    }
    GetVanishingPointX() {
      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointX;
    }
    GetVanishingPointY() {
      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointY;
    }
    GetVanishingPoint() {
      return [this.GetVanishingPointX(), this.GetVanishingPointY()];
    }
    HasVanishingPointOutsideViewport() {
      const e = this.GetVanishingPointX(), t = this.GetVanishingPointY();
      return e < 0 || e > 1 || t < 0 || t > 1;
    }
    SetPerspectiveProjection() {
      this._isOrthographicProjection && (this._isOrthographicProjection = false, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    SetOrthographicProjection() {
      this._isOrthographicProjection || (this._isOrthographicProjection = true, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    IsOrthographicProjection() {
      return this._isOrthographicProjection;
    }
    IsPerspectiveProjection() {
      return !this.IsOrthographicProjection();
    }
    Set3DCameraEnabled(e) {
      e = !!e, this._is3dCameraEnabled !== e && (this._is3dCameraEnabled = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    Is3DCameraEnabled() {
      return this._is3dCameraEnabled;
    }
    Set3DCameraOrientation(e, t, s, r, a, n, i, o, l) {
      vec3EqualsXYZ(this._cam3dposition, e, t, s) && vec3EqualsXYZ(this._cam3dlook, r, a, n) && vec3EqualsXYZ(this._cam3dup, i, o, l) || (vec3.set(this._cam3dposition, e, t, s), vec3.set(this._cam3dlook, r, a, n), vec3.set(this._cam3dup, i, o, l), this.Set3DCameraChanged());
    }
    Set3DCameraChanged() {
      this._SetAllLayersMVChanged(), this._runtime.UpdateRender();
    }
    Get3DCameraPosition() {
      return this._cam3dposition;
    }
    Get3DCameraLookAt() {
      return this._cam3dlook;
    }
    Get3DCameraUpVector() {
      return this._cam3dup;
    }
    GetScale() {
      return this._scale;
    }
    SetScale(e) {
      this._scale !== e && (this._scale = e, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender());
    }
    SetAngle(e) {
      e = C32.clampAngle(e), this._angle !== e && (this._angle = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    GetAngle() {
      return this._angle;
    }
    GetWidth() {
      return this._width;
    }
    SetWidth(e) {
      !isFinite(e) || e < 1 || (this._width = e);
    }
    GetHeight() {
      return this._height;
    }
    SetHeight(e) {
      !isFinite(e) || e < 1 || (this._height = e);
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    _GetRootLayers() {
      return this._rootLayers;
    }
    *allLayers() {
      for (const e of this._rootLayers) yield* e.selfAndAllSubLayers();
    }
    GetLayers() {
      return this._allLayersFlat;
    }
    GetLayerCount() {
      return this._allLayersFlat.length;
    }
    GetLayer(e) {
      return "number" == typeof e ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString());
    }
    GetLayerByIndex(e) {
      return e = C32.clamp(Math.floor(e), 0, this._allLayersFlat.length - 1), this._allLayersFlat[e];
    }
    GetLayerByName(e) {
      return this._layersByName.get(e.toLowerCase()) || null;
    }
    HasLayerByName(e) {
      return !!this.GetLayerByName(e);
    }
    GetLayerBySID(e) {
      return this._layersBySid.get(e) || null;
    }
    _SetAllLayersProjectionChanged() {
      for (const e of this._allLayersFlat) e._SetProjectionMatrixChanged();
    }
    _SetAllLayersMVChanged() {
      for (const e of this._allLayersFlat) e._SetMVMatrixChanged();
    }
    AddLayer(e, t, s) {
      if (this.HasLayerByName(e)) throw new Error(`layer name '${e}' already in use`);
      if (!t && s < 2) throw new Error("invalid insert position");
      const r = s >= 2 ? t : t.GetParentLayer(), a = C32.New(C32.Layer, this, r, { name: e, sid: Math.floor(1e15 * Math.random()), isDynamic: true });
      this._InsertLayer(a, t, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
    }
    MoveLayer(e, t, s) {
      if (!t && s < 2) throw new Error("invalid insert position");
      e === t && s < 2 || (this._RemoveLayer(e), this._InsertLayer(e, t, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers());
    }
    RemoveLayer(e) {
      if (this._RemoveLayer(e)) {
        const t = this._runtime.GetEventSheetManager();
        t.BlockFlushingInstances(true), e.Release(), t.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
      }
    }
    RemoveAllDynamicLayers() {
      const e = /* @__PURE__ */ new Set();
      for (const t2 of this.allLayers()) t2.IsDynamic() && !t2.HasAnyDynamicParentLayer() && e.add(t2);
      if (0 === e.size) return;
      const t = this._runtime.GetEventSheetManager();
      t.BlockFlushingInstances(true);
      for (const t2 of e) this._RemoveLayer(t2), t2.Release();
      t.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
    }
    _InsertLayer(e, t, s) {
      if (s >= 2) if (t) {
        if (t === e || t.HasParentLayer(e)) throw new Error(`cannot move layer '${e.GetName()}' to sub-layer of itself`);
        t._AddSubLayer(e, 2 === s), e._SetParentLayer(t);
      } else 2 === s ? this._rootLayers.push(e) : this._rootLayers.unshift(e), e._SetParentLayer(null);
      else {
        const r = t.GetParentLayer();
        if (r) {
          if (t.HasParentLayer(e)) throw new Error(`cannot move layer '${e.GetName()}' to sub-layer of itself`);
          r._InsertSubLayer(e, t, 0 === s), e._SetParentLayer(r);
        } else {
          let r2 = this._rootLayers.indexOf(t);
          if (-1 === r2) throw new Error("cannot find layer to insert by");
          0 === s && ++r2, this._rootLayers.splice(r2, 0, e), e._SetParentLayer(null);
        }
      }
    }
    _RemoveLayer(e) {
      const t = e.GetParentLayer();
      if (t) return t._RemoveSubLayer(e), true;
      if (this._rootLayers.length > 1) {
        const t2 = this._rootLayers.indexOf(e);
        if (-1 === t2) throw new Error("cannot find layer to remove");
        return this._rootLayers.splice(t2, 1), true;
      }
      return false;
    }
    _ReindexLayers() {
      this._allLayersFlat = [...this.allLayers()], this._layersByName.clear(), this._layersBySid.clear();
      for (let e = 0, t = this._allLayersFlat.length; e < t; ++e) {
        const t2 = this._allLayersFlat[e];
        t2._SetIndex(e), this._layersByName.set(t2.GetName().toLowerCase(), t2), this._layersBySid.set(t2.GetSID(), t2);
      }
    }
    _ReindexHTMLLayers() {
      let e = 0;
      for (const t of this._rootLayers) {
        for (const s of t.selfAndAllSubLayers()) s._SetHTMLIndex(e);
        t.IsHTMLElementsLayer() && e++;
      }
    }
    GetHTMLLayerCount() {
      return this._rootLayers.at(-1).GetHTMLIndex() + 1;
    }
    async _ReindexAndUpdateAllLayers() {
      this._ReindexLayers(), this._ReindexHTMLLayers(), this._pendingSetHTMLLayerCount = this.GetHTMLLayerCount();
    }
    _GetPendingSetHTMLLayerCount() {
      return this._pendingSetHTMLLayerCount;
    }
    _ResetPendingHTMLLayerCount() {
      this._pendingSetHTMLLayerCount = -1;
    }
    GetRootLayersForHTMLLayer(e) {
      const t = [];
      for (const s of this._rootLayers) {
        const r = s.GetHTMLIndex();
        if (r === e) t.push(s);
        else if (r > e) break;
      }
      return t;
    }
    SaveTransform() {
      return { "scrollX": this.GetScrollX(), "scrollY": this.GetScrollY(), "scale": this.GetScale(), "angle": this.GetAngle(), "vpX": this.GetVanishingPointX(), "vpY": this.GetVanishingPointY() };
    }
    RestoreTransform(e) {
      this.SetScrollX(e["scrollX"]), this.SetScrollY(e["scrollY"]), this.SetScale(e["scale"]), this.SetAngle(e["angle"]), this.SetVanishingPointXY(e["vpX"], e["vpY"]);
    }
    GetLayoutBackgroundColor() {
      let e = this._rootLayers.filter((e2) => e2.ShouldDraw())[0];
      for (; e; ) {
        if (!e.IsTransparent()) return tempColor.copyRgb(e.GetBackgroundColor()), tempColor.setA(1), tempColor;
        if (e.UsesOwnTexture()) return tempColor.setRgba(0, 0, 0, 0), tempColor;
        e = e.GetSubLayers().filter((e2) => e2.ShouldDraw())[0];
      }
      return tempColor.setRgba(0, 0, 0, 0), tempColor;
    }
    IsFirstVisit() {
      return this._isFirstVisit;
    }
    _GetInitialObjectClasses() {
      return [...this._initialObjectClasses];
    }
    _AddInitialObjectClass(e) {
      if (e.IsInContainer()) for (const t of e.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(t);
      else this._initialObjectClasses.add(e);
    }
    _GetTextureLoadedObjectTypes() {
      return [...this._textureLoadedTypes];
    }
    _Load(e, t) {
      if (e === this || !t) return Promise.resolve();
      e && (C32.CopySet(this._textureLoadedTypes, e._textureLoadedTypes), e._textureLoadedTypes.clear());
      const s = [];
      for (const e2 of this._initialObjectClasses) this._textureLoadedTypes.has(e2) || (s.push(e2.LoadTextures(t)), this._textureLoadedTypes.add(e2));
      return Promise.all(s);
    }
    async MaybeLoadTexturesFor(e) {
      if (e.IsFamily()) throw new Error("cannot load textures for family");
      const t = this._runtime.GetRenderer();
      if (!t || t.IsContextLost() || this._textureLoadedTypes.has(e)) return;
      this._textureLoadedTypes.add(e);
      const s = e.LoadTextures(t);
      this._AddPendingTextureLoadPromise(s), await s, e.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender();
    }
    _AddPendingTextureLoadPromise(e) {
      this._textureLoadPendingPromises.add(e), e.then(() => this._textureLoadPendingPromises.delete(e)).catch(() => this._textureLoadPendingPromises.delete(e));
    }
    WaitForPendingTextureLoadsToComplete() {
      return Promise.all([...this._textureLoadPendingPromises]);
    }
    MaybeUnloadTexturesFor(e) {
      if (e.IsFamily() || e.GetInstanceCount() > 0) throw new Error("cannot unload textures");
      const t = this._runtime.GetRenderer();
      t && this._textureLoadedTypes.has(e) && (this._textureLoadedTypes.delete(e), e.ReleaseTextures(t));
    }
    _Unload(e, t) {
      if (e !== this && t) for (const t2 of this._textureLoadedTypes) t2.IsGlobal() || e._initialObjectClasses.has(t2) || (t2.ReleaseTextures(), this._textureLoadedTypes.delete(t2));
    }
    _OnRendererContextLost() {
      this._textureLoadedTypes.clear();
    }
    async _StartRunning(e) {
      const t = this._runtime, s = this._layoutManager, r = t.GetEventSheetManager();
      this._eventSheetName && (this._eventSheet = r.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes()), s._SetMainRunningLayout(this), this._width = this._originalWidth, this._height = this._originalHeight, this._scrollX = t.GetOriginalViewportWidth() / 2, this._scrollY = t.GetOriginalViewportHeight() / 2, this.BoundScrolling(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._ReindexHTMLLayers(), await this._runtime.GetCanvasManager().SetHTMLLayerCount(this.GetHTMLLayerCount(), true), this._MoveGlobalObjectsToThisLayout(e), this._runtime.SetUsingCreatePromises(true), this._CreateInitialInstances(), this._isFirstVisit || this._CreatePersistedInstances(), this._CreateAndLinkContainerInstances(this._createdInstances), this._CreateAndLinkContainerInstances(this._createdPersistedInstances), this._CreateInitialNonWorldInstances(), s.ClearPendingChangeLayout(), t.FlushPendingInstances(), this._runtime.SetUsingCreatePromises(false);
      const a = this._runtime.GetCreatePromises();
      if (await Promise.all(a), C32.clearArray(a), !t.IsLoadingState()) {
        for (const e2 of this._createdInstances) e2.SetupInitialSceneGraphConnections();
        for (const e2 of this._createdPersistedInstances) e2.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);
        for (const [e2, t2] of Object.entries(this._persistData)) {
          const s2 = this._runtime.GetObjectClassBySID(parseInt(e2, 10));
          s2 && !s2.IsFamily() && s2.HasPersistBehavior() && C32.clearArray(t2);
        }
        for (const e2 of this._createdInstances) e2._TriggerOnCreated();
        for (const e2 of this._createdPersistedInstances) e2._TriggerOnCreated();
        for (const e2 of this._createdInstances) e2.HasParent() || e2._OnHierarchyReady();
        for (const e2 of this._createdPersistedInstances) e2.HasParent() || e2._OnHierarchyReady();
      }
      C32.clearArray(this._createdInstances), C32.clearArray(this._createdPersistedInstances), this._createdPersistedInstancesToDataMap.clear(), this._createdPersistedIndexToInstanceMap.clear(), await Promise.all([...this._initialObjectClasses].map((e2) => e2.PreloadTexturesWithInstances(this._runtime.GetRenderer()))), e && (t.Dispatcher().dispatchEvent(new C32.Event("beforefirstlayoutstart")), await t.DispatchUserScriptEventAsyncWait(new C32.Event("beforeprojectstart"))), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event("beforeanylayoutstart")), t.Dispatcher().dispatchEvent(new C32.Event("beforelayoutstart")), await this.DispatchUserScriptEventAsyncWait(new C32.Event("beforelayoutstart")), t.IsLoadingState() || await t.TriggerAsync(C32.Plugins.System.Cnds.OnLayoutStart, null, null), t.Dispatcher().dispatchEvent(new C32.Event("afterlayoutstart")), await this.DispatchUserScriptEventAsyncWait(new C32.Event("afterlayoutstart")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event("afteranylayoutstart")), e && (t.Dispatcher().dispatchEvent(new C32.Event("afterfirstlayoutstart")), await t.DispatchUserScriptEventAsyncWait(new C32.Event("afterprojectstart"))), r._RunQueuedTriggers(s), await this.WaitForPendingTextureLoadsToComplete(), this._isFirstVisit = false;
    }
    _MoveGlobalObjectsToThisLayout(e) {
      for (const e2 of this._runtime.GetAllObjectClasses()) if (!e2.IsFamily() && e2.IsWorldType()) for (const t of e2.GetInstances()) {
        const e3 = t.GetWorldInfo(), s = e3.GetLayer(), r = s.GetName(), a = this.GetLayerByName(r);
        if (a) e3._SetLayer(a, true), a._MaybeAddInstance(t);
        else {
          const r2 = C32.clamp(s.GetIndex(), 0, this._allLayersFlat.length - 1), a2 = this._allLayersFlat[r2];
          e3._SetLayer(a2, true), a2._MaybeAddInstance(t);
        }
      }
      if (!e) for (const e2 of this._allLayersFlat) e2._SortInstancesByLastCachedZIndex(false);
    }
    _CreateInitialInstances() {
      for (const e of this._allLayersFlat) e.CreateInitialInstances(this._createdInstances), e._Start();
    }
    _CreatePersistedInstances() {
      let e = false;
      for (const [t, s] of Object.entries(this._persistData)) {
        const r = this._runtime.GetObjectClassBySID(parseInt(t, 10));
        if (r && !r.IsFamily() && r.HasPersistBehavior()) for (const t2 of s) {
          let s2 = null;
          if (r.IsWorldType() && (s2 = t2.hasOwnProperty("instJson") ? this.GetLayerBySID(t2["instJson"]["w"]["l"]) : this.GetLayerBySID(t2["w"]["l"]), !s2)) continue;
          const a = this._runtime.CreateInstanceFromData(r, s2, false, 0, 0, true);
          t2.hasOwnProperty("instJson") ? a.LoadFromJson(t2["instJson"]) : a.LoadFromJson(t2), e = true, this._createdPersistedInstances.push(a), t2.hasOwnProperty("instJson") && (this._createdPersistedInstancesToDataMap.set(a, t2), this._createdPersistedIndexToInstanceMap.set(t2["index"], a));
        }
      }
      for (const e2 of this._allLayersFlat) e2._SortInstancesByLastCachedZIndex(true), e2.SetZIndicesChanged();
      e && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap());
    }
    _CreateAndLinkContainerInstances(e) {
      for (const t of e) {
        if (!t.IsInContainer()) continue;
        const s = t.GetWorldInfo(), r = t.GetIID();
        for (const a of t.GetObjectClass().GetContainer().objectTypes()) {
          if (a === t.GetObjectClass()) continue;
          const n = a.GetInstances();
          if (n.length > r) t._AddSibling(n[r]);
          else {
            let r2;
            r2 = s ? this._runtime.CreateInstanceFromData(a, s.GetLayer(), true, s.GetX(), s.GetY(), true) : this._runtime.CreateInstanceFromData(a, null, true, 0, 0, true), this._runtime.FlushPendingInstances(), a._UpdateIIDs(), t._AddSibling(r2), e.push(r2);
          }
        }
      }
    }
    _CreateInitialNonWorldInstances() {
      for (const e of this._initialNonWorld) {
        this._runtime.GetObjectClassByIndex(e[1]).IsInContainer() || this._runtime.CreateInstanceFromData(e, null, true);
      }
    }
    _CreateGlobalNonWorlds() {
      const e = [], t = this._initialNonWorld;
      let s = 0;
      for (let r = 0, a = t.length; r < a; ++r) {
        const a2 = t[r], n = this._runtime.GetObjectClassByIndex(a2[1]);
        n.IsGlobal() ? n.IsInContainer() && n.GetContainer().HasAnyWorldType() || e.push(this._runtime.CreateInstanceFromData(a2, null, true)) : (t[s] = a2, ++s);
      }
      C32.truncateArray(t, s), this._runtime.FlushPendingInstances(), this._CreateAndLinkContainerInstances(e);
    }
    RecreateInitialObjects(e, t, s, r, a, n, i) {
      if (s) return s.RecreateInitialObjects(e, t, a, n, r, i);
      {
        const s2 = [];
        for (const o of this._allLayersFlat) s2.push(o.RecreateInitialObjects(e, t, a, n, r, i));
        return s2.flat();
      }
    }
    async _StopRunning() {
      const e = this._layoutManager;
      this._runtime.IsLoadingState() || (await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event("beforeanylayoutend")), await this.DispatchUserScriptEventAsyncWait(new C32.Event("beforelayoutend")), await this._runtime.TriggerAsync(C32.Plugins.System.Cnds.OnLayoutEnd, null, null), await this.DispatchUserScriptEventAsyncWait(new C32.Event("afterlayoutend")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event("afteranylayoutend"))), e.SetIsEndingLayout(true), this._runtime.GetEventSheetManager().ClearAllScheduledWaits(), this._isFirstVisit || this._SavePersistData();
      for (const e2 of this._allLayersFlat) e2._End();
      for (const e2 of this._runtime.GetAllObjectClasses()) if (!(e2.IsGlobal() || e2.IsWorldType() || e2.GetPlugin().IsSingleGlobal() || e2.IsFamily())) {
        for (const t of e2.GetInstances()) this._runtime.DestroyInstance(t);
        this._runtime.FlushPendingInstances();
      }
      e.SetIsEndingLayout(false), e.GetMainRunningLayout() === this && e._SetMainRunningLayout(null);
    }
    _SaveInstanceToPersist(e, t) {
      const s = e.GetObjectClass().GetSID().toString();
      this._persistData.hasOwnProperty(s) || (this._persistData[s] = []);
      const r = this._persistData[s], a = { "index": t, "instJson": e.SaveToJson(), "sceneGraphJson": { "children": [] } };
      r.push(a), this._persistedIntances.set(e, a);
    }
    _SaveSceneGraphInfoToPersist(e) {
      const t = this._persistedIntances.get(e);
      for (const s of e.GetChildren()) {
        const e2 = this._persistedIntances.get(s);
        e2 && t["sceneGraphJson"]["children"].push({ "index": e2["index"], "flags": C32.SceneGraphInfo._GetFlagsNumber(s.GetWorldInfo()) });
      }
    }
    _SavePersistData() {
      this._persistedIntances.clear();
      let e = 0;
      for (const t of this._allLayersFlat) {
        t._UpdateZIndices();
        for (const s of t._GetInstances()) {
          const t2 = s.GetObjectClass();
          !t2.IsGlobal() && t2.HasPersistBehavior() && (this._SaveInstanceToPersist(s, e), e++);
        }
      }
      for (const e2 of this._allLayersFlat) for (const t of e2._GetInstances()) {
        const e3 = t.GetObjectClass();
        !e3.IsGlobal() && e3.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(t);
      }
      this._persistedIntances.clear();
    }
    ResetPersistData() {
      this._persistData = {}, this._isFirstVisit = true;
    }
    GetRenderTarget() {
      return this._curRenderTarget;
    }
    UsesOwnTexture() {
      const e = this._runtime, t = e.GetRenderer().IsWebGL();
      return "low" === e.GetCanvasManager().GetCurrentFullscreenScalingQuality() || t && e.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect() || t && e.Uses3DFeatures();
    }
    _MaybeStartDrawToOwnTexture(e) {
      const t = this._runtime.GetCanvasManager();
      if (this.UsesOwnTexture()) {
        e.SetRenderTarget(null), e.ClearRgba(0, 0, 0, 0);
        const s = { sampling: this._runtime.GetSampling(), isSampled: e.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(), canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };
        "low" === t.GetCurrentFullscreenScalingQuality() && (s.width = t.GetDrawWidth(), s.height = t.GetDrawHeight()), this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(s);
      } else this._curRenderTarget = null;
    }
    _MaybeCopyOwnTextureToBackbuffer(e) {
      this._runtime._NeedsHTMLLayerCompositing(e) && (e.SetDepthEnabled(false), e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(this._curRenderTarget));
    }
    _MaybeEndDrawToOwnTexture(e) {
      this.UsesOwnTexture() && (e.SetDepthEnabled(false), this._DrawLayoutOwnTextureToRenderTarget(e, this._curRenderTarget));
    }
    DrawMain(e) {
      e.SetRenderTarget(this._curRenderTarget), e.Clear(this.GetLayoutBackgroundColor()), this._runtime.Uses3DFeatures() && e.ClearDepth();
      const t = this.GetRootLayersForHTMLLayer(0);
      this._DrawLayerList(e, this._curRenderTarget, t, true), e.IsWebGPU() && e.StartMeasuringRenderPassTime(0, 1), this._MaybeEndDrawToOwnTexture(e), this._curRenderTarget = null;
    }
    DrawForHTMLLayerIndex(e, t) {
      let s = null;
      this._runtime._NeedsHTMLLayerCompositing(e) && (s = this._curRenderTarget), e.SetRenderTarget(s), e.ClearRgba(0, 0, 0, 0), this._runtime.Uses3DFeatures() && e.ClearDepth();
      const r = this.GetRootLayersForHTMLLayer(t);
      this._DrawLayerList(e, s, r, true), this._MaybeCopyOwnTextureToBackbuffer(e), e.EndBatch(), this._runtime.GetCanvasManager().BlitMainCanvasToHTMLLayerCanvas(t);
    }
    _DrawLayerList(e, t, s, r) {
      const a = s.filter((e2) => e2.ShouldDraw());
      for (let s2 = 0, n = a.length; s2 < n; ) {
        const i = a[s2];
        if (i.SelfAndAllSubLayersHave3DCamera() && !i.SelfOrAnySubLayerUsesOwnTexture()) {
          tempRender3dList.push(i);
          for (let e2 = s2 + 1; e2 < n; ++e2) {
            const t2 = a[e2];
            if (!t2.SelfAndAllSubLayersHave3DCamera() || t2.SelfOrAnySubLayerUsesOwnTexture()) break;
            tempRender3dList.push(a[e2]);
          }
          if (tempRender3dList.length >= 2 || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {
            this._Draw3DLayers(e, t, tempRender3dList), s2 += tempRender3dList.length, C32.clearArray(tempRender3dList);
            continue;
          }
          C32.clearArray(tempRender3dList);
        }
        i.Draw(e, t, r && 0 === s2), ++s2;
      }
    }
    _DrawLayoutOwnTextureToRenderTarget(e, t) {
      const s = this._effectList.GetActiveEffectTypes(), r = this._runtime;
      0 === s.length ? (e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(t), e.InvalidateRenderTarget(t), r.ReleaseAdditionalRenderTarget(t)) : (tempLayoutRect.set(0, 0, r.GetViewportWidth(), r.GetViewportHeight()), this.GetEffectChain().Render(e, null, { contentObject: this, blendMode: 3, devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(), layerAngle: this.GetAngle(), layoutRect: tempLayoutRect, drawSurfaceRect: null, invalidateRenderTargets: true }));
    }
    _Draw3DLayers(e, t, s) {
      const r = s[0], a = r._MaybeStartWebGLProfiling(e);
      r._MaybeStartWebGPUProfiling(e), s[0].IsTransparent() || (tempColor.copyRgb(s[0].GetBackgroundColor()), tempColor.setA(1), e.Clear(tempColor)), e.SetDepthEnabled(true);
      const n = tempInstanceList1, i = tempInstanceList2, o = tempInstanceList3;
      for (const t2 of s) t2._UpdateZIndices(), t2._AppendAllInstancesIncludingSubLayersInDrawOrder(n), t2._FireDrawEvent(e, "beforedraw");
      for (let s2 = 0, r2 = n.length; s2 < r2; ) {
        const a2 = n[s2], l = a2.GetWorldInfo(), h = l.GetLayer();
        if (!l.IsVisible() || !l.IsInViewport3D(h._GetViewFrustum())) {
          ++s2;
          continue;
        }
        (!a2.RendersToOwnZPlane() || l.GetDepth() > 0) && o.push(a2);
        const c = a2.GetWorldInfo().GetTotalZElevation();
        i.push(a2);
        let d = s2 + 1;
        for (; d < r2; ++d) {
          const e2 = n[d], t2 = e2.GetWorldInfo();
          if (t2.IsVisible() && t2.IsInViewport3D(t2.GetLayer()._GetViewFrustum())) {
            if (t2.GetTotalZElevation() !== c) break;
            e2.RendersToOwnZPlane() ? (t2.GetDepth() > 0 && o.push(e2), i.push(e2)) : o.push(e2);
          }
        }
        if (1 !== i.length || i[0].MustMitigateZFighting()) {
          this._Draw3DLayersCoplanarInstances(e, t, i);
          for (let s3 = 0, r3 = o.length; s3 < r3; ++s3) {
            const r4 = o[s3], a3 = r4.GetWorldInfo(), n2 = a3.GetLayer();
            a3._SetDrawNonBackFacesOnly(true), MaybePrepareLayerDraw(n2, e), n2._DrawInstanceMaybeWithEffects(r4, a3, e, t), a3._SetDrawNonBackFacesOnly(false);
          }
        } else {
          MaybePrepareLayerDraw(h, e), h._DrawInstanceMaybeWithEffects(a2, l, e, t);
          for (let s3 = 0, r3 = o.length; s3 < r3; ++s3) {
            const r4 = o[s3];
            if (r4 === a2) continue;
            const n2 = r4.GetWorldInfo(), i2 = n2.GetLayer();
            MaybePrepareLayerDraw(i2, e), i2._DrawInstanceMaybeWithEffects(r4, n2, e, t);
          }
        }
        s2 = d, C32.clearArray(i), C32.clearArray(o);
      }
      for (const t2 of s) t2._FireDrawEvent(e, "afterdraw");
      a && e.EndQuery(a), C32.clearArray(n), lastLayerPreparedForDrawing = null;
    }
    _Draw3DLayersCoplanarInstances(e, t, s) {
      e.CoplanarStartStencilPass();
      for (let t2 = 0, r = s.length; t2 < r; ++t2) {
        const r2 = s[t2], a = r2.GetWorldInfo(), n = a.GetLayer();
        a._SetDrawBackFaceOnly(true), MaybePrepareLayerDraw(n, e), n._DrawInstance(r2, a, e);
      }
      e.CoplanarStartColorPass();
      for (let r = 0, a = s.length; r < a; ++r) {
        const a2 = s[r], n = a2.GetWorldInfo(), i = n.GetLayer();
        MaybePrepareLayerDraw(i, e), i._DrawInstanceMaybeWithEffects(a2, n, e, t), n._SetDrawBackFaceOnly(false);
      }
      e.CoplanarRestoreStandardRendering();
    }
    _SaveToJson() {
      const e = { "sx": this.GetScrollX(), "sy": this.GetScrollY(), "s": this.GetScale(), "a": this.GetAngle(), "w": this.GetWidth(), "h": this.GetHeight(), "ortho": this.IsOrthographicProjection(), "vpX": this.GetVanishingPointX(), "vpY": this.GetVanishingPointY(), "fv": this._isFirstVisit, "persist": this._persistData, "fx": this._effectList.SaveToJson(), "layers": {}, "dynamicLayers": [] };
      for (const t of this._allLayersFlat) if (t.IsDynamic()) {
        const s = t.GetParentLayer();
        e["dynamicLayers"].push({ "sid": t.GetSID(), "name": t.GetName(), "parentSid": s ? s.GetSID() : null, "siblingIndex": t._GetSiblingIndex(), "data": t._SaveToJson() });
      } else e["layers"][t.GetSID().toString()] = t._SaveToJson();
      return e;
    }
    _LoadFromJson(e) {
      this._scrollX = e["sx"], this._scrollY = e["sy"], this._scale = e["s"], this._angle = e["a"], this._width = e["w"], this._height = e["h"], this._isOrthographicProjection = !!e["ortho"], e.hasOwnProperty("vpX") && (this._vanishingPointX = e["vpX"]), e.hasOwnProperty("vpY") && (this._vanishingPointY = e["vpY"]), this._isFirstVisit = !!e["fv"], this._persistData = e["persist"], this._effectList.LoadFromJson(e["fx"]), this._needsRebuildEffectChainSteps = true;
      for (const [t, s] of Object.entries(e["layers"])) {
        const e2 = parseInt(t, 10), r = this.GetLayerBySID(e2);
        r && r._LoadFromJson(s);
      }
      if (e.hasOwnProperty("dynamicLayers")) {
        this.RemoveAllDynamicLayers(), this._runtime.FlushPendingInstances();
        const t = /* @__PURE__ */ new Map(), s = e["dynamicLayers"];
        for (let e2 = s.length - 1; e2 >= 0; --e2) {
          const r = s[e2], a = r["sid"], n = r["name"], i = r["parentSid"], o = r["siblingIndex"], l = r["data"];
          if (this._ReindexLayers(), this.HasLayerByName(n) || this.GetLayerBySID(a)) continue;
          let h, c;
          if (null === i) h = null, c = this._rootLayers;
          else {
            if (h = this.GetLayerBySID(i), !h) continue;
            c = h.GetSubLayers();
          }
          const d = C32.New(C32.Layer, this, h, { name: n, sid: a, isDynamic: true });
          c.push(d);
          let _ = t.get(c);
          _ || (_ = [], t.set(c, _)), _.push({ layer: d, siblingIndex: o }), d._LoadFromJson(l);
        }
        for (const [e2, s2] of t) {
          s2.sort((e3, t2) => e3.siblingIndex - t2.siblingIndex);
          for (const t2 of s2) {
            const s3 = t2.layer, r = t2.siblingIndex;
            let a = e2.indexOf(s3);
            e2.splice(a, 1), e2.splice(r, 0, s3);
          }
        }
      }
      this._ReindexAndUpdateAllLayers(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged();
    }
    GetILayout() {
      return this._iLayout;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    DispatchUserScriptEvent(e) {
      e.layout = this.GetILayout();
      const t = this._runtime, s = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine();
      s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), s && C3Debugger.AddScriptTime();
    }
    DispatchUserScriptEventAsyncWait(e) {
      return e.layout = this.GetILayout(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);
    }
    DispatchRuntimeUserScriptEventAsyncWait(e) {
      return e.layout = this.GetILayout(), this._runtime.DispatchUserScriptEventAsyncWait(e);
    }
    _LogLayerTree() {
      this._LogLayerList(this._rootLayers);
    }
    _LogLayerList(e, t = 0) {
      const s = e.slice(0);
      s.reverse();
      for (const e2 of s) console.log(`${"	".repeat(t)}- ${e2.GetName()}`), this._LogLayerList(e2.GetSubLayers(), t + 1);
    }
  };
}
var vec3EqualsXYZ2;
var MaybePrepareLayerDraw2;
{
  const C32 = self.C3;
  C32.LayoutManager = class extends C32.DefendedBase {
    #t;
    #n = [];
    #u = /* @__PURE__ */ new Map();
    #a = /* @__PURE__ */ new Map();
    #i = null;
    #e = [];
    #s = null;
    #o = 0;
    #y = null;
    constructor(t) {
      super(), this.#t = t;
    }
    Release() {
      this.#t = null, this.#i = null, this.#s = null, this.#y = null, C32.clearArray(this.#n), this.#u.clear(), this.#a.clear(), C32.clearArray(this.#e);
    }
    Create(t) {
      const n = C32.New(C32.Layout, this, this.#n.length, t);
      this.#n.push(n), this.#u.set(n.GetName().toLowerCase(), n), this.#a.set(n.GetSID(), n);
    }
    GetRuntime() {
      return this.#t;
    }
    SetFirstLayout(t) {
      this.#s = t;
    }
    GetFirstLayout() {
      if (this.#s) return this.#s;
      if (this.#n.length) return this.#n[0];
      throw new Error("no first layout");
    }
    GetLayoutByName(t) {
      return this.#u.get(t.toLowerCase()) || null;
    }
    GetLayoutBySID(t) {
      return this.#a.get(t) || null;
    }
    GetLayoutByIndex(t) {
      return t = C32.clamp(Math.floor(t), 0, this.#n.length - 1), this.#n[t];
    }
    GetLayout(t) {
      return "number" == typeof t ? this.GetLayoutByIndex(t) : this.GetLayoutByName(t.toString());
    }
    GetAllLayouts() {
      return this.#n;
    }
    _SetMainRunningLayout(t) {
      this.#i = t;
    }
    GetMainRunningLayout() {
      return this.#i;
    }
    _AddRunningSubLayout(t) {
      if (this.#e.includes(t)) throw new Error("layout already running");
      this.#e.push(t);
    }
    _RemoveRunningSubLayout(t) {
      const n = this.#e.indexOf(t);
      if (-1 === n) throw new Error("layout not running");
      this.#e.splice(n, 1);
    }
    *runningLayouts() {
      this.#i && (yield this.#i), this.#e.length && (yield* this.#e);
    }
    IsLayoutRunning(t) {
      return this.#i === t || this.#e.includes(t);
    }
    SetIsEndingLayout(t) {
      if (t) this.#o++;
      else {
        if (this.#o <= 0) throw new Error("already unset");
        this.#o--;
      }
    }
    IsEndingLayout() {
      return this.#o > 0;
    }
    ChangeMainLayout(t) {
      this.#y = t;
    }
    ClearPendingChangeLayout() {
      this.#y = null;
    }
    IsPendingChangeMainLayout() {
      return !!this.#y;
    }
    GetPendingChangeMainLayout() {
      return this.#y;
    }
    SetAllLayerProjectionChanged() {
      const t = this.GetMainRunningLayout();
      t && t._SetAllLayersProjectionChanged();
    }
    SetAllLayerMVChanged() {
      const t = this.GetMainRunningLayout();
      t && t._SetAllLayersMVChanged();
    }
  };
}
{
  const C32 = self.C3, NAMES_REGEXP = new RegExp("<(.+?)>", "g");
  C32.TimelineManager = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e, this._timelineDataManager = C32.New(C32.TimelineDataManager), this._pluginInstance = null, this._timelines = [], this._timelinesByName = /* @__PURE__ */ new Map(), this._objectClassToTimelineMap = /* @__PURE__ */ new Map(), this._timelinesCreatedByTemplate = /* @__PURE__ */ new Map(), this._scheduledTimelines = [], this._playingTimelines = [], this._markedForRemovalTimelines = [], this._hasRuntimeListeners = false, this._changingLayout = false, this._isTickingTimelines = false, this._tickFunc = () => this._OnTick(), this._tick2Func = () => this._OnTick2(), this._beforeLayoutChange = () => this._OnBeforeChangeLayout(), this._layoutChange = () => this._OnAfterChangeLayout(), this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance), this._beforeLoad = (e2) => this._OnBeforeLoad(), this._afterLoad = (e2) => this._OnAfterLoad(), this._afterLayoutStart = (e2) => this._OnAfterLayoutStart(), this._destroyedWhileLoadingState = [], this._renderChange = 0;
    }
    Release() {
      this.RemoveRuntimeListeners(), this._tickFunc = null, this._tick2Func = null, this._beforeLayoutChange = null, this._layoutChange = null, this._instanceDestroy = null, this._afterLoad = null;
      for (const e of this._timelines) e.Stop(), e.Release();
      C32.clearArray(this._timelines), this._timelines = null, this._timelineDataManager.Release(), this._timelineDataManager = null, C32.clearArray(this._scheduledTimelines), this._scheduledTimelines = null, C32.clearArray(this._playingTimelines), this._playingTimelines = null, C32.clearArray(this._markedForRemovalTimelines), this._markedForRemovalTimelines = null, this._timelinesByName.clear(), this._timelinesByName = null, this._objectClassToTimelineMap.clear(), this._objectClassToTimelineMap = null, this._timelinesCreatedByTemplate.clear(), this._timelinesCreatedByTemplate = null, C32.clearArray(this._destroyedWhileLoadingState), this._destroyedWhileLoadingState = null, this._runtime = null;
    }
    AddRuntimeListeners() {
      const e = this._runtime.Dispatcher();
      e.addEventListener("pretick", this._tickFunc), e.addEventListener("tick2", this._tick2Func), e.addEventListener("beforelayoutchange", this._beforeLayoutChange), e.addEventListener("layoutchange", this._layoutChange), e.addEventListener("instancedestroy", this._instanceDestroy), e.addEventListener("beforeload", this._beforeLoad), e.addEventListener("afterload", this._afterLoad), e.addEventListener("afterlayoutstart", this._afterLayoutStart);
    }
    RemoveRuntimeListeners() {
      const e = this._runtime.Dispatcher();
      e.removeEventListener("pretick", this._tickFunc), e.removeEventListener("tick2", this._tick2Func), e.removeEventListener("beforelayoutchange", this._beforeLayoutChange), e.removeEventListener("layoutchange", this._layoutChange), e.removeEventListener("instancedestroy", this._instanceDestroy), e.removeEventListener("beforeload", this._beforeLoad), e.removeEventListener("afterload", this._afterLoad), e.removeEventListener("afterlayoutstart", this._afterLayoutStart);
    }
    Create(e) {
      this._timelineDataManager.Add(e);
      const i = C32.TimelineState.CreateInitial(e, this);
      this.Add(i), this.SetTimelineObjectClassesToMap(i), this._timelinesCreatedByTemplate.set(i.GetName(), 0);
    }
    CreateFromTemplate(e) {
      const i = this.GetTimelineDataManager(), t = e.GetTemplateName(), s = i.Get(t), n = C32.TimelineState.CreateFromTemplate(`${t}:${this._timelinesCreatedByTemplate.get(t)}`, s, this);
      return this._IncreaseTemplateTimelinesCount(t), this.Add(n), this._runtime.IsDebug() && globalThis.C3Debugger.TimelineCreated(n), n;
    }
    GetCreatedTemplateTimelinesCount(e) {
      return this._timelinesCreatedByTemplate.get(e);
    }
    _IncreaseTemplateTimelinesCount(e) {
      this._timelinesCreatedByTemplate.set(e, this._timelinesCreatedByTemplate.get(e) + 1);
    }
    _SetCreatedTemplateTimelinesCount() {
      for (const e of this._timelines) {
        if (e.IsTemplate()) continue;
        const i = e.GetTemplateName();
        this._IncreaseTemplateTimelinesCount(i);
      }
    }
    _ClearCreatedTemplateTimelinesCount() {
      for (const e of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(e, 0);
    }
    Add(e) {
      this._timelines.push(e), this._timelinesByName.set(e.GetName().toLowerCase(), e);
    }
    Remove(e) {
      e.Removed(), e.IsTemplate() || (C32.arrayFindRemove(this._timelines, e), C32.arrayFindRemove(this._scheduledTimelines, e), C32.arrayFindRemove(this._playingTimelines, e), C32.arrayFindRemove(this._markedForRemovalTimelines, e), this._timelinesByName.delete(e.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(e), this._runtime.IsDebug() && globalThis.C3Debugger.TimelineDestroyed(e), e.IsReleased() || e.Release());
    }
    Trigger(e) {
      this._runtime.Trigger(e, this._pluginInstance, null);
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTimelineDataManager() {
      return this._timelineDataManager;
    }
    SetPluginInstance(e) {
      this._pluginInstance = e;
    }
    GetPluginInstance() {
      return this._pluginInstance;
    }
    *GetTimelines() {
      for (const e of this._timelines) yield e;
    }
    *GetPlayingTimelines() {
      for (const e of this._playingTimelines) yield e;
    }
    SetTimelineObjectClassToMap(e, i) {
      this._objectClassToTimelineMap.has(e) || this._objectClassToTimelineMap.set(e, /* @__PURE__ */ new Set()), this._objectClassToTimelineMap.get(e).add(i);
    }
    SetTimelineObjectClassesToMap(e) {
      for (const i of e.GetObjectClasses()) this.SetTimelineObjectClassToMap(i, e);
    }
    RemoveTimelineFromObjectClassMap(e) {
      for (const [i, t] of this._objectClassToTimelineMap.entries()) t.has(e) && (t.delete(e), 0 === t.size && this._objectClassToTimelineMap.delete(i));
    }
    GetTimelinesForObjectClass(e) {
      if (this._objectClassToTimelineMap.has(e)) return this._objectClassToTimelineMap.get(e);
    }
    GetTimelineOfTemplateForInstances(e, i) {
      if (i) for (const t of this._timelines) {
        if (i.every((e2) => t.HasTrackInstance(e2.instance, e2.trackId)) && t.GetName().includes(e.GetName())) return t;
      }
    }
    GetTimelineByName(e) {
      return this._timelinesByName.get(e.toLowerCase()) || null;
    }
    GetScheduledOrPlayingTimelineByName(e) {
      for (const i of this._scheduledTimelines) if (i.GetName() === e) return i;
      for (const i of this._playingTimelines) if (i.GetName() === e) return i;
      return null;
    }
    *GetTimelinesByName(e) {
      if (NAMES_REGEXP.test(e)) {
        let i;
        NAMES_REGEXP.lastIndex = 0;
        const t = /* @__PURE__ */ new Set();
        do {
          if (i = NAMES_REGEXP.exec(e), i) {
            const e2 = i[1].split(",");
            for (const i2 of e2) t.add(i2);
          }
        } while (i);
        for (const e2 of t.values()) {
          const i2 = this.GetTimelineByName(e2);
          i2 && (yield i2);
        }
        t.clear();
      } else {
        const i = this.GetTimelineByName(e);
        i && (yield i);
      }
    }
    *GetTimelinesByTags(e) {
      for (const i of this._timelines) i.HasTags(e) && (yield i);
    }
    AddScheduledTimeline(e) {
      this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e), this._MaybeEnableRuntimeListeners();
    }
    RemovePlayingTimeline(e) {
      C32.arrayFindRemove(this._playingTimelines, e), this._MaybeDisableRuntimeListeners();
    }
    ScheduleTimeline(e) {
      this._playingTimelines.includes(e) ? (e.SetPlaying(true), e.SetScheduled(false), e.SetMarkedForRemoval(false)) : (e.SetPlaying(false), e.SetScheduled(true), e.SetMarkedForRemoval(false), this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e)), this._MaybeEnableRuntimeListeners();
    }
    DeScheduleTimeline(e) {
      e.SetPlaying(false), e.SetScheduled(false), e.ResolvePlayPromise(), C32.arrayFindRemove(this._scheduledTimelines, e), this._MaybeDisableRuntimeListeners();
    }
    CompleteTimeline(e) {
      e.SetPlaying(false), e.SetScheduled(false), this._playingTimelines.includes(e) && (e.SetMarkedForRemoval(true), this._markedForRemovalTimelines.push(e), C32.arrayFindRemove(this._playingTimelines, e)), this._scheduledTimelines.includes(e) && e.SetMarkedForRemoval(true);
    }
    CompleteTimelineBeforeChangeOfLayout(e) {
      e.SetPlaying(false), e.SetScheduled(false), e.SetMarkedForRemoval(false), e.SetPlaybackRate(1), C32.arrayFindRemove(this._playingTimelines, e);
    }
    CompleteTimelineAndResolve(e) {
      this.CompleteTimeline(e), e.ResolvePlayPromise();
    }
    _OnTick() {
      const e = this.GetRuntime();
      if (e.IsLoadingState()) return;
      if (!this._hasRuntimeListeners) return;
      if (this._changingLayout) return;
      let i = 0;
      for (e.IsDebug() && (i = performance.now()), this._isTickingTimelines = true; this._scheduledTimelines.length; ) {
        const e2 = this._scheduledTimelines.pop();
        e2.IsMarkedForRemoval() ? (e2.SetInitialStateForce(), this._markedForRemovalTimelines.push(e2)) : (e2.SetInitialState(), this._playingTimelines.push(e2)), 0 !== e2.GetRenderChange() && (this._renderChange = 1);
      }
      const t = this._runtime._GetDtFast(), s = this._runtime.GetDt1(), n = this._runtime.GetTimeScale();
      for (let e2 = this._playingTimelines.length - 1; e2 >= 0; e2--) {
        const i2 = this._playingTimelines[e2];
        i2 && i2.Tick(t, n, s);
      }
      this._isTickingTimelines = false, e.IsDebug() && globalThis.C3Debugger.AddTweensAndTimelinesTime(performance.now() - i), 0 !== this._renderChange && e.UpdateRender();
    }
    _OnTick2() {
      const e = this.GetRuntime();
      if (e.IsLoadingState()) return;
      if (!this._hasRuntimeListeners) return;
      if (this._changingLayout) return;
      let i, t = 0;
      e.IsDebug() && (t = performance.now());
      for (let e2 = 0, t2 = this._markedForRemovalTimelines.length; e2 < t2; e2++) {
        const t3 = this._markedForRemovalTimelines[e2];
        i || (i = /* @__PURE__ */ new Set()), t3.Removed(), this._MaybeExecuteTimelineFinishTriggers(t3), i.add(t3);
      }
      if (i) {
        C32.arrayRemoveAllInSet(this._markedForRemovalTimelines, i), this._renderChange = 0;
        for (let e2 = 0, i2 = this._playingTimelines.length; e2 < i2; e2++) if (0 !== this._playingTimelines[e2].GetRenderChange()) {
          this._renderChange = 1;
          break;
        }
      }
      this._MaybeDisableRuntimeListeners(), e.IsDebug() && globalThis.C3Debugger.AddTweensAndTimelinesTime(performance.now() - t);
    }
    _MaybeExecuteTimelineFinishTriggers(e) {
      e.IsReleased() || e.HasValidTracks() && e.IsComplete() && e.InitialStateSet() && e.FinishTriggers();
    }
    _MaybeEnableRuntimeListeners() {
      this._hasRuntimeListeners || (this._hasRuntimeListeners = true);
    }
    _MaybeDisableRuntimeListeners() {
      this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = false);
    }
    _OnBeforeChangeLayout() {
      for (this._changingLayout = true; this._scheduledTimelines.length; ) this.DeScheduleTimeline(this._scheduledTimelines.pop());
      const e = /* @__PURE__ */ new Set();
      for (const i of this._playingTimelines) {
        i._OnBeforeChangeLayout() && (i.Removed(), e.add(i));
      }
      C32.arrayRemoveAllInSet(this._playingTimelines, e), e.clear();
      for (const i of this._markedForRemovalTimelines) {
        i._OnBeforeChangeLayout() && (i.Removed(), e.add(i));
      }
      C32.arrayRemoveAllInSet(this._markedForRemovalTimelines, e), this._MaybeDisableRuntimeListeners();
      for (const e2 of this._timelines) e2.CleanCaches();
    }
    _OnAfterChangeLayout() {
      this._changingLayout = false;
    }
    _OnInstanceDestroy(e) {
      const i = e.GetObjectClass(), t = this.GetTimelinesForObjectClass(i);
      if (t) if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(e);
      else for (const e2 of t) e2.IsTemplate() || (e2.IsReleased() ? this.Remove(e2) : e2.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(e2), this.Remove(e2)));
    }
    _OnBeforeLoad() {
      for (const e of this._scheduledTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);
      for (const e of this._playingTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);
    }
    _OnAfterLoad() {
      for (const e of this._destroyedWhileLoadingState) this._OnInstanceDestroy(e);
      C32.clearArray(this._destroyedWhileLoadingState);
      for (const e of this._timelines) e._OnAfterLoad();
    }
    _OnAfterLayoutStart() {
      const e = this._runtime.GetLayoutManager().GetMainRunningLayout();
      if (e) for (const i of this._timelines) {
        const t = i.GetStartOnLayout();
        t && (e.GetName() === t && this.ScheduleTimeline(i));
      }
    }
    _SaveToJson() {
      return { "timelinesJson": this._SaveTimelinesToJson(), "scheduledTimelinesJson": this._SaveScheduledTimelinesToJson(), "playingTimelinesJson": this._SavePlayingTimelinesToJson(), "markedForRemovalTimelinesJson": this._SaveMarkedForRemovalTimelinesToJson(), "hasRuntimeListeners": this._hasRuntimeListeners, "changingLayout": this._changingLayout, "isTickingTimelines": this._isTickingTimelines };
    }
    _LoadFromJson(e) {
      e && (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(e["timelinesJson"]), this._LoadScheduledTimelinesFromJson(e["scheduledTimelinesJson"]), this._LoadPlayingTimelinesFromJson(e["playingTimelinesJson"]), this._LoadMarkedForRemovalTimelinesFromJson(e["markedForRemovalTimelinesJson"]), this._hasRuntimeListeners = !e["hasRuntimeListeners"], this._changingLayout = !!e["changingLayout"], this._isTickingTimelines = !!e["isTickingTimelines"], this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners());
    }
    _SaveTimelinesToJson() {
      return this._timelines.map((e) => e._SaveToJson());
    }
    _LoadTimelinesFromJson(e) {
      for (const i of e) {
        let e2 = this.GetTimelineByName(i["name"]);
        if (e2) e2._LoadFromJson(i);
        else {
          const t = this._GetTemplateNameFromJson(i);
          if (!t) continue;
          const s = this.GetTimelineByName(t);
          e2 = this.CreateFromTemplate(s), e2._LoadFromJson(i);
        }
        e2.HasTracks() || this.Remove(e2);
      }
    }
    _GetTemplateNameFromJson(e) {
      const i = e["name"].split(":");
      return i && 2 === i.length ? i[0] : null;
    }
    _SaveScheduledTimelinesToJson() {
      return this._SaveTimelines(this._scheduledTimelines);
    }
    _LoadScheduledTimelinesFromJson(e) {
      this._LoadTimelines(e, this._scheduledTimelines);
    }
    _SavePlayingTimelinesToJson() {
      return this._SaveTimelines(this._playingTimelines);
    }
    _LoadPlayingTimelinesFromJson(e) {
      this._LoadTimelines(e, this._playingTimelines);
    }
    _SaveMarkedForRemovalTimelinesToJson() {
      return this._SaveTimelines(this._markedForRemovalTimelines);
    }
    _LoadMarkedForRemovalTimelinesFromJson(e) {
      this._LoadTimelines(e, this._markedForRemovalTimelines);
    }
    _IsTimelineInJson(e, i) {
      if (!i) return false;
      for (const t of i) if (t === e.GetName()) return true;
      return false;
    }
    _SaveTimelines(e) {
      return e.map((e2) => e2.GetName());
    }
    _LoadTimelines(e, i) {
      const t = /* @__PURE__ */ new Set();
      for (const s of i) this._IsTimelineInJson(s, e) || t.add(s);
      if (C32.arrayRemoveAllInSet(i, t), e) {
        const t2 = (e2) => (i2) => i2.GetName() === e2;
        for (const s of e) {
          const e2 = this.GetTimelineByName(s);
          if (e2) {
            i.find(t2(s)) || i.push(e2);
          }
        }
      }
    }
  };
}
{
  const C32 = self.C3, STEPS = 100, LENGTH_STEP_SIZE = 0.01, BEZIER_STEP_SIZE = 25, REFINE_ITERATIONS = 20, LOOKUP_STEPS_FROM_LAST = 5, TANGENT_RESULT = [0, 0], MAP_RESULT = [0, 0], SHORT_PROJECTION_RESULT = [0, 0], PROJECTION_RESULT = [0, 0, 0, 0, 0], REFINE_LUT = new Array(4), REFINE_LUT_OBJECTS = [{ x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }], REFINE_RESULT = { x: 0, y: 0, t: 0, distance: 0 };
  C32.TimelineInfo = class {
    constructor(t, i) {
      this._initialized = false, this._timeline = t, this._segments = [];
      let e = null;
      if (e = i ? this._timeline.GetTrackById(i) : C32.first(this._timeline.GetTracks()), !e) return;
      const s = e.GetPropertyTrack("offsetX"), _ = e.GetPropertyTrack("offsetY");
      if (!s || !_) return;
      this._xTrack = s, this._yTrack = _;
      const h = s.GetPropertyKeyframeDataItemArrayIncludingDisabled(), n = _.GetPropertyKeyframeDataItemArrayIncludingDisabled();
      for (let t2 = 1, i2 = Math.min(h.length, n.length); t2 < i2; ++t2) {
        const i3 = h[t2], e2 = (i3.GetNext(), i3.GetPrevious()), s2 = n[t2], _2 = (s2.GetNext(), s2.GetPrevious());
        e2 && "cubic-bezier" === e2.GetPathMode() && _2 && "cubic-bezier" === _2.GetPathMode() ? this._segments.push(C32.New(C32.TimelineCubicBezierSegmentInfo, e2, _2, i3, s2, this._segments.length)) : (e2 && "line" === e2.GetPathMode() && _2 && _2.GetPathMode(), this._segments.push(C32.New(C32.TimelineLineSegmentInfo, i3, s2, this._segments.length)));
      }
      this._initialized = true;
    }
    Release() {
      for (const t of this._segments) t.Release();
      C32.clearArray(this._segments), this._segments = null, this._timeline = null, this._xTrack = null, this._yTrack = null;
    }
    WasInitialized() {
      return this._initialized;
    }
    segments() {
      return this._segments;
    }
    SetOrigin(t) {
      const i = "relative" === this._xTrack.GetResultMode() ? t.GetX() : 0, e = "relative" === this._yTrack.GetResultMode() ? t.GetY() : 0;
      for (const t2 of this._segments) t2.SetOrigin(i, e);
    }
    Project(t, i, e) {
      let s = NaN, _ = this._segments.length;
      for (let e2 = 0; e2 < _; e2++) {
        const _2 = this._segments[e2];
        if ("cubic-bezier" === _2.GetType()) {
          const e3 = _2.Project(t, i);
          (isNaN(s) || e3[3] < s) && (s = e3[3], SHORT_PROJECTION_RESULT[0] = e3[2], SHORT_PROJECTION_RESULT[1] = _2.GetIndex());
        }
      }
      return SHORT_PROJECTION_RESULT;
    }
    ProjectWithOptions(t, i, e) {
      const s = e.tRange;
      C32.IsFiniteNumber(s[0]) || (s[0] = 0), C32.IsFiniteNumber(s[1]) || (s[1] = 1);
      let _ = NaN, h = this._segments.length;
      for (let e2 = 0; e2 < h; e2++) {
        const h2 = this._segments[e2];
        if ("cubic-bezier" === h2.GetType()) {
          const e3 = h2.ProjectWithRange(t, i, s);
          (isNaN(_) || e3[3] < _) && (_ = e3[3], SHORT_PROJECTION_RESULT[0] = e3[2], SHORT_PROJECTION_RESULT[1] = h2.GetIndex());
        }
      }
      return SHORT_PROJECTION_RESULT;
    }
    Tangent(t, i) {
      return this._segments[i].Tangent(t);
    }
    TangentAngle(t, i) {
      return this._segments[i].TangentAngle(t);
    }
  }, C32.TimelineCubicBezierSegmentInfo = class {
    constructor(t, i, e, s, _) {
      this._index = _;
      const h = t.GetAddOn("cubic-bezier"), n = e.GetAddOn("cubic-bezier"), r = i.GetAddOn("cubic-bezier"), a = s.GetAddOn("cubic-bezier");
      this._aX = t.GetValueWithResultMode(), this._aY = i.GetValueWithResultMode(), this._bX = t.GetValueWithResultMode() + h.GetStartAnchor(), this._bY = i.GetValueWithResultMode() + r.GetStartAnchor(), this._cX = e.GetValueWithResultMode() + n.GetEndAnchor(), this._cY = s.GetValueWithResultMode() + a.GetEndAnchor(), this._dX = e.GetValueWithResultMode(), this._dY = s.GetValueWithResultMode(), this._aXO = 0, this._aYO = 0, this._bXO = 0, this._bYO = 0, this._cXO = 0, this._cYO = 0, this._dXO = 0, this._dYO = 0, this._d0x = 0, this._d0y = 0, this._d1x = 0, this._d1y = 0, this._d2x = 0, this._d2y = 0, this._x1Factor = 0, this._x2Factor = 0, this._x3Factor = 0, this._y1Factor = 0, this._y2Factor = 0, this._y3Factor = 0, this._lutIndex = NaN, this._initialized = false, this._len = 100, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._length = 0, this._lut = [], this._lutObjects = [];
      for (let t2 = 0; t2 < 100; t2++) this._lutObjects.push({ x: 0, y: 0, t: 0, distance: 0 });
      this._CalculateLength();
    }
    Release() {
      C32.clearArray(this._arcLengths), this._arcLengths = null, C32.clearArray(this._lut), this._lut = null, C32.clearArray(this._lutObjects), this._lutObjects = null;
    }
    GetType() {
      return "cubic-bezier";
    }
    GetIndex() {
      return this._index;
    }
    GetStepCount() {
      return Math.floor(this._length / 25);
    }
    GetStepIncrement() {
      return 1 / this.GetStepCount();
    }
    SetOrigin(t, i) {
      this._originX = t, this._originY = i, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._CalculateLength(), this._aXO = this._aX + this._originX, this._aYO = this._aY + this._originY, this._bXO = this._bX + this._originX, this._bYO = this._bY + this._originY, this._cXO = this._cX + this._originX, this._cYO = this._cY + this._originY, this._dXO = this._dX + this._originX, this._dYO = this._dY + this._originY, this._d0x = 3 * (this._bXO - this._aXO), this._d0y = 3 * (this._bYO - this._aYO), this._d1x = 3 * (this._cXO - this._bXO), this._d1y = 3 * (this._cYO - this._bYO), this._d2x = 3 * (this._dXO - this._cXO), this._d2y = 3 * (this._dYO - this._cYO), this._x1Factor = 3 * (this._bXO - this._aXO), this._x2Factor = 3 * (this._aXO + this._cXO - 2 * this._bXO), this._x3Factor = this._dXO - this._aXO + 3 * (this._bXO - this._cXO), this._y1Factor = 3 * (this._bYO - this._aYO), this._y2Factor = 3 * (this._aYO + this._cYO - 2 * this._bYO), this._y3Factor = this._dYO - this._aYO + 3 * (this._bYO - this._cYO);
    }
    Map(t) {
      if (!this._initialized) return NaN;
      const i = this._Map(t);
      return MAP_RESULT[0] = this._X(i), MAP_RESULT[1] = this._Y(i), MAP_RESULT;
    }
    Project(t, i) {
      const e = this._GenerateLUT(100), s = this._FindClosestFromLUT(t, i, e), _ = this._RefineProjection(t, i, e, s);
      return PROJECTION_RESULT[0] = _.x, PROJECTION_RESULT[1] = _.y, PROJECTION_RESULT[2] = _.t, PROJECTION_RESULT[3] = _.distance, PROJECTION_RESULT;
    }
    ProjectWithRange(t, i, e) {
      const s = this._GenerateLUT(100), _ = this._FindClosestFromLUTWithRange(t, i, s, e), h = this._RefineProjection(t, i, s, _);
      return PROJECTION_RESULT[0] = h.x, PROJECTION_RESULT[1] = h.y, PROJECTION_RESULT[2] = h.t, PROJECTION_RESULT[3] = h.distance, PROJECTION_RESULT;
    }
    Tangent(t) {
      const i = 1 - t, e = i * i, s = 2 * i * t, _ = t * t, h = e * this._d0x + s * this._d1x + _ * this._d2x, n = e * this._d0y + s * this._d1y + _ * this._d2y, r = C32.hypot2DFast(h, n);
      return TANGENT_RESULT[0] = h / r, TANGENT_RESULT[1] = n / r, TANGENT_RESULT;
    }
    TangentAngle(t) {
      const i = 1 - t, e = i * i, s = 2 * i * t, _ = t * t, h = e * this._d0x + s * this._d1x + _ * this._d2x, n = e * this._d0y + s * this._d1y + _ * this._d2y;
      return Math.atan2(n, h);
    }
    _Map(t) {
      if (!this._initialized) return;
      let i = t * this._arcLengths[this._len], e = 0, s = this._len, _ = 0;
      for (; e < s; ) _ = e + ((s - e) / 2 | 0), this._arcLengths[_] < i ? e = _ + 1 : s = _;
      this._arcLengths[_] > i && _--;
      const h = this._arcLengths[_];
      return h === i ? _ / this._len : (_ + (i - h) / (this._arcLengths[_ + 1] - h)) / this._len;
    }
    _X(t) {
      return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(t, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN;
    }
    _Y(t) {
      return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(t, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN;
    }
    _GenerateLUT(t) {
      if (t = t || 100, this._lut.length >= t) return this._lut;
      this._lut = new Array(t), t++;
      for (let i = 0; i < t - 1; i++) {
        const e = i / (t - 1), s = e ** 2, _ = e ** 3, h = this._x1Factor * e, n = this._x2Factor * s, r = this._x3Factor * _, a = this._y1Factor * e, c = this._y2Factor * s, l = this._y3Factor * _, o = this._aXO + h + n + r, d = this._aYO + a + c + l;
        this._lutObjects[i].x = o, this._lutObjects[i].y = d, this._lutObjects[i].t = e, this._lutObjects[i].distance = 0, this._lut[i] = this._lutObjects[i];
      }
      return this._lut;
    }
    _FindClosestFromLUT(t, i, e, s = null, _ = Number.MAX_SAFE_INTEGER) {
      let h = 0;
      if (isNaN(this._lutIndex)) for (let s2 = 0; s2 < 100; s2++) {
        const n = e[s2], r = n.x - t, a = n.y - i;
        n.distance = r * r + a * a, n.distance < _ && (_ = n.distance, h = s2);
      }
      else {
        for (let s2 = this._lutIndex; s2 < this._lutIndex + 5 && !(s2 >= e.length); s2++) {
          const n = e[s2], r = n.x - t, a = n.y - i;
          n.distance = r * r + a * a, n.distance < _ && (_ = n.distance, h = s2);
        }
        for (let s2 = this._lutIndex; s2 > this._lutIndex - 5 && !(s2 < 0); s2--) {
          const n = e[s2], r = n.x - t, a = n.y - i;
          n.distance = r * r + a * a, n.distance < _ && (_ = n.distance, h = s2);
        }
      }
      return this._lutIndex = h, h;
    }
    _FindClosestFromLUTWithRange(t, i, e, s, _ = Number.MAX_SAFE_INTEGER) {
      let h = 0;
      if (isNaN(this._lutIndex)) for (let n = 0; n < 100; n++) {
        const r = e[n], a = r.x - t, c = r.y - i;
        r.distance = a * a + c * c, r.t >= s[0] && r.t <= s[1] && r.distance < _ && (_ = r.distance, h = n);
      }
      else {
        for (let n = this._lutIndex; n < this._lutIndex + 5 && !(n >= e.length); n++) {
          const r = e[n], a = r.x - t, c = r.y - i;
          r.distance = a * a + c * c, r.t >= s[0] && r.t <= s[1] && r.distance < _ && (_ = r.distance, h = n);
        }
        for (let n = this._lutIndex; n > this._lutIndex - 5 && !(n < 0); n--) {
          const r = e[n], a = r.x - t, c = r.y - i;
          r.distance = a * a + c * c, r.t >= s[0] && r.t <= s[1] && r.distance < _ && (_ = r.distance, h = n);
        }
      }
      return this._lutIndex = h, h;
    }
    _RefineProjection(t, i, e, s) {
      let _ = e[s], h = 1, n = Number.MAX_SAFE_INTEGER;
      t: do {
        const h2 = e.length;
        let r = 0 === s ? 0 : s - 1, a = s === h2 - 1 ? h2 - 1 : s + 1, c = e[r].t, l = (e[a].t - c) / 4;
        if (l < 1e-3) break;
        REFINE_LUT[0] = e[r];
        for (let e2 = 1; e2 <= 2; e2++) {
          const h3 = c + e2 * l, r2 = h3 ** 2, a2 = h3 ** 3, o = this._x1Factor * h3, d = this._x2Factor * r2, u = this._x3Factor * a2, O = this._y1Factor * h3, T = this._y2Factor * r2, E = this._y3Factor * a2, R = this._aXO + o + d + u, g = this._aYO + O + T + E, N = R - t, I = g - i, S = N * N + I * I;
          if (S < n) {
            n = S, s = e2, REFINE_RESULT.x = R, REFINE_RESULT.y = g, REFINE_RESULT.t = h3, REFINE_RESULT.distance = S, _ = REFINE_RESULT;
            break t;
          }
          const x = REFINE_LUT_OBJECTS[e2 - 1];
          x.x = R, x.y = g, x.t = h3, x.distance = S, REFINE_LUT[e2] = x;
        }
        REFINE_LUT[3] = e[a], e = REFINE_LUT;
      } while (h++ < 20);
      return _;
    }
    _CalculateLength() {
      this._initialized = true;
      let t = this._X(0), i = this._Y(0), e = 0;
      for (let s = 1; s <= this._len; s++) {
        const _ = this._X(0.01 * s), h = this._Y(0.01 * s), n = t - _, r = i - h;
        e += C32.hypot2DFast(n, r), this._arcLengths[s] = e, t = _, i = h;
      }
      this._length = e;
    }
  }, C32.TimelineLineSegmentInfo = class {
    constructor(t, i, e) {
      this._index = e, this._targetX = t.GetValueWithResultMode(), this._targetY = i.GetValueWithResultMode(), this._originX = 0, this._originY = 0;
    }
    Release() {
    }
    GetType() {
      return "line";
    }
    GetIndex() {
      return this._index;
    }
    SetOrigin(t, i) {
      this._originX = t, this._originY = i;
    }
    GetX() {
      return this._targetX + this._originX;
    }
    GetY() {
      return this._targetY + this._originY;
    }
  };
}
{
  const C32 = self.C3, PING_PONG_BEGIN = 0, PING_PONG_END = 1;
  C32.TimelineState = class extends C32.DefendedBase {
    constructor(t, e, i) {
      super(), this._runtime = i.GetRuntime(), this._timelineManager = i, this._timelineDataItem = e, this._name = t, this._tracks = [], this._tracksLength = 0, this._beforeAndAfterTracks = null, this._beforeAndAfterTracksLength = 0, this.CreateTrackStates(), this._playPromise = null, this._playResolve = null, this._playheadTime = 0, this._overshoot = 0, this._playbackRate = 1, this._pingPongState = 0, this._resumePingPongState = -1, this._currentRepeatCount = 1, this._isPlaying = false, this._isScheduled = false, this._initialStateSet = false, this._complete = true, this._released = false, this._markedForRemoval = false, this._completedTick = -1, this._implicitPause = false, this._isTemplate = false, this._finishedTriggers = false, this._firstTick = false, this._lastDelta = NaN, this._tags = [""], this._stringTags = "", this._tagsChanged = false, this._renderChange = 0, this._hasNestedContent = 0, this._stoppedKeyframeDataItem = null, this._iTimelineState = null;
    }
    static CreateInitial(t, e) {
      const i = e.GetTimelineDataManager(), s = i.GetNameId(), a = i.Get(t[s]), n = C32.New(C32.TimelineState, t[s], a, e);
      return n.SetIsTemplate(true), n;
    }
    static CreateFromTemplate(t, e, i) {
      return C32.New(C32.TimelineState, t, e, i);
    }
    Release() {
      if (this.IsReleased()) return;
      const t = this._runtime.Dispatcher();
      this._timelineManager.DeScheduleTimeline(this), this._timelineManager.CompleteTimelineAndResolve(this);
      for (const t2 of this._tracks) t2.Release();
      C32.clearArray(this._tracks), this._tracks = null, this._runtime = null, this._timelineManager = null, this._timelineDataItem = null, this._released = true, this._playPromise = null, this._playResolve = null, this.FireReleaseEvent(t);
    }
    FireReleaseEvent(t) {
      const e = C32.New(C32.Event, "timelinestatereleased");
      e.timelineState = this, t.dispatchEvent(e);
    }
    GetType() {
      return 0;
    }
    CreateTrackStates() {
      for (const t of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracksLength = this._tracks.push(C32.TrackState.Create(this, t));
    }
    GetTimelineManager() {
      return this._timelineManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTracks() {
      return this._tracks;
    }
    GetSimilarPropertyTracks(t, e, i, s) {
      if (!this._hasNestedContent) return;
      let a;
      for (let n = 0; n < this._tracks.length; n++) {
        let r = this._tracks[n];
        if (t !== r.GetInstance()) continue;
        const h = r.GetPropertyTrack(i);
        h && (e.constructor === h.GetSourceAdapter().constructor && h.GetResultMode() === s.GetResultMode() && (a || (a = []), a.push(h)));
      }
      return a;
    }
    HasTracks() {
      return !!this._tracks.length;
    }
    GetTrackById(t) {
      for (const e of this._tracks) if (C32.equalsNoCase(e.GetId(), t)) return e;
      return null;
    }
    GetTrackByName(t) {
      for (const e of this._tracks) if (!e.IsInstanceTrack() && C32.equalsNoCase(e.GetName(), t)) return e;
      return null;
    }
    SetName(t) {
      this._name = t;
    }
    GetName() {
      return this._name;
    }
    GetTimelineDataItem() {
      return this._timelineDataItem;
    }
    GetTemplateName() {
      return this._timelineDataItem.GetName();
    }
    GetTotalTime() {
      return this._timelineDataItem.GetTotalTime();
    }
    SetTotalTime(t) {
      this._timelineDataItem.SetTotalTime(t);
    }
    GetStep() {
      return this._timelineDataItem.GetStep();
    }
    SetStep(t) {
      this._timelineDataItem.SetStep(t);
    }
    GetInterpolationMode() {
      return this._timelineDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(t) {
      this._timelineDataItem.SetInterpolationMode(t);
    }
    GetResultMode() {
      return this._timelineDataItem.GetResultMode();
    }
    SetResultMode(t) {
      this._timelineDataItem.GetResultMode(t);
    }
    SetEase(t) {
      for (const e of this.GetTracks()) e.SetEase(t);
    }
    GetLoop() {
      return this._timelineDataItem.GetLoop();
    }
    SetLoop(t) {
      return this._timelineDataItem.SetLoop(t);
    }
    GetPingPong() {
      return this._timelineDataItem.GetPingPong();
    }
    SetPingPong(t) {
      return this._timelineDataItem.SetPingPong(t);
    }
    GetRepeatCount() {
      return this._timelineDataItem.GetRepeatCount();
    }
    GetCurrentRepeatCount() {
      return this._currentRepeatCount;
    }
    SetRepeatCount(t) {
      return this._timelineDataItem.SetRepeatCount(t);
    }
    SetPlaybackRate(t) {
      if (t = Number(t), C32.IsFiniteNumber(t)) return this._playbackRate = t;
    }
    GetPlaybackRate() {
      return this._playbackRate;
    }
    GetStartOnLayout() {
      return this._timelineDataItem.GetStartOnLayout();
    }
    GetTransformWithSceneGraph() {
      return this._timelineDataItem.GetTransformWithSceneGraph();
    }
    GetUseSystemTimescale() {
      return this._timelineDataItem.GetUseSystemTimescale();
    }
    GetPingPongState() {
      return this._pingPongState;
    }
    IsForwardPlayBack() {
      return !this.IsPlaying() || this._playbackRate > 0;
    }
    GetStatus() {
      return this.IsPlaying() ? "playing" : this.IsPaused() ? "paused" : this.IsComplete() ? "complete" : "other";
    }
    GetPlayPromise() {
      return this._playPromise || (this._playPromise = new Promise((t) => {
        this._playResolve = t;
      })), this._playPromise;
    }
    ResolvePlayPromise() {
      this._playPromise && (this._playResolve(), this._playPromise = null, this._playResolve = null);
    }
    SetTags(t) {
      this._tags = C32.TimelineState._GetTagArray(t), this._tagsChanged = true;
    }
    GetTags() {
      return this._tags;
    }
    GetStringTags() {
      return this._tagsChanged && (this._stringTags = this._tags.join(" ")), this._tagsChanged = false, this._stringTags;
    }
    HasTags(t) {
      if (!this._tags) return false;
      if (!this._tags.length) return false;
      const e = C32.TimelineState._GetTagArray(t);
      return !!e && (!!e.length && e.every(C32.TimelineState._HasTag, this));
    }
    OnStarted() {
      C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStarted), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStartedByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStartedByTags), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnAnyTimelineStarted), C32.Plugins.Timeline.Cnds.PopTriggerTimeline());
    }
    OnCompleted() {
      this._completedTick = this._runtime.GetTickCount();
    }
    FinishTriggers() {
      this._finishedTriggers || (this._finishedTriggers = true, C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnAnyTimelineFinished), C32.Plugins.Timeline.Cnds.PopTriggerTimeline()));
    }
    SetPlaying(t) {
      this._isPlaying = t;
    }
    IsCompletedTick() {
      return this._completedTick === this._runtime.GetTickCount();
    }
    IsPlaying(t = false) {
      return !!this.IsCompletedTick() || (!(!this.IsScheduled() || t) || this._isPlaying);
    }
    _IsPlaying() {
      return this.IsPlaying(true);
    }
    IsPaused() {
      return this._IsPaused();
    }
    _IsPaused() {
      return !this.IsReleased() && (!this.IsScheduled() && (!this._IsPlaying() && !this.IsComplete()));
    }
    SetScheduled(t) {
      this._isScheduled = t;
    }
    IsScheduled() {
      return this._isScheduled;
    }
    SetComplete(t) {
      this._complete = t;
      const e = this.GetLoop(), i = this.GetPingPong();
      if (e || i) {
        if (e && !i) ;
        else if (!e && i) {
          const t2 = this.GetTime();
          1 === this._pingPongState && (t2 <= 0 || t2 >= this.GetTotalTime()) && (this._complete = true);
        }
      } else {
        const t2 = this.GetTime();
        (t2 <= 0 || t2 >= this.GetTotalTime()) && (this._complete = true);
      }
    }
    IsComplete() {
      return this._complete;
    }
    IsReleased() {
      return this._released;
    }
    SetMarkedForRemoval(t) {
      this._markedForRemoval = t;
    }
    IsMarkedForRemoval() {
      return this._markedForRemoval;
    }
    SetImplicitPause(t) {
      this._implicitPause = t;
    }
    IsImplicitPause() {
      return this._implicitPause;
    }
    SetIsTemplate(t) {
      this._isTemplate = !!t;
    }
    IsTemplate() {
      return this._isTemplate;
    }
    InitialStateSet() {
      return this._initialStateSet;
    }
    GetTime() {
      return this._playheadTime;
    }
    SetTime(t) {
      if (t = Number(t), !C32.IsFiniteNumber(t)) return;
      const e = this.GetTime();
      this._SetTime(t), this.SetComplete(false), this.IsComplete() || this.SetImplicitPause(true), (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet) && (this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime()), this._SetUpdateStateBefore(), this._Interpolate(this.GetTime(), false, true, true, e), this._SetUpdateStateAfter(), this._renderChange && this.GetRuntime().UpdateRender(), this._OnSetTime();
    }
    _SetTime(t) {
      C32.IsFiniteNumber(t) || (t = this.GetTotalTime()), t < 0 ? this._playheadTime = 0 : t >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = t;
    }
    _SetTimeAndReset(t) {
      C32.IsFiniteNumber(t) || (t = this.GetTotalTime()), t < 0 ? this._playheadTime = 0 : t >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = t;
      for (const t2 of this._tracks) t2.SetResetState();
    }
    _OnSetTime() {
      C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSetByTags), C32.Plugins.Timeline.Cnds.PopTriggerTimeline());
    }
    _CanResume() {
      if (this.GetLoop()) return true;
      if (this.GetPingPong() && 1 === this._pingPongState) {
        if (this.IsForwardPlayBack()) {
          if (this.GetTime() >= this.GetTotalTime()) return false;
        } else if (this.GetTime() <= 0) return false;
      } else if (!this.GetLoop() && !this.GetPingPong()) {
        if (this.IsForwardPlayBack()) {
          if (this.GetTime() >= this.GetTotalTime()) return false;
        } else if (this.GetTime() <= 0) return false;
      }
      return true;
    }
    Resume() {
      this.IsReleased() || this._CanResume() && this.Play(true);
    }
    Play(t = false) {
      return !this.IsReleased() && (!this.IsScheduled() && (this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : !this._IsPlaying() && (!!(this.IsComplete() || t || this.IsImplicitPause()) && this._ScheduleStoppedTimeline())));
    }
    _SchedulePlayingTimeline() {
      return this.SetImplicitPause(false), this._timelineManager.RemovePlayingTimeline(this), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;
    }
    _ScheduleStoppedTimeline() {
      return this.SetImplicitPause(false), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;
    }
    Stop(t = false) {
      this.IsReleased() || (this.SetComplete(t), this._timelineManager.CompleteTimeline(this), this.IsComplete() && this.ResolvePlayPromise());
    }
    Reset(t = true, e = false) {
      if (this.IsReleased()) return;
      if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);
      if (this.IsComplete()) return;
      this.Stop(true), this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
      const i = this.GetTime();
      this._SetUpdateStateBefore(), e ? this._InterpolateBeforeChangeLayout(i) : this._Interpolate(i, false, false, true), t && this._OnSetTime(), this._SetUpdateStateAfter(), this._renderChange && t && this.GetRuntime().UpdateRender();
    }
    ResetBeforeChangeLayout() {
      this.Reset(false, true);
    }
    _InterpolateBeforeChangeLayout(t) {
      this._Interpolate(t, false, false, true, NaN, false, true);
    }
    _OnBeforeChangeLayout() {
      return !!this.IsReleased() || !(!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks()) && (this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout(), true);
    }
    SetInitialStateFromSetTime() {
      this.SetInitialState(true);
    }
    SetInitialStateForce() {
      this.SetInitialState(false, true), this.SetPlaying(false), this.SetScheduled(false);
    }
    SetInitialState(t = false, e = false) {
      if (!this.IsMarkedForRemoval() || e) if (t) {
        this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this._SetUpdateStateBefore();
        for (const t2 of this._tracks) t2.SetInitialState();
        this._SetUpdateStateAfter();
      } else if (this.SetPlaying(true), this.SetScheduled(false), this.OnStarted(), this.IsComplete()) {
        this._completedTick = -1, 0 !== this._pingPongState && (this._playbackRate = Math.abs(this._playbackRate)), this._pingPongState = 0, this._resumePingPongState = -1, this._currentRepeatCount = 1, this._complete = false, this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime()), this._SetUpdateStateBefore();
        for (const t2 of this._tracks) t2.SetInitialState();
        this._SetUpdateStateAfter();
      } else {
        -1 !== this._resumePingPongState && (this._pingPongState = this._resumePingPongState), this._firstTick = true, this._finishedTriggers = false, this._SetUpdateStateBefore();
        for (const t2 of this._tracks) t2.SetResumeState();
        this._SetUpdateStateAfter();
      }
    }
    GetRenderChange() {
      return this._renderChange;
    }
    _SetUpdateStateBefore() {
      this._hasNestedContent = 0;
      for (const t of this._tracks) t.IsNested() && (this._hasNestedContent = 1);
    }
    _SetUpdateStateAfter() {
      this._renderChange = 0;
      for (const t of this._tracks) t._SetUpdateState(), 0 === this._renderChange && 1 === t.GetRenderChange() && (this._renderChange = 1), this._beforeAndAfterTracks || 1 !== t.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []), this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(t));
    }
    Tick(t, e, i) {
      if (this.GetUseSystemTimescale()) {
        if (0 === t && 0 === this._lastDelta) return;
        this._lastDelta = t, t = i;
      } else {
        if (0 === i && 0 === this._lastDelta) return;
        this._lastDelta = i, t = i, e = 1;
      }
      const s = this._playheadTime + this._overshoot, a = s + t * e * this._playbackRate, n = this._timelineDataItem._totalTime;
      a < 0 ? (this._playheadTime = 0, this._overshoot = -a) : a >= n ? (this._playheadTime = n, this._overshoot = this._playheadTime - a) : (this._playheadTime = a, this._overshoot = 0);
      let r = false, h = false;
      const l = this.GetLoop(), o = this.GetPingPong();
      let m;
      l || o ? l && !o ? this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTimeAndReset(0), h = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(n), h = true) : !l && o ? this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTime(n), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : r = true : 0 === this._pingPongState && (this._pingPongState = 1)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : r = true : 0 === this._pingPongState && (this._pingPongState = 1)) : l && o && (this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTime(n), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, this._pingPongState++, C32.wrap(this._pingPongState, 0, 2)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, this._pingPongState++, C32.wrap(this._pingPongState, 0, 2))) : this._playbackRate > 0 ? this._playheadTime >= n && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), h = true) : (this._SetTime(n), r = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(n), h = true) : (this._SetTime(0), r = true));
      const _ = this._tracksLength;
      if (r) {
        for (m = 0; m < _; m++) this._tracks[m].SetEndState();
        return this.Stop(true), void this.OnCompleted();
      }
      const c = this._beforeAndAfterTracksLength;
      for (m = 0; m < c; m++) {
        const t2 = this._beforeAndAfterTracks[m], e2 = t2.GetStartOffset();
        this._playheadTime - e2 < 0 && s - e2 > 0 ? t2.BeforeInterpolate(e2) : t2.BeforeInterpolate(this._playheadTime);
      }
      if (1 === this._hasNestedContent) for (m = 0; m < _; m++) {
        const t2 = this._tracks[m], e2 = t2.GetStartOffset();
        this._playheadTime - e2 < 0 && s - e2 > 0 ? t2.Interpolate(e2, true, false, h, this._firstTick, false) : t2.Interpolate(this._playheadTime, true, false, h, this._firstTick, false);
      }
      else for (m = 0; m < _; m++) this._tracks[m].Interpolate(this._playheadTime, true, false, h, this._firstTick, false);
      if (!this.IsPlaying() && this._stoppedKeyframeDataItem) {
        const t2 = this._stoppedKeyframeDataItem.GetTime() + this._stoppedKeyframeDataItem.GetKeyframeData().GetTrackDataItem().GetStartOffset(), e2 = this._playheadTime - t2;
        this._playheadTime -= e2, 0 !== this._overshoot && (this._overshoot -= e2), this._stoppedKeyframeDataItem = null;
      }
      for (m = 0; m < c; m++) {
        const t2 = this._beforeAndAfterTracks[m], e2 = t2.GetStartOffset();
        this._playheadTime - e2 < 0 && s - e2 > 0 ? t2.AfterInterpolate(e2) : t2.AfterInterpolate(this._playheadTime);
      }
      this._firstTick && (this._firstTick = false);
    }
    SetStoppedOnKeyframe(t) {
      this._stoppedKeyframeDataItem = t;
    }
    GetStoppedOnKeyframe() {
      return this._stoppedKeyframeDataItem;
    }
    _GetTrackStartTime(t, e, i, s = false) {
      let a = t;
      if ("number" == typeof e && !isNaN(e)) {
        const t2 = this.GetTime() - i.GetStartOffset(), n = e - i.GetStartOffset();
        t2 < 0 && n > 0 && (a = i.GetStartOffset(), s && this._SetTime(a));
      }
      return a;
    }
    _Interpolate(t, e = false, i = false, s = false, a = NaN, n = false, r = false) {
      for (const e2 of this._tracks) {
        const s2 = this._GetTrackStartTime(t, a, e2);
        e2.BeforeInterpolate(s2, i);
      }
      for (const n2 of this._tracks) {
        const h = this._GetTrackStartTime(t, a, n2, true);
        n2.Interpolate(h, e, i, s, this._firstTick, r);
      }
      for (const e2 of this._tracks) {
        const s2 = this._GetTrackStartTime(t, a, e2);
        e2.AfterInterpolate(s2, i);
      }
      this._firstTick && n && (this._firstTick = false);
    }
    AddTrack() {
      const t = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), e = C32.TrackState.Create(this, t);
      return this._tracksLength = this._tracks.push(e), e;
    }
    Removed() {
      if (!this.IsReleased()) for (const t of this._tracks) t.TimelineRemoved();
    }
    CleanCaches() {
      for (const t of this._tracks) t.CleanCaches();
    }
    *GetInstances() {
      for (const t of this._tracks) {
        t.GetInstance() && (yield t.GetInstance());
      }
    }
    ClearTrackInstances() {
      for (const t of this._tracks) t.ClearInstance();
    }
    SetTrackInstance(t, e, i) {
      if (e) {
        if ("number" == typeof i && i >= 0) {
          const t2 = this._tracks[i];
          if (!t2) return;
          return t2.SetInstance(e), void this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
        }
        for (const i2 of this._tracks) if (i2.IsInstanceTrack()) {
          if (t) {
            if (i2.GetId() !== t) continue;
            i2.SetInstance(e), this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
            break;
          }
          if (!i2.HasInstance()) {
            i2.SetInstance(e), this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
            break;
          }
        }
      }
    }
    HasTrackInstance(t, e) {
      for (const i of this._tracks) if (i.IsInstanceTrack()) {
        if (e) {
          if (e === i.GetId() && t === i.GetInstance()) return true;
        } else if (t === i.GetInstance()) return true;
      }
      return false;
    }
    HasValidTracks() {
      return this._tracks.some((t) => !t.IsInstanceTrack() || t.CanInstanceBeValid());
    }
    HasValidGlobalTracks() {
      return this._tracks.some((t) => {
        if (t.IsInstanceTrack()) {
          if (!t.CanInstanceBeValid()) return false;
          const e = t.GetObjectClass();
          return !!e && e.IsGlobal();
        }
        return false;
      });
    }
    GetPropertyTrack(t) {
      for (const e of this.GetTracks()) for (const i of e.GetPropertyTracks()) if (i.GetPropertyName() === t) return i;
    }
    GetTrackFromInstance(t) {
      for (const e of this._tracks) if (t === e.GetInstance()) return e;
      return null;
    }
    GetKeyframeWithTags(t) {
      let e = t ? t.split(" ") : [];
      const i = new Set(e.map((t2) => t2.toLowerCase().trim()));
      e = [...i.values()];
      for (const t2 of this.GetTracks()) for (const i2 of t2.GetKeyframeDataItems()) {
        if (e.every((t3) => i2.HasTag(t3))) return i2;
      }
    }
    GetObjectClasses() {
      const t = [];
      for (const e of this.GetTracks()) t.push(e.GetObjectClass());
      return t.filter((t2) => t2);
    }
    _OnAfterLoad() {
      for (const t of this.GetTracks()) t._OnAfterLoad();
    }
    _SaveToJson() {
      return { "tracksJson": this._SaveTracksToJson(), "name": this._name, "playheadTime": this.GetTime(), "playbackRate": this._playbackRate, "pingPongState": this._pingPongState, "resumePingPongState": this._resumePingPongState, "currentRepeatCount": this._currentRepeatCount, "isPlaying": this._isPlaying, "isScheduled": this._isScheduled, "initialStateSet": this._initialStateSet, "finishedTriggers": this._finishedTriggers, "complete": this._complete, "released": this._released, "markedForRemoval": this._markedForRemoval, "completedTick": this._completedTick, "implicitPause": this._implicitPause, "isTemplate": this._isTemplate, "tags": this._tags.join(" "), "stringTags": this._stringTags, "tagsChanged": this._tagsChanged, "firstTick": this._firstTick };
    }
    _LoadFromJson(t) {
      t && (this._LoadTracksFromJson(t["tracksJson"]), this._name = t["name"], this._playheadTime = t["playheadTime"], this._playbackRate = t["playbackRate"], this._pingPongState = t["pingPongState"], this._resumePingPongState = t.hasOwnProperty("resumePingPongState") ? t["resumePingPongState"] : -1, this._currentRepeatCount = t["currentRepeatCount"], this._isPlaying = !!t["isPlaying"], this._isScheduled = !!t["isScheduled"], this._initialStateSet = !!t["initialStateSet"], this._finishedTriggers = !!t.hasOwnProperty("finishedTriggers") && !!t["finishedTriggers"], this._complete = !!t["complete"], this._released = !!t["released"], this._markedForRemoval = !!t["markedForRemoval"], this._completedTick = t["completedTick"], this._implicitPause = !!t["implicitPause"], this._isTemplate = !!t["isTemplate"], this._tags = t["tags"].split(" "), this._stringTags = t["stringTags"], this._tagsChanged = !!t["tagsChanged"], this._firstTick = !!t["firstTick"]);
    }
    _SaveTracksToJson() {
      return this._tracks.map((t) => t._SaveToJson());
    }
    _LoadTracksFromJson(t) {
      this.ClearTrackInstances(), t.forEach((t2, e) => {
        this._tracks[e]._LoadFromJson(t2);
      }), this._tracks.filter((t2) => t2.CanInstanceBeValid());
    }
    static _HasTag(t) {
      const e = this.GetTags();
      return "" === t ? 1 === e.length && "" === e[0] : e.map((t2) => t2.toLowerCase()).includes(t.toLowerCase());
    }
    static _GetTagArray(t) {
      if (C32.IsArray(t)) return t.slice(0);
      if (C32.IsString(t)) return t.split(" ");
      throw new Error("invalid tags");
    }
    GetITimelineState() {
      return this._iTimelineState || (this._iTimelineState = C32.New(self.ITimelineState, this)), this._iTimelineState;
    }
  };
}
{
  const C32 = self.C3, INSTANCE_TRACK = 0, VALUE_TRACK = 1, AUDIO_TRACK = 2;
  C32.TrackState = class extends C32.DefendedBase {
    constructor(t, e) {
      super(), this._timeline = t, this._trackDataItem = e, this._trackData = e.GetTrackData(), this._instanceUid = NaN, this._objectClassIndex = NaN, this._instance = null, this._worldInfo = null, this._cleared = false, this._isNested = e.GetStartOffset() > 0, this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this._instanceUidToLoad = NaN, this._lastKeyframeDataItem = null, this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(), this._propertyTracks = [], this.CreatePropertyTrackStates(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0, this._keyframeReachedOnCurrentTick = null;
    }
    static Create(t, e) {
      return C32.New(C32.TrackState, t, e);
    }
    Release() {
      this._keyframeDataItems = null;
      for (const t of this._propertyTracks) t.Release();
      C32.clearArray(this._propertyTracks), this._propertyTracks = null, this._timeline = null, this._instance = null, this._worldInfo = null, this._trackDataItem = null, this._lastKeyframeDataItem = null;
    }
    CreatePropertyTrackStates() {
      for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C32.PropertyTrackState.Create(this, t));
    }
    TimelineRemoved() {
      for (const t of this._propertyTracks) t.TimelineRemoved();
    }
    CleanCaches() {
      for (const t of this._propertyTracks) t.CleanCaches();
      this._instance = null, this._worldInfo = null;
    }
    GetTimeline() {
      return this._timeline;
    }
    GetRuntime() {
      return this._timeline.GetRuntime();
    }
    GetKeyframeDataItems() {
      return this._keyframeDataItems || (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()), this._keyframeDataItems;
    }
    GetPropertyTracks() {
      return this._propertyTracks;
    }
    GetPropertyTrack(t) {
      for (let e = 0; e < this._propertyTracks.length; e++) {
        const a = this._propertyTracks[e];
        if (a.GetPropertyName() === t) return a;
      }
    }
    MaybeGetInstance() {
      this._instance || this.GetInstance();
    }
    IsInstanceValid() {
      return !!this._instance && !this._instance.IsDestroyed();
    }
    CanInstanceBeValid() {
      if (!this.IsInstanceTrack()) return false;
      if (this._cleared) return false;
      const t = this.GetInstanceUID(), e = this.GetRuntime().GetInstanceByUID(t);
      return !!e && !e.IsDestroyed();
    }
    GetObjectClass() {
      if (!this.IsInstanceTrack()) return;
      const t = this.GetObjectClassIndex();
      return -1 !== t ? this.GetRuntime().GetObjectClassByIndex(t) : void 0;
    }
    GetTrackIndexInTimeline() {
      return this._timeline.GetTracks().indexOf(this);
    }
    ClearInstance() {
      this._instance = null, this._instanceUid = NaN, this._worldInfo = null, this._objectClassIndex = NaN, this._cleared = true;
    }
    HasInstance() {
      return !!this._instance;
    }
    GetInstance() {
      if (this._cleared) return;
      if (this._instance && this.IsInstanceValid()) return this._instance;
      const t = this.GetInstanceUID();
      return this._instance = this.GetRuntime().GetInstanceByUID(t), this._instance;
    }
    SetInstance(t) {
      if (this._cleared = false, this._instance !== t) {
        this.CleanCaches(), this._instance = t, this._objectClassIndex = t.GetObjectClass().GetIndex(), this._instanceUid = t.GetUID(), this._worldInfo = t.GetWorldInfo();
        for (const e of this.propertyTrackItems()) {
          const a = e.propertyTrack, s = e.sourceAdapter;
          switch (a.GetSourceAdapterId()) {
            case "instance-variable": {
              s.GetEditorIndex();
              const a2 = t.GetObjectClass(), r = a2.GetInstanceVariableIndexByName(e.name), i = a2.GetInstanceVariableName(r), n = a2.GetInstanceVariableType(r);
              i === e.name && n === e.type && s.UpdateInstanceVariableIndex(r);
              break;
            }
            case "behavior": {
              const a2 = e.behaviorType, r = this.GetObjectClass(), i = t.GetObjectClass(), n = s.GetBehaviorType(i);
              if (a2 && n) {
                const t2 = a2.GetName();
                r.GetBehaviorIndexByName(t2), i.GetBehaviorIndexByName(t2), s.GetEditorIndex();
                s.UpdateBehaviorTypeSid(n.GetSID());
              }
              break;
            }
          }
        }
      }
    }
    *propertyTrackItems() {
      for (const t of this._propertyTracks) {
        const e = t.GetSourceAdapter(), a = this.GetObjectClass(), s = { propertyTrack: t, sourceAdapter: e };
        switch (t.GetSourceAdapterId()) {
          case "world-instance":
            s.property = t.GetPropertyName();
            break;
          case "instance-variable": {
            const t2 = e.GetEditorIndex();
            s.name = a.GetInstanceVariableName(t2), s.type = a.GetInstanceVariableType(t2);
            break;
          }
          case "effect": {
            const t2 = a.GetEffectList(), r = e.GetEffectType(t2);
            s.effectType = r;
            break;
          }
          case "behavior": {
            const t2 = e.GetBehaviorType(a);
            s.behaviorType = t2;
            break;
          }
          case "plugin":
            s.plugin = a.GetPlugin();
        }
        yield s;
      }
    }
    GetWorldInfo() {
      if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo;
      const t = this.GetInstance();
      return t && (this._worldInfo = t.GetWorldInfo()), this._worldInfo;
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    GetInstanceUID() {
      return isNaN(this._instanceUid) ? this._trackDataItem.GetInstanceUID() : this._instanceUid;
    }
    SetInstanceUID(t) {
      this._trackDataItem.SetInstanceUID(t);
    }
    GetInterpolationMode() {
      return this._trackDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(t) {
      this._trackDataItem.SetInterpolationMode(t);
    }
    GetResultMode() {
      return this._trackDataItem.GetResultMode();
    }
    GetId() {
      return this._trackDataItem.GetId();
    }
    GetStartOffset() {
      return this._trackDataItem.GetStartOffset();
    }
    GetLocalTotalTime() {
      return this._trackDataItem.GetLocalTotalTime();
    }
    SetLocalTotalTime(t) {
      this._trackDataItem.SetLocalTotalTime(t);
    }
    SetResultMode(t) {
      this._trackDataItem.SetResultMode(t);
    }
    SetEase(t) {
      for (const e of this.GetKeyframeDataItems()) e.SetEase(t);
      for (const e of this.GetPropertyTracks()) e.SetEase(t);
    }
    GetEnable() {
      return this._trackDataItem.GetEnable();
    }
    SetEnable(t) {
      this._trackDataItem.SetEnable(t);
    }
    GetObjectClassIndex() {
      return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex;
    }
    SetObjectClassIndex(t) {
      this._trackDataItem.SetObjectClassIndex(t);
    }
    SetOriginalWidth(t) {
      this._trackDataItem.SetOriginalWidth(t);
    }
    GetOriginalWidth() {
      const t = this.GetInstance();
      if (t) {
        if (t.GetSdkInstance().IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalWidth();
      }
      return this._trackDataItem.GetOriginalWidth();
    }
    SetOriginalHeight(t) {
      this._trackDataItem.SetOriginalHeight(t);
    }
    GetOriginalHeight() {
      const t = this.GetInstance();
      if (t) {
        if (t.GetSdkInstance().IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalHeight();
      }
      return this._trackDataItem.GetOriginalHeight();
    }
    GetType() {
      return this._trackDataItem.GetType();
    }
    GetName() {
      return this._trackDataItem.GetName();
    }
    IsInstanceTrack() {
      return 0 === this.GetType();
    }
    IsValueTrack() {
      return 1 === this.GetType();
    }
    IsAudioTrack() {
      return 2 === this.GetType();
    }
    GetWorldInfoChange() {
      return this._worldInfoChange;
    }
    GetRenderChange() {
      return this._renderChange;
    }
    GetNeedsBeforeAndAfter() {
      return this._needsBeforeAndAfter;
    }
    IsNested() {
      return this._isNested;
    }
    SetResetState() {
      for (const t2 of this._propertyTracks) t2.SetResetState();
      const t = this.GetTimeline(), e = t.GetTime();
      t.IsForwardPlayBack() ? this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(e) : this._lastKeyframeDataItem = this._GetFirstKeyFrameAfterTime(e);
    }
    SetInitialState() {
      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
      const t = this.GetTimeline().IsForwardPlayBack(), e = t ? 0 : this.GetLocalTotalTime();
      for (const t2 of this._propertyTracks) t2.SetInitialState(e), 0 === this._worldInfoChange && 1 === t2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === t2.GetRenderChange() && (this._renderChange = 1);
      this._needsBeforeAndAfter = 0;
      this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = t ? this._GetLastKeyFrameBeforeTime(e) : this._GetFirstKeyFrameAfterTime(e), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(e), this.OnInitialKeyframeReached(this._lastKeyframeDataItem);
    }
    GetCurrentKeyframeInterval() {
      const t = this.GetLastKeyframe(), e = this.GetNextKeyframe();
      let a, s;
      return this._timeline.IsForwardPlayBack() ? (a = { GetTime: () => t.GetTime() + this.GetStartOffset(), GetTags: () => t.GetTagsString() || "<no tags>" }, s = { GetTime: () => e ? e.GetTime() + this.GetStartOffset() : this.GetLocalTotalTime(), GetTags: () => e?.GetTagsString() || "<no tags>" }) : (a = { GetTime: () => e ? e.GetTime() + this.GetStartOffset() : this.GetLocalTotalTime(), GetTags: () => e?.GetTagsString() || "<no tags>" }, s = { GetTime: () => t.GetTime() + this.GetStartOffset(), GetTags: () => t.GetTagsString() || "<no tags>" }), [a, s];
    }
    GetLastKeyframe() {
      const t = this._timeline.GetTime() - this.GetStartOffset();
      return this._timeline.IsForwardPlayBack() ? this._GetLastKeyFrameBeforeTime(t) : this._GetFirstKeyFrameAfterTime(t);
    }
    GetNextKeyframe() {
      return this._timeline.IsForwardPlayBack() ? this.GetLastKeyframe().GetNext() : this.GetLastKeyframe().GetLast();
    }
    SetResumeState() {
      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
      const t = this._timeline.IsForwardPlayBack(), e = this._timeline.GetTime() - this.GetStartOffset();
      this._lastKeyframeDataItem = t ? this._GetLastKeyFrameBeforeTime(e) : this._GetFirstKeyFrameAfterTime(e);
      for (const t2 of this._propertyTracks) t2.SetResumeState(e);
    }
    SetEndState() {
      if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(), (this.IsInstanceValid() || !this.IsInstanceTrack()) && !this._isNested)) {
        const t = this._timeline.GetTime();
        t >= this.GetStartOffset() + this.GetLocalTotalTime() ? this.Interpolate(this.GetLocalTotalTime(), true, false, true, false, false, true) : t <= 0 && this.Interpolate(0, true, false, true, false, false, true);
      }
    }
    _SetUpdateState() {
      for (let t = 0, e = this._propertyTracks.length; t < e; t++) {
        const e2 = this._propertyTracks[t];
        e2._SetUpdateState(), 0 === this._worldInfoChange && 1 === e2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e2.GetRenderChange() && (this._renderChange = 1);
      }
    }
    BeforeInterpolate(t, e = false) {
      const a = this._propertyTracks.length;
      for (let s = 0; s < a; s++) this._propertyTracks[s].BeforeInterpolate(t, e);
    }
    Interpolate(t, e = false, a = false, s = false, r = false, i = false, n = false) {
      this._instance || this.GetInstance();
      const h = this._instance && !this._instance.IsDestroyed(), o = 0 === this._trackDataItem._type;
      if ((h || !o) && !(i && o && this.GetObjectClass().IsGlobal() || (t -= this.GetStartOffset()) < 0)) {
        this.MaybeSetInitialStateOfNestedTrack(t, e), this.MaybeTriggerKeyframeReachedConditions(t, e, r), !this.GetTimeline().IsPlaying() && this.GetTimeline().GetStoppedOnKeyframe() && (t = this.GetTimeline().GetStoppedOnKeyframe().GetTime());
        for (let e2 = 0, r2 = this._propertyTracks.length; e2 < r2; e2++) this._propertyTracks[e2].Interpolate(t, a, s, n);
        this.MaybeSetEndStateOfNestedTrack(t, e), 0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged());
      }
    }
    AfterInterpolate(t, e = false) {
      const a = this._propertyTracks.length;
      for (let s = 0; s < a; s++) this._propertyTracks[s].AfterInterpolate(t, e);
    }
    MaybeSetInitialStateOfNestedTrack(t, e) {
      if (!e) return;
      if (!this._isNested) return;
      if (this._initialStateOfNestedSet) return;
      if (this.GetTimeline().IsForwardPlayBack()) {
        if (t < 0) return;
      } else if (t > this.GetLocalTotalTime()) return;
      for (const t2 of this._propertyTracks) t2.SetInitialState();
      this._initialStateOfNestedSet = true;
    }
    MaybeSetEndStateOfNestedTrack(t, e) {
      if (!e) return;
      if (!this._isNested) return;
      if (this._endStateOfNestedSet) return;
      if (this.GetTimeline().IsForwardPlayBack()) {
        if (t >= this.GetLocalTotalTime()) {
          for (const t2 of this._propertyTracks) t2.Interpolate(this.GetLocalTotalTime(), false, true);
          this._endStateOfNestedSet = true;
        }
      } else if (t <= 0) {
        for (const t2 of this._propertyTracks) t2.Interpolate(0, false, true);
        this._endStateOfNestedSet = true;
      }
    }
    MaybeTriggerKeyframeReachedConditions(t, e, a) {
      if (this._keyframeReachedOnCurrentTick = null, a) return;
      if (!e) return;
      if (!C32.Plugins.Timeline) return;
      const s = this.GetTimeline();
      if (s.IsForwardPlayBack()) {
        const e2 = this._lastKeyframeDataItem.GetNext(), a2 = this._lastKeyframeDataItem.GetTime(), r = e2 ? e2.GetTime() : s.GetTotalTime();
        (t <= a2 || t >= r) && (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem), e2 && this.OnKeyframeReached(this._lastKeyframeDataItem));
      } else {
        if (!this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem)) return;
        this._lastKeyframeDataItem || (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem));
        const e2 = this._lastKeyframeDataItem.GetLast(), a2 = this._lastKeyframeDataItem.GetTime(), s2 = e2 ? e2.GetTime() : 0;
        (t >= a2 || t <= s2) && (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem), this._lastKeyframeDataItem && this.OnKeyframeReached(this._lastKeyframeDataItem));
      }
    }
    _GetLastKeyFrameBeforeTime(t) {
      const e = this._trackData.GetKeyFrameDataItemAtTime(t, this._trackDataItem);
      return e || this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem);
    }
    _GetFirstKeyFrameAfterTime(t) {
      const e = this._trackData.GetKeyFrameDataItemAtTime(t, this._trackDataItem);
      return e || this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem);
    }
    OnKeyframeReached(t, e = false) {
      if (!C32.Plugins.Timeline) return;
      const a = this.GetTimeline(), s = a.GetTimelineManager();
      C32.Plugins.Timeline.Cnds.PushTriggerTimeline(a), C32.Plugins.Timeline.Cnds.PushTriggerKeyframe(t), s.Trigger(C32.Plugins.Timeline.Cnds.OnAnyKeyframeReached), s.Trigger(C32.Plugins.Timeline.Cnds.OnKeyframeReached), a.IsPlaying() || e || a.SetStoppedOnKeyframe(t), C32.Plugins.Timeline.Cnds.PopTriggerTimeline(a), C32.Plugins.Timeline.Cnds.PopTriggerKeyframe(t), this._keyframeReachedOnCurrentTick = t;
    }
    WasKeyframeReachedOnCurrentTick() {
      return this._keyframeReachedOnCurrentTick;
    }
    OnInitialKeyframeReached(t) {
      this.OnKeyframeReached(t, true);
    }
    AddKeyframe() {
      return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem();
    }
    AddPropertyTrack() {
      const t = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem(), e = C32.PropertyTrackState.Create(this, t);
      return this._propertyTracks.push(e), e;
    }
    DeleteKeyframes(t) {
      this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(t);
    }
    DeletePropertyKeyframes(t) {
      for (const e of this._propertyTracks) e.DeletePropertyKeyframes(t);
    }
    SaveState() {
      for (const t of this._propertyTracks) t.SaveState();
    }
    CompareInitialStateWithCurrent() {
      if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) for (const t of this._propertyTracks) t.CompareInitialStateWithCurrent();
    }
    CompareSaveStateWithCurrent() {
      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
      let t = false;
      for (const e of this._propertyTracks) {
        const a = e.CompareSaveStateWithCurrent();
        !t && a && (t = true);
      }
      if (t) {
        const t2 = this.AddKeyframe();
        t2.SetTime(this.GetTimeline().GetTime()), t2.SetEase("noease"), t2.SetEnable(true), t2.SetTags("");
      }
    }
    _OnAfterLoad() {
      isNaN(this._instanceUidToLoad) || this._LoadInstanceFromJson(this._instanceUidToLoad), this._instanceUidToLoad = NaN;
    }
    _SaveToJson() {
      const t = this.GetInstance(), e = t ? t.GetUID() : this.GetInstanceUID();
      return { "propertyTracksJson": this._SavePropertyTracksToJson(), "lastKeyframeDataItemJson": this._SaveLastKeyframeDataItemToJson(), "initialStateOfNestedSet": this._initialStateOfNestedSet, "endStateOfNestedSet": this._endStateOfNestedSet, "instanceUid": e, "cleared": this._cleared };
    }
    _LoadFromJson(t) {
      if (t) {
        this._LoadPropertyTracksFromJson(t["propertyTracksJson"]), this._LoadLastKeyframeDataItemFromJson(t["lastKeyframeDataItemJson"]), this._instanceUidToLoad = t["instanceUid"], this._initialStateOfNestedSet = false, t.hasOwnProperty["initialStateOfNestedSet"] && (this._initialStateOfNestedSet = t["initialStateOfNestedSet"]), this._endStateOfNestedSet = false, t.hasOwnProperty["endStateOfNestedSet"] && (this._endStateOfNestedSet = t["endStateOfNestedSet"]), this._cleared = !!t.hasOwnProperty("cleared") && t["cleared"];
        for (const t2 of this._propertyTracks) 0 === this._worldInfoChange && 1 === t2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === t2.GetRenderChange() && (this._renderChange = 1);
        this._needsBeforeAndAfter = 0, this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
      }
    }
    _SaveLastKeyframeDataItemToJson() {
      return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem);
    }
    _SavePropertyTracksToJson() {
      return this._propertyTracks.map((t) => t._SaveToJson());
    }
    _LoadPropertyTracksFromJson(t) {
      t.forEach((t2, e) => {
        this._propertyTracks[e]._LoadFromJson(t2);
      });
    }
    _LoadInstanceFromJson(t) {
      if (!C32.IsFiniteNumber(t)) return;
      const e = this.GetRuntime().GetInstanceByUID(t);
      if (!e) return;
      this.GetTimeline().SetTrackInstance(this._trackDataItem.GetId(), e, this.GetTrackIndexInTimeline());
    }
    _LoadLastKeyframeDataItemFromJson(t) {
      const e = this._trackDataItem.GetKeyframeData();
      this._lastKeyframeDataItem = e.GetKeyframeDataItemFromIndex(t);
    }
  };
}
{
  const C32 = self.C3;
  C32.PropertyTrackState = class extends C32.DefendedBase {
    constructor(e, t) {
      super(), this._track = e, this._propertyTrackDataItem = t, this._propertyTrackData = t.GetPropertyTrackData(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0, this._sourceAdapter = this.GetSourceAdapter(), this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), this._lastPropertyKeyframeDataItem = null, this._absoluteValueObject = null;
    }
    static Create(e, t) {
      return C32.New(C32.PropertyTrackState, e, t);
    }
    Release() {
      this._track = null, this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null), this._propertyKeyframeDataItems = null, this._propertyTrackDataItem = null, this._propertyTrackData = null;
    }
    GetWorldInfoChange() {
      return this._worldInfoChange;
    }
    GetRenderChange() {
      return this._renderChange;
    }
    GetNeedsBeforeAndAfter() {
      return this._needsBeforeAndAfter;
    }
    HasAbsoluteValueObject() {
      return !!this._absoluteValueObject;
    }
    SetAbsoluteValueObject(e) {
      this._absoluteValueObject = e;
    }
    GetAbsoluteValueObject() {
      return this._absoluteValueObject;
    }
    GetTrack() {
      return this._track;
    }
    GetPropertyTrackDataItem() {
      return this._propertyTrackDataItem;
    }
    GetPropertyTrackData() {
      return this._propertyTrackData;
    }
    GetTimeline() {
      return this._track.GetTimeline();
    }
    GetRuntime() {
      return this._track.GetRuntime();
    }
    GetInstance() {
      return this._track.GetInstance();
    }
    GetSourceAdapter() {
      if (this._sourceAdapter) return this._sourceAdapter;
      let e;
      switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
        case "behavior":
          e = new C32.PropertyTrackState.BehaviorSourceAdapter(this);
          break;
        case "effect":
          e = new C32.PropertyTrackState.EffectSourceAdapter(this), this._renderChange = 1;
          break;
        case "instance-variable":
          e = new C32.PropertyTrackState.InstanceVariableSourceAdapter(this);
          break;
        case "plugin":
          e = new C32.PropertyTrackState.PluginSourceAdapter(this), this._renderChange = 1;
          break;
        case "world-instance":
          e = new C32.PropertyTrackState.PropertySourceAdapter(this), this._renderChange = 1, this._worldInfoChange = 1;
          break;
        case "value":
          e = new C32.PropertyTrackState.ValueSourceAdapter(this);
          break;
        case "audio":
          e = new C32.PropertyTrackState.AudioSourceAdapter(this);
      }
      return this._sourceAdapter = e, this._sourceAdapter;
    }
    GetSourceAdapterId() {
      return this._propertyTrackDataItem.GetSourceAdapterId();
    }
    SetSourceAdapterId(e) {
      this._propertyTrackDataItem.SetSourceAdapterId(e);
    }
    GetSourceAdapterArgs() {
      return this._propertyTrackDataItem.GetSourceAdapterArguments();
    }
    SetSourceAdapterArgs(e) {
      this._propertyTrackDataItem.SetSourceAdapterArguments(e);
    }
    GetSourceAdapterValue() {
      return this.GetSourceAdapter().GetValue();
    }
    GetPropertyName() {
      return this._propertyTrackDataItem.GetProperty();
    }
    SetPropertyName(e) {
      this._propertyTrackDataItem.SetProperty(e);
    }
    GetPropertyType() {
      return this._propertyTrackDataItem.GetType();
    }
    SetPropertyType(e) {
      this._propertyTrackDataItem.SetType(e);
    }
    GetPropertyKeyframeType() {
      return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType();
    }
    GetMin() {
      return this._propertyTrackDataItem.GetMin();
    }
    SetMin(e) {
      this._propertyTrackDataItem.SetMin(e);
    }
    GetMax() {
      return this._propertyTrackDataItem.GetMax();
    }
    SetMax(e) {
      this._propertyTrackDataItem.SetMax(e);
    }
    GetEnable() {
      return this._propertyTrackDataItem.GetEnable();
    }
    SetEnable(e) {
      this._propertyTrackDataItem.SetEnable(e);
    }
    GetInterpolationMode() {
      return this._propertyTrackDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(e) {
      this._propertyTrackDataItem.SetInterpolationMode(e);
    }
    GetResultMode() {
      return this._propertyTrackDataItem.GetResultMode();
    }
    SetResultMode(e) {
      this._propertyTrackDataItem.SetResultMode(e);
    }
    SetEase(e) {
      for (const t of this.GetPropertyKeyframeDataItems()) t.SetEase(e);
    }
    CanHavePropertyKeyframes() {
      return this._propertyTrackDataItem.CanHavePropertyKeyframes();
    }
    GetPropertyKeyframeDataItems() {
      return this._propertyKeyframeDataItems || (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()), this._propertyKeyframeDataItems;
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled() {
      return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled();
    }
    GetPropertyKeyFrameDataItemAtTime(e) {
      return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e) {
      return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
    }
    GetPropertyKeyframeDataItemPairForTime(e) {
      let t, r = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
      return r ? t = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(e, this._propertyTrackDataItem) : (r = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), t = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem)), { start: r, end: t };
    }
    *GetPropertyKeyframeValues() {
      for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetValueWithResultMode();
    }
    *GetPropertyKeyframeTimes() {
      for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetTime();
    }
    TimelineRemoved() {
      this.GetSourceAdapter().TimelineRemoved();
    }
    CleanCaches() {
      this.GetSourceAdapter().CleanCaches();
    }
    GetCurrentState() {
      return this.GetSourceAdapter().GetCurrentState();
    }
    SetResetState() {
      this.GetSourceAdapter().SetResetState();
    }
    SetInitialState(e) {
      this.GetSourceAdapter().SetInitialState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e), this._SetUpdateState();
    }
    SetResumeState(e) {
      this.GetSourceAdapter().SetResumeState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e);
    }
    _SetUpdateState() {
      const e = this.GetTrack();
      if (this._needsBeforeAndAfter = 0, e.IsInstanceTrack()) {
        const t = this.GetTimeline(), r = e.GetInstance(), a = this.GetSourceAdapter(), o = this.GetPropertyName();
        if (a.MayNeedBeforeAndAfterInterpolate()) {
          const e2 = t.GetSimilarPropertyTracks(r, a, o, this);
          e2 && e2.length && (this._needsBeforeAndAfter = 1);
        } else this._needsBeforeAndAfter = 0;
      }
    }
    _GetLastPropertyKeyFrameBeforeTime(e) {
      const t = this.GetTimeline(), r = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
      return r || (t.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem));
    }
    BeforeInterpolate(e, t) {
      let r, a;
      if (t) r = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
      else {
        if (this._lastPropertyKeyframeDataItem) {
          const t2 = this.GetTimeline(), r2 = this._lastPropertyKeyframeDataItem.GetNext(), a2 = this._lastPropertyKeyframeDataItem.GetTime(), o = r2 ? r2.GetTime() : t2.GetTotalTime();
          (e <= a2 || e >= o) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem));
        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
        r = this._lastPropertyKeyframeDataItem;
      }
      r && (a = r.GetNext()), this._sourceAdapter.BeforeInterpolate(r, a);
    }
    Interpolate(e, t = false, r = false, a = false) {
      let o, s, p = false;
      if (t) o = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
      else {
        if (this._lastPropertyKeyframeDataItem) {
          const t2 = this.GetTimeline(), r2 = this._lastPropertyKeyframeDataItem.GetNext(), a2 = this._lastPropertyKeyframeDataItem.GetTime(), o2 = r2 ? r2.GetTime() : t2.GetTotalTime();
          (e <= a2 || e >= o2) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true);
        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true;
        o = this._lastPropertyKeyframeDataItem;
      }
      o && (s = o.GetNext()), this._sourceAdapter.Interpolate(e, o, s, t, r, a, p);
    }
    GetInterpolatedValue(e) {
      if (this._lastPropertyKeyframeDataItem) {
        const t2 = this.GetTimeline(), r2 = this._lastPropertyKeyframeDataItem.GetNext(), a = this._lastPropertyKeyframeDataItem.GetTime(), o = r2 ? r2.GetTime() : t2.GetTotalTime();
        (e <= a || e >= o) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem));
      } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
      const t = this._lastPropertyKeyframeDataItem, r = t.GetNext();
      return this._sourceAdapter.GetInterpolatedValue(e, t, r);
    }
    GetInterpolatedValueFast(e, t, r) {
      return this._sourceAdapter.GetInterpolatedValue(e, t, r);
    }
    AfterInterpolate(e, t) {
      let r, a;
      if (t) r = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
      else {
        if (this._lastPropertyKeyframeDataItem) {
          const t2 = this.GetTimeline(), r2 = this._lastPropertyKeyframeDataItem.GetNext(), a2 = this._lastPropertyKeyframeDataItem.GetTime(), o = r2 ? r2.GetTime() : t2.GetTotalTime();
          (e <= a2 || e >= o) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem));
        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
        r = this._lastPropertyKeyframeDataItem;
      }
      r && (a = r.GetNext()), this._sourceAdapter.AfterInterpolate(r, a);
    }
    static GetStartPropertyKeyframeForTime(e, t) {
      const r = t.GetPropertyTrackDataItem();
      return t._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, r);
    }
    static GetEndPropertyKeyframeForTime(e, t) {
      const r = t.GetPropertyTrackDataItem();
      return t._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, r);
    }
    static GetPropertyKeyframeValueWithPlaybackDirection(e, t, r) {
      return t ? r.GetTimeline().IsForwardPlayBack() ? e.GetValueWithResultMode() : t.GetValueWithResultMode() : e.GetValueWithResultMode();
    }
    AddPropertyKeyframe() {
      const e = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
      return this._lastPropertyKeyframeDataItem = null, e;
    }
    DeletePropertyKeyframes(e) {
      this._lastPropertyKeyframeDataItem = null;
      this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(e);
    }
    SaveState() {
      this.GetSourceAdapter().SaveState();
    }
    CompareInitialStateWithCurrent() {
      if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
        const e = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem), t = this.GetSourceAdapter().GetCurrentState();
        e.SetAbsoluteValue(t);
      }
    }
    CompareSaveStateWithCurrent() {
      const e = this.GetSourceAdapter().CompareSaveStateWithCurrent();
      return e && this.AddPropertyKeyframeAtCurrentTime(), this.GetSourceAdapter().ClearSaveState(), e;
    }
    AddPropertyKeyframeAtCurrentTime() {
      const e = this.GetTimeline().GetTime(), t = this.GetSourceAdapter(), r = C32.PropertyTrackState.GetStartPropertyKeyframeForTime(e, this), a = this.AddPropertyKeyframe();
      a.SetType(r.GetType()), a.SetTime(e), a.SetEase(r.GetEase()), a.SetEnable(true), a.SetValue(t.GetValueAtTime()), a.SetAbsoluteValue(t.GetCurrentState());
    }
    _SaveToJson() {
      return { "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson() };
    }
    _LoadFromJson(e) {
      e && this.GetSourceAdapter()._LoadFromJson(e["sourceAdapterJson"]);
    }
  };
}
{
  const C32 = self.C3, NS = C32.PropertyTrackState;
  NS.PropertySourceAdapter = class {
    constructor(e) {
      this._propertyTrack = e, this._propertyAdapter = null, this.GetPropertyAdapter();
    }
    Release() {
      this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null), this._propertyTrack = null;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate();
    }
    GetPropertyTrack() {
      return this._propertyTrack;
    }
    TimelineRemoved() {
      this._propertyAdapter && this._propertyAdapter.TimelineRemoved();
    }
    CleanCaches() {
      this._propertyAdapter && this._propertyAdapter.CleanCaches();
    }
    GetPropertyAdapter() {
      return this._propertyAdapter || (this._propertyAdapter = this._CreatePropertyAdapter()), this._propertyAdapter;
    }
    GetEditorIndex() {
    }
    GetIndex() {
      return this.GetEditorIndex();
    }
    GetTarget() {
    }
    SetResetState() {
      this.GetPropertyAdapter().SetResetState();
    }
    SetInitialState() {
      this.GetPropertyAdapter().SetInitialState();
    }
    SetResumeState() {
      this.GetPropertyAdapter().SetResumeState();
    }
    BeforeInterpolate(e, t) {
      this._propertyAdapter.BeforeChangeProperty(e, t);
    }
    Interpolate(e, t, r, p, a, o, n) {
      let s;
      switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
          s = NS.NumericTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
          break;
        case "angle":
          s = NS.AngleTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
          break;
        case "boolean":
          s = NS.BooleanTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
          break;
        case "color":
          s = NS.ColorTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
          break;
        case "text":
          s = NS.TextTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
      }
      this._propertyAdapter.ChangeProperty(e, s, t, r, p, a, o, n);
    }
    GetInterpolatedValue(e, t, r) {
      switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
          return NS.NumericTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
        case "angle":
          return NS.AngleTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
        case "boolean":
          return NS.BooleanTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
        case "color":
          return NS.ColorTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
        case "text":
          return NS.TextTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
      }
    }
    AfterInterpolate(e, t) {
      this._propertyAdapter.AfterChangeProperty(e, t);
    }
    SaveState() {
      this.GetPropertyAdapter().SetSaveState();
    }
    ClearSaveState() {
      this.GetPropertyAdapter().ClearSaveState();
    }
    GetCurrentState() {
      return this.GetPropertyAdapter().GetCurrentState();
    }
    CompareInitialStateWithCurrent() {
      return this.GetPropertyAdapter().CompareInitialStateWithCurrent();
    }
    CompareSaveStateWithCurrent() {
      return this.GetPropertyAdapter().CompareSaveStateWithCurrent();
    }
    GetValueAtTime() {
      const e = this._propertyTrack, t = e.GetTrack().GetTimeline().GetTime(), r = NS.GetStartPropertyKeyframeForTime(t, e), p = r.GetNext();
      switch (e.GetPropertyKeyframeType()) {
        case "numeric":
          return NS.NumericTypeAdapter.Interpolate(t, r, p, e);
        case "angle":
          return NS.AngleTypeAdapter.Interpolate(t, r, p, e);
        case "boolean":
          return NS.BooleanTypeAdapter.Interpolate(t, r, p, e);
        case "color":
          return NS.ColorTypeAdapter.Interpolate(t, r, p, e);
        case "text":
          return NS.TextTypeAdapter.Interpolate(t, r, p, e);
      }
    }
    _CreatePropertyAdapter() {
      const e = this._propertyTrack;
      switch (e.CanHavePropertyKeyframes() ? e.GetPropertyKeyframeType() : "") {
        case "combo":
        case "boolean":
        case "text":
        case "string":
          return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
        case "numeric":
        case "number":
        case "angle":
          return "combo" === this._propertyTrack.GetPropertyType() ? new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
        case "color":
        case "offsetColor":
          return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);
        default:
          return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
      }
    }
    _SaveToJson() {
      return { "propertyAdapterJson": this.GetPropertyAdapter()._SaveToJson() };
    }
    _LoadFromJson(e) {
      e && this.GetPropertyAdapter()._LoadFromJson(e["propertyAdapterJson"]);
    }
  };
}
{
  const C32 = self.C3, INDEX = 0;
  class InstanceVariableSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(e) {
      super(e), this._updatedIndex = NaN;
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
    }
    GetIndex() {
      return this._updatedIndex ? this._updatedIndex : super.GetIndex();
    }
    GetTarget() {
      return this._propertyTrack.GetTrack().GetInstance();
    }
    UpdateInstanceVariableIndex(e) {
      this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== e && (this._updatedIndex = e);
    }
    Interpolate(e, t, r, a, n, d, p) {
      this.GetPropertyAdapter().CanChange(t.GetValue()) && super.Interpolate(e, t, r, a, n, d, p);
    }
    GetInterpolatedValue(e, t, r) {
      if (this.GetPropertyAdapter().CanChange(t.GetValue())) return super.GetInterpolatedValue(e, t, r);
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "index": this._updatedIndex });
    }
    _LoadFromJson(e) {
      e && (super._LoadFromJson(e), this._updatedIndex = e["index"]);
    }
  }
  C32.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;
}
{
  const C32 = self.C3, SID = 0, INDEX = 1, NAME = 2;
  class BehaviorSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(e) {
      super(e), this._sid = NaN;
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1];
    }
    GetTarget() {
      const e = this._propertyTrack.GetPropertyTrackDataItem(), t = this._propertyTrack.GetTrack(), r = this._sid ? this._sid : e.GetSourceAdapterArguments()[0], a = t.GetInstance(), s = a.GetBehaviorIndexBySID(r);
      return a.GetBehaviorInstances()[s].GetSdkInstance();
    }
    GetBehaviorType(e) {
      const t = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
      return e.GetBehaviorTypeByName(t);
    }
    UpdateBehaviorTypeSid(e) {
      this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== e && (this._sid = e);
    }
    Interpolate(e, t, r, a, s, o, p) {
      const c = this._propertyTrack.GetTrack().GetInstance();
      this.GetBehaviorType(c.GetObjectClass()) && super.Interpolate(e, t, r, a, s, o, p);
    }
    GetInterpolatedValue(e, t, r) {
      const a = this._propertyTrack.GetTrack().GetInstance();
      if (this.GetBehaviorType(a.GetObjectClass())) return super.GetInterpolatedValue(e, t, r);
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "sid": this._sid });
    }
    _LoadFromJson(e) {
      e && (super._LoadFromJson(e), this._sid = e["sid"]);
    }
  }
  C32.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;
}
{
  const C32 = self.C3, NAME = 0, INDEX = 1;
  class EffectSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(e) {
      super(e);
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1];
    }
    GetTarget() {
      const e = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList(), t = e.GetEffectList(), r = this.GetEffectType(t).GetIndex();
      return e.IsEffectIndexActive(r) ? e.GetEffectParametersForIndex(r) : null;
    }
    GetEffectType(e) {
      const t = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
      return e.GetEffectTypeByName(t);
    }
    Interpolate(e, t, r, c, f, a, s) {
      this._IsEffectActive() && super.Interpolate(e, t, r, c, f, a, s);
    }
    GetInterpolatedValue(e, t, r) {
      if (this._IsEffectActive()) return super.GetInterpolatedValue(e, t, r);
    }
    _IsEffectActive() {
      const e = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList(), t = e.GetEffectList(), r = this.GetEffectType(t);
      if (!r) return;
      const c = r.GetIndex();
      return e.IsEffectIndexActive(c);
    }
  }
  C32.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;
}
{
  const C32 = self.C3, INDEX = 0, UNIQUE_PROPERTIES = 1, SPRITE_START_FROM_UNIQUE_PROPERTY = 0;
  class PluginSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(e) {
      super(e), this._optionalCallbacksRelative = null, this._optionalCallbacksAbsolute = null, this._forceNextChange = false;
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
    }
    GetTarget() {
      return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance();
    }
    Interpolate(e, t, r, a, i, n, s) {
      const o = this._propertyTrack.GetTrack();
      o.GetObjectClass().GetPlugin() === o.GetInstance().GetObjectClass().GetPlugin() && super.Interpolate(e, t, r, a, i, n, s);
    }
    GetInterpolatedValue(e, t, r) {
      const a = this._propertyTrack.GetTrack();
      if (a.GetObjectClass().GetPlugin() === a.GetInstance().GetObjectClass().GetPlugin()) return super.GetInterpolatedValue(e, t, r);
    }
    _IsTimelineChunkDiscreteLike(e, t) {
      if (!t) return true;
      if (e?.GetValueWithResultMode() === t?.GetValueWithResultMode()) return true;
      const r = this._propertyTrack?.GetInterpolationMode();
      return "discrete" === r;
    }
    _WasKeyframeReached(e, t, r) {
      const a = e.WasKeyframeReachedOnCurrentTick();
      if (!a) return false;
      return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? a.GetTime() === t.GetTime() : a.GetTime() === r.GetTime();
    }
    SetResetState() {
      this.GetPropertyAdapter().SetResetState();
      const e = this._propertyTrack.GetTrack().GetObjectClass().GetPlugin();
      this._forceNextChange = false, C32.Plugins.Sprite && e instanceof C32.Plugins.Sprite && "initial-animation" === this._propertyTrack.GetPropertyName() && (this._forceNextChange = true);
    }
    ForceChanges() {
      const e = this._forceNextChange;
      return this._forceNextChange = false, e;
    }
    GetOptionalCallbacks(e, t) {
      const r = this._propertyTrack.GetTrack(), a = r.GetObjectClass().GetPlugin();
      if (C32.Plugins.Sprite && a instanceof C32.Plugins.Sprite && ("initial-frame" === this._propertyTrack.GetPropertyName() || "initial-animation" === this._propertyTrack.GetPropertyName())) switch (this._propertyTrack.GetResultMode()) {
        case "relative":
          return this._optionalCallbacksRelative ? (this._optionalCallbacksRelative.startFrom = e.GetAddOn("initial-animation")?.GetStartFrom() ?? 0, this._optionalCallbacksRelative.keyframeReached = this._WasKeyframeReached(r, e, t), this._optionalCallbacksRelative.isChunkDiscreteLike = this._IsTimelineChunkDiscreteLike(e, t), this._optionalCallbacksRelative) : (this._optionalCallbacksRelative = { onFrameChange: (e2, t2, a2, i, n) => {
            if (t2 !== i) {
              const a3 = i / t2, n2 = r.GetPropertyTrack("offsetWidth"), s = r.GetPropertyTrack("offsetScaleX");
              if (n2 || s) {
                const o = n2?.GetSourceAdapter()?.GetPropertyAdapter(), c = s?.GetSourceAdapter()?.GetPropertyAdapter();
                if (e2.HasParent() && e2.GetTransformWithParentWidth()) c && c.SetOriginalSizeProperty(i), e2.SetWidth(this.GetNewWidth(i, t2, e2, r, o, c));
                else {
                  const t3 = i * ((e2._GetSceneGraphInfo()?._GetStartWidth() ?? this.GetInstanceOriginalWidth(e2, r)) / this.GetInstanceOriginalWidth(e2, r));
                  c && c.SetOriginalSizeProperty(i);
                  const n3 = o?.GetChangeAccumulatorProperty() ?? 0, s2 = c?.GetChangeAccumulatorProperty() ?? 0;
                  e2.SetWidth(t3 + (n3 + s2 * a3));
                }
              } else e2.SetWidth(e2.GetWidth() * a3);
            }
            if (a2 !== n) {
              const t3 = n / a2, i2 = r.GetPropertyTrack("offsetHeight"), s = r.GetPropertyTrack("offsetScaleY");
              if (i2 || s) {
                const o = i2?.GetSourceAdapter()?.GetPropertyAdapter(), c = s?.GetSourceAdapter()?.GetPropertyAdapter();
                if (e2.HasParent() && e2.GetTransformWithParentHeight()) c && c.SetOriginalSizeProperty(n), e2.SetHeight(this.GetNewHeight(n, a2, e2, r, o, c));
                else {
                  const a3 = n * ((e2._GetSceneGraphInfo()?._GetStartHeight() ?? this.GetInstanceOriginalHeight(e2, r)) / this.GetInstanceOriginalHeight(e2, r));
                  c && c.SetOriginalSizeProperty(n);
                  const i3 = o?.GetChangeAccumulatorProperty() ?? 0, s2 = c?.GetChangeAccumulatorProperty() ?? 0;
                  e2.SetHeight(a3 + (i3 + s2 * t3));
                }
              } else e2.SetHeight(e2.GetHeight() * t3);
            }
          }, startFrom: e.GetAddOn("initial-animation")?.GetStartFrom() ?? 0, keyframeReached: this._WasKeyframeReached(r, e, t), isChunkDiscreteLike: this._IsTimelineChunkDiscreteLike(e, t) }, this._optionalCallbacksRelative);
        case "absolute":
          return this._optionalCallbacksAbsolute ? (this._optionalCallbacksAbsolute.startFrom = e.GetAddOn("initial-animation")?.GetStartFrom() ?? 0, this._optionalCallbacksAbsolute.keyframeReached = this._WasKeyframeReached(r, e, t), this._optionalCallbacksAbsolute.isChunkDiscreteLike = this._IsTimelineChunkDiscreteLike(e, t), this._optionalCallbacksAbsolute) : (this._optionalCallbacksAbsolute = { startFrom: e.GetAddOn("initial-animation")?.GetStartFrom() ?? 0, keyframeReached: this._WasKeyframeReached(r, e, t), isChunkDiscreteLike: this._IsTimelineChunkDiscreteLike(e, t) }, this._optionalCallbacksAbsolute);
      }
    }
    GetLastPropertyKeyframeValue(e, t, r, a = 0) {
      const i = t.GetTimeline().GetTrackFromInstance(e.GetInstance());
      if (!i) return a;
      const n = i.GetPropertyTrack(r);
      if (!n) return a;
      const s = n.GetPropertyTrackDataItem().GetPropertyKeyframeData();
      if (!s) return a;
      const o = s.GetLastPropertyKeyframeDataItem();
      return o ? o.GetValue() : a;
    }
    GetInstanceOriginalWidth(e, t) {
      const r = t.GetTimeline().GetTrackFromInstance(e.GetInstance());
      if (r) return r.GetOriginalWidth();
      const a = e.GetInstance().GetSdkInstance();
      return a.IsOriginalSizeKnown() ? a.GetOriginalWidth() : e._GetSceneGraphInfo()._GetStartWidth();
    }
    GetInstanceOriginalHeight(e, t) {
      const r = t.GetTimeline().GetTrackFromInstance(e.GetInstance());
      if (r) return r.GetOriginalHeight();
      const a = e.GetInstance().GetSdkInstance();
      return a.IsOriginalSizeKnown() ? a.GetOriginalHeight() : e._GetSceneGraphInfo()._GetStartHeight();
    }
    GetNewWidth(e, t, r, a, i, n) {
      const s = r._GetSceneGraphInfo()._GetStartWidth(), o = s / r.GetParent()._GetSceneGraphInfo()._GetStartWidth();
      let c = 1;
      const l = n?.GetAbsoluteScaleXOffsetProperty() ?? 0;
      if (0 !== l) {
        const e2 = s / this.GetInstanceOriginalWidth(r, a);
        c = (e2 + l) / (0 === e2 ? Number.EPSILON : e2);
      }
      const G = s * (e / t);
      let h = i?.GetAbsoluteWidthOffsetProperty() ?? 0;
      h += G - s;
      const p = (s + h) / (0 === s ? Number.EPSILON : s);
      return r.GetParent().GetWidth() * o * c * p;
    }
    GetNewHeight(e, t, r, a, i, n) {
      const s = r._GetSceneGraphInfo()._GetStartHeight(), o = s / r.GetParent()._GetSceneGraphInfo()._GetStartHeight();
      let c = 1;
      const l = n?.GetAbsoluteScaleYOffsetProperty() ?? 0;
      if (0 !== l) {
        const e2 = s / this.GetInstanceOriginalHeight(r, a);
        c = (e2 + l) / (0 === e2 ? Number.EPSILON : e2);
      }
      const G = s * (e / t);
      let h = i?.GetAbsoluteHeightOffsetProperty() ?? 0;
      h += G - s;
      const p = (s + h) / (0 === s ? Number.EPSILON : s);
      return r.GetParent().GetHeight() * o * c * p;
    }
  }
  C32.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;
}
{
  const C32 = self.C3;
  class ValueSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(t) {
      super(t), this._value = 0, this._init = false;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return false;
    }
    SetInitialState() {
      const t = this._propertyTrack.GetPropertyTrackData();
      let e = this._propertyTrack.GetPropertyTrackDataItem();
      e = t.GetFirstPropertyKeyframeDataItem(e), this._value = e.GetValueWithResultMode();
    }
    SetResumeState() {
    }
    GetValue() {
      return this._init || this._propertyTrack.Interpolate(0), this._value;
    }
    Interpolate(t, e, r, a, i, o, u) {
      this._value = C32.PropertyTrackState.NumericTypeAdapter.Interpolate(t, e, r, this._propertyTrack), this._init = true;
    }
    SaveState() {
    }
    ClearSaveState() {
    }
    GetCurrentState() {
      return this._value;
    }
    CompareInitialStateWithCurrent() {
      return false;
    }
    CompareSaveStateWithCurrent() {
      return false;
    }
    _SaveToJson() {
      return { "value": this._value, "init": this._init };
    }
    _LoadFromJson(t) {
      t && (this._value = t["value"], this._init = !t.hasOwnProperty("init") || t["init"]);
    }
  }
  C32.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;
}
{
  const C32 = self.C3, PROJECT_FILE = 0, PROJECT_FILE_NAME = 0, PROJECT_FILE_TYPE = 1, START_OFFSET = 1, AUDIO_DURATION = 2, AUDIO_TAG = 3;
  class AudioSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(t) {
      super(t), this._audioPlaybackStarted = false, this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = this._propertyTrack.GetTimeline(), this._track = this._propertyTrack.GetTrack(), this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs(), this._fileArgs = this._sourceAdapterArgs[0], this._startOffsetTime = this._sourceAdapterArgs[1], this._sourceAdapterArgs[3] ? this._audioTag = this._sourceAdapterArgs[3] : this._audioTag = Math.random().toString(36).slice(2), this._pauseTime = NaN, this._pauseVolume = NaN, this._volume = NaN, this._audioSource = null, this._Initialize();
    }
    Release() {
      super.Release(), this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = null, this._track = null, this._sourceAdapterArgs = null, this._fileArgs = null, this._audioSource = null;
    }
    _Initialize() {
      if (!self.C3.Plugins.Audio) return;
      const t = this._propertyTrack.GetRuntime().GetSingleGlobalObjectClassByCtor(self.C3.Plugins.Audio);
      t && (this._sdkInstance = t.GetSingleGlobalInstance().GetSdkInstance()), this._actions = self.C3.Plugins.Audio.Acts, this._expressions = self.C3.Plugins.Audio.Exps;
    }
    _MaybeSetAudioSource() {
      if (this._audioSource) return;
      const t = this._propertyTrack.GetTrack().GetPropertyTrack("audioSource");
      t && (this._audioSource = t.GetSourceAdapter());
    }
    _GetPauseVolume() {
      const t = this._propertyTrack.GetTrack().GetPropertyTrack("volume");
      return t ? t.GetSourceAdapter()._pauseVolume : this._pauseVolume;
    }
    TimelineRemoved() {
      super.TimelineRemoved(), this._audioPlaybackStarted = false, this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag), this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)), this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));
    }
    GetAudioTag() {
      return this._audioTag;
    }
    GetVolume() {
      return this._volume;
    }
    SetVolume(t) {
      this._volume = t;
    }
    SetInitialState() {
      super.SetInitialState(), this._pauseTime = NaN, this._audioPlaybackStarted = false;
    }
    SetResumeState() {
      super.SetResumeState();
      const t = this._propertyTrack.GetTimeline().GetTime();
      switch (this._pauseTime = t - this._startOffsetTime, this._propertyTrack.GetPropertyName()) {
        case "audioSource":
          break;
        case "volume":
          this._pauseVolume = this._propertyTrack.GetInterpolatedValue(t);
      }
      this._audioPlaybackStarted = false;
    }
    Interpolate(t, e, s, i, a, o, r) {
      if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
        case "audioSource": {
          if (!this._timeline.IsForwardPlayBack()) return;
          if (i) return void (this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));
          if (t < this._startOffsetTime) return void (this._audioPlaybackStarted = false);
          const e2 = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag), s2 = this._timeline.GetPlaybackRate();
          if (s2 !== e2 && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, s2), this._audioPlaybackStarted) return;
          if (!this._propertyTrack.GetTimeline().IsPlaying()) return;
          if (this._audioPlaybackStarted = true, isNaN(this._pauseTime)) {
            const e3 = self["performance"].now(), s3 = t - this._startOffsetTime;
            if ("suspended" === this._sdkInstance.GetAudioContextState()) return void (this._audioPlaybackStarted = false);
            const i2 = s3 + (self["performance"].now() - e3) / 1e3;
            if (this._actions) {
              let t2 = this.GetVolume();
              isNaN(t2) ? (this.SetVolume(0), t2 = 0) : this.SetVolume(t2), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, t2, this._audioTag, i2);
            }
          } else {
            const t2 = this._pauseTime;
            this._pauseTime = NaN;
            const e3 = this._GetPauseVolume();
            this._pauseVolume = NaN;
            if ("suspended" === this._sdkInstance.GetAudioContextState()) return void (this._audioPlaybackStarted = false);
            this._actions && (this.SetVolume(e3), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, e3, this._audioTag, t2));
          }
          break;
        }
        case "volume":
          this._MaybeSetAudioSource(), super.Interpolate(t, e, s, i, a, o, r);
      }
    }
    GetInterpolatedValue(t, e, s) {
      if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
        case "audioSource":
          return;
        case "volume":
          return this._MaybeSetAudioSource(), super.GetInterpolatedValue(t, e, s);
      }
    }
    Getter(t, e) {
      return this._audioSource ? this._audioSource.GetVolume() : 0;
    }
    Setter(t, e, s, i) {
      this._audioSource && this._audioSource.SetVolume(this.Getter() + e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());
    }
    AbsoluteSetter(t, e, s) {
      this._audioSource && this._audioSource.SetVolume(e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());
    }
    DoesRounding() {
      return true;
    }
    _SaveToJson() {
      return { "audioPlaybackStarted": this._audioPlaybackStarted, "audioTag": this._audioTag, "pauseTime": this._pauseTime, "pauseVolume": this._pauseVolume, "volume": this._volume };
    }
    _LoadFromJson(t) {
      t && (this._audioPlaybackStarted = t["audioPlaybackStarted"], this._audioTag = t["audioTag"], this._pauseTime = t["pauseTime"], this._pauseVolume = t["pauseVolume"], this._volume = t["volume"], this._Initialize());
    }
  }
  C32.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;
}
{
  const C32 = self.C3;
  C32.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(t) {
      this._sourceAdapter = t, this._propertyTrack = t.GetPropertyTrack(), this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(), this._property = this._propertyTrack.GetPropertyName(), this._firstAbsoluteUpdate = false, this._saveState = null, this._target = null;
    }
    Release() {
      this._sourceAdapter = null, this._propertyTrack = null, this._worldInfo = null, this._saveState = null, this._target = null;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return false;
    }
    TimelineRemoved() {
    }
    CleanCaches() {
      this._worldInfo = null, this._saveState = null, this._target = null;
    }
    GetSourceAdapter() {
      return this._sourceAdapter;
    }
    GetPropertyTrack() {
      return this._propertyTrack;
    }
    GetWorldInfo() {
      return this._worldInfo || (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()), this._worldInfo;
    }
    SetFirstAbsoluteUpdate(t) {
      this._firstAbsoluteUpdate = !!t;
    }
    GetFirstAbsoluteUpdate() {
      return this._firstAbsoluteUpdate;
    }
    SetResetState() {
    }
    SetInitialState() {
    }
    SetResumeState() {
    }
    SetSaveState() {
      this._saveState = this.GetCurrentState();
    }
    ClearSaveState() {
      this._saveState = null;
    }
    GetCurrentState() {
    }
    CompareInitialStateWithCurrent() {
    }
    CompareSaveStateWithCurrent() {
    }
    CanChange(t) {
      return typeof this._Getter() === typeof t;
    }
    BeforeChangeProperty(t, e) {
    }
    ChangeProperty(t, e, r, a, s, o, i, n) {
    }
    AfterChangeProperty(t, e) {
    }
    _FirstKeyframeGetter() {
      return this._PickTimelinePlaybackMode(() => {
        const t = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(t);
      }, () => {
        const t = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(t);
      }).GetAbsoluteValue();
    }
    _CurrentKeyframeGetter() {
      const t = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset();
      return this._PickTimelinePlaybackMode(() => {
        const e = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, e);
      }, () => {
        const e = this._propertyTrack.GetPropertyTrackDataItem(), r = this._propertyTrack.GetPropertyTrackData(), a = r.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, e);
        return a || r.GetLastPropertyKeyframeDataItem(e);
      }).GetAbsoluteValue();
    }
    _PickTimelinePlaybackMode(t, e) {
      return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? t() : e();
    }
    _PickResultMode(t, e) {
      return "relative" === this._propertyTrack.GetResultMode() ? t() : e();
    }
    _PickFirstAbsoluteUpdate(t, e) {
      return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(false), t()) : e();
    }
    _GetAbsoluteInitialValue(t) {
    }
    _GetIndex() {
      return this._sourceAdapter.GetIndex();
    }
    _GetTarget() {
      return this._target || (this._target = this._sourceAdapter.GetTarget()), this._target;
    }
    _PickSource(t, e, r, a, s, o) {
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          return t();
        case "effect":
          return e();
        case "instance-variable":
          return r();
        case "plugin":
          return a();
        case "world-instance":
          return s();
        case "audio":
          return o();
      }
    }
    _SaveToJson() {
      return { "firstAbsoluteUpdate": this._firstAbsoluteUpdate, "saveState": this._saveState };
    }
    _LoadFromJson(t) {
      t && (this._firstAbsoluteUpdate = t["firstAbsoluteUpdate"], this._saveState = t["saveState"]);
    }
    _GetPropertyKeyframeStubs(t, e = false) {
      const r = [];
      for (const a of t) {
        const t2 = a.GetTrack().GetStartOffset();
        for (const s of a.GetPropertyKeyframeDataItems()) e && 0 === s.GetTime() ? r.push({ time: t2 + s.GetTime(), value: s.GetAbsoluteValue() }) : e || r.push({ time: t2 + s.GetTime(), value: s.GetAbsoluteValue() });
      }
      return r.sort((t2, e2) => t2.time - e2.time);
    }
    _GetLastPropertyKeyframeStub(t, e, r) {
      return this._GetPropertyKeyframeStubLowerThanPlayhead(e, r);
    }
    _GetPropertyKeyframeStubLowerThanPlayhead(t, e) {
      for (let r = e.length - 1; r >= 0; r--) {
        if (e[r].time <= t) return e[r];
      }
      return null;
    }
  };
}
{
  const C32 = self.C3, TMP_COLORS_MAP = /* @__PURE__ */ new Map(), TMP_COLOR = [0, 0, 0];
  class ColorInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(e) {
      super(e);
    }
    SetResetState() {
    }
    SetInitialState() {
    }
    SetResumeState() {
    }
    GetCurrentState() {
      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();
      switch (e) {
        case "behavior":
        case "plugin":
          return this._ToColorArray(t.GetPropertyValueByIndex(r));
        case "effect":
          return this._ToColorArray(t[r]);
        case "world-instance":
          return this._ToColorArray(this._Getter());
      }
    }
    CompareInitialStateWithCurrent() {
      const e = this._FirstKeyframeGetter();
      return !this._CompareColors(e, this._Getter());
    }
    CompareSaveStateWithCurrent() {
      return !C32.IsNullOrUndefined(this._saveState) && !this._CompareColors(this._saveState, this._Getter());
    }
    _CompareColors(e, t) {
      return e = this._GetColorFromArray(e), t = this._GetColorFromArray(t), e.equalsIgnoringAlpha(t);
    }
    _FirstKeyframeGetter() {
      const e = super._FirstKeyframeGetter();
      return this._GetColorFromArray(e);
    }
    _CurrentKeyframeGetter() {
      const e = super._CurrentKeyframeGetter();
      return this._GetColorFromArray(e);
    }
    _GetAbsoluteInitialValue(e) {
    }
    _ToColorArray(e) {
      return C32.IsInstanceOf(e, C32.Color) ? e.toArray().slice(0, 3) : e.slice(0, 3);
    }
    _GetColorFromArray(e) {
      return C32.IsInstanceOf(e, C32.Color) ? e : new C32.Color(e[0], e[1], e[2], 1);
    }
    CanChange(e) {
      return true;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return true;
    }
    BeforeChangeProperty() {
      const e = this._propertyTrack.GetTimeline(), t = this._propertyTrack.GetInstance(), r = this._propertyTrack.GetSourceAdapter(), o = e.GetSimilarPropertyTracks(t, r, this._property, this._propertyTrack);
      if (o && o.length > 1) {
        TMP_COLORS_MAP.has(t) || TMP_COLORS_MAP.set(t, /* @__PURE__ */ new Map());
        const e2 = TMP_COLORS_MAP.get(t), r2 = this._propertyTrack.GetSourceAdapterId();
        e2.has(r2) || e2.set(r2, /* @__PURE__ */ new Map());
        const o2 = e2.get(r2);
        o2.has(this._property) || o2.set(this._property, { used: false, color: new C32.Color(0, 0, 0, 1) });
      }
    }
    _GetTmpColor(e, t, r) {
      const o = TMP_COLORS_MAP.get(e).get(t).get(r);
      return o.used = true, o.color;
    }
    ChangeProperty(e, t, r, o, s, a, n, i) {
      const p = this._propertyTrack.GetTimeline(), _ = this._propertyTrack.GetTrack(), c = this._propertyTrack.GetInstance(), l = this._propertyTrack.GetSourceAdapter(), h = this._propertyTrack.GetSourceAdapterId(), C = this._property, y = p.GetSimilarPropertyTracks(c, l, C, this._propertyTrack);
      if (y && y.length > 1) {
        const e2 = this._GetPropertyKeyframeStubs(y, true), r2 = this._GetLastPropertyKeyframeStub(p, p.GetTime(), e2);
        if (r2) {
          const e3 = _.GetStartOffset(), o2 = r2.time - e3;
          if (0 === o2) this._GetTmpColor(c, h, this._property).addRgb(t[0], t[1], t[2]);
          else {
            if (o2 < 0) return;
            const e4 = t[0], r3 = t[1], s2 = t[2], a2 = this._propertyTrack.Interpolate(o2, false, true), n2 = C32.Color.DiffChannel(e4, a2[0]), i2 = C32.Color.DiffChannel(r3, a2[1]), p2 = C32.Color.DiffChannel(s2, a2[2]);
            this._GetTmpColor(c, h, this._property).addRgb(n2, i2, p2);
          }
        }
      } else this._Setter(t[0], t[1], t[2]);
    }
    AfterChangeProperty() {
      const e = this._propertyTrack.GetInstance();
      if (!TMP_COLORS_MAP.has(e)) return;
      const t = TMP_COLORS_MAP.get(e), r = this._propertyTrack.GetSourceAdapterId();
      if (!t.has(r)) return;
      const o = t.get(r);
      if (!o.has(this._property)) return;
      const s = o.get(this._property), a = s.used, n = s.color;
      a && this._Setter(n.getR(), n.getG(), n.getB()), 0 === o.size && t.delete(r), 0 === t.size && TMP_COLORS_MAP.delete(e);
    }
    _Getter() {
      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();
      switch (e) {
        case "behavior":
        case "plugin":
          return this._GetColorFromArray(t.GetPropertyValueByIndex(r));
        case "effect":
          return t[r].clone();
        case "world-instance":
          return this.GetWorldInfo().GetUnpremultipliedColor().clone();
      }
    }
    _Setter(e, t, r) {
      const o = this._propertyTrack.GetSourceAdapterId(), s = this._GetTarget(), a = this._GetIndex();
      switch (o) {
        case "behavior":
        case "plugin":
          TMP_COLOR[0] = e, TMP_COLOR[1] = t, TMP_COLOR[2] = r, s.SetPropertyValueByIndex(a, TMP_COLOR);
          break;
        case "effect":
          s[a].setRgb(e, t, r);
          break;
        case "world-instance":
          this.GetWorldInfo().SetUnpremultipliedColorRGB(e, t, r);
      }
    }
    _SaveToJson() {
    }
    _LoadFromJson(e) {
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;
}
{
  const C32 = self.C3, NS = C32.PropertyTrackState;
  class NoInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(e) {
      super(e);
    }
    SetResetState() {
    }
    SetInitialState() {
    }
    SetResumeState() {
    }
    GetCurrentState() {
      return this._Getter();
    }
    CompareInitialStateWithCurrent() {
      return this._FirstKeyframeGetter() !== this.GetCurrentState();
    }
    CompareSaveStateWithCurrent() {
      return !C32.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();
    }
    MayNeedBeforeAndAfterInterpolate() {
      return false;
    }
    ChangeProperty(e, t, r, a, s, n, i, o) {
      const c = this._propertyTrack, p = c.GetTrack(), h = c.GetSourceAdapterId(), l = c.GetTimeline(), u = p.GetInstance(), S = c.GetSourceAdapter(), G = this._property, d = l.GetSimilarPropertyTracks(u, S, G, c);
      if (d && d.length > 1) {
        const r2 = this._GetPropertyKeyframeStubs(d), a2 = e + p.GetStartOffset(), s2 = this._GetLastPropertyKeyframeStub(l, a2, r2);
        s2 && (t = s2.value);
      }
      switch (c.GetPropertyKeyframeType()) {
        case "numeric":
          if (!NS.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, h)) return;
          this._Setter(t, r, a);
          break;
        case "angle":
          if (!NS.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, h)) return;
          this._Setter(t, r, a);
          break;
        case "boolean":
          if (!NS.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, h)) return;
          this._Setter(t, r, a);
          break;
        case "color":
          if (!NS.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, h)) return;
          this._Setter(t, r, a);
          break;
        case "text": {
          const e2 = this._ForceChanges();
          if (!NS.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, h) && !e2) return;
          this._Setter(t, r, a);
          break;
        }
      }
    }
    _ForceChanges() {
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
        case "effect":
        case "instance-variable":
          return false;
        case "plugin":
          return this.GetSourceAdapter().ForceChanges();
      }
      return false;
    }
    _Getter() {
      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();
      switch (e) {
        case "behavior":
        case "plugin":
          return t.GetPropertyValueByIndex(r);
        case "effect":
          return t[r];
        case "instance-variable":
          return t.GetInstanceVariableValue(r);
      }
    }
    _Setter(e, t, r) {
      const a = this._propertyTrack.GetSourceAdapterId(), s = this._GetTarget(), n = this._GetIndex();
      switch (a) {
        case "behavior":
          s.SetPropertyValueByIndex(n, e);
          break;
        case "effect":
          s[n] = e;
          break;
        case "instance-variable":
          s.SetInstanceVariableValue(n, e);
          break;
        case "plugin":
          s.SetPropertyValueByIndex(n, e, this.GetSourceAdapter().GetOptionalCallbacks(t, r));
      }
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;
}
{
  const C32 = self.C3, NS = C32.PropertyTrackState.PropertyInterpolationAdapter, INSTANCE_FUNC_MAP = /* @__PURE__ */ new Map(), add = (t, e, a, r, i, s = false, o = null, n = null) => {
    INSTANCE_FUNC_MAP.set(t, { setter: e, absolute_setter: a, getter: r, round: i, fRound: s, init: o, reset: n });
  }, get_original_size = (t, e) => {
    const a = e.GetTimeline().GetTrackFromInstance(t.GetInstance());
    if (a) return a.GetOriginalWidth();
    const r = t.GetInstance().GetSdkInstance();
    return r.IsOriginalSizeKnown() ? r.GetOriginalWidth() : t._GetSceneGraphInfo()._GetStartWidth();
  }, get_last_property_keyframe_value = (t, e, a, r = 0) => {
    const i = e.GetTimeline().GetTrackFromInstance(t.GetInstance());
    if (!i) return r;
    const s = i.GetPropertyTrack(a);
    if (!s) return r;
    const o = s.GetPropertyTrackDataItem().GetPropertyKeyframeData();
    if (!o) return r;
    const n = o.GetLastPropertyKeyframeDataItem();
    return n ? n.GetValue() : r;
  }, get_parents = (t) => {
    const e = [];
    let a = t.GetParent();
    for (; a; ) e.push(a), a = a.GetParent();
    return e.reverse(), e;
  };
  add("offsetX", (t, e, a, r) => {
    "relative" === r._propertyTrack.GetResultMode() ? t.OffsetX(e, a.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetX(e);
  }, (t, e) => t.SetX(e), (t) => t.GetX(), true), add("offsetY", (t, e, a, r) => {
    "relative" === r._propertyTrack.GetResultMode() ? t.OffsetY(e, a.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetY(e);
  }, (t, e) => t.SetY(e), (t) => t.GetY(), true), add("offsetWidth", (t, e, a, r, i = false, s = true) => {
    if (0 === e) return;
    const o = "relative" === r._propertyTrack.GetResultMode(), n = 1 === r._typeAdapter.GetType();
    if ((o || n) && t.HasParent() && t.GetTransformWithParentWidth()) {
      if (isNaN(r._absoluteToFactor)) {
        const e2 = get_parents(t);
        let a3;
        if (n) {
          a3 = e2[e2.length - 1].GetWidth();
        } else {
          a3 = e2[e2.length - 1]._GetSceneGraphInfo()._GetStartWidth();
        }
        r._absoluteToFactor = 0 === a3 ? Number.EPSILON : a3;
      }
      if (i) return;
      r._absoluteWidthOffset += e;
      const a2 = e / r._absoluteToFactor;
      t.OffsetWidth(a2, s), r._changeAccumulator += a2;
    } else t.OffsetWidth(e), r._changeAccumulator += e;
  }, (t, e) => t.SetWidth(e), (t) => t.GetWidth(), true, false, null, (t) => {
    t._changeAccumulator = 0, t._absoluteWidthOffset = 0;
  }), add("offsetHeight", (t, e, a, r, i = false, s = true) => {
    if (0 === e) return;
    const o = "relative" === r._propertyTrack.GetResultMode(), n = 1 === r._typeAdapter.GetType();
    if ((o || n) && t.HasParent() && t.GetTransformWithParentHeight()) {
      if (isNaN(r._absoluteToFactor)) {
        const e2 = get_parents(t);
        let a3;
        if (n) {
          a3 = e2[e2.length - 1].GetHeight();
        } else {
          a3 = e2[e2.length - 1]._GetSceneGraphInfo()._GetStartHeight();
        }
        r._absoluteToFactor = 0 === a3 ? Number.EPSILON : a3;
      }
      if (i) return;
      r._absoluteHeightOffset += e;
      const a2 = e / r._absoluteToFactor;
      t.OffsetHeight(a2, s), r._changeAccumulator += a2;
    } else t.OffsetHeight(e), r._changeAccumulator += e;
  }, (t, e) => t.SetHeight(e), (t) => t.GetHeight(), true, false, null, (t) => {
    t._changeAccumulator = 0, t._absoluteHeightOffset = 0;
  }), add("offsetAngle", (t, e, a, r, i) => {
    t.OffsetAngle(e);
  }, (t, e) => t.SetAngle(e), (t) => t.GetAngle(), false, true), add("offsetOpacity", (t, e, a, r, i) => {
    e /= r._opacityFactor ? r._opacityFactor : 1;
    const s = t.GetOpacity() + e;
    if (0 === r._clampAccumulator) s > 1 ? r._clampAccumulator += s - 1 : s < 0 && (r._clampAccumulator += s), t.OffsetOpacity(e);
    else {
      const a2 = t.GetOpacity() + e;
      e > 0 && r._clampAccumulator > 0 ? a2 > 1 && (r._clampAccumulator += a2 - 1) : e > 0 && r._clampAccumulator < 0 ? (r._clampAccumulator += e, r._clampAccumulator > 0 && (t.OffsetOpacity(r._clampAccumulator), r._clampAccumulator = 0)) : e < 0 && r._clampAccumulator > 0 ? (r._clampAccumulator += e, r._clampAccumulator < 0 && (t.OffsetOpacity(r._clampAccumulator), r._clampAccumulator = 0)) : e < 0 && r._clampAccumulator < 0 && a2 < 0 && (r._clampAccumulator += a2);
    }
  }, (t, e) => {
    t.SetOpacity(e);
  }, (t) => t.GetOpacity(), false, true, (t, e, a) => {
    switch (t._clampAccumulator = 0, t._propertyTrack.GetResultMode()) {
      case "relative": {
        t._propertyTrack.GetPropertyTrackData();
        const e2 = t._propertyTrack.GetPropertyTrackDataItem().GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        let a2 = t.GetWorldInfo().GetOpacity(), r2 = a2;
        for (const i2 of e2) {
          const e3 = i2.GetTime();
          r2 = a2 + t._propertyTrack.GetInterpolatedValue(e3), r2 = C32.clamp(r2, 0, 1);
        }
        t._totalForewardOpacityDelta = a2 - r2, t._totalForewardOpacityDelta = Math.round(100 * (t._totalForewardOpacityDelta + Number.EPSILON)) / 100, r2 = a2;
        for (let a3 = e2.length - 1; a3 >= 0; a3--) {
          const i2 = e2[a3].GetTime();
          r2 -= t._propertyTrack.GetInterpolatedValue(i2), r2 = C32.clamp(r2, 0, 1);
        }
        t._totalBackwardOpacityDelta = r2, t._totalBackwardOpacityDelta = Math.round(100 * (t._totalBackwardOpacityDelta + Number.EPSILON)) / 100;
        break;
      }
    }
    const r = "relative" === t._propertyTrack.GetResultMode(), i = 1 === t._typeAdapter.GetType();
    if ((r || i) && e.HasParent() && e.GetTransformWithParentOpacity()) {
      const r2 = get_parents(e);
      let i2 = r2[0]._GetSceneGraphInfo().GetStartOpacity();
      i2 += get_last_property_keyframe_value(r2[0], a, "offsetOpacity");
      for (let t2 = 1; t2 < r2.length; t2++) i2 += get_last_property_keyframe_value(r2[t2], a, "offsetOpacity");
      t._opacityFactor = 0 === i2 ? 1 : i2;
    }
  }, (t) => {
    switch (t._propertyTrack.GetResultMode()) {
      case "relative": {
        t._clampAccumulator = 0;
        const e = t.GetWorldInfo();
        let a = e.GetOpacity();
        a = Math.round(100 * (a + Number.EPSILON)) / 100, t._propertyTrack.GetTimeline().IsForwardPlayBack() ? (e.SetOpacity(a + t._totalForewardOpacityDelta), t._lastValue = 0) : (e.SetOpacity(a - t._totalBackwardOpacityDelta), t._lastValue = t.GetSourceAdapter().GetValueAtTime());
        break;
      }
    }
  }), add("offsetOriginX", (t, e) => t.OffsetOriginX(e), (t, e) => t.SetOriginX(e), (t) => t.GetOriginX(), false), add("offsetOriginY", (t, e) => t.OffsetOriginY(e), (t, e) => t.SetOriginY(e), (t) => t.GetOriginY(), false), add("offsetZElevation", (t, e) => t.OffsetZElevation(e), (t, e) => t.SetZElevation(e), (t) => t.GetZElevation(), true), add("offsetScaleX", (t, e, a, r) => {
    if (0 === e) return;
    const i = t.GetWidth() < 0 ? -1 : 1;
    if (r._absoluteScaleXOffset += e, "relative" === r._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentWidth()) {
      const s = get_last_property_keyframe_value(t, a, "offsetWidth"), o = isNaN(r._originalSize) ? a.GetOriginalWidth() : r._originalSize, n = (o + s / (t._GetSceneGraphInfo()._GetStartWidth() / o)) * i * e;
      isNaN(r._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetWidth").setter(t, 1, a, r, true);
      const l = n / r._absoluteToFactor;
      t.OffsetWidth(l, true), r._changeAccumulator += l;
    } else {
      const s = (isNaN(r._originalSize) ? a.GetOriginalWidth() : r._originalSize) * i * e;
      t.OffsetWidth(s), r._changeAccumulator += s;
    }
  }, (t, e, a) => {
    t.SetWidth(a.GetOriginalWidth() * e);
  }, (t, e) => {
    const a = t.GetWidth() < 0 ? -1 : 1;
    if (t.GetTransformWithParentWidth()) {
      const r = t.GetParent(), i = e.GetTimeline().GetTrackFromInstance(r.GetInstance());
      let s = NaN;
      if (i) s = r.GetWidth() / i.GetOriginalWidth();
      else {
        const t2 = r.GetInstance().GetSdkInstance();
        s = t2.IsOriginalSizeKnown() ? r.GetWidth() / t2.GetOriginalWidth() : 1;
      }
      return t.GetWidth() * a / (e.GetOriginalWidth() * s);
    }
    return t.GetWidth() * a / e.GetOriginalWidth();
  }, false, false, null, (t) => {
    t._changeAccumulator = 0, t._originalSize = NaN, t._absoluteScaleXOffset = 0;
  }), add("offsetScaleY", (t, e, a, r) => {
    if (0 === e) return;
    const i = t.GetHeight() < 0 ? -1 : 1;
    if (r._absoluteScaleYOffset += e, "relative" === r._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentHeight()) {
      const s = get_last_property_keyframe_value(t, a, "offsetHeight"), o = isNaN(r._originalSize) ? a.GetOriginalHeight() : r._originalSize, n = (o + s / (t._GetSceneGraphInfo()._GetStartHeight() / o)) * i * e;
      isNaN(r._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetHeight").setter(t, 1, a, r, true);
      const l = n / r._absoluteToFactor;
      t.OffsetHeight(l, true), r._changeAccumulator += l;
    } else {
      const s = (isNaN(r._originalSize) ? a.GetOriginalHeight() : r._originalSize) * i * e;
      t.OffsetHeight(s), r._changeAccumulator += s;
    }
  }, (t, e, a) => {
    t.SetHeight(a.GetOriginalHeight() * e);
  }, (t, e) => {
    const a = t.GetHeight() < 0 ? -1 : 1;
    if (t.GetTransformWithParentHeight()) {
      const r = t.GetParent(), i = e.GetTimeline().GetTrackFromInstance(r.GetInstance());
      let s = NaN;
      if (i) s = r.GetHeight() / i.GetOriginalHeight();
      else {
        const t2 = r.GetInstance().GetSdkInstance();
        s = t2.IsOriginalSizeKnown() ? r.GetHeight() / t2.GetOriginalHeight() : 1;
      }
      return t.GetHeight() * a / (e.GetOriginalHeight() * s);
    }
    return t.GetHeight() * a / e.GetOriginalHeight();
  }, false, false, null, (t) => {
    t._changeAccumulator = 0, t._originalSize = NaN, t._absoluteScaleYOffset = 0;
  });
  class NumericInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(t) {
      super(t), this._lastValue = 0, this._clampAccumulator = 0, this._totalForewardOpacityDelta = 0, this._totalBackwardOpacityDelta = 0, this._opacityFactor = NaN, this._absoluteToFactor = NaN, this._changeAccumulator = 0, this._originalSize = NaN, this._absoluteWidthOffset = 0, this._absoluteScaleXOffset = 0, this._absoluteHeightOffset = 0, this._absoluteScaleYOffset = 0, this._angleReflectMirrorOrFlip = void 0, this._angleReflectMirrorAndFlip = void 0, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, this._round = false, this._fRound = false, C32.IsInstanceOf(this._propertyTrack.GetTimeline(), C32.TweenState) ? this._typeAdapter = new C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
      const e = this._propertyTrack.GetPropertyName();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "world-instance": {
          const t2 = INSTANCE_FUNC_MAP.get(e);
          this._instance_getter = t2.getter, this._instance_setter = t2.setter, this._instance_absolute_setter = t2.absolute_setter, this._round = t2.round, this._fRound = t2.fRound, this._init_action = t2.init, this._reset_action = t2.reset;
          break;
        }
        case "audio":
          this._source_adapter_getter = t.Getter, this._source_adapter_setter = t.Setter, this._source_adapter_absolute_setter = t.AbsoluteSetter, this._round = !!t.DoesRounding(), this._fRound = false;
      }
    }
    Release() {
      this._typeAdapter = null, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, super.Release();
    }
    MayNeedBeforeAndAfterInterpolate() {
      return this._typeAdapter.MayNeedBeforeAndAfterInterpolate();
    }
    GetLastValue() {
      return this._lastValue;
    }
    SetLastValue(t) {
      this._lastValue = t;
    }
    SetResetState() {
      this._reset_action && this._reset_action(this);
    }
    SetInitialState() {
      const t = this._typeAdapter.SetInitialState();
      if ("number" == typeof t && (this._lastValue = t), this._init_action) {
        const t2 = this.GetWorldInfo(), e = this._propertyTrack.GetTrack();
        this._init_action(this, t2, e);
      }
    }
    SetResumeState() {
      const t = this._typeAdapter.SetResumeState();
      "number" == typeof t && (this._lastValue = t);
    }
    GetCurrentState() {
      return this._Getter();
    }
    CompareInitialStateWithCurrent() {
      return this._FirstKeyframeGetter() !== this.GetCurrentState();
    }
    CompareSaveStateWithCurrent() {
      return !C32.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();
    }
    BeforeChangeProperty(t, e) {
      this._typeAdapter.BeforeChangeProperty(t, e);
    }
    ChangeProperty(t, e, a, r, i, s, o, n) {
      return this._typeAdapter.ChangeProperty(t, e, a, r, i, s, o, n);
    }
    AfterChangeProperty(t, e) {
      this._typeAdapter.AfterChangeProperty(t, e);
    }
    _Getter() {
      const t = this._GetTarget(), e = this._GetIndex(), a = this.GetWorldInfo(), r = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
        case "plugin":
          return t.GetPropertyValueByIndex(e);
        case "effect":
          return t[e];
        case "instance-variable":
          return t.GetInstanceVariableValue(e);
        case "world-instance":
          return this._instance_getter(a, r);
        case "audio":
          return this._source_adapter_getter.call(this.GetSourceAdapter(), a, r);
      }
    }
    _Setter(t, e, a, r = true) {
      const i = this._GetTarget(), s = this._GetIndex(), o = this.GetWorldInfo(), n = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          i.OffsetPropertyValueByIndex(s, t);
          break;
        case "effect":
          i[s] += t;
          break;
        case "instance-variable":
          i.SetInstanceVariableOffset(s, t);
          break;
        case "plugin":
          i.OffsetPropertyValueByIndex(s, t, this.GetSourceAdapter().GetOptionalCallbacks(e, a));
          break;
        case "world-instance":
          this._instance_setter(o, t, n, this, false, r);
          break;
        case "audio":
          this._source_adapter_setter.call(this.GetSourceAdapter(), o, t, n, this);
      }
    }
    _SetterAbsolute(t, e, a, r, i) {
      let s = this._propertyTrack.GetInterpolationMode();
      if (s = "default" === s ? "continuous" : s, "discrete" === s && !e) return;
      if ("discrete" === s && a) {
        const t2 = this._propertyTrack.GetTimeline().GetTime();
        if (!this._propertyTrack.GetPropertyKeyFrameDataItemAtTime(t2)) return;
      }
      const o = this._GetTarget(), n = this._GetIndex(), l = this.GetWorldInfo(), c = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          o.SetPropertyValueByIndex(n, t);
          break;
        case "effect":
          o[n] = t;
          break;
        case "instance-variable":
          o.SetInstanceVariableValue(n, t);
          break;
        case "plugin":
          o.SetPropertyValueByIndex(n, t, this.GetSourceAdapter().GetOptionalCallbacks(r, i));
          break;
        case "world-instance":
          this._instance_absolute_setter(l, t, c);
          break;
        case "audio":
          this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), l, t, c);
      }
    }
    _MaybeEnsureValue(t, e, a, r, i, s, o, n) {
      this._typeAdapter._MaybeEnsureValue(t, e, a, r, i, s, o, n);
    }
    _AddDelta(t, e, a, r, i) {
      if ("angle" === this._propertyTrack.GetPropertyType()) t = C32.toDegrees(t);
      const s = (t.toString().split(".")[1] || "").length, o = this._Getter();
      let n;
      if (0 === s) if (this._round) n = Math.round(o);
      else if (this._fRound) if ("angle" === this._propertyTrack.GetPropertyType()) n = C32.toRadians(Math.round(C32.toDegrees(o)));
      else n = Number(C32.toFixed(o, 2));
      else n = o;
      else n = this._round ? Number(C32.toFixed(o, s)) : (this._fRound, o);
      switch (this._Setter(n - o, e, a, false), this._propertyTrack.GetPropertyName()) {
        case "offsetWidth":
        case "offsetScaleX": {
          const t2 = this.GetWorldInfo(), e2 = t2.GetWidth(), a2 = Number(C32.toFixed(e2, 2));
          t2.OffsetWidth(a2 - e2);
          break;
        }
        case "offsetHeight":
        case "offsetScaleY": {
          const t2 = this.GetWorldInfo(), e2 = t2.GetHeight(), a2 = Number(C32.toFixed(e2, 2));
          t2.OffsetHeight(a2 - e2);
          break;
        }
      }
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "v": this._lastValue, "a": this._clampAccumulator, "fod": this._totalForewardOpacityDelta, "bod": this._totalBackwardOpacityDelta, "of": this._opacityFactor, "sf": this._absoluteToFactor, "armorf": this._angleReflectMirrorOrFlip, "armandf": this._angleReflectMirrorAndFlip, "ca": this._changeAccumulator, "os": this._originalSize, "awo": this._absoluteWidthOffset, "aho": this._absoluteHeightOffset, "asxo": this._absoluteScaleXOffset, "asyo": this._absoluteScaleYOffset });
    }
    _LoadFromJson(t) {
      t && (super._LoadFromJson(t), this._lastValue = t["v"], this._clampAccumulator = t["a"], this._totalForewardOpacityDelta = C32.IsFiniteNumber(t["fod"]) ? t["fod"] : 0, this._totalBackwardOpacityDelta = C32.IsFiniteNumber(t["bod"]) ? t["bod"] : 0, this._opacityFactor = C32.IsFiniteNumber(t["of"]) ? t["of"] : NaN, this._absoluteToFactor = C32.IsFiniteNumber(t["sf"]) ? t["sf"] : NaN, this._angleReflectMirrorOrFlip = C32.IsFiniteNumber(t["armorf"]) ? t["armorf"] : void 0, this._angleReflectMirrorAndFlip = C32.IsFiniteNumber(t["armandf"]) ? t["armandf"] : void 0, this._changeAccumulator = C32.IsFiniteNumber(t["ca"]) ? t["ca"] : 0, this._originalSize = C32.IsFiniteNumber(t["os"]) ? t["os"] : NaN, this._absoluteWidthOffset = C32.IsFiniteNumber(t["awo"]) ? t["awo"] : 0, this._absoluteHeightOffset = C32.IsFiniteNumber(t["aho"]) ? t["aho"] : 0, this._absoluteScaleXOffset = C32.IsFiniteNumber(t["asxo"]) ? t["asxo"] : 0, this._absoluteScaleYOffset = C32.IsFiniteNumber(t["asyo"]) ? t["asyo"] : 0);
    }
    SetOriginalSizeProperty(t) {
      this._originalSize = t;
    }
    GetChangeAccumulatorProperty() {
      return this._changeAccumulator;
    }
    GetAbsoluteWidthOffsetProperty() {
      return this._absoluteWidthOffset;
    }
    GetAbsoluteHeightOffsetProperty() {
      return this._absoluteHeightOffset;
    }
    GetAbsoluteScaleXOffsetProperty() {
      return this._absoluteScaleXOffset;
    }
    GetAbsoluteScaleYOffsetProperty() {
      return this._absoluteScaleYOffset;
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;
}
{
  const C32 = self.C3;
  class AbsoluteValueObject {
    constructor(e) {
      this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false, this._propertyTracks = e;
      for (let e2 = 0, t = this._propertyTracks.length; e2 < t; e2++) this._propertyTracks[e2].SetAbsoluteValueObject(this);
    }
    GetPropertyTracks() {
      return this._propertyTracks;
    }
    SetUsed() {
      this._used = true;
    }
    GetUsed() {
      return this._used;
    }
    SetValue(e) {
      this._value = e;
    }
    GetValue() {
      return this._value;
    }
    SetPropertyKeyframeReached(e) {
      this._propertyKeyframeReached = e;
    }
    GetPropertyKeyframeReached() {
      return this._propertyKeyframeReached;
    }
    SetEndState(e) {
      this._endState = e;
    }
    GetEndState() {
      return this._endState;
    }
    Reset() {
      this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false;
    }
  }
  class NumericInterpolationAdapterForTimeline {
    constructor(e) {
      this._numericInterpolationAdapter = e;
    }
    Release() {
      this._numericInterpolationAdapter = null;
    }
    GetType() {
      return 0;
    }
    SetInitialState() {
      const e = this._numericInterpolationAdapter;
      this._numericInterpolationAdapter.GetPropertyTrack();
      return e._PickResultMode(() => e._PickTimelinePlaybackMode(() => 0, () => e.GetSourceAdapter().GetValueAtTime()), () => {
      });
    }
    SetResumeState() {
    }
    MayNeedBeforeAndAfterInterpolate() {
      this._numericInterpolationAdapter;
      switch (this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()) {
        case "relative":
          return false;
        case "absolute":
          return true;
      }
    }
    BeforeChangeProperty(e, t) {
      this._numericInterpolationAdapter;
      const r = this._numericInterpolationAdapter.GetPropertyTrack(), a = r.GetPropertyName();
      switch (r.GetResultMode()) {
        case "relative":
          break;
        case "absolute":
          if (r.HasAbsoluteValueObject()) {
            r.GetAbsoluteValueObject().Reset();
          } else {
            const e2 = r.GetTimeline(), t2 = r.GetInstance(), s = r.GetSourceAdapter(), o = e2.GetSimilarPropertyTracks(t2, s, a, r);
            o && o.length > 1 && new AbsoluteValueObject(o);
          }
      }
    }
    ChangeProperty(e, t, r, a, s, o, i, n) {
      const l = this._numericInterpolationAdapter, u = this._numericInterpolationAdapter.GetPropertyTrack();
      switch (u.GetResultMode()) {
        case "relative": {
          const i2 = l.GetLastValue();
          l._Setter(t - i2, r, a), o && this._MaybeEnsureValue(e, r, a, s, i2, t), l.SetLastValue(t);
          break;
        }
        case "absolute": {
          const e2 = u.GetTimeline(), s2 = u.GetTrack();
          u.GetInstance(), u.GetSourceAdapter();
          if (u.HasAbsoluteValueObject()) {
            const r2 = u.GetAbsoluteValueObject(), a2 = r2.GetPropertyTracks(), o2 = l._GetPropertyKeyframeStubs(a2, true), c = l._GetLastPropertyKeyframeStub(e2, e2.GetTime(), o2);
            if (c) {
              const e3 = s2.GetStartOffset(), a3 = c.time - e3;
              if (0 === a3) r2.SetEndState(i), r2.SetPropertyKeyframeReached(n), r2.SetUsed(), r2.SetValue(r2.GetValue() + t);
              else {
                if (a3 < 0) return;
                const e4 = u.GetInterpolatedValue(a3);
                r2.SetEndState(i), r2.SetPropertyKeyframeReached(n), r2.SetUsed(), r2.SetValue(r2.GetValue() + (t - e4));
              }
            }
          } else l._SetterAbsolute(t, n, i, r, a);
          break;
        }
      }
    }
    AfterChangeProperty(e, t) {
      const r = this._numericInterpolationAdapter, a = this._numericInterpolationAdapter.GetPropertyTrack();
      switch (a.GetResultMode()) {
        case "relative":
          break;
        case "absolute":
          if (a.HasAbsoluteValueObject()) {
            const s = a.GetAbsoluteValueObject();
            s.GetUsed() && r._SetterAbsolute(s.GetValue(), s.GetPropertyKeyframeReached(), s.GetEndState(), e, t);
          }
      }
    }
    _MaybeEnsureValue(e, t, r, a, s, o) {
      const i = this._numericInterpolationAdapter;
      a || (t && e === t.GetTime() ? i._AddDelta(t.GetValueWithResultMode(), t, r) : r && e === r.GetTime() ? i._AddDelta(r.GetValueWithResultMode(), t, r) : o - s === 0 && i._AddDelta(t.GetValueWithResultMode(), t, r));
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;
}
{
  const C32 = self.C3;
  class NumericInterpolationAdapterForTween {
    constructor(e) {
      this._numericInterpolationAdapter = e;
    }
    Release() {
      this._numericInterpolationAdapter = null;
    }
    GetType() {
      return 1;
    }
    SetInitialState() {
      const e = this._numericInterpolationAdapter;
      return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._FirstKeyframeGetter());
    }
    SetResumeState() {
      const e = this._numericInterpolationAdapter;
      if (e._FirstKeyframeGetter() !== e._CurrentKeyframeGetter()) return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._CurrentKeyframeGetter());
    }
    MayNeedBeforeAndAfterInterpolate() {
      return false;
    }
    BeforeChangeProperty() {
    }
    ChangeProperty(e, t, r, a, n, i, o, l) {
      const s = this._numericInterpolationAdapter, u = s.GetLastValue();
      switch (s.GetPropertyTrack().GetResultMode()) {
        case "relative":
          s._Setter(t - u, r, a), i && this._MaybeEnsureValue(e, r, a, n, u, t, false, o);
          break;
        case "absolute":
          s.GetFirstAbsoluteUpdate() ? (s.SetFirstAbsoluteUpdate(false), s._Setter(u, r, a)) : 0 === e && 0 === s.GetPropertyTrack().GetTimeline().GetTotalTime() ? s._SetterAbsolute(t, true, false, r, a) : (s._Setter(t - u, r, a), i && this._MaybeEnsureValue(e, r, a, n, u, t, this._ForceEndValue(), o));
      }
      s.SetLastValue(t);
    }
    AfterChangeProperty() {
    }
    _GetAbsoluteInitialValue(e) {
      return e - this._numericInterpolationAdapter.GetCurrentState();
    }
    _ForceEndValue() {
      const e = this._numericInterpolationAdapter, t = e.GetWorldInfo().GetInstance(), r = e.GetPropertyTrack().GetRuntime().GetTimelineManager();
      let a = 0;
      for (const e2 of r.GetPlayingTimelines()) 0 === e2.GetType() ? e2.HasTrackInstance(t) && a++ : 1 === e2.GetType() && e2.GetInstance() === t && a++;
      return a <= 1;
    }
    _MaybeEnsureValue(e, t, r, a, n, i, o, l) {
      const s = this._numericInterpolationAdapter;
      a ? t && e === t.GetTime() ? s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : r && e === r.GetTime() ? s._AddDelta(r.GetValueWithResultMode(), t, r, o, l) : r || s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : t && e === t.GetTime() ? s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : r && e === r.GetTime() ? s._AddDelta(r.GetValueWithResultMode(), t, r, o, l) : i - n === 0 && s._AddDelta(t.GetValueWithResultMode(), t, r, o, l);
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;
}
{
  const C32 = self.C3, Ease = self.Ease;
  C32.PropertyTrackState.NumericTypeAdapter = class {
    constructor() {
    }
    static WillChange(e, t, a, r) {
      let n;
      switch (r) {
        case "behavior":
        case "plugin":
          n = t.GetPropertyValueByIndex(e);
          break;
        case "effect":
          n = t[e];
          break;
        case "instance-variable":
          n = t.GetInstanceVariableValue(e);
      }
      return n !== a;
    }
    static Interpolate(e, t, a, r) {
      if (!a) {
        const e2 = r.GetPropertyTrackDataItem();
        return r.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2).GetValueWithResultMode();
      }
      let n = r.GetInterpolationMode();
      if ("default" === n && (n = "continuous"), "combo" === r.GetPropertyType() && (n = "discrete"), "discrete" === n) return C32.PropertyTrackState.GetPropertyKeyframeValueWithPlaybackDirection(t, a, r);
      if ("continuous" === n || "step" === n) {
        const s = r.GetTimeline().GetStep();
        if ("step" === n && 0 !== s) {
          const t2 = 1 / s;
          e = Math.floor(e * t2) / t2;
        }
        const c = t.GetValueWithResultMode(), i = a.GetValueWithResultMode(), o = t.GetAddOn("cubic-bezier"), l = a.GetAddOn("cubic-bezier"), u = o && o.GetStartEnable() && l && l.GetEndEnable();
        if (!u && c === i) return c;
        const G = t.GetTime(), p = a.GetTime();
        "step" === n && 0 !== s && (e = C32.clamp(e, G, p));
        const y = C32.normalize(e, G, p), b = t.GetEase();
        let d;
        if (u) {
          const e2 = p - G;
          d = Ease.GetRuntimeEase(b)(e2 * y, 0, 1, e2), d = Ease.GetRuntimeEase("cubicbezier")(d, c, c + o.GetStartAnchor(), i + l.GetEndAnchor(), i);
        } else d = Ease.GetRuntimeEase(b)((p - G) * y, c, i - c, p - G);
        return "integer" === r.GetPropertyType() ? Math.floor(d) : d;
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.PropertyTrackState.AngleTypeAdapter = class {
    constructor() {
    }
    static WillChange(e, t, a, r) {
      let s;
      switch (r) {
        case "behavior":
        case "plugin":
          s = t.GetPropertyValueByIndex(e);
          break;
        case "effect":
          s = t[e];
          break;
        case "instance-variable":
          s = t.GetInstanceVariableValue(e);
      }
      return s !== a;
    }
    static Interpolate(e, t, a, r) {
      if (!a) {
        const e2 = r.GetPropertyTrackDataItem();
        return r.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2).GetValueWithResultMode();
      }
      let s = r.GetInterpolationMode();
      if ("default" === s && (s = "continuous"), "combo" === r.GetPropertyType() && (s = "discrete"), "discrete" === s) return C32.PropertyTrackState.GetPropertyKeyframeValueWithPlaybackDirection(t, a, r);
      if ("continuous" === s || "step" === s) {
        const n = r.GetTimeline().GetStep();
        if ("step" === s && 0 !== n) {
          const t2 = 1 / n;
          e = Math.floor(e * t2) / t2;
        }
        const c = t.GetTime(), o = a.GetTime(), i = t.GetValueWithResultMode(), l = a.GetValueWithResultMode();
        "step" === s && 0 !== n && (e = C32.clamp(e, c, o));
        const u = t.GetAddOn("angle");
        if (!u) {
          if (i === l) return i;
          const a2 = C32.normalize(e, c, o), r2 = self.Ease.GetRuntimeEase(t.GetEase());
          return C32.angleLerp(i, l, r2(a2, 0, 1, 1));
        }
        {
          const a2 = u.GetRevolutions();
          if (i === l && 0 === a2) return i;
          const r2 = C32.normalize(e, c, o), s2 = self.Ease.GetRuntimeEase(t.GetEase())(r2, 0, 1, 1);
          switch (u.GetDirection()) {
            case "closest":
              return C32.angleLerp(i, l, s2, a2);
            case "clockwise":
              return C32.angleLerpClockwise(i, l, s2, a2);
            case "anti-clockwise":
              return C32.angleLerpAntiClockwise(i, l, s2, a2);
          }
        }
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {
    }
    static WillChange(e, t, a, r) {
      let c;
      switch (r) {
        case "behavior":
        case "plugin":
          c = t.GetPropertyValueByIndex(e);
          break;
        case "effect":
          c = t[e];
          break;
        case "instance-variable":
          c = t.GetInstanceVariableValue(e);
      }
      return !!c != !!a;
    }
    static Interpolate(e, t, a, r) {
      if (!a) {
        const e2 = r.GetPropertyTrackDataItem();
        return r.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2).GetValueWithResultMode() ? 1 : 0;
      }
      return C32.PropertyTrackState.GetPropertyKeyframeValueWithPlaybackDirection(t, a, r) ? 1 : 0;
    }
  };
}
{
  const C32 = self.C3, TEMP_COLOR_ARRAY = [0, 0, 0], TEMP_COLOR_ARRAY_2 = [0, 0, 0], TEMP_COLOR_ARRAY_3 = [0, 0, 0];
  C32.PropertyTrackState.ColorTypeAdapter = class {
    constructor() {
    }
    static WillChange(R, e, _, t) {
      let A;
      switch (t) {
        case "behavior":
        case "plugin":
          A = e.GetPropertyValueByIndex(R);
          break;
        case "effect":
          A = e[R];
          break;
        case "instance-variable":
          A = e.GetInstanceVariableValue(R);
      }
      return Array.isArray(_) ? (TEMP_COLOR_ARRAY[0] = _[0], TEMP_COLOR_ARRAY[1] = _[1], TEMP_COLOR_ARRAY[2] = _[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(_), TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), Array.isArray(A) ? (TEMP_COLOR_ARRAY_2[0] = A[0], TEMP_COLOR_ARRAY_2[1] = A[1], TEMP_COLOR_ARRAY_2[2] = A[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(A), TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || (TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2]);
    }
    static Interpolate(R, e, _, t) {
      if (!_) {
        const R2 = t.GetPropertyTrackDataItem(), e2 = t.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(R2).GetValueWithResultMode();
        return TEMP_COLOR_ARRAY[0] = e2[0], TEMP_COLOR_ARRAY[1] = e2[1], TEMP_COLOR_ARRAY[2] = e2[2], TEMP_COLOR_ARRAY;
      }
      let A = t.GetInterpolationMode();
      if ("default" === A && (A = "continuous"), "discrete" === A) {
        const R2 = C32.PropertyTrackState.GetPropertyKeyframeValueWithPlaybackDirection(e, _, t);
        return TEMP_COLOR_ARRAY[0] = R2[0], TEMP_COLOR_ARRAY[1] = R2[1], TEMP_COLOR_ARRAY[2] = R2[2], TEMP_COLOR_ARRAY;
      }
      if ("continuous" === A || "step" === A) {
        const O = t.GetTimeline().GetStep();
        if ("step" === A && 0 !== O) {
          const e2 = 1 / O;
          R = Math.floor(R * e2) / e2;
        }
        const a = e.GetTime(), r = _.GetTime(), M = e.GetValueWithResultMode(), C = _.GetValueWithResultMode();
        "step" === A && 0 !== O && (R = C32.clamp(R, a, r));
        const P = C32.normalize(R, a, r), T = e.GetEase(), o = M[0], E = M[1], L = M[2], Y = C[0], s = C[1], l = C[2], i = self.Ease.GetRuntimeEase(T), c = r - a, n = c * P;
        return TEMP_COLOR_ARRAY[0] = o === Y ? o : i(n, o, Y - o, c), TEMP_COLOR_ARRAY[1] = E === s ? E : i(n, E, s - E, c), TEMP_COLOR_ARRAY[2] = L === l ? L : i(n, L, l - L, c), TEMP_COLOR_ARRAY;
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.PropertyTrackState.TextTypeAdapter = class {
    constructor() {
    }
    static WillChange(e, t, a, r) {
      let c;
      switch (r) {
        case "behavior":
        case "plugin":
          c = t.GetPropertyValueByIndex(e);
          break;
        case "effect":
          c = t[e];
          break;
        case "instance-variable":
          c = t.GetInstanceVariableValue(e);
      }
      return c !== a;
    }
    static Interpolate(e, t, a, r) {
      if (!a) {
        const e2 = r.GetPropertyTrackDataItem();
        return r.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2).GetValueWithResultMode();
      }
      return C32.PropertyTrackState.GetPropertyKeyframeValueWithPlaybackDirection(t, a, r);
    }
  };
}
{
  const C32 = self.C3;
  C32.TimelineDataManager = class {
    constructor() {
      this._timelineDataItems = /* @__PURE__ */ new Map();
    }
    Release() {
      for (const e of this._timelineDataItems.values()) e.Release();
      this._timelineDataItems.clear(), this._timelineDataItems = null;
    }
    Add(e) {
      const a = new C32.TimelineDataItem(e), t = a.GetName();
      this._timelineDataItems.set(t, a);
    }
    Get(e) {
      return this._timelineDataItems.get(e);
    }
    GetNameId() {
      return 0;
    }
    static _CreateDataItems(e, a, t, s) {
      if (a) for (const i of a) C32.TimelineDataManager._CreateDataItem("create", i, e, t, s);
    }
    static _CreateDataItemsIncludingDisabled(e, a, t, s) {
      if (a) for (const i of a) C32.TimelineDataManager._CreateDataItem("create-including-disabled", i, e, t, s);
    }
    static _LoadDataItemsFromJson(e, a, t, s) {
      e.length ? a.forEach((a2, t2) => {
        e[t2]._LoadFromJson(a2);
      }) : a.forEach((a2) => {
        C32.TimelineDataManager._CreateDataItem("load", a2, e, t, s);
      });
    }
    static _CreateDataItem(e, a, t, s, i) {
      let n;
      if ("function" == typeof s) switch (e) {
        case "load":
          n = new s(null, i);
          break;
        case "create":
        case "create-including-disabled":
          n = new s(a, i);
      }
      else if ("object" == typeof s) {
        const t2 = a[s.prop], c = s.map.get(t2);
        switch (e) {
          case "load":
            n = new c(null, i);
            break;
          case "create":
          case "create-including-disabled":
            n = new c(a, i);
        }
      }
      switch (e) {
        case "load":
          n._LoadFromJson(a), t.push(n);
          break;
        case "create":
          if ("function" == typeof n.GetEnable && !n.GetEnable()) return n.Release();
          t.push(n);
          break;
        case "create-including-disabled":
          t.push(n);
      }
    }
  };
}
{
  const C32 = self.C3, NAME = 0, TOTAL_TIME = 1, STEP = 2, INTERPOLATION_MODE = 3, RESULT_MODE = 4, TRACKS = 5, LOOP = 6, PING_PONG = 7, REPEAT_COUNT = 8, START_ON_LAYOUT = 9, TRANSFORM_WITH_SCENE_GRAPH = 10, USE_SYSTEM_TIMESCALE = 11;
  C32.TimelineDataItem = class {
    constructor(t) {
      this._name = "", this._totalTime = NaN, this._step = 0, this._interpolationMode = "default", this._resultMode = "default", this._loop = false, this._pingPong = false, this._repeatCount = 1, this._trackData = null, this._startOnLayout = "", this._transformWithSceneGraph = false, this._useSystemTimescale = true, t && (this._name = t[0], this._totalTime = t[1], this._step = t[2], this._interpolationMode = t[3], this._resultMode = t[4], this._loop = !!t[6], this._pingPong = !!t[7], this._repeatCount = t[8], this._startOnLayout = t[9], this._transformWithSceneGraph = !!t[10], this._useSystemTimescale = !!t[11], this._trackData = new C32.TrackData(t[5], this));
    }
    Release() {
      this._trackData.Release(), this._trackData = null;
    }
    GetTrackData() {
      return this._trackData || (this._trackData = new C32.TrackData(null, this)), this._trackData;
    }
    GetName() {
      return this._name;
    }
    SetName(t) {
      this._name = t;
    }
    GetTotalTime() {
      return this._totalTime;
    }
    SetTotalTime(t) {
      this._totalTime = t;
    }
    GetStep() {
      return this._step;
    }
    SetStep(t) {
      this._step = t;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(t) {
      this._interpolationMode = t;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(t) {
      this._resultMode = t;
    }
    GetLoop() {
      return this._loop;
    }
    SetLoop(t) {
      this._loop = t;
    }
    GetPingPong() {
      return this._pingPong;
    }
    SetPingPong(t) {
      this._pingPong = t;
    }
    GetRepeatCount() {
      return this._repeatCount;
    }
    SetRepeatCount(t) {
      this._repeatCount = t;
    }
    GetStartOnLayout() {
      return this._startOnLayout;
    }
    GetTransformWithSceneGraph() {
      return this._transformWithSceneGraph;
    }
    GetUseSystemTimescale() {
      return this._useSystemTimescale;
    }
    _SaveToJson() {
      return { "trackDataJson": this._trackData._SaveToJson(), "name": this._name, "totalTime": this._totalTime, "step": this._step, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "loop": this._loop, "pingPong": this._pingPong, "repeatCount": this._repeatCount, "startOnLayout": this._startOnLayout, "transformWithSceneGraph": !!this._transformWithSceneGraph, "useSystemTimescale": this._useSystemTimescale };
    }
    _LoadFromJson(t) {
      t && (this.GetTrackData()._LoadFromJson(t["trackDataJson"]), this._name = t["name"], this._totalTime = t["totalTime"], this._step = t["step"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._loop = t["loop"], this._pingPong = t["pingPong"], this._repeatCount = t["repeatCount"], this._startOnLayout = t["startOnLayout"], this._transformWithSceneGraph = !!t["transformWithSceneGraph"], this._useSystemTimescale = !!t["useSystemTimescale"]);
    }
  };
}
{
  const C32 = self.C3, WI_DATA = 0, OC_INDEX = 1, WI_UID = 2, INTERPOLATION_MODE = 1, RESULT_MODE = 2, ENABLED = 3, KEYFRAMES = 4, PROPERTY_TRACKS = 5, ID = 6, NESTED_DATA = 7, START_OFFSET = 0, LOCAL_TOTAL_TIME = 1, WI_ADDITIONAL_DATA = 8, ORIGINAL_WIDTH = 0, ORIGINAL_HEIGHT = 1, TRACK_TYPE = 9, TRACK_NAME = 10;
  class TrackDataItem {
    constructor(t, a) {
      this._trackData = a, this._instanceData = null, this._additionalInstanceData = null, this._instanceUid = NaN, this._objectClassIndex = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = false, this._keyframeData = null, this._propertyTrackData = null, this._id = "", this._nestedData = null, this._startOffset = 0, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), this._type = 0, this._name = "", t && (t[0] && (this._instanceData = t[0], this._instanceUid = t[0][2], this._objectClassIndex = t[0][1]), this._interpolationMode = t[1], this._resultMode = t[2], this._enabled = !!t[3], t[6] && (this._id = t[6]), t[7] && (this._nestedData = t[7], this._startOffset = t[7][0], this._localTotalTime = t[7][1]), t[8] && (this._additionalInstanceData = t[8]), t[8] && (this._additionalInstanceData = t[8]), t[9] && (this._type = t[9]), t[10] && (this._name = t[10]), this._keyframeData = new C32.KeyframeData(t[4], this), this._propertyTrackData = new C32.PropertyTrackData(t[5], this));
    }
    Release() {
      this._instanceData = null, this._trackData = null, this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null), this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null), this._nestedData = null;
    }
    GetTrackData() {
      return this._trackData;
    }
    GetKeyframeData() {
      return this._keyframeData || (this._keyframeData = new C32.KeyframeData(null, this)), this._keyframeData;
    }
    GetPropertyTrackData() {
      return this._propertyTrackData || (this._propertyTrackData = new C32.PropertyTrackData(null, this)), this._propertyTrackData;
    }
    GetInstanceData() {
      return this._instanceData;
    }
    GetObjectClassIndex() {
      return this._objectClassIndex;
    }
    SetObjectClassIndex(t) {
      this._objectClassIndex = t;
    }
    GetInstanceUID() {
      return this._instanceUid;
    }
    SetInstanceUID(t) {
      this._instanceUid = t;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(t) {
      this._interpolationMode = t;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(t) {
      this._resultMode = t;
    }
    GetEnable() {
      return this._enabled;
    }
    SetEnable(t) {
      this._enabled = !!t;
    }
    GetId() {
      return this._id;
    }
    GetStartOffset() {
      return this._startOffset;
    }
    GetLocalTotalTime() {
      return this._localTotalTime;
    }
    SetLocalTotalTime(t) {
      this._localTotalTime = t;
    }
    GetOriginalWidth() {
      return this._additionalInstanceData[0];
    }
    SetOriginalWidth(t) {
      this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[0] = t;
    }
    GetOriginalHeight() {
      return this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[1];
    }
    SetOriginalHeight(t) {
      this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[1] = t;
    }
    GetType() {
      return this._type;
    }
    GetName() {
      return this._name;
    }
    _SaveToJson() {
      return { "keyframeDataJson": this._keyframeData._SaveToJson(), "propertyTrackDataJson": this._propertyTrackData._SaveToJson(), "instanceData": this._instanceData, "additionalInstanceData": this._additionalInstanceData, "instanceUid": this._instanceUid, "objectClassIndex": this._objectClassIndex, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "enabled": this._enabled, "id": this._id, "nestedData": this._nestedData, "type": this._type, "name": this._name };
    }
    _LoadFromJson(t) {
      t && (this._instanceData = t["instanceData"], this._instanceUid = t["instanceUid"], this._objectClassIndex = t["objectClassIndex"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._enabled = t["enabled"], this._id = t["id"], this._type = t["type"] ? t["type"] : 0, this._name = t["name"] ? t["name"] : "", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), t["nestedData"] && (this._nestedData = t["nestedData"], this._startOffset = this._nestedData[0], this._localTotalTime = this._nestedData[1]), t["additionalInstanceData"] && (this._additionalInstanceData = t["additionalInstanceData"]), this.GetKeyframeData()._LoadFromJson(t["keyframeDataJson"]), this.GetPropertyTrackData()._LoadFromJson(t["propertyTrackDataJson"]));
    }
  }
  C32.TrackData = class {
    constructor(t, a) {
      this._timelineDataItem = a, this._trackDataItems = [], C32.TimelineDataManager._CreateDataItems(this._trackDataItems, t, TrackDataItem, this);
    }
    Release() {
      this._timelineDataItem = null;
      for (const t of this._trackDataItems) t.Release();
      C32.clearArray(this._trackDataItems), this._trackDataItems = null;
    }
    GetTimelineDataItem() {
      return this._timelineDataItem;
    }
    AddEmptyTrackDataItem() {
      const t = new TrackDataItem(null, this);
      return this._trackDataItems.push(t), t;
    }
    GetFirstKeyframeDataItem(t) {
      return t.GetKeyframeData().GetKeyframeDataItemArray()[0];
    }
    GetLastKeyframeDataItem(t) {
      return t.GetKeyframeData().GetKeyframeDataItemArray().at(-1);
    }
    GetKeyFrameDataItemAtTime(t, a) {
      const e = a.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
      for (let a2 = 0; a2 < s; a2++) {
        const s2 = e[a2];
        if (s2.GetTime() === t) return s2;
      }
    }
    GetFirstKeyFrameDataItemHigherThan(t, a) {
      const e = a.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
      for (let a2 = 0; a2 < s; a2++) {
        const s2 = e[a2];
        if (s2.GetTime() > t) return s2;
      }
    }
    GetFirstKeyFrameDataItemHigherOrEqualThan(t, a) {
      const e = a.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
      for (let a2 = 0; a2 < s; a2++) {
        const s2 = e[a2];
        if (s2.GetTime() >= t) return s2;
      }
    }
    GetFirstKeyFrameDataItemLowerOrEqualThan(t, a) {
      const e = a.GetKeyframeData().GetKeyframeDataItemArray();
      for (let a2 = e.length - 1; a2 >= 0; a2--) {
        const s = e[a2];
        if (s.GetTime() <= t) return s;
      }
    }
    *trackDataItems() {
      for (const t of this._trackDataItems) yield t;
    }
    _SaveToJson() {
      return { "trackDataItemsJson": this._trackDataItems.map((t) => t._SaveToJson()) };
    }
    _LoadFromJson(t) {
      t && C32.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, t["trackDataItemsJson"], TrackDataItem, this);
    }
  };
}
{
  const C32 = self.C3, SOURCE_DATA = 0, SOURCE = 0, PROPERTY = 1, TYPE = 2, MIN = 3, MAX = 4, INTERPOLATION_MODE = 5, RESULT_MODE = 6, ENABLED = 7, PROPERTY_KEYFRAMES = 8, CAN_HAVE_PROPERTY_KEYFRAMES = 9;
  class PropertyTrackDataItem {
    constructor(t, e) {
      this._propertyTrackData = e, this._sourceAdapterId = "", this._sourceAdapterArguments = null, this._property = null, this._type = null, this._min = NaN, this._max = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = false, this._propertyKeyframeData = null, this._canHavePropertyKeyframes = true, t && (this._sourceAdapterId = t[0][0], this._sourceAdapterArguments = t[0].slice(1), this._property = t[1], this._type = t[2], this._min = t[3], this._max = t[4], this._interpolationMode = t[5], this._resultMode = t[6], this._enabled = !!t[7], this._propertyKeyframeData = new C32.PropertyKeyframeData(t[8], this), this._canHavePropertyKeyframes = t[9]);
    }
    Release() {
      this._propertyKeyframeData.Release(), this._propertyKeyframeData = null, this._propertyTrackData = null, this._sourceAdapterArguments = null;
    }
    GetPropertyTrackData() {
      return this._propertyTrackData;
    }
    GetPropertyKeyframeData() {
      return this._propertyKeyframeData || (this._propertyKeyframeData = new C32.PropertyKeyframeData(null, this)), this._propertyKeyframeData;
    }
    GetSourceAdapterId() {
      return this._sourceAdapterId;
    }
    SetSourceAdapterId(t) {
      this._sourceAdapterId = t;
    }
    GetSourceAdapterArguments() {
      return this._sourceAdapterArguments;
    }
    SetSourceAdapterArguments(t) {
      this._sourceAdapterArguments = t;
    }
    GetProperty() {
      return this._property;
    }
    SetProperty(t) {
      this._property = t;
    }
    GetType() {
      return this._type;
    }
    SetType(t) {
      this._type = t;
    }
    GetMin() {
      return this._min;
    }
    SetMin(t) {
      this._min = t;
    }
    GetMax() {
      return this._max;
    }
    SetMax(t) {
      this._max = t;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(t) {
      this._interpolationMode = t;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(t) {
      this._resultMode = t;
    }
    GetEnable() {
      return this._enabled;
    }
    SetEnable(t) {
      this._enabled = !!t;
    }
    CanHavePropertyKeyframes() {
      return !!this._canHavePropertyKeyframes;
    }
    _SaveToJson() {
      return { "propertyKeyframeDataJson": this._propertyKeyframeData._SaveToJson(), "sourceAdapterId": this._sourceAdapterId, "sourceAdapterArguments": this._sourceAdapterArguments, "property": this._property, "type": this._type, "min": this._min, "max": this._max, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "enabled": this._enabled, "canHavePropertyKeyframes": this._canHavePropertyKeyframes };
    }
    _LoadFromJson(t) {
      t && (this._sourceAdapterId = t["sourceAdapterId"], this._sourceAdapterArguments = t["sourceAdapterArguments"], this._property = t["property"], this._type = t["type"], this._min = t["min"], this._max = t["max"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._enabled = t["enabled"], this._canHavePropertyKeyframes = t["canHavePropertyKeyframes"], this.GetPropertyKeyframeData()._LoadFromJson(t["propertyKeyframeDataJson"]));
    }
  }
  C32.PropertyTrackData = class {
    constructor(t, e) {
      this._trackDataItem = e, this._propertyTrackDataItems = [], C32.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, t, PropertyTrackDataItem, this);
    }
    Release() {
      this._trackDataItem = null;
      for (const t of this._propertyTrackDataItems) t.Release();
      C32.clearArray(this._propertyTrackDataItems), this._propertyTrackDataItems = null;
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    AddEmptyPropertyTrackDataItem() {
      const t = new PropertyTrackDataItem(null, this);
      return this._propertyTrackDataItems.push(t), t;
    }
    GetFirstPropertyKeyframeDataItem(t) {
      return t.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0];
    }
    GetLastPropertyKeyframeDataItem(t) {
      return t.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1);
    }
    GetPropertyKeyFrameDataItemAtTime(t, e) {
      const r = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a = r.length;
      for (let e2 = 0; e2 < a; e2++) {
        const a2 = r[e2];
        if (a2.GetTime() === t) return a2;
      }
    }
    GetFirstPropertyKeyFrameDataItemHigherThan(t, e) {
      const r = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a = r.length;
      for (let e2 = 0; e2 < a; e2++) {
        const a2 = r[e2];
        if (a2.GetTime() > t) return a2;
      }
    }
    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, e) {
      const r = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a = r.length;
      for (let e2 = 0; e2 < a; e2++) {
        const a2 = r[e2];
        if (a2.GetTime() >= t) return a2;
      }
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, e) {
      const r = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
      for (let e2 = r.length - 1; e2 >= 0; e2--) {
        const a = r[e2];
        if (a.GetTime() <= t) return a;
      }
    }
    *propertyTrackDataItems() {
      for (const t of this._propertyTrackDataItems) yield t;
    }
    _SaveToJson() {
      return { "propertyTrackDataItemsJson": this._propertyTrackDataItems.map((t) => t._SaveToJson()) };
    }
    _LoadFromJson(t) {
      t && C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, t["propertyTrackDataItemsJson"], PropertyTrackDataItem, this);
    }
  };
}
{
  const C32 = self.C3, TIME = 0, EASE = 1, ENABLE = 2, TAGS = 3;
  class KeyframeDataItem {
    constructor(e, t) {
      if (this._keyframeData = t, this._time = -1, this._ease = "noease", this._enable = false, this._tags = null, this._lowerTags = null, !e) return;
      this._time = e[0], this._ease = e[1], this._enable = !!e[2];
      const a = e[3];
      this._tags = a ? a.split(" ") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())), this._next = null, this._last = null;
    }
    Release() {
      this._keyframeData = null, C32.clearArray(this._tags), this._tags = null, this._lowerTags.clear(), this._lowerTags = null, this._next = null;
    }
    GetKeyframeData() {
      return this._keyframeData;
    }
    GetNext() {
      return this._next;
    }
    SetNext(e) {
      this._next = e;
    }
    GetLast() {
      return this._last;
    }
    SetLast(e) {
      this._last = e;
    }
    GetTime() {
      return this._time;
    }
    SetTime(e) {
      this._time = e, this._keyframeData._LinkKeyframeDataItems();
    }
    GetEase() {
      return this._ease;
    }
    SetEase(e) {
      this._ease = e;
    }
    GetEnable() {
      return this._enable;
    }
    SetEnable(e) {
      this._enable = !!e;
    }
    GetTags() {
      return this._tags;
    }
    SetTags(e) {
      this._tags = e ? e.split(" ") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase()));
    }
    GetLowerTags() {
      return this._lowerTags;
    }
    GetTagsString() {
      return Array.from(this._lowerTags).join(",").trim();
    }
    HasTag(e) {
      return this._lowerTags.has(e.toLowerCase());
    }
    _SaveToJson() {
      return { "time": this._time, "ease": this._ease, "enable": this._enable, "tags": this._tags };
    }
    _LoadFromJson(e) {
      e && (this._time = e["time"], this._ease = e["ease"], this._enable = e["enable"], this._tags = e["tags"], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())));
    }
  }
  C32.KeyframeData = class {
    constructor(e, t) {
      this._trackDataItem = t, this._keyframeDataItems = [], C32.TimelineDataManager._CreateDataItems(this._keyframeDataItems, e, KeyframeDataItem, this), this._LinkKeyframeDataItems();
    }
    Release() {
      this._trackDataItem = null;
      for (const e of this._keyframeDataItems) e.Release();
      C32.clearArray(this._keyframeDataItems), this._keyframeDataItems = null;
    }
    _LinkKeyframeDataItems() {
      this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
      for (let e = 0; e < this._keyframeDataItems.length; e++) {
        const t = this._keyframeDataItems[e];
        t.SetNext(this._keyframeDataItems[e + 1]), t.SetLast(this._keyframeDataItems[e - 1]);
      }
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    GetKeyframeDataItemCount() {
      return this._keyframeDataItems.length;
    }
    GetKeyframeDataItemArray() {
      return this._keyframeDataItems;
    }
    AddEmptyKeyframeDataItem() {
      const e = new KeyframeDataItem(null, this);
      return this._keyframeDataItems.push(e), this._LinkKeyframeDataItems(), e;
    }
    DeleteKeyframeDataItems(e) {
      for (const t of this._keyframeDataItems) {
        if (!e(t)) continue;
        const a = this._keyframeDataItems.indexOf(t);
        -1 !== a && (t.Release(), this._keyframeDataItems.splice(a, 1));
      }
      this.SortKeyframeDataItems(), this._LinkKeyframeDataItems();
    }
    SortKeyframeDataItems() {
      this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
    }
    GetKeyframeDataItemIndex(e) {
      return this._keyframeDataItems.indexOf(e);
    }
    GetKeyframeDataItemFromIndex(e) {
      return this._keyframeDataItems[e];
    }
    *keyframeDataItems() {
      for (const e of this._keyframeDataItems) yield e;
    }
    *keyframeDataItemsReverse() {
      for (let e = this._keyframeDataItems.length - 1; e >= 0; e--) yield this._keyframeDataItems[e];
    }
    _SaveToJson() {
      return { "keyframeDataItemsJson": this._keyframeDataItems.map((e) => e._SaveToJson()) };
    }
    _LoadFromJson(e) {
      e && (C32.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, e["keyframeDataItemsJson"], KeyframeDataItem, this), this._LinkKeyframeDataItems());
    }
  };
}
{
  const C32 = self.C3, VALUE_DATA = 0, VALUE_DATA_VALUE = 0, VALUE_DATA_ABSOLUTE_VALUE = 1, VALUE_DATA_TYPE = 2, TIME = 1, EASE = 2, ENABLE = 3, ADDONS = 4, PATH_MODE = 5;
  class PropertyKeyframeDataItem {
    constructor(e, t) {
      this._propertyKeyframeData = t, this._value = null, this._aValue = null, this._type = "", this._time = NaN, this._ease = "noease", this._enable = false, this._addonData = null, this._addonInstance = void 0, this._pathMode = "line", e && (this._value = e[0][0], this._aValue = e[0][1], this._type = e[0][2], this._time = e[1], this._ease = e[2], this._enable = !!e[3], this._pathMode = e[5], this._addonData = null, e[4] && (this._addonData = new C32.AddonData(e[4], this)), this._next = null, this._prev = null);
    }
    Release() {
      this._propertyKeyframeData = null, this._addonData && (this._addonData.Release(), this._addonData = null), this._next = null, this._prev = null;
    }
    GetAddonData() {
      return this._addonData;
    }
    SetNext(e) {
      this._next = e;
    }
    GetNext() {
      return this._next;
    }
    SetPrevious(e) {
      this._prev = e;
    }
    GetPrevious() {
      return this._prev;
    }
    GetValue() {
      return this._value;
    }
    SetValue(e) {
      "color" === this._type && C32.IsFiniteNumber(e) ? (this._value[0] = C32.GetRValue(e), this._value[1] = C32.GetGValue(e), this._value[2] = C32.GetBValue(e)) : this._value = e;
    }
    GetAbsoluteValue() {
      return this._aValue;
    }
    SetAbsoluteValue(e) {
      "color" === this._type && C32.IsFiniteNumber(e) ? (this._aValue[0] = C32.GetRValue(e), this._aValue[1] = C32.GetGValue(e), this._aValue[2] = C32.GetBValue(e)) : this._aValue = e;
    }
    GetValueWithResultMode() {
      const e = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
      return "relative" === e ? this.GetValue() : "absolute" === e ? this.GetAbsoluteValue() : void 0;
    }
    GetType() {
      return this._type;
    }
    SetType(e) {
      this._type = e;
    }
    GetTime() {
      return this._time;
    }
    SetTime(e) {
      this._time = e, this._propertyKeyframeData._LinkPropertyKeyframeDataItems();
    }
    GetEase() {
      return this._ease;
    }
    SetEase(e) {
      this._ease = e;
    }
    GetEnable() {
      return this._enable;
    }
    SetEnable(e) {
      this._enable = !!e;
    }
    GetPathMode() {
      return this._pathMode;
    }
    GetAddOn(e) {
      if (!this._addonData) return;
      if (this._addonInstance || null === this._addonInstance) return this._addonInstance;
      const t = this._addonData.GetAddDataItemArray();
      if (!t) return this._addonInstance = null, this._addonInstance;
      const a = t.length;
      for (let r = 0; r < a; r++) {
        const a2 = t[r];
        if (a2.GetId() === e) return this._addonInstance = a2, this._addonInstance;
      }
      return this._addonInstance = null, this._addonInstance;
    }
    _SaveToJson() {
      const e = this._addonData;
      return { "addonDataJson": e ? e._SaveToJson() : e, "value": this._value, "aValue": this._aValue, "type": this._type, "time": this._time, "ease": this._ease, "enable": this._enable };
    }
    _LoadFromJson(e) {
      e && (e["addonDataJson"] && this._addonData._SetFromJson(e["addonDataJson"]), this._value = e["value"], this._aValue = e["aValue"], this._type = e["type"], this._time = e["time"], this._ease = e["ease"], this._enable = e["enable"]);
    }
  }
  C32.PropertyKeyframeData = class {
    constructor(e, t) {
      this._propertyTrackDataItem = t, this._propertyKeyframeDataItems = [], this._propertyKeyframeDataItemsIncludingDisabled = [], C32.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, e, PropertyKeyframeDataItem, this), C32.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, e, PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems();
    }
    Release() {
      this._propertyTrackDataItem = null;
      for (const e of this._propertyKeyframeDataItems) e.Release();
      C32.clearArray(this._propertyKeyframeDataItems), this._propertyKeyframeDataItems = null;
      for (const e of this._propertyKeyframeDataItemsIncludingDisabled) e.Release();
      C32.clearArray(this._propertyKeyframeDataItemsIncludingDisabled), this._propertyKeyframeDataItemsIncludingDisabled = null;
    }
    _LinkPropertyKeyframeDataItems() {
      let e = this._propertyKeyframeDataItems;
      e.sort((e2, t) => e2.GetTime() - t.GetTime());
      for (let t = 0; t < e.length; t++) {
        const a = e[t];
        t + 1 < e.length && a.SetNext(e[t + 1]), t - 1 >= 0 && a.SetPrevious(e[t - 1]);
      }
      e = this._propertyKeyframeDataItemsIncludingDisabled, e.sort((e2, t) => e2.GetTime() - t.GetTime());
      for (let t = 0; t < e.length; t++) {
        const a = e[t];
        t + 1 < e.length && a.SetNext(e[t + 1]), t - 1 >= 0 && a.SetPrevious(e[t - 1]);
      }
    }
    AddEmptyPropertyKeyframeDataItem() {
      const e = new PropertyKeyframeDataItem(null, this);
      return this._propertyKeyframeDataItems.push(e), this._LinkPropertyKeyframeDataItems(), e;
    }
    DeletePropertyKeyframeDataItems(e) {
      for (const t of this._propertyKeyframeDataItems) {
        if (!e(t)) continue;
        const a = this._propertyKeyframeDataItems.indexOf(t);
        -1 !== a && (t.Release(), this._propertyKeyframeDataItems.splice(a, 1));
      }
      this.SortPropertyKeyFrameDataItems(), this._LinkPropertyKeyframeDataItems();
    }
    SortPropertyKeyFrameDataItems() {
      this._propertyKeyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
    }
    GetPropertyTrackDataItem() {
      return this._propertyTrackDataItem;
    }
    GetPropertyKeyframeDataItemCount() {
      return this._propertyKeyframeDataItems.length;
    }
    GetLastPropertyKeyframeDataItem() {
      return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length - 1];
    }
    GetPropertyKeyframeDataItemArray() {
      return this._propertyKeyframeDataItems;
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled() {
      return this._propertyKeyframeDataItemsIncludingDisabled;
    }
    *propertyKeyframeDataItems() {
      for (const e of this._propertyKeyframeDataItems) yield e;
    }
    *propertyKeyframeDataItemsReverse() {
      for (let e = this._propertyKeyframeDataItems.length - 1; e >= 0; e--) yield this._propertyKeyframeDataItems[e];
    }
    _SaveToJson() {
      const e = this._propertyKeyframeDataItems, t = this._propertyKeyframeDataItemsIncludingDisabled;
      return { "propertyKeyframeDataItemsJson": e.map((e2) => e2._SaveToJson()), "propertyKeyframeDataItemsIncludingDisabledJson": t.map((e2) => e2._SaveToJson()) };
    }
    _LoadFromJson(e) {
      e && (C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, e["propertyKeyframeDataItemsJson"], PropertyKeyframeDataItem, this), C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, e["propertyKeyframeDataItemsIncludingDisabledJson"], PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems());
    }
  };
}
{
  const C32 = self.C3, ADDON_ID = 0, ADDON_DATA = 1;
  class AddonDataItem {
    constructor(t, a) {
      this._addonData = a, this._id = t[0], this._data = t[1];
    }
    Release() {
      this._addonData = null, this._data = null;
    }
    GetAddonData() {
      return this._addonData;
    }
    GetId() {
      return this._id;
    }
    _SaveToJson() {
      return { "id": this._id, "data": this._data };
    }
    _LoadFromJson(t) {
      t && (this._id = t["id"], this._data = t["data"]);
    }
  }
  const START_ANCHOR = 0, START_ENABLE = 1, END_ANCHOR = 2, END_ENABLE = 3;
  class AddonDataCubicBezierItem extends AddonDataItem {
    constructor(t, a) {
      super(t, a), this._startAnchor = this._data[0], this._startEnable = !!this._data[1], this._endAnchor = this._data[2], this._endEnable = !!this._data[3];
    }
    Release() {
      super.Release();
    }
    GetStartAnchor() {
      return this._startAnchor;
    }
    GetStartEnable() {
      return this._startEnable;
    }
    GetEndAnchor() {
      return this._endAnchor;
    }
    GetEndEnable() {
      return this._endEnable;
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "startAnchor": this._startAnchor, "startEnable": !!this._startEnable, "endAnchor": this._endAnchor, "endEnable": !!this._endEnable });
    }
    _LoadFromJson(t) {
      t && (super._LoadFromJson(t), this._startAnchor = t["startAnchor"], this._startEnable = !!t["startEnable"], this._endAnchor = t["endAnchor"], this._endEnable = !!t["endEnable"]);
    }
  }
  const DIRECTION = 0, REVOLUTIONS = 1;
  class AddonDataAngleItem extends AddonDataItem {
    constructor(t, a) {
      super(t, a), this._direction = this._data[0], this._revolutions = this._data[1];
    }
    Release() {
      super.Release();
    }
    GetDirection() {
      return this._direction;
    }
    GetRevolutions() {
      return this._revolutions;
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "direction": this._direction, "revolutions": this._revolutions });
    }
    _LoadFromJson(t) {
      t && (super._LoadFromJson(t), this._direction = t["direction"], this._revolutions = t["revolutions"]);
    }
  }
  const START_FROM = 0;
  class AddonDataInitialAnimationItem extends AddonDataItem {
    constructor(t, a) {
      super(t, a), this._startFrom = this._data[0];
    }
    Release() {
      super.Release();
    }
    GetStartFrom() {
      return this._startFrom;
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "startFrom": this._startFrom });
    }
    _LoadFromJson(t) {
      t && (super._LoadFromJson(t), this._startFrom = t["startFrom"]);
    }
  }
  C32.AddonData = class {
    constructor(t, a) {
      this._propertyKeyframeDataItem = a, this._addonDataItems = [], C32.TimelineDataManager._CreateDataItems(this._addonDataItems, t, { prop: 0, map: /* @__PURE__ */ new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem], ["initial-animation", AddonDataInitialAnimationItem]]) }, this);
    }
    Release() {
      this._propertyKeyframeDataItem = null;
      for (const t of this._addonDataItems) t.Release();
      C32.clearArray(this._addonDataItems), this._addonDataItems = null;
    }
    GetPropertyKeyframeDataItem() {
      return this._propertyKeyframeDataItem;
    }
    GetAddDataItemArray() {
      return this._addonDataItems;
    }
    *addonDataItems() {
      for (const t of this._addonDataItems) yield t;
    }
    _SaveToJson() {
      return { "addonDataItemsJson": this._addonDataItems.map((t) => t._SaveToJson()) };
    }
    _LoadFromJson(t) {
      t && C32.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, t["addonDataItemsJson"], { prop: "id", map: /* @__PURE__ */ new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem], ["initial-animation", AddonDataInitialAnimationItem]]) }, this);
    }
  };
}
{
  const C32 = self.C3, INITIAL_VALUE_MODE_START_VALUE = "start-value", INITIAL_VALUE_MODE_CURRENT_STATE = "current-state", PING_PONG_BEGIN = 0, PING_PONG_END = 1;
  let createdTweens = 0;
  C32.TweenState = class extends C32.TimelineState {
    constructor(e, t) {
      super("tween-" + createdTweens++, e, t), this._id = "", this._destroyInstanceOnComplete = false, this._initialValueMode = "start-value", this._instance = null, this._on_completed_callbacks = null, this._on_started_callbacks = null, this._releasePromise = null, this._releaseResolve = null, this._behInst = null, this._track = null, this._iTweenState = null;
    }
    Release() {
      this.IsReleased() || (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensReleased), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweensReleased), this.ResolveReleasePromise(), super.Release(), this._instance = null, this._on_completed_callbacks = null, this._on_started_callbacks = null, this._behInst = null, this._track = null, this._releasePromise = null, this._releaseResolve = null);
    }
    FireReleaseEvent(e) {
      const t = C32.New(C32.Event, "tweenstatereleased");
      t.tweenState = this, e.dispatchEvent(t);
    }
    GetType() {
      return 1;
    }
    CreateTrackStates() {
      for (const e of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(C32.TweenTrackState.Create(this, e));
      this._track = this._tracks[0];
    }
    AddTrack() {
      const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), t = C32.TweenTrackState.Create(this, e);
      return this._tracks.push(t), this._CacheTrack(), t;
    }
    _CacheTrack() {
      this._track = this._tracks[0];
    }
    GetPropertyTrack(e) {
      return this._track.GetPropertyTracks()[0];
    }
    SetPropertyType(e) {
      this._propertyType = e;
    }
    GetInstance() {
      const e = this.GetTracks();
      if (!e || !e.length) return;
      const t = e[0];
      if (this._track = t, !t) return;
      const s = t.GetInstance();
      return t.IsInstanceValid() ? s : void 0;
    }
    SetBehaviorInstance(e) {
      this._behInst = e;
    }
    GetReleasePromise() {
      return this._releasePromise || (this._releasePromise = new Promise((e) => {
        this._releaseResolve = e;
      })), this._releasePromise;
    }
    ResolveReleasePromise() {
      this._releasePromise && (this._releaseResolve && this._releaseResolve(), this._releasePromise = null, this._releaseResolve = null);
    }
    AddStartedCallback(e) {
      this._on_started_callbacks || (this._on_started_callbacks = []), this._on_started_callbacks.push(e);
    }
    AddCompletedCallback(e) {
      this._on_completed_callbacks || (this._on_completed_callbacks = []), this._on_completed_callbacks.push(e);
    }
    RemoveStartedCallback(e) {
      if (!this._on_started_callbacks) return;
      const t = this._on_started_callbacks.indexOf(e);
      -1 !== t && this._on_started_callbacks.splice(t, 1);
    }
    RemoveCompletedCallback(e) {
      if (!this._on_completed_callbacks) return;
      const t = this._on_completed_callbacks.indexOf(e);
      -1 !== t && this._on_completed_callbacks.splice(t, 1);
    }
    SetStartValue(e, t) {
      for (const s of this._tracks) for (const n of s._propertyTracks) {
        if (n.GetPropertyName() !== t) continue;
        const s2 = n.GetPropertyTrackData(), i = n.GetPropertyTrackDataItem(), a = s2.GetFirstPropertyKeyframeDataItem(i);
        a.SetValue(e), a.SetAbsoluteValue(e);
      }
    }
    _GetPropertyTrackState(e) {
      for (const t of this._tracks) for (const s of t._propertyTracks) if (s.GetPropertyName() === e) return s;
    }
    BeforeSetEndValues(e) {
      let t = false;
      for (const s of e) {
        const e2 = this._GetPropertyTrackState(s);
        e2 && (this.SetStartValue(e2.GetCurrentState(), s), t = true);
      }
      if (t) {
        if (this.IsForwardPlayBack()) {
          const e2 = this.GetTotalTime() - this.GetTime();
          this.SetTotalTime(e2);
          for (const t2 of this._tracks) t2.SetLocalTotalTime(e2);
          this._SetTime(0);
        } else {
          const e2 = this.GetTime();
          this.SetTotalTime(e2);
          for (const t2 of this._tracks) t2.SetLocalTotalTime(e2);
          this._SetTime(e2);
        }
        this.SetInitialStateFromSetTime();
      }
    }
    SetEndValue(e, t) {
      const s = this._GetPropertyTrackState(t);
      if (!s) return;
      const n = s.GetPropertyTrackData(), i = s.GetPropertyTrackDataItem(), a = n.GetLastPropertyKeyframeDataItem(i);
      a.SetTime(this.GetTotalTime()), a.SetValue(e), a.SetAbsoluteValue(e);
    }
    SetId(e) {
      this._id = e;
    }
    GetId() {
      return this._id;
    }
    SetInitialValueMode(e) {
      this._initialValueMode = e;
    }
    GetInitialValueMode() {
      return this._initialValueMode;
    }
    SetDestroyInstanceOnComplete(e) {
      this._destroyInstanceOnComplete = e;
    }
    GetDestroyInstanceOnComplete() {
      return this._destroyInstanceOnComplete;
    }
    OnStarted() {
      if (this._on_started_callbacks) for (const e of this._on_started_callbacks) e(this);
      if (!this.IsComplete()) for (const e of this._tracks) e.CompareSaveStateWithCurrent();
    }
    OnCompleted() {
      this._completedTick = this._runtime.GetTickCount();
    }
    FinishTriggers() {
      if (!this._finishedTriggers && (this._finishedTriggers = true, this._on_completed_callbacks)) for (const e of this._on_completed_callbacks) e(this);
    }
    SetTime(e) {
      this._DeleteIntermediateKeyframes(), super.SetTime(e);
    }
    _SetTimeAndReset(e) {
      C32.IsFiniteNumber(e) || (e = this.GetTotalTime()), e < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e, this._track.SetResetState();
    }
    SetInitialState(e) {
      if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode()) for (const e2 of this._tracks) e2.CompareInitialStateWithCurrent();
      super.SetInitialState(e);
    }
    Stop(e = false) {
      if (super.Stop(e), !this.IsComplete()) for (const e2 of this._tracks) e2.SaveState();
    }
    Reset(e = true, t = false) {
      this._DeleteIntermediateKeyframes(), super.Reset(e, t);
    }
    _DeleteIntermediateKeyframes() {
      for (const e of this._tracks) {
        const t = (e2) => {
          const t2 = e2.GetTime(), s = this.GetTotalTime();
          return 0 !== t2 && t2 !== s;
        };
        e.DeleteKeyframes(t), e.DeletePropertyKeyframes(t);
      }
    }
    _OnBeforeChangeLayout() {
      if (this.IsReleased()) return true;
      const e = this.GetInstance();
      return (!e || !e.GetObjectClass().IsGlobal()) && (this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.ResetBeforeChangeLayout(), true);
    }
    Tick(e, t, s) {
      if (this._instance || (this._instance = this.GetInstance()), !this._instance || this._instance.IsDestroyed()) return this.Stop(true), void this.OnCompleted();
      const n = this._instance.GetTimeScale();
      if (-1 !== n && (e = s * n), 0 === e && 0 === this._lastDelta) return;
      this._lastDelta = e;
      const i = this._playheadTime + this._overshoot + e * this._playbackRate, a = this._timelineDataItem._totalTime;
      i < 0 ? (this._playheadTime = 0, this._overshoot = -i) : i >= a ? (this._playheadTime = a, this._overshoot = this._playheadTime - i) : (this._playheadTime = i, this._overshoot = 0);
      let r = false, o = false;
      const h = this.GetLoop(), l = this.GetPingPong();
      if (h || l ? h && !l ? this._playbackRate > 0 ? this._playheadTime >= a && (this._SetTimeAndReset(0), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), o = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(a), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), o = true) : !h && l ? this._playbackRate > 0 ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 0 : this._resumePingPongState = 0) : (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), r = true) : 0 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 1 : this._resumePingPongState = 1)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 0 : this._resumePingPongState = 0) : (r = true, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)) : 0 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 1 : this._resumePingPongState = 1)) : h && l && (this._playbackRate > 0 ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o = true, 0 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), this.IsPlaying() ? (this._pingPongState++, this._pingPongState = C32.wrap(this._pingPongState, 0, 2)) : (this._resumePingPongState = this._pingPongState + 1, this._resumePingPongState = C32.wrap(this._resumePingPongState, 0, 2))) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o = true, 0 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), this.IsPlaying() ? (this._pingPongState++, this._pingPongState = C32.wrap(this._pingPongState, 0, 2)) : (this._resumePingPongState = this._pingPongState + 1, this._resumePingPongState = C32.wrap(this._resumePingPongState, 0, 2)))) : this._playbackRate > 0 ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), o = true) : (this._SetTime(a), r = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(a), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), o = true) : (this._SetTime(0), r = true)), !this.IsReleased() && this.IsPlaying()) {
        if (r) return this._track.SetEndState(), this.Stop(true), void this.OnCompleted();
        this._track.Interpolate(this._playheadTime, true, false, o, this._firstTick, false), this._firstTick && (this._firstTick = false);
      }
    }
    _TweenTrigger(e) {
      const t = this.GetInstance();
      this._behInst.PushTriggerTween(this), this._runtime.Trigger(e, t, this._behInst.GetBehaviorType()), this._behInst.PopTriggerTween();
    }
    _SaveToJson() {
      const e = super._SaveToJson(), t = this.GetTimelineDataItem();
      return Object.assign(e, { "tweenDataItemJson": t._SaveToJson(), "id": this._id, "destroyInstanceOnComplete": this._destroyInstanceOnComplete, "initialValueMode": this._initialValueMode });
    }
    _LoadFromJson(e) {
      if (!e) return;
      this.GetTimelineDataItem()._LoadFromJson(e["tweenDataItemJson"]), super._LoadFromJson(e), this._id = e["id"], this._destroyInstanceOnComplete = e["destroyInstanceOnComplete"], this._initialValueMode = e["initialValueMode"], this._CacheTrack();
    }
    static IsPlaying(e) {
      return e.IsPlaying();
    }
    static IsPaused(e) {
      return e.IsPaused();
    }
    static IsPing(e) {
      return !!e.GetPingPong() && 0 === e.GetPingPongState();
    }
    static IsPong(e) {
      return !!e.GetPingPong() && 1 === e.GetPingPongState();
    }
    static Build(e) {
      const t = e.runtime.GetTimelineManager(), s = new C32.TimelineDataItem();
      if (e.json) {
        s._LoadFromJson(e.json["tweenDataItemJson"]);
        const n = new C32.TweenState(s, t);
        return n._LoadFromJson(e.json), n;
      }
      {
        const n = new C32.TweenState(s, t);
        C32.IsArray(e.propertyTracksConfig) || (e.propertyTracksConfig = [e.propertyTracksConfig]), n.SetId(e.id), n.SetTags(e.tags), n.SetInitialValueMode(e.initialValueMode), n.SetDestroyInstanceOnComplete(e.releaseOnComplete), n.SetLoop(e.loop), n.SetPingPong(e.pingPong), n.SetTotalTime(e.time), n.SetStep(0), n.SetInterpolationMode("default"), n.SetResultMode(e.propertyTracksConfig[0].resultMode), n.SetRepeatCount(e.repeatCount);
        const i = n.AddTrack();
        i.SetInstanceUID(e.instance.GetUID()), i.SetInterpolationMode("default"), i.SetResultMode(e.propertyTracksConfig[0].resultMode), i.SetEnable(true), i.SetObjectClassIndex(e.instance.GetObjectClass().GetIndex());
        const a = e.instance.GetSdkInstance(), r = a.IsOriginalSizeKnown() ? a.GetOriginalWidth() : e.instance.GetWorldInfo().GetWidth(), o = a.IsOriginalSizeKnown() ? a.GetOriginalHeight() : e.instance.GetWorldInfo().GetHeight();
        i.SetOriginalWidth(r), i.SetOriginalHeight(o);
        const h = i.AddKeyframe();
        h.SetTime(0), h.SetEase("noease"), h.SetEnable(true), h.SetTags("");
        const l = i.AddKeyframe();
        l.SetTime(e.time), l.SetEase("noease"), l.SetEnable(true), l.SetTags("");
        for (const t2 of e.propertyTracksConfig) {
          const s2 = i.AddPropertyTrack();
          s2.SetSourceAdapterId(t2.sourceId), s2.SetSourceAdapterArgs(t2.sourceArgs), s2.SetPropertyName(t2.property), s2.SetPropertyType(t2.type), s2.SetMin(NaN), s2.SetMax(NaN), s2.SetInterpolationMode("default"), s2.SetResultMode(t2.resultMode), s2.SetEnable(true);
          const n2 = s2.AddPropertyKeyframe();
          n2.SetType(t2.valueType), n2.SetTime(0), n2.SetEase(t2.ease), n2.SetEnable(true), n2.SetValue(t2.startValue), n2.SetAbsoluteValue(t2.startValue);
          const a2 = s2.AddPropertyKeyframe();
          a2.SetType(t2.valueType), a2.SetTime(e.time), a2.SetEase(t2.ease), a2.SetEnable(true), a2.SetValue(t2.endValue), a2.SetAbsoluteValue(t2.endValue), s2.GetSourceAdapter();
        }
        return n;
      }
    }
    static SetInstanceUID(e, t) {
      if (!isNaN(t)) for (const s of e.GetTracks()) s.SetInstanceUID(t);
    }
    static SetBehaviorInstance(e, t) {
      e.SetBehaviorInstance(t);
    }
    GetITweenState(e, t) {
      return this._iTweenState || (this._iTweenState = C32.New(self.ITweenState, this, e, t)), this._iTweenState;
    }
  };
}
{
  const C32 = self.C3;
  C32.TweenTrackState = class extends C32.TrackState {
    constructor(t, e) {
      super(t, e), this._firstPropertyTrack = null, this._secondPropertyTrack = null;
    }
    static Create(t, e) {
      return C32.New(C32.TweenTrackState, t, e);
    }
    _CachePropertyTracks() {
      1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0], this._secondPropertyTrack = this._propertyTracks[1]);
    }
    CreatePropertyTrackStates() {
      for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C32.TweenPropertyTrackState.Create(this, t));
      this._CachePropertyTracks();
    }
    AddPropertyTrack() {
      const t = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem(), e = C32.TweenPropertyTrackState.Create(this, t);
      return this._propertyTracks.push(e), this._CachePropertyTracks(), e;
    }
    SetInitialState() {
      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
      const t = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
      for (const e of this._propertyTracks) e.SetInitialState(t), 0 === this._worldInfoChange && 1 === e.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e.GetRenderChange() && (this._renderChange = 1);
      this._needsBeforeAndAfter = 0;
      this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(t), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(t);
    }
    BeforeInterpolate() {
    }
    Interpolate(t, e = false, r = false, s = false, a = false, o = false, n = false) {
      if (this._instance || this.GetInstance(), !this._instance) return;
      return !this._instance.IsDestroyed() && ((!o || !this.GetObjectClass().IsGlobal()) && (this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(t, r, s, n), this._secondPropertyTrack.Interpolate(t, r, s, n)) : this._firstPropertyTrack.Interpolate(t, r, s, n), void (0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged()))));
    }
    AfterInterpolate() {
    }
    _LoadFromJson(t) {
      super._LoadFromJson(t), this._CachePropertyTracks();
    }
  };
}
{
  const C32 = self.C3;
  C32.TweenPropertyTrackState = class extends C32.PropertyTrackState {
    constructor(t, e) {
      super(t, e), this._basic = false;
    }
    static Create(t, e) {
      return C32.New(C32.TweenPropertyTrackState, t, e);
    }
    Interpolate(t, e = false, r = false, a = false) {
      let s, o;
      if (this._basic) s = this._propertyKeyframeDataItems[0], o = this._propertyKeyframeDataItems[1];
      else if (e) s = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem), o = s.GetNext();
      else {
        if (this._lastPropertyKeyframeDataItem) {
          const e2 = this.GetTimeline(), r2 = this._lastPropertyKeyframeDataItem.GetNext(), a2 = this._lastPropertyKeyframeDataItem.GetTime(), s2 = r2 ? r2.GetTime() : e2.GetTotalTime();
          (t <= a2 || t >= s2) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem));
        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem);
        s = this._lastPropertyKeyframeDataItem, o = s.GetNext();
      }
      this._sourceAdapter.Interpolate(t, s, o, e, r, a);
    }
    AddPropertyKeyframe() {
      const t = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
      return this._lastPropertyKeyframeDataItem = null, this._basic = this.GetPropertyKeyframeDataItems().length <= 2, t;
    }
    DeletePropertyKeyframes(t) {
      this._lastPropertyKeyframeDataItem = null;
      this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(t), this._basic = this.GetPropertyKeyframeDataItems().length <= 2;
    }
    _SaveToJson() {
      return { "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson(), "basic": this._basic };
    }
    _LoadFromJson(t) {
      t && (this.GetSourceAdapter()._LoadFromJson(t["sourceAdapterJson"]), this._basic = t["basic"]);
    }
  };
}
{
  const C32 = self.C3, Ease = self.Ease, NAME = 0, TRANSITION_KEYFRAMES = 1, LINEAR = 2;
  C32.Transition = class extends C32.DefendedBase {
    constructor(e, t = true) {
      super(), this._name = e[0], this._linear = e[2], this._transitionKeyframes = [];
      for (const t2 of e[1]) {
        const e2 = C32.TransitionKeyframe.Create(this, t2);
        this._transitionKeyframes.push(e2);
      }
      for (let e2 = 0; e2 < this._transitionKeyframes.length; e2++) {
        const t2 = this._transitionKeyframes[e2], a = this._transitionKeyframes[e2 + 1], s = this._transitionKeyframes[e2 - 1];
        t2.SetNext(a), t2.SetPrevious(s);
      }
      this._precalculatedSamples = /* @__PURE__ */ new Map(), this._transitionKeyframeCache = /* @__PURE__ */ new Map(), this._PreCalcSamples(), t && Ease.AddCustomEase(this._name, (e2, t2, a, s) => this.Interpolate(e2, t2, a, s), null, { transition: this });
    }
    static Create(e) {
      return C32.New(C32.Transition, e);
    }
    Release() {
      for (const e of this._transitionKeyframes) e.Release();
      C32.clearArray(this._transitionKeyframes), this._transitionKeyframes = null, this._precalculatedSamples.clear(), this._precalculatedSamples = null, this._transitionKeyframeCache.clear(), this._transitionKeyframeCache = null;
    }
    MakeLinear(e) {
      this._linear = !!e;
    }
    GetTransitionKeyFrameAt(e) {
      const t = this._transitionKeyframeCache.get(e);
      if (t) return t;
      for (const t2 of this._transitionKeyframes) if (t2.GetValueX() === e) return this._transitionKeyframeCache.set(e, t2), t2;
    }
    GetFirstTransitionKeyFrameLowerOrEqualThan(e) {
      for (let t = this._transitionKeyframes.length - 1; t >= 0; t--) {
        const a = this._transitionKeyframes[t], s = a.GetValueX();
        if (s <= e) {
          let t2 = a;
          if (s < e) return t2;
          if (s === e) {
            for (; t2; ) {
              const e2 = t2.GetPrevious();
              if (!e2) break;
              if (e2.GetValueX() !== t2.GetValueX()) break;
              t2 = e2;
            }
            return t2;
          }
        }
      }
    }
    Interpolate(e, t, a, s) {
      let n = e / s;
      if (this._linear) {
        const n2 = this.GetTransitionKeyFrameAt(0), r2 = this.GetTransitionKeyFrameAt(1), i2 = t + (t + a) * n2.GetValueY(), l2 = (t + a) * r2.GetValueY() - i2;
        return 0 === s ? i2 + l2 : Ease.NoEase(e, i2, l2, s);
      }
      0 === s && (n = 1);
      let r = this.GetFirstTransitionKeyFrameLowerOrEqualThan(n), i = r.GetNext();
      if (!i) {
        const e2 = r.GetPrevious(), t2 = r;
        r = e2, i = t2;
      }
      const l = i.GetValueX() - r.GetValueX(), o = C32.mapToRange(n, r.GetValueX(), i.GetValueX(), 0, l);
      if (r.IsSegmentLinear() || 0 === l) {
        const e2 = t + (t + a) * r.GetValueY(), s2 = (t + a) * i.GetValueY() - e2;
        return 0 === l ? 1 === o ? e2 + s2 : e2 : Ease.NoEase(o, e2, s2, l);
      }
      const h = r.GetValueX(), u = r.GetValueY(), c = r.GetValueX() + r.GetStartAnchorX(), f = r.GetValueY() + r.GetStartAnchorY(), G = i.GetValueX() + i.GetEndAnchorX(), m = i.GetValueY() + i.GetEndAnchorY(), _ = i.GetValueX(), y = i.GetValueY();
      let K = Ease.GetRuntimeEase("spline")(o, h, u, c, f, G, m, _, y, this._precalculatedSamples.get(r));
      return K += r.GetValueY(), (1 - K) * t + K * (t + a);
    }
    _PreCalcSamples() {
      this._precalculatedSamples.clear();
      for (let e = 0; e < this._transitionKeyframes.length - 1; e++) {
        const t = this._transitionKeyframes[e];
        if (!t.GetStartEnable()) continue;
        const a = t, s = this._transitionKeyframes[e + 1];
        if (!s.GetEndEnable()) continue;
        const n = a.GetValueX(), r = a.GetValueX() + a.GetStartAnchorX(), i = s.GetValueX() + s.GetEndAnchorX(), l = s.GetValueX();
        this._precalculatedSamples.set(a, Ease.GetBezierSamples(n, r, i, l));
      }
    }
  };
}
{
  const C32 = self.C3, VALUE_X = 0, VALUE_Y = 1, START_ANCHOR_X = 2, START_ANCHOR_Y = 3, END_ANCHOR_X = 4, END_ANCHOR_Y = 5, START_ENABLE = 6, END_ENABLE = 7, SEGMENT_MODE = 8;
  C32.TransitionKeyframe = class extends C32.DefendedBase {
    constructor(t, e) {
      super(), this._transition = t, this._valueX = e[0], this._valueY = e[1], this._startAnchorX = e[2], this._startAnchorY = e[3], this._endAnchorX = e[4], this._endAnchorY = e[5], this._startEnable = e[6], this._endEnable = e[7], this._segmentMode = e[8], this._next = null, this._prev = null;
    }
    Release() {
      this._transition = null;
    }
    static Create(t, e) {
      return C32.New(C32.TransitionKeyframe, t, e);
    }
    SetNext(t) {
      this._next = t;
    }
    GetNext() {
      return this._next;
    }
    SetPrevious(t) {
      this._prev = t;
    }
    GetPrevious() {
      return this._prev;
    }
    GetValueX() {
      return this._valueX;
    }
    GetValueY() {
      return this._valueY;
    }
    GetStartAnchorX() {
      return this._startAnchorX;
    }
    GetStartAnchorY() {
      return this._startAnchorY;
    }
    GetEndAnchorX() {
      return this._endAnchorX;
    }
    GetEndAnchorY() {
      return this._endAnchorY;
    }
    GetStartEnable() {
      return this._startEnable;
    }
    GetEndEnable() {
      return this._endEnable;
    }
    IsSegmentLinear() {
      return "linear" === this._segmentMode;
    }
    IsSegmentCubic() {
      return "cubic" === this._segmentMode;
    }
  };
}
{
  const C32 = self.C3;
  C32.TransitionManager = class extends C32.DefendedBase {
    constructor(s) {
      super(), this._runtime = s, this._transitions = [];
    }
    Release() {
      for (const s of this._transitions) s.Release();
      C32.clearArray(this._transitions), this._transitions = null;
    }
    Create(s) {
      this._transitions.push(C32.Transition.Create(s));
    }
  };
}
{
  const C32 = self.C3;
  C32.TemplateManager = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e, this._templateDataMap = null, this._instanceToTemplateNameMap = null, this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance);
    }
    Release() {
      if (this.RemoveRuntimeListeners(), this._templateDataMap) {
        for (const e of this._templateDataMap.values()) e.clear();
        this._templateDataMap.clear();
      }
      this._templateDataMap = null, this._runtime = null;
    }
    Create(e) {
      if (this._templateDataMap || (this._templateDataMap = /* @__PURE__ */ new Map()), !e) return;
      const t = e[0][16][0], a = e[1];
      this._templateDataMap.has(a) || this._templateDataMap.set(a, /* @__PURE__ */ new Map());
      this._templateDataMap.get(a).set(t, e);
    }
    AddRuntimeListeners() {
      const e = this._runtime.Dispatcher();
      e && e.addEventListener("instancedestroy", this._instanceDestroy);
    }
    RemoveRuntimeListeners() {
      const e = this._runtime.Dispatcher();
      e && e.removeEventListener("instancedestroy", this._instanceDestroy);
    }
    HasTemplates() {
      return !!this._templateDataMap && 0 !== this._templateDataMap.size;
    }
    GetTemplateData(e, t) {
      let a = 0;
      if (a = e instanceof C32.ObjectClass ? e.GetIndex() : e, !this._templateDataMap.has(a)) return;
      const s = this._templateDataMap.get(a).get(t);
      return s ? JSON.parse(JSON.stringify(s)) : void 0;
    }
    MapInstanceToTemplateName(e, t) {
      this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = /* @__PURE__ */ new WeakMap()), this._instanceToTemplateNameMap.has(e) || this._instanceToTemplateNameMap.set(e, t);
    }
    GetInstanceTemplateName(e) {
      if (!this._instanceToTemplateNameMap) return "";
      const t = this._instanceToTemplateNameMap.get(e);
      return t || "";
    }
    _OnInstanceDestroy(e) {
      this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(e) && this._instanceToTemplateNameMap.delete(e);
    }
  };
}
{
  const C32 = self.C3;
  C32.FlowchartManager = class {
    constructor(a) {
      this._runtime = a, this._flowchartDataManager = new C32.FlowchartDataManager();
    }
    Release() {
      this._flowchartDataManager.Release(), this._flowchartDataManager = null, this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    Create(a) {
      this._flowchartDataManager.Add(a);
    }
    GetFlowchartDataItemByName(a) {
      return this._flowchartDataManager.Get(a);
    }
    HasFlowcharts() {
      return this._flowchartDataManager.HasFlowcharts();
    }
  };
}
{
  const C32 = self.C3;
  C32.FlowchartState = class {
    constructor(t, e, r, a, o, h, s) {
      this._runtime = o.GetRuntime(), this._flowchartManager = o, this._flowchartName = t, this._startNodeTag = r, this._flowchartDataItem = a, this._tag = e, this._pluginInstance = h, this._pluginUID = s ?? h.GetInstance().GetUID(), this._SetStartFlowchartNode(), this._currentFlowchartNodeId = this._startFlowchartNode?.GetFlowchartId() ?? -1, this._previousFlowchartNodeIds = [], this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._triggerCount = 0, this._markForRelease = false, this._released = false;
    }
    Release() {
      this._released || (C32.clearArray(this._previousFlowchartNodeIds), this._previousFlowchartNodeIds = null, this._runtime = null, this._flowchartManager = null, this._flowchartDataItem = null, this._pluginInstance = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._released = true);
    }
    WasReleased() {
      return this._released;
    }
    GetFlowchartManager() {
      return this._flowchartManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetName() {
      return this._flowchartName;
    }
    GetFlowchartDataItem() {
      return this._flowchartDataItem;
    }
    GetTag() {
      return this._tag;
    }
    GetPluginInstance() {
      return this._pluginInstance || (this._pluginInstance = this._runtime.GetInstanceByUID(this._pluginUID).GetSdkInstance()), this._pluginInstance;
    }
    GetCurrentNode() {
      return this.GetFlowchartElementById(this._currentFlowchartNodeId);
    }
    GetCurrentNodeTag() {
      const t = this.GetCurrentNode();
      return t ? t.GetTag() : "";
    }
    GetCurrentNodeTags() {
      const t = this.GetCurrentNode();
      return t ? t.GetTags() : [];
    }
    CurrentNodeHasTags(t) {
      const e = this.GetCurrentNodeTags();
      if (!e) return false;
      if (!e.length) return false;
      const r = C32.FlowchartState._GetTagArray(t);
      return !(!r || !r.length) && r.every(C32.FlowchartState._HasTag, e);
    }
    CurrentNodeCompareTags(t, e) {
      const r = this.GetCurrentNodeTags();
      if (!r) return false;
      if (!r.length) return false;
      const a = C32.FlowchartState._GetTagArray(t);
      return !(!a || !a.length) && a.every((t2) => C32.FlowchartState._CompareTag.call(r, t2, e));
    }
    static _HasTag(t) {
      const e = this;
      return "" === t ? 1 === e.length && "" === e[0] : e.map((t2) => t2.trim().toLowerCase()).includes(t.trim().toLowerCase());
    }
    static _GetTagArray(t) {
      return t.trim().split(" ");
    }
    static _CompareTag(t, e) {
      const r = this;
      return "" === t ? 1 === r.length && "" === r[0] : r.some((r2) => C32.compare(r2.trim(), e, t.trim()));
    }
    GetCurrentNodeParent(t) {
      const e = this.GetCurrentNode();
      if (e) {
        if (C32.IsFiniteNumber(t)) {
          const r = e.GetParentFlowchartIds(), a = r ? r[t] : void 0;
          if (C32.IsFiniteNumber(a)) return this.GetFlowchartElementById(a);
        }
        if ("string" == typeof t) for (const r of e.GetParentFlowchartIds()) {
          const e2 = this.GetFlowchartElementById(r);
          if (e2.HasTags(t)) return this.GetFlowchartElementById(e2.GetFlowchartId());
        }
      }
    }
    GetCurrentNodeParentTag(t) {
      const e = this.GetCurrentNodeParent(t);
      return e ? e.GetTag() : "";
    }
    GetCurrentNodeParentTags(t) {
      const e = this.GetCurrentNodeParent(t);
      return e ? e.GetTags() : "";
    }
    GetCurrentNodeParentIndex(t) {
      const e = this.GetCurrentNode();
      if (!e) return -1;
      const r = e.GetParentFlowchartIds();
      if (!r) return -1;
      const a = this.GetCurrentNodeParent(t);
      return a ? r.indexOf(a.GetFlowchartId()) : -1;
    }
    GetCurrentNodeParentCount() {
      const t = this.GetCurrentNode();
      if (!t) return 0;
      const e = t.GetParentFlowchartIds();
      return e ? e.length : 0;
    }
    GetFlowchartElementById(t) {
      return this._flowchartDataItem.GetFlowchartElementById(t);
    }
    Reset() {
      this._GetRootFlowchartState()._Reset(true);
    }
    _Reset(t) {
      if (this._GetReferenceFlowchartStates()) {
        for (const [t2, e] of this._GetReferenceFlowchartStates().entries()) e._Reset(false);
        this._GetReferenceFlowchartStates().clear();
      }
      if (this._referenceFlowchartStates = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNode = null, this._currentReferenceFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._previousFlowchartNodeIds = [], t) {
        this._flowchartManager.SetCurrentFlowchartState(this);
        const t2 = this._startFlowchartNode.GetFlowchartId();
        t2 !== this._currentFlowchartNodeId && this._GotoFlowchartNode(t2);
      } else this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId();
    }
    GetCurrentNodeOutputCount() {
      const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      return t ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemCount() : 0;
    }
    IsIndexOfDefaultOutput(t) {
      return !(t < 0) && t === this.GetDefaultOutputIndex();
    }
    GetDefaultOutputIndex() {
      const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      if (!t) return -1;
      let e = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
      return e ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems().indexOf(e) : -1;
    }
    GetCurrentNodeOutputNameAt(t) {
      const e = this._GetFlowchartNodeOutputAt(t);
      return e ? e.GetName() : "";
    }
    GetCurrentNodeOutputValueAt(t) {
      let e;
      return C32.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), "string" == typeof t && (e = this._GetFlowchartNodeOutputByName(t)), "number" != typeof t && "string" != typeof t && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression"), e ? e.GetValue() : "";
    }
    _MaybeByPassNodes(t, e) {
      if (t.GetEnable()) return t.GetFlowchartId();
      {
        const r = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
        if (!r) return e.GetFlowchartId();
        const a = r.GetConnectedFlowchartNodeFlowchartId();
        if (!C32.IsFiniteNumber(a)) return e.GetFlowchartId();
        const o = this.GetFlowchartElementById(a);
        return o ? this._MaybeByPassNodes(o, e) : e.GetFlowchartId();
      }
    }
    _MaybeByPassNodesInReferenceFlowchart(t, e) {
      if (t.GetEnable()) {
        if ("reference" === t.GetType()) {
          const e2 = t.GetReferenceFlowchartName(), r = t.GetReferenceFlowchartStartNodeTag(), a = this._flowchartManager.GetFlowchartDataItemByName(e2);
          if (!a) return [-1, null];
          const o = a.GetFlowchartNodeByTags(r);
          return o ? this._MaybeByPassNodesInReferenceFlowchart(o, a) : this._MaybeByPassNodesInReferenceFlowchart(a.GetFlowchartStartNode(), a);
        }
        return [t.GetFlowchartId(), e];
      }
      {
        const r = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
        if (!r) return [-1, null];
        const a = r.GetConnectedFlowchartNodeFlowchartId();
        if (!C32.IsFiniteNumber(a)) return [-1, null];
        const o = e.GetFlowchartElementById(a);
        return o ? this._MaybeByPassNodesInReferenceFlowchart(o, e) : [-1, null];
      }
    }
    _ProcessAllByPasses(t, e) {
      let r = this.GetFlowchartElementById(t);
      if (r) {
        if (!r.GetEnable()) {
          const e2 = this.GetFlowchartElementById(this._currentFlowchartNodeId);
          t = this._MaybeByPassNodes(r, e2);
        }
        if (C32.IsFiniteNumber(t) && t !== this._currentFlowchartNodeId) if (r = this.GetFlowchartElementById(t), "reference" === r.GetType()) {
          const a = r.GetReferenceFlowchartName(), o = r.GetReferenceFlowchartStartNodeTag(), h = this._flowchartManager.GetFlowchartDataItemByName(a);
          let s = h.GetFlowchartNodeByTags(o);
          if (s) {
            const r2 = this._MaybeByPassNodesInReferenceFlowchart(s, h);
            if (-1 === r2[0]) return;
            e(this._currentFlowchartNodeId, t, r2[1], r2[0]);
          } else e(this._currentFlowchartNodeId, t);
        } else e(this._currentFlowchartNodeId, t);
      }
    }
    GotoNextFlowchartNode(t) {
      let e;
      if (C32.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), "string" == typeof t && (e = this._GetFlowchartNodeOutputByName(t)), !e) return;
      let r = e.GetConnectedFlowchartNodeFlowchartId();
      C32.IsFiniteNumber(r) && this._ProcessAllByPasses(r, (t2, e2, r2, a) => {
        this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r2, a);
      });
    }
    GotoNextFlowchartNodeDefault() {
      const t = this._GetFlowchartNodeOutputDefault();
      if (!t) return;
      const e = t.GetConnectedFlowchartNodeFlowchartId();
      C32.IsFiniteNumber(e) && this._ProcessAllByPasses(e, (t2, e2, r, a) => {
        this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r, a);
      });
    }
    GotoAnyFlowchartNode(t) {
      const e = this._flowchartDataItem.GetFlowchartNodeByTags(t);
      if (!e) return;
      const r = e.GetFlowchartId();
      C32.IsFiniteNumber(r) && this._ProcessAllByPasses(r, (t2, e2, r2, a) => {
        this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r2, a);
      });
    }
    GotoPreviousFlowchartNode() {
      const t = this._previousFlowchartNodeIds.pop();
      C32.IsFiniteNumber(t) ? this._GotoFlowchartNode(t) : this._GetPreviousFlowchartState() && (this._flowchartManager.SetCurrentFlowchartState(this._GetPreviousFlowchartState(), true, false, false), this._GetPreviousFlowchartState()._GotoFlowchartNode(this._GetPreviousFlowchartStateStartNodeId()), this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(this._GetPreviousFlowchartState()));
    }
    GotoParentFlowchartNode(t) {
      if (!this.GetCurrentNode()) return;
      const e = this.GetCurrentNodeParent(t);
      if (e) {
        if (!e.GetEnable()) return;
        const t2 = e.GetFlowchartId();
        if (!C32.IsFiniteNumber(t2)) return;
        this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(e.GetFlowchartId());
      }
    }
    HasOutput(t) {
      if (C32.IsFiniteNumber(t)) {
        return !!this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems()[t];
      }
      if ("string" == typeof t) {
        const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
        for (let r = 0; r < e.length; r++) if (e[r].GetName() === t) return true;
        return false;
      }
      return false;
    }
    MarkForRelease() {
      this._markForRelease = true;
    }
    IsInTriggerState() {
      return this._triggerCount > 0;
    }
    PushIsTriggerState() {
      this._triggerCount++;
    }
    PopIsTriggerState() {
      this._triggerCount--, 0 === this._triggerCount && this._markForRelease && this._flowchartManager.RemoveFlowchartState(this);
    }
    _GotoFlowchartNode(t, e, r) {
      const a = this._currentFlowchartNodeId, o = this.GetPluginInstance().GetInstance();
      this.PushIsTriggerState(), this._flowchartManager.PushFlowchartState(this), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChange, o), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChange, o), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChangeInFlowchart, o), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChangeInFlowchart, o), this._currentFlowchartNodeId = t;
      let h = this.GetFlowchartElementById(this._currentFlowchartNodeId);
      if ("dictionary" === h.GetType()) this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChange, o), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChange, o), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, o), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, o);
      if (this._flowchartManager.PopFlowchartState(), this.PopIsTriggerState(), !this.WasReleased() && (h = this.GetFlowchartElementById(this._currentFlowchartNodeId), "reference" === h.GetType())) {
        const t2 = e ? e.GetName() : h.GetReferenceFlowchartName();
        if (this._HasReferenceFlowchartState(h)) {
          this._previousFlowchartNodeIds.pop();
          const t3 = this._GetReferenceFlowchartState(h);
          this._flowchartManager.SetCurrentFlowchartState(t3, true, true, false), t3._SetPreviousFlowchart(this, a);
          this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(t3);
        } else {
          const e2 = "number" == typeof r ? r : h.GetReferenceFlowchartStartNodeTag();
          if (t2) {
            this._previousFlowchartNodeIds.pop();
            let r2 = h.GetReferenceFlowchartTag();
            if (r2) {
              let t3 = this._flowchartManager.GetFlowchartState(r2);
              for (; t3; ) r2 = C32.IncrementNumberAtEndOf(r2), t3 = this._flowchartManager.GetFlowchartState(r2);
            } else {
              r2 = `${t2}-ref`;
              let e3 = this._flowchartManager.GetFlowchartState(r2);
              for (; e3; ) r2 = C32.IncrementNumberAtEndOf(r2), e3 = this._flowchartManager.GetFlowchartState(r2);
            }
            const o2 = this._flowchartManager.AddFlowchartState(t2, e2, r2, this._pluginInstance, true);
            o2._SetPreviousFlowchart(this, a), this._SetReferenceFlowchartState(h, o2);
            const s = this._GetRootFlowchartState();
            o2._SetRootFlowchartState(s), s._SetCurrentReferenceFlowchart(o2);
          }
        }
      }
    }
    _GetFlowchartNodeOutputDefault() {
      const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      return t ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault() : null;
    }
    _GetFlowchartNodeOutputAt(t) {
      const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      if (!e) return null;
      const r = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
      if (!r) return null;
      const a = r[t];
      return a || null;
    }
    _GetFlowchartNodeOutputByName(t) {
      const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      if (!e) return null;
      const r = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemByName(t);
      return r || null;
    }
    _SetStartFlowchartNode(t) {
      if ("number" == typeof t) {
        let e = this.GetFlowchartElementById(t);
        e || (e = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = e;
      } else if ("number" == typeof this._startNodeTag) {
        let t2 = this.GetFlowchartElementById(this._startNodeTag);
        t2 || (t2 = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = t2;
      } else {
        let t2 = this._flowchartDataItem.GetFlowchartNodeByTags(this._startNodeTag);
        t2 || (t2 = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = t2;
      }
    }
    _SaveToJson() {
      return this._markForRelease ? null : { "flowchartName": this._flowchartName, "flowchartTag": this._tag, "startNodeTag": this._startNodeTag, "currentNodeId": this._currentFlowchartNodeId, "previousNodeIds": this._previousFlowchartNodeIds, "pluginUID": this._pluginInstance.GetInstance().GetUID(), "reference": { "previousFlowchartTag": this._GetPreviousFlowchartState() ? this._GetPreviousFlowchartState().GetTag() : "", "previousStartNodeId": C32.IsFiniteNumber(this._GetPreviousFlowchartStateStartNodeId()) ? this._GetPreviousFlowchartStateStartNodeId() : NaN, "referencesJson": this._GetFlowchartReferencesJson(), "currentReferenceFlowchartTag": this.GetCurrentReferenceFlowchart() ? this.GetCurrentReferenceFlowchart().GetTag() : "", "rootFlowchartTag": this._GetRootFlowchartState() ? this._GetRootFlowchartState().GetTag() : "" } };
    }
    _GetFlowchartReferencesJson() {
      if (!this._HasReferenceFlowchartStates()) return null;
      const t = [];
      for (const [e, r] of this._GetReferenceFlowchartStates().entries()) t.push({ "flowchartElementId": e.GetFlowchartId(), "flowchartStateTag": r.GetTag() });
      return t.length ? t : null;
    }
    _LoadFromJson(t) {
      if (t) {
        if (this._flowchartName = t["flowchartName"], this._tag = t["flowchartTag"], this._startNodeTag = t["startNodeTag"], this._currentFlowchartNodeId = t["currentNodeId"], this._previousFlowchartNodeIds = t["previousNodeIds"], this._pluginUID = t["pluginUID"], t.hasOwnProperty("reference")) {
          const e = t["reference"];
          this._previousFlowchartStateTag = e["previousFlowchartTag"], this._previousFlowchartStateStartNodeId = e["previousStartNodeId"], this._referenceFlowchartStatesJson = e["referencesJson"], this._currentReferenceFlowchartStateTag = e["currentReferenceFlowchartTag"], this._rootFlowchartStateTag = e["rootFlowchartTag"];
        }
        this._SetStartFlowchartNode();
      }
    }
    _GetPreviousFlowchartState() {
      return "string" == typeof this._previousFlowchartStateTag && this._previousFlowchartStateTag && (this._previousFlowchartState = this._flowchartManager.GetFlowchartState(this._previousFlowchartStateTag), this._previousFlowchartStateTag = ""), this._previousFlowchartState;
    }
    _GetPreviousFlowchartStateStartNodeId() {
      return this._previousFlowchartStateStartNodeId;
    }
    _SetPreviousFlowchart(t, e) {
      this._previousFlowchartState = t, this._previousFlowchartStateStartNodeId = e;
    }
    GetCurrentReferenceFlowchart() {
      return "string" == typeof this._currentReferenceFlowchartStateTag && this._currentReferenceFlowchartStateTag && (this._currentReferenceFlowchartState = this._flowchartManager.GetFlowchartState(this._currentReferenceFlowchartStateTag), this._currentReferenceFlowchartStateTag = ""), this._currentReferenceFlowchartState;
    }
    _SetCurrentReferenceFlowchart(t) {
      this._currentReferenceFlowchartState = t, this._currentReferenceFlowchartState === this && (this._currentReferenceFlowchartState = null);
    }
    _GetRootFlowchartState() {
      return "string" == typeof this._rootFlowchartStateTag && this._rootFlowchartStateTag && (this._rootFlowchartState = this._flowchartManager.GetFlowchartState(this._rootFlowchartStateTag), this._rootFlowchartStateTag = ""), this._rootFlowchartState ? this._rootFlowchartState : this;
    }
    _SetRootFlowchartState(t) {
      this._rootFlowchartState = t;
    }
    _HasReferenceFlowchartStates() {
      return this._RebuildReferenceFlowchartStates(), !!this._referenceFlowchartStates;
    }
    _HasReferenceFlowchartState(t) {
      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates && this._referenceFlowchartStates.has(t);
    }
    _RebuildReferenceFlowchartStates() {
      if (this._referenceFlowchartStatesJson) {
        this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map());
        for (const t of this._referenceFlowchartStatesJson) {
          const e = this._flowchartManager.GetFlowchartState(t["flowchartStateTag"]), r = e.GetFlowchartElementById(t["flowchartElementId"]);
          this._referenceFlowchartStates.set(r, e);
        }
        this._referenceFlowchartStatesJson = null;
      }
    }
    _GetReferenceFlowchartStates() {
      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates;
    }
    _GetReferenceFlowchartState(t) {
      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates.get(t);
    }
    _SetReferenceFlowchartState(t, e) {
      this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map()), this._referenceFlowchartStates.set(t, e);
    }
  };
}
{
  const C32 = self.C3;
  C32.FlowchartStateManager = class {
    constructor(t) {
      this._runtime = t, this._flowchartStates = /* @__PURE__ */ new Map(), this._currentFlowchartState = null, this._flowchartStateStack = [], this._on_after_load = () => this._OnAfterLoad(), this._loadJson = null;
    }
    Release() {
      C32.clearArray(this._flowchartStateStack), this._flowchartStateStack = null, this._flowchartStates.clear(), this._flowchartStates = null, this._currentFlowchartState = null, this._runtime = null, this._loadJson = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetFlowchartDataItemByName(t) {
      return this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t);
    }
    AddFlowchartState(t, e, a, r, h, s) {
      const o = this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t);
      if (!o) return void console.warn(`[Flowcharts] no flowchart found with name '${t}'`);
      if (this._flowchartStates.has(a)) {
        const t2 = this._flowchartStates.get(a);
        t2 && this.RemoveFlowchartState(t2);
      }
      const n = new C32.FlowchartState(t, a, e, o, this, r, s);
      return this._flowchartStates.set(a, n), h && this.SetCurrentFlowchartState(n, true), n;
    }
    RemoveFlowchartState(t) {
      if (t.MarkForRelease(), t.IsInTriggerState()) return;
      const e = t.GetTag();
      this._flowchartStates.delete(e), t.Release(), this._currentFlowchartState === t && (this._currentFlowchartState = null);
    }
    ResetFlowchartState(t) {
      t.Reset();
    }
    GetFlowchartState(t) {
      return this._flowchartStates.get(t);
    }
    PushFlowchartState(t) {
      this._flowchartStateStack.push(t);
    }
    PopFlowchartState() {
      this._flowchartStateStack.pop();
    }
    SetCurrentFlowchartState(t, e = false, a = false, r = true) {
      if (r) {
        const e2 = t.GetCurrentReferenceFlowchart();
        t = e2 || t;
      }
      t !== this._currentFlowchartState && (this._TriggerBeforeFlowchartChange(), this._TriggerAfterFlowchartChange(t, e, a));
    }
    GetCurrentFlowchartState(t) {
      return "string" == typeof t ? this.GetFlowchartState(t) : this._flowchartStateStack.length ? this._flowchartStateStack[this._flowchartStateStack.length - 1] : this._currentFlowchartState;
    }
    _TriggerBeforeFlowchartChange() {
      if (!this._currentFlowchartState) return;
      if (this._currentFlowchartState.WasReleased()) return;
      const t = this._currentFlowchartState.GetPluginInstance().GetInstance();
      this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeFlowchartChange, t), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();
    }
    _TriggerAfterFlowchartChange(t, e = false, a = false) {
      if (this._currentFlowchartState = t, !this._currentFlowchartState) return;
      if (this._currentFlowchartState.WasReleased()) return;
      const r = this._currentFlowchartState.GetPluginInstance().GetInstance();
      this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnFlowchartChange, r), true !== a && "number" != typeof a || this._currentFlowchartState._SetStartFlowchartNode(a), e && (this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChange, r), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChange, r), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, r), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, r)), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();
    }
    _SaveToJson() {
      return { "flowchartJsonObjects": [...this._flowchartStates.values()].map((t) => t._SaveToJson()), "currentFlowchartTag": this._currentFlowchartState ? this._currentFlowchartState.GetTag() : null };
    }
    _LoadFromJson(t) {
      if (!t) return;
      this._loadJson = t;
      const e = /* @__PURE__ */ new Map();
      for (const t2 of this._loadJson["flowchartJsonObjects"]) {
        const a = t2["flowchartTag"];
        if (this._flowchartStates.has(a)) {
          const r = this._flowchartStates.get(a);
          r._LoadFromJson(t2), e.set(a, r);
        } else {
          const a2 = this.AddFlowchartState(t2["flowchartName"], t2["startNodeTag"], t2["flowchartTag"], null, false, t2["pluginUID"]);
          a2._LoadFromJson(t2), e.set(t2["flowchartTag"], a2);
        }
      }
      for (const [t2, a] of this._flowchartStates.entries()) e.has(t2) || a.Release();
      this._flowchartStates.clear(), this._flowchartStates = e, this._runtime.IsLoadingState() ? this._runtime.Dispatcher().addEventListener("afterload", this._on_after_load) : this._OnAfterLoad();
    }
    _OnAfterLoad() {
      this._runtime.Dispatcher().removeEventListener("afterload", this._on_after_load);
      const t = this._flowchartStates.get(this._loadJson["currentFlowchartTag"]);
      t && this.SetCurrentFlowchartState(t, true), this._loadJson = null;
    }
  };
}
{
  const C32 = self.C3;
  C32.FlowchartDataManager = class {
    constructor() {
      this._flowchartDataItems = /* @__PURE__ */ new Map();
    }
    Release() {
      for (const t of this._flowchartDataItems.values()) t.Release();
      this._flowchartDataItems.clear(), this._flowchartDataItems = null;
    }
    Add(t) {
      const a = new C32.FlowchartDataItem(t), s = a.GetName();
      this._flowchartDataItems.set(s, a);
    }
    Get(t) {
      return this._flowchartDataItems.get(t);
    }
    HasFlowcharts() {
      return !!this._flowchartDataItems.size;
    }
    static CreateDataItems(t, a, s, e) {
      if (a) for (const o of a) {
        const a2 = new s(o, e);
        t.push(a2);
      }
    }
  };
}
{
  const C32 = self.C3, NAME = 0, NODES = 1;
  C32.FlowchartDataItem = class {
    constructor(t) {
      this._name = t[0], this._flowchartNodeData = new C32.FlowchartNodeData(t[1], this);
    }
    Release() {
      this._flowchartNodeData.Release(), this._flowchartNodeData = null;
    }
    GetFlowchartNodeData() {
      return this._flowchartNodeData;
    }
    GetFlowchartElementById(t) {
      return this._flowchartNodeData.GetFlowchartElementById(t);
    }
    GetFlowchartNodeByTags(t) {
      return this._flowchartNodeData.GetFlowchartNodeByTags(t);
    }
    GetFlowchartStartNode() {
      return this._flowchartNodeData.GetFlowchartStartNode();
    }
    GetName() {
      return this._name;
    }
  };
}
{
  const C32 = self.C3, FLOWCHART_ID = 0, TAG = 1, PARENT_FLOWCHART_IDS = 2, PARENT_OUTPUT_FLOWCHART_IDS = 3, CHILDREN_FLOWCHART_IDS = 4, OUTPUTS = 5, IS_START = 6, TYPE = 7, DICTIONARY_ENABLE = 8, REFERENCE_FLOWCHART = 8, REFERENCE_FLOWCHART_START_NODE = 9, REFERENCE_FLOWCHART_TAG = 10, REFERENCE_FLOWCHART_ENABLE = 11;
  class FlowchartNodeDataItem {
    constructor(t, e) {
      this._flowchartNodeData = e, this._type = t[7], this._flowchartId = t[0], this._tag = t[1], this._tag ? this._tags = this._tag.trim().split(" ").map((t2) => t2.trim()) : this._tags = [], this._parentFlowchartIds = t[2], this._parentOutputFlowchartIds = null, this._childrenFlowchartIds = null, this._enable = false, "dictionary" === this._type && (this._parentOutputFlowchartIds = t[3], this._childrenFlowchartIds = t[4], this._enable = t[8]), this._isStart = t[6], this._referenceFlowchartName = null, this._referenceFlowchartStartNodeTag = null, this._referenceFlowchartTag = null, "reference" === this._type && (this._referenceFlowchartName = t[8], this._referenceFlowchartStartNodeTag = t[9], this._referenceFlowchartTag = t[10], this._enable = t[11]), this._flowchartNodeOutputData = new C32.FlowchartNodeOutputData(t[5], this);
    }
    Release() {
      this._flowchartNodeData = null;
    }
    GetFlowchartNodeData() {
      return this._flowchartNodeData;
    }
    GetFlowchartNodeOutputData() {
      return this._flowchartNodeOutputData;
    }
    GetFlowchartId() {
      return this._flowchartId;
    }
    GetTag() {
      return this._tag;
    }
    GetTags() {
      return this._tags;
    }
    HasTags(t) {
      if (!this._tags) return false;
      if (!this._tags.length) return false;
      const e = C32.FlowchartState._GetTagArray(t);
      return !(!e || !e.length) && e.every(C32.FlowchartState._HasTag, this._tags);
    }
    GetIsStart() {
      return this._isStart;
    }
    SetIsStart(t) {
      this._isStart = !!t;
    }
    CanBeStartNode() {
      if ("dictionary" === this._type) return true;
      if ("reference" === this._type) return false;
      throw new Error(`unexpected flowchart node type: ${this._type}`);
    }
    GetParentFlowchartIds() {
      return this._parentFlowchartIds;
    }
    GetParentOutputFlowchartIds() {
      return this._parentOutputFlowchartIds;
    }
    GetChildrenFlowchartIds() {
      return this._childrenFlowchartIds;
    }
    GetType() {
      return this._type;
    }
    GetEnable() {
      return this._enable;
    }
    GetReferenceFlowchartName() {
      return this._referenceFlowchartName;
    }
    GetReferenceFlowchartStartNodeTag() {
      return this._referenceFlowchartStartNodeTag;
    }
    GetReferenceFlowchartTag() {
      return this._referenceFlowchartTag;
    }
  }
  C32.FlowchartNodeData = class {
    constructor(t, e) {
      this._flowchartDataItem = e, this._flowchartNodeItems = [], this._flowchartNodeItemsIdMap = /* @__PURE__ */ new Map(), this._flowchartNodeItemsTagMap = /* @__PURE__ */ new Map(), this._flowchartNodeStartItem = null, C32.FlowchartDataManager.CreateDataItems(this._flowchartNodeItems, t, FlowchartNodeDataItem, this);
      for (const t2 of this._flowchartNodeItems) {
        const e2 = t2.GetFlowchartId(), a = t2.GetTag(), r = t2.GetTags(), s = t2.GetIsStart();
        if (this._flowchartNodeItemsIdMap.set(e2, t2), a) for (const e3 of r) this._flowchartNodeItemsTagMap.has(e3) || this._flowchartNodeItemsTagMap.set(e3, /* @__PURE__ */ new Set()), this._flowchartNodeItemsTagMap.get(e3).add(t2);
        s && (this._flowchartNodeStartItem = t2);
        const o = t2.GetFlowchartNodeOutputData();
        for (const t3 of o.flowchartNodeOutputDataItems()) {
          const e3 = t3.GetFlowchartId();
          this._flowchartNodeItemsIdMap.set(e3, t3);
        }
      }
      this._flowchartNodeStartItem || this._SetStartNodeIfMissing();
    }
    Release() {
      this._flowchartDataItem = null;
      for (const t of this._flowchartNodeItems) t.Release();
      C32.clearArray(this._flowchartNodeItems), this._flowchartNodeItems = null;
    }
    GetFlowchartDataItem() {
      return this._flowchartDataItem;
    }
    GetFlowchartElementById(t) {
      return this._flowchartNodeItemsIdMap.get(t);
    }
    GetFlowchartNodeByTags(t) {
      if (!t || !t.length) return null;
      const e = [];
      for (const a of t.trim().split(" ")) {
        let t2 = this._flowchartNodeItemsTagMap.get(a.trim()) ?? /* @__PURE__ */ new Set();
        if (0 === t2.size) return null;
        e.push(t2);
      }
      return [...e.reduce((t2, e2) => e2.size < t2.size ? e2 : t2)].filter((t2) => e.every((e2) => e2.has(t2)))[0];
    }
    GetFlowchartStartNode() {
      return this._flowchartNodeStartItem;
    }
    *flowchartNodeDataItems() {
      for (const t of this._flowchartNodeItems) yield t;
    }
    _SetStartNodeIfMissing() {
      let t = 0;
      for (const e of this.flowchartNodeDataItems()) e.GetIsStart() && t++;
      if (0 === t) {
        for (const t2 of this.flowchartNodeDataItems()) if (t2.CanBeStartNode() && !t2.GetIsStart()) return void t2.SetIsStart(true);
      } else {
        if (1 === t) return;
        if (t > 1) {
          let t2 = true;
          for (const e of this.flowchartNodeDataItems()) e.CanBeStartNode() && (e.GetIsStart() && t2 ? t2 = false : e.GetIsStart() && !t2 && e.SetIsStart(false));
        }
      }
      for (const t2 of this.flowchartNodeDataItems()) if (t2.CanBeStartNode() && t2.GetIsStart()) return void (this._flowchartNodeStartItem = t2);
    }
  };
}
{
  const C32 = self.C3, FLOWCHART_ID = 0, NAME = 1, VALUE = 2, CONNECTED_FLOWCHART_NODE_FLOWCHART_ID = 3, ENABLE = 4, DEFAULT = 5;
  class FlowchartNodeDataOutputItem {
    constructor(t, e) {
      this._flowchartNodeOutputData = e, this._flowchartId = t[0], this._name = t[1], this._value = t[2], this._connectedFlowchartNodeFlowchartId = t[3], this._enable = t[4], this._default = t[5];
    }
    Release() {
      this._flowchartNodeOutputData = null;
    }
    GetFlowchartNodeOutputData() {
      return this._flowchartNodeOutputData;
    }
    GetFlowchartId() {
      return this._flowchartId;
    }
    GetName() {
      return this._name;
    }
    GetValue() {
      return this._value;
    }
    GetConnectedFlowchartNodeFlowchartId() {
      return this._connectedFlowchartNodeFlowchartId;
    }
    GetEnable() {
      return this._enable;
    }
    GetDefault() {
      return this._default;
    }
  }
  C32.FlowchartNodeOutputData = class {
    constructor(t, e) {
      this._flowchartDataNodeItem = e, this._flowchartNodeOutputItems = [], this._flowchartNodeOutputItemsNameMap = /* @__PURE__ */ new Map(), C32.FlowchartDataManager.CreateDataItems(this._flowchartNodeOutputItems, t, FlowchartNodeDataOutputItem, this), this._enabledFlowchartNodeOutputItems = this._flowchartNodeOutputItems.filter((t2) => t2.GetEnable());
      for (const t2 of this._enabledFlowchartNodeOutputItems) this._flowchartNodeOutputItemsNameMap.set(t2.GetName(), t2);
    }
    Release() {
      this._flowchartDataNodeItem = null;
      for (const t of this._flowchartNodeOutputItems) t.Release();
      C32.clearArray(this._flowchartNodeOutputItems), this._flowchartNodeOutputItems = null, C32.clearArray(this._enabledFlowchartNodeOutputItems), this._enabledFlowchartNodeOutputItems = null;
    }
    GetFlowchartNodeDataItem() {
      return this._flowchartDataNodeItem;
    }
    GetFlowchartNodeOutputDataItemCount() {
      return this._enabledFlowchartNodeOutputItems.length;
    }
    GetFlowchartNodeOutputDataItems() {
      return this._enabledFlowchartNodeOutputItems;
    }
    GetFlowchartNodeOutputDataItemByName(t) {
      return this._flowchartNodeOutputItemsNameMap.get(t);
    }
    GetFlowchartNodeOutputDefault() {
      for (const t of this._enabledFlowchartNodeOutputItems) if (t.GetDefault()) return t;
    }
    *flowchartNodeOutputDataItems() {
      for (const t of this._enabledFlowchartNodeOutputItems) yield t;
    }
  };
}
{
  const C32 = self.C3;
  C32.SolStack = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._objectClass = t, this._stack = [], this._stack.push(C32.New(C32.Sol, this)), this._index = 0, this._current = this._stack[0];
    }
    Release() {
      for (const t of this._stack) t.Release();
      C32.clearArray(this._stack), this._current = null, this._objectClass = null;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetCurrentSol() {
      return this._current;
    }
    GetOneBelowCurrentSol() {
      return this._stack[this._index - 1];
    }
    Clear() {
      this.GetCurrentSol().Clear();
    }
    PushClean() {
      const t = this._stack, s = ++this._index;
      if (s === t.length) {
        const s2 = C32.New(C32.Sol, this);
        t.push(s2), this._current = s2;
      } else {
        const e = t[s];
        e.Reset(), this._current = e;
      }
    }
    PushCopy() {
      const t = this._stack, s = ++this._index;
      s === t.length && t.push(C32.New(C32.Sol, this));
      const e = t[s];
      e.Copy(t[s - 1]), this._current = e;
    }
    Pop() {
      this._current = this._stack[--this._index];
    }
    RemoveInstances(t) {
      const s = this._stack;
      for (let e = 0, n = s.length; e < n; ++e) s[e].RemoveInstances(t);
    }
  };
}
{
  const C32 = self.C3;
  C32.Sol = class extends C32.DefendedBase {
    constructor(s) {
      super(), this._stack = s, this._objectClass = this._stack.GetObjectClass(), this._eventStack = this._objectClass.GetRuntime().GetEventStack(), this._selectAll = true, this._instances = [], this._elseInstances = [];
    }
    Release() {
      this.ClearArrays(), this._stack = null, this._objectClass = null, this._eventStack = null;
    }
    ClearArrays() {
      C32.clearArray(this._instances), C32.clearArray(this._elseInstances);
    }
    GetObjectClass() {
      return this._objectClass;
    }
    IsSelectAll() {
      return this._selectAll;
    }
    HasAnyInstances() {
      return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length;
    }
    GetInstances() {
      return this._selectAll ? this._objectClass.GetInstances() : this._instances;
    }
    HasAnyElseInstances() {
      return !!this._elseInstances.length;
    }
    GetElseInstances() {
      return this._elseInstances;
    }
    GetExpressionInstances() {
      const s = this.GetInstances();
      return s.length ? s : this._elseInstances;
    }
    Reset() {
      this._selectAll = true, C32.clearArray(this._elseInstances);
    }
    Clear() {
      this._selectAll = true;
    }
    Copy(s) {
      s.IsSelectAll() ? this.Reset() : (this._selectAll = false, C32.shallowAssignArray(this._instances, s._instances), C32.clearArray(this._elseInstances));
    }
    _PushInstance(s) {
      this._instances.push(s);
    }
    _PushElseInstance(s) {
      this._elseInstances.push(s);
    }
    _SetSelectAll(s) {
      this._selectAll = !!s;
    }
    _GetOwnInstances() {
      return this._instances;
    }
    _GetOwnElseInstances() {
      return this._elseInstances;
    }
    SetSinglePicked(s) {
      this._selectAll = false, C32.clearArray(this._instances), this._instances.push(s);
    }
    SetArrayPicked(s) {
      this._selectAll = false, C32.shallowAssignArray(this._instances, s);
    }
    SetSetPicked(s) {
      this._selectAll = false, C32.clearArray(this._instances);
      for (const e of s) this._instances.push(e);
    }
    AddElseInstances(s, e) {
      for (const t of e) s.has(t) || this._elseInstances.push(t);
    }
    TransferElseInstancesToOwn(s) {
      for (const e of s) this._instances.push(e);
      C32.arrayRemoveAllInSet(this._elseInstances, s);
    }
    ClearElseInstances() {
      C32.clearArray(this._elseInstances);
    }
    PickOne(s) {
      if (s) if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {
        this.IsSelectAll() && (C32.clearArray(this._instances), C32.shallowAssignArray(this._elseInstances, s.GetObjectClass().GetInstances()), this._selectAll = false);
        const e = this._elseInstances.indexOf(s);
        -1 !== e && (this._instances.push(this._elseInstances[e]), this._elseInstances.splice(e, 1));
      } else this.SetSinglePicked(s);
    }
    RemoveInstances(s) {
      C32.arrayRemoveAllInSet(this._instances, s), C32.arrayRemoveAllInSet(this._elseInstances, s);
    }
  };
}
{
  const C32 = self.C3;
  C32.EventStack = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._stack.push(C32.New(C32.EventStackFrame, this, null)), this._index = 0, this._expFuncStack = [];
    }
    Release() {
      for (const t of this._stack) t.Release();
      C32.clearArray(this._stack), C32.clearArray(this._expFuncStack), this._eventSheetManager = null, this._runtime = null;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetCurrentStackFrame() {
      return this._stack[this._index];
    }
    GetAllStackFrames() {
      return this._stack;
    }
    GetCurrentStackFrameIndex() {
      return this._index;
    }
    Push(t) {
      const e = this._stack, n = ++this._index;
      if (n === e.length) {
        const n2 = C32.New(C32.EventStackFrame, this, t);
        return e.push(n2), n2;
      }
      {
        const s = e[n];
        return s.Reset(t), s;
      }
    }
    Pop() {
      --this._index;
    }
    PushExpFunc(t) {
      this._expFuncStack.push(t);
    }
    PopExpFunc() {
      this._expFuncStack.pop();
    }
    GetCurrentExpFuncStackFrame() {
      const t = this._expFuncStack;
      return 0 === t.length ? null : t.at(-1);
    }
  };
}
{
  const C32 = self.C3;
  C32.EventStackFrame = class extends C32.DefendedBase {
    constructor(t, e) {
      super(), this._stack = t, this._runtime = this._stack.GetRuntime(), this._currentEvent = e, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._expressionObjectClass = null, this._functionReturnType = 0, this._functionReturnValue = 0, this._dynamicSolModifiers = null;
    }
    Release() {
      this.Reset(null), this._stack = null, this._runtime = null;
    }
    Reset(t) {
      this._currentEvent = t, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._dynamicSolModifiers = null;
    }
    _Restore(t, e) {
      this._currentEvent = t, this._cndIndex = 0, this._actIndex = e;
    }
    ResetQuick() {
      this._cndIndex = 0, this._actIndex = 0;
    }
    GetCurrentEvent() {
      return this._currentEvent;
    }
    SetCurrentEvent(t) {
      this._currentEvent = t;
    }
    GetConditionIndex() {
      return this._cndIndex;
    }
    SetConditionIndex(t) {
      this._cndIndex = t;
    }
    GetActionIndex() {
      return this._actIndex;
    }
    SetActionIndex(t) {
      this._actIndex = t;
    }
    SetLastEventTrue(t) {
      this._lastEventTrue = !!t;
    }
    GetLastEventTrue() {
      return this._lastEventTrue;
    }
    SetElseBranchRan(t) {
      this._elseBranchRan = !!t;
    }
    GetElseBranchRan() {
      return this._elseBranchRan;
    }
    SetExpressionObjectClass(t) {
      this._expressionObjectClass = t;
    }
    GetExpressionObjectClass() {
      return this._expressionObjectClass;
    }
    InitCallFunctionExpression(t, e) {
      this._functionReturnType = t, this._functionReturnValue = e;
    }
    GetFunctionReturnType() {
      return this._functionReturnType;
    }
    SetFunctionReturnValue(t) {
      this._functionReturnValue = t;
    }
    GetFunctionReturnValue() {
      return this._functionReturnValue;
    }
    IsSolModifierAfterCnds() {
      const t = this._currentEvent;
      return !!t.IsSolWriterAfterCnds() || this._cndIndex < t.GetConditionCount() - 1 && !!t.GetSolModifiers().length;
    }
    SetDynamicSolModifiers(t) {
      this._dynamicSolModifiers = t;
    }
    GetDynamicSolModifiers() {
      return this._dynamicSolModifiers;
    }
  };
}
{
  const C32 = self.C3;
  C32.LocalVarStack = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1, this._current = null, this._initialValues = [];
    }
    Release() {
      C32.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;
    }
    _SetInitialValues(t) {
      this._initialValues = t;
      const e = this._initialValues.slice(0);
      this._stack.push(e), this._index = 0, this._current = e;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetCurrent() {
      return this._current;
    }
    Push() {
      const t = ++this._index, e = this._stack;
      t === e.length ? e.push(this._initialValues.slice(0)) : C32.shallowAssignArray(e[t], this._initialValues), this._current = e[t];
    }
    Pop() {
      this._current = this._stack[--this._index];
    }
  };
}
{
  const C32 = self.C3;
  C32.LoopStack = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1;
    }
    Release() {
      C32.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    IsInLoop() {
      return this._index >= 0;
    }
    GetCurrent() {
      return this._stack[this._index];
    }
    Push() {
      if (++this._index, this._index === this._stack.length) {
        const t = C32.New(C32.Loop, this);
        return this._stack.push(t), t;
      }
      {
        const t = this._stack[this._index];
        return t.Reset(), t;
      }
    }
    Pop() {
      --this._index;
    }
    FindByName(t) {
      const e = this._stack;
      for (let s = this._index; s >= 0; --s) {
        const n = e[s];
        if (n.GetName() === t) return n;
      }
      return null;
    }
    _GetStack() {
      return this._stack.slice(0, this._index + 1);
    }
  };
}
{
  const C32 = self.C3;
  C32.Loop = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._loopStack = e, this._name = "", this._index = 0, this._isStopped = false, this._end = NaN;
    }
    Reset() {
      this._name = "", this._index = 0, this._isStopped = false, this._end = NaN;
    }
    SetName(e) {
      this._name = e;
    }
    GetName() {
      return this._name;
    }
    SetIndex(e) {
      this._index = e;
    }
    GetIndex() {
      return this._index;
    }
    Stop() {
      this._isStopped = true;
    }
    IsStopped() {
      return this._isStopped;
    }
    SetEnd(e) {
      this._end = e;
    }
    GetEnd() {
      return this._end;
    }
  };
}
{
  const C32 = self.C3;
  C32.ArrayStack = class extends C32.DefendedBase {
    constructor() {
      super(), this._stack = [], this._index = -1;
    }
    Release() {
      C32.clearArray(this._stack);
    }
    GetCurrent() {
      return this._stack[this._index];
    }
    Push() {
      if (++this._index, this._index === this._stack.length) {
        const s = [];
        return this._stack.push(s), s;
      }
      return this._stack[this._index];
    }
    Pop() {
      --this._index;
    }
  };
}
{
  let SortSolArray = function(t, e) {
    return t.GetIndex() - e.GetIndex();
  }, IsSolArrayIdentical = function(t, e) {
    for (let s = 0, n = t.length; s < n; ++s) if (t[s] !== e[s]) return false;
    return true;
  };
  SortSolArray2 = SortSolArray, IsSolArrayIdentical2 = IsSolArrayIdentical;
  const C32 = self.C3, assert = self.assert;
  C32.EventSheetManager = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._runtime = t, this._allSheets = [], this._sheetsByName = /* @__PURE__ */ new Map(), this._allGroups = [], this._groupsByName = /* @__PURE__ */ new Map(), this._blocksBySid = /* @__PURE__ */ new Map(), this._cndsBySid = /* @__PURE__ */ new Map(), this._actsBySid = /* @__PURE__ */ new Map(), this._allUniqueSolModifiers = /* @__PURE__ */ new Map(), this._eventVarsBySid = /* @__PURE__ */ new Map(), this._nextLocalVarIndex = 0, this._allGlobalVars = [], this._allLocalVars = [], this._localVarInitialValues = [], this._functionBlocksByName = /* @__PURE__ */ new Map(), this._customActionBlocksMap = /* @__PURE__ */ new Map(), this._eventStack = C32.New(C32.EventStack, this), this._localVarStack = C32.New(C32.LocalVarStack, this), this._loopStack = C32.New(C32.LoopStack, this), this._triggersToPostInit = [], this._queuedTriggers = [], this._queuedDebugTriggers = [], this._runningEventsDepth = 0, this._executingTriggerDepth = 0, this._blockFlushingDepth = 0, this._scheduledWaits = [], this._asyncActionPromises = [], this._signalTags = [], this._signalPromises = /* @__PURE__ */ new Map(), this._instSignals = /* @__PURE__ */ new Map(), self["c3_callFunction"] = (t2, e) => this._InvokeFunctionFromJS(t2, e);
    }
    Release() {
      this.ClearAllScheduledWaits(), this._eventStack.Release(), this._eventStack = null, this._localVarStack.Release(), this._localVarStack = null, C32.clearArray(this._queuedTriggers), C32.clearArray(this._queuedDebugTriggers), this._runtime = null, C32.clearArray(this._allSheets), this._sheetsByName.clear();
    }
    Create(t) {
      const e = C32.New(C32.EventSheet, this, t);
      this._allSheets.push(e), this._sheetsByName.set(e.GetName().toLowerCase(), e);
    }
    _AddTriggerToPostInit(t) {
      this._triggersToPostInit.push(t);
    }
    _PostInit() {
      for (const t of this._customActionBlocksMap.values()) t._CheckOverrideState();
      for (const t of this._functionBlocksByName.values()) t._PostInit();
      for (const t of this._customActionBlocksMap.values()) t._PostInit();
      for (const t of this._allSheets) t._PostInit();
      for (const t of this._allSheets) t._UpdateDeepIncludes();
      for (const t of this._triggersToPostInit) t._PostInit(false);
      C32.clearArray(this._triggersToPostInit), this._localVarStack._SetInitialValues(this._localVarInitialValues);
    }
    GetRuntime() {
      return this._runtime;
    }
    GetEventSheetByName(t) {
      return this._sheetsByName.get(t.toLowerCase()) || null;
    }
    _RegisterGroup(t) {
      this._allGroups.push(t), this._groupsByName.set(t.GetGroupName(), t);
    }
    _RegisterEventBlock(t) {
      this._blocksBySid.set(t.GetSID(), t);
    }
    _RegisterCondition(t) {
      this._cndsBySid.set(t.GetSID(), t);
    }
    _RegisterAction(t) {
      this._actsBySid.set(t.GetSID(), t);
    }
    _RegisterFunctionBlock(t) {
      switch (t.GetFunctionType()) {
        case 0:
          this._functionBlocksByName.set(t.GetFunctionName().toLowerCase(), t);
          break;
        case 1:
          this._customActionBlocksMap.set(t.GetFunctionName().toLowerCase(), t);
      }
    }
    _RegisterEventVariable(t) {
      this._eventVarsBySid.set(t.GetSID(), t), t.IsGlobal() ? this._allGlobalVars.push(t) : this._allLocalVars.push(t);
    }
    _DeduplicateSolModifierList(t) {
      t.length >= 2 && t.sort(SortSolArray);
      let e = this._allUniqueSolModifiers.get(t.length);
      e || (e = [], this._allUniqueSolModifiers.set(t.length, e));
      for (let s = 0, n = e.length; s < n; ++s) {
        const n2 = e[s];
        if (IsSolArrayIdentical(t, n2)) return n2;
      }
      return e.push(t), t;
    }
    _GetNextLocalVarIndex(t) {
      return this._localVarInitialValues.push(t.GetInitialValue()), this._nextLocalVarIndex++;
    }
    GetEventStack() {
      return this._eventStack;
    }
    GetCurrentEventStackFrame() {
      return this.GetEventStack().GetCurrentStackFrame();
    }
    GetCurrentEvent() {
      return this.GetCurrentEventStackFrame().GetCurrentEvent();
    }
    GetCurrentCondition() {
      const t = this.GetCurrentEventStackFrame();
      return t.GetCurrentEvent().GetConditionAt(t.GetConditionIndex());
    }
    GetCurrentAction() {
      const t = this.GetCurrentEventStackFrame();
      return t.GetCurrentEvent().GetActionAt(t.GetActionIndex());
    }
    GetLocalVarStack() {
      return this._localVarStack;
    }
    GetLoopStack() {
      return this._loopStack;
    }
    GetAllLocalVariablesInScope(t) {
      const e = [];
      for (t = t.GetScopeParent(); t; ) C32.appendArray(e, t._GetAllLocalVariablesInScope()), t = t.GetScopeParent();
      return e;
    }
    _GetLocalVariablesScriptInterface(t) {
      const e = {};
      for (const s of this.GetAllLocalVariablesInScope(t)) e[s.GetJsPropName()] = s._GetScriptInterfaceDescriptor();
      return Object.create(Object.prototype, e);
    }
    GetEventVariableBySID(t) {
      return this._eventVarsBySid.get(t) || null;
    }
    GetEventBlockBySID(t) {
      return this._blocksBySid.get(t) || null;
    }
    GetConditionBySID(t) {
      return this._cndsBySid.get(t) || null;
    }
    GetActionBySID(t) {
      return this._actsBySid.get(t) || null;
    }
    GetFunctionBlockByName(t) {
      return this._functionBlocksByName.get(t.toLowerCase()) || null;
    }
    GetCustomActionBlockByName(t, e) {
      let s = this._customActionBlocksMap.get((t.GetName() + "." + e).toLowerCase());
      if (s) return s;
      if (!t.IsFamily()) {
        for (const n of t.GetFamilies()) if (s = this._customActionBlocksMap.get((n.GetName() + "." + e).toLowerCase()), s) return s;
      }
      return null;
    }
    GetAllGlobalVariables() {
      return this._allGlobalVars;
    }
    GetAllLocalVariables() {
      return this._allLocalVars;
    }
    ResetAllGlobalsToInitialValue(t) {
      for (const t2 of this._allGlobalVars) t2.ResetToInitialValue();
      if (t) for (const t2 of this._allLocalVars) t2.IsStatic() && t2.ResetToInitialValue();
    }
    GetEventGroupByName(t) {
      return this._groupsByName.get(t.toLowerCase()) || null;
    }
    GetEventGroupBySID(t) {
      const e = this._blocksBySid.get(t);
      return e && e.IsGroup() ? e : null;
    }
    GetAllGroups() {
      return this._allGroups;
    }
    ResetAllGroupsInitialActivation() {
      for (const t of this._allGroups) t.ResetInitialActivation();
    }
    _ResetAllHasRunFlags() {
      for (const t of this._allSheets) t._ResetHasRunFlag();
    }
    RunEvents(t) {
      this._ResetAllHasRunFlags(), this._runningEventsDepth++;
      for (const e of t.runningLayouts()) {
        const t2 = e.GetEventSheet();
        t2 && (this._runtime.PushCurrentLayout(e), t2.Run(), this._runtime.PopCurrentLayout());
      }
      this._runningEventsDepth--;
    }
    async DebugRunEvents(t) {
      this._ResetAllHasRunFlags(), this._runningEventsDepth++;
      for (const e of this._DebugRunEventsGen(t)) await this._runtime.DebugBreak(e);
      this._runningEventsDepth--;
    }
    *_DebugRunEventsGen(t) {
      for (const e of t.runningLayouts()) {
        const t2 = e.GetEventSheet();
        t2 && (this._runtime.PushCurrentLayout(e), yield* t2.DebugRun(), this._runtime.PopCurrentLayout());
      }
    }
    _Trigger(t, e, s, n) {
      let i = false;
      if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);
      this._executingTriggerDepth++;
      for (const r of t.runningLayouts()) {
        const t2 = r.GetEventSheet();
        if (!t2) continue;
        this._runtime.PushCurrentLayout(r);
        for (const r2 of t2.deepIncludes()) {
          const t3 = r2._Trigger(e, s, n);
          i = i || t3;
        }
        const o = t2._Trigger(e, s, n);
        i = i || o, this._runtime.PopCurrentLayout();
      }
      return this._executingTriggerDepth--, i;
    }
    *_DebugTrigger(t, e, s, n) {
      let i = false;
      if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);
      this._executingTriggerDepth++;
      for (const r of t.runningLayouts()) {
        const t2 = r.GetEventSheet();
        if (!t2) continue;
        this._runtime.PushCurrentLayout(r);
        for (const r2 of t2.deepIncludes()) {
          const t3 = yield* r2._DebugTrigger(e, s, n);
          i = i || t3;
        }
        const o = yield* t2._DebugTrigger(e, s, n);
        i = i || o, this._runtime.PopCurrentLayout();
      }
      return this._executingTriggerDepth--, i;
    }
    QueueTrigger(t, e, s) {
      return this._queuedTriggers.push([t, e, s]), false;
    }
    QueueDebugTrigger(t, e, s) {
      let n = null;
      const i = new Promise((t2) => n = t2);
      return this._queuedDebugTriggers.push([t, e, s, n]), i;
    }
    *_RunQueuedDebugTriggersGen() {
      if (this._runtime.HitBreakpoint()) throw new Error("should not be in breakpoint");
      const t = this._runtime.GetLayoutManager();
      for (; this._queuedDebugTriggers.length; ) {
        const [e, s, n, i] = this._queuedDebugTriggers.shift();
        i(yield* this._DebugTrigger(t, e, s, n));
      }
    }
    async RunQueuedDebugTriggersAsync() {
      for (const t of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(t);
    }
    _FastTrigger(t, e, s, n) {
      let i = false;
      const r = t.GetMainRunningLayout(), o = r.GetEventSheet();
      if (!o) return;
      this._executingTriggerDepth++, this._runtime.PushCurrentLayout(r);
      const a = o.deepIncludes();
      for (let t2 = 0, r2 = a.length; t2 < r2; ++t2) {
        const r3 = a[t2]._FastTrigger(e, s, n);
        i = i || r3;
      }
      const l = o._FastTrigger(e, s, n);
      return i = i || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, i;
    }
    *_DebugFastTrigger(t, e, s, n) {
      let i = false;
      const r = t.GetMainRunningLayout(), o = r.GetEventSheet();
      if (!o) return;
      this._executingTriggerDepth++, this._runtime.PushCurrentLayout(r);
      const a = o.deepIncludes();
      for (let t2 = 0, r2 = a.length; t2 < r2; ++t2) {
        const r3 = yield* a[t2]._DebugFastTrigger(e, s, n);
        i = i || r3;
      }
      const l = yield* o._DebugFastTrigger(e, s, n);
      return i = i || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, i;
    }
    GetTriggerDepth() {
      return this._executingTriggerDepth;
    }
    IsInTrigger() {
      return this.GetTriggerDepth() > 0;
    }
    _IncTriggerDepth() {
      return ++this._executingTriggerDepth;
    }
    _DecTriggerDepth() {
      --this._executingTriggerDepth;
    }
    IsRunningEvents() {
      return this._runningEventsDepth > 0;
    }
    IsInEventEngine() {
      return this.IsRunningEvents() || this.IsInTrigger();
    }
    _RunQueuedTriggers(t) {
      for (const [e, s, n] of this._queuedTriggers) this._Trigger(t, e, s, n);
      C32.clearArray(this._queuedTriggers);
    }
    BlockFlushingInstances(t) {
      t ? this._blockFlushingDepth++ : this._blockFlushingDepth--;
    }
    IsFlushingBlocked() {
      return this._blockFlushingDepth > 0;
    }
    ClearSol(t) {
      for (let e = 0, s = t.length; e < s; ++e) t[e].GetSolStack().Clear();
    }
    PushCleanSol(t) {
      for (let e = 0, s = t.length; e < s; ++e) t[e].GetSolStack().PushClean();
    }
    PushCopySol(t) {
      for (let e = 0, s = t.length; e < s; ++e) t[e].GetSolStack().PushCopy();
    }
    PopSol(t) {
      for (let e = 0, s = t.length; e < s; ++e) t[e].GetSolStack().Pop();
    }
    GetDynamicSolModifiersSet(t) {
      const e = /* @__PURE__ */ new Set(), s = this._eventStack.GetAllStackFrames(), n = this._eventStack.GetCurrentStackFrameIndex();
      for (let i = 0; i <= n; ++i) {
        const n2 = s[i].GetDynamicSolModifiers();
        if (n2) for (const s2 of n2) t && t.has(s2) || e.add(s2);
      }
      return e;
    }
    PushCleanSolDynamic(t) {
      const e = /* @__PURE__ */ new Set([...t]), s = this.GetDynamicSolModifiersSet(e);
      if (s.size > 0) {
        for (const t2 of s) t2.GetSolStack().PushClean();
        return [...s];
      }
      return null;
    }
    AddScheduledWait() {
      const t = C32.New(C32.ScheduledWait, this);
      return this._scheduledWaits.push(t), t;
    }
    scheduledWaits() {
      return this._scheduledWaits;
    }
    RunScheduledWaits() {
      if (!this._scheduledWaits.length) return;
      const t = this.GetCurrentEventStackFrame();
      let e = false;
      this._runningEventsDepth++;
      for (let s = 0, n = this._scheduledWaits.length; s < n; ++s) {
        const n2 = this._scheduledWaits[s];
        n2._ShouldRun() && n2._Run(t), n2.ShouldRelease() && (e = true);
      }
      e && (this._FilterScheduledWaitsToRelease(), t.Reset(null)), this._runningEventsDepth--;
    }
    async DebugRunScheduledWaits() {
      if (!this._scheduledWaits.length) return;
      const t = this.GetCurrentEventStackFrame();
      let e = false;
      this._runningEventsDepth++;
      for (let s = 0, n = this._scheduledWaits.length; s < n; ++s) {
        const n2 = this._scheduledWaits[s];
        n2._ShouldRun() && await n2._DebugRun(t), n2.ShouldRelease() && (e = true);
      }
      e && (this._FilterScheduledWaitsToRelease(), t.Reset(null)), this._runningEventsDepth--;
    }
    _FilterScheduledWaitsToRelease() {
      const t = C32.arrayFilterOut(this._scheduledWaits, (t2) => t2.ShouldRelease());
      for (const e of t) e.Release();
    }
    ClearAllScheduledWaits() {
      for (const t of this._scheduledWaits) t.Release();
      C32.clearArray(this._scheduledWaits);
    }
    _OnInstancesReleased(t) {
      for (const e of this._scheduledWaits) e.RemoveInstances(t);
      for (const e of t) {
        const t2 = this._instSignals.get(e);
        if (this._instSignals.delete(e), t2) for (const { resolve: e2 } of t2.signalPromises.values()) e2(true);
      }
    }
    AddAsyncActionPromise(t) {
      this._asyncActionPromises.push({ promise: t, triggerDepth: this.GetTriggerDepth() });
    }
    ClearAsyncActionPromises() {
      C32.clearArray(this._asyncActionPromises);
    }
    GetPromiseForAllAsyncActions() {
      const t = this.GetTriggerDepth(), e = Promise.all(this._asyncActionPromises.filter((e2) => e2.triggerDepth === t).map((t2) => t2.promise));
      return this._asyncActionPromises = this._asyncActionPromises.filter((e2) => e2.triggerDepth < t), e;
    }
    Signal(t) {
      const e = t.toLowerCase();
      this._signalTags.push(e), this._runtime.Trigger(C32.Plugins.System.Cnds.OnSignal, null), this._signalTags.pop();
      for (const t2 of this._runtime.GetEventSheetManager().scheduledWaits()) t2.IsSignal() && t2.GetSignalTag() === e && t2.SetSignalled();
      const s = this._signalPromises.get(e);
      s && (s.resolve(), this._signalPromises.delete(e));
    }
    WaitForSignal(t) {
      const e = t.toLowerCase(), s = this._signalPromises.get(e);
      if (s) return s.promise;
      {
        let t2 = null;
        const s2 = new Promise((e2) => t2 = e2);
        return this._signalPromises.set(e, { promise: s2, resolve: t2 }), s2;
      }
    }
    GetCurrentSignalTag() {
      if (0 === this._signalTags.length) throw new Error("not in a signal");
      return this._signalTags.at(-1);
    }
    _GetInstanceSignalState(t) {
      let e = this._instSignals.get(t);
      return e || (e = { signalTags: [], signalPromises: /* @__PURE__ */ new Map() }, this._instSignals.set(t, e)), e;
    }
    InstanceSignal(t, e) {
      const s = this._GetInstanceSignalState(t), n = e.toLowerCase();
      s.signalTags.push(n), this._runtime.Trigger(t.GetPlugin().GetConstructor().Cnds.OnInstanceSignal, t), s.signalTags.pop();
      for (const e2 of this._runtime.GetEventSheetManager().scheduledWaits()) e2.IsInstanceSignals() && e2.GetSignalTag() === n && e2.SetInstanceSignalled(t);
      const i = s.signalPromises.get(n);
      i && (i.resolve(false), s.signalPromises.delete(n)), 0 === s.signalTags.length && 0 === s.signalPromises.size && this._instSignals.delete(t);
    }
    WaitForInstanceSignal(t, e) {
      const s = this._GetInstanceSignalState(t), n = e.toLowerCase(), i = s.signalPromises.get(n);
      if (i) return i.promise;
      {
        let t2 = null;
        const e2 = new Promise((e3) => t2 = e3);
        return s.signalPromises.set(n, { promise: e2, resolve: t2 }), e2;
      }
    }
    GetCurrentInstanceSignalTag(t) {
      const e = this._GetInstanceSignalState(t);
      if (!e || 0 === e.signalTags.length) throw new Error("not in a signal");
      return e.signalTags.at(-1);
    }
    _SaveToJson() {
      return { "groups": this._SaveGroupsToJson(), "cnds": this._SaveCndsToJson(), "acts": this._SaveActsToJson(), "vars": this._SaveVarsToJson(), "waits": this._SaveScheduledWaitsToJson() };
    }
    _LoadFromJson(t) {
      this._LoadGroupsFromJson(t["groups"]), this._LoadCndsFromJson(t["cnds"]), this._LoadActsFromJson(t["acts"]), this._LoadVarsFromJson(t["vars"]), this._LoadScheduledWaitsFromJson(t["waits"]);
    }
    _SaveGroupsToJson() {
      const t = {};
      for (const e of this.GetAllGroups()) t[e.GetSID().toString()] = e.IsGroupActive();
      return t;
    }
    _LoadGroupsFromJson(t) {
      for (const [e, s] of Object.entries(t)) {
        const t2 = parseInt(e, 10), n = this.GetEventGroupBySID(t2);
        n && n.SetGroupActive(s);
      }
    }
    _SaveCndsToJson() {
      const t = {};
      for (const [e, s] of this._cndsBySid) {
        const n = s._SaveToJson();
        n && (t[e.toString()] = n);
      }
      return t;
    }
    _LoadCndsFromJson(t) {
      const e = /* @__PURE__ */ new Map();
      for (const [s, n] of Object.entries(t)) e.set(parseInt(s, 10), n);
      for (const [t2, s] of this._cndsBySid) s._LoadFromJson(e.get(t2) || null);
    }
    _SaveActsToJson() {
      const t = {};
      for (const [e, s] of this._actsBySid) {
        const n = s._SaveToJson();
        n && (t[e.toString()] = n);
      }
      return t;
    }
    _LoadActsFromJson(t) {
      const e = /* @__PURE__ */ new Map();
      for (const [s, n] of Object.entries(t)) e.set(parseInt(s, 10), n);
      for (const [t2, s] of this._actsBySid) s._LoadFromJson(e.get(t2) || null);
    }
    _SaveVarsToJson() {
      const t = {};
      for (const [e, s] of this._eventVarsBySid) s.IsConstant() || !s.IsGlobal() && !s.IsStatic() || (t[e.toString()] = s.GetValue());
      return t;
    }
    _LoadVarsFromJson(t) {
      for (const [e, s] of Object.entries(t)) {
        const t2 = parseInt(e, 10), n = this.GetEventVariableBySID(t2);
        n && n.SetValue(s);
      }
    }
    _SaveScheduledWaitsToJson() {
      return this._scheduledWaits.filter((t) => !t.IsPromise()).map((t) => t._SaveToJson());
    }
    _LoadScheduledWaitsFromJson(t) {
      this.ClearAllScheduledWaits();
      for (const e of t) {
        const t2 = C32.ScheduledWait._CreateFromJson(this, e);
        t2 && this._scheduledWaits.push(t2);
      }
    }
    _GetPerfRecords() {
      return [...this._runtime.GetLayoutManager().runningLayouts()].map((t) => t.GetEventSheet()).filter((t) => t).map((t) => t._GetPerfRecord());
    }
    FindFirstFunctionBlockParent(t) {
      for (; t; ) {
        const e = t.GetScopeParent();
        if (e instanceof C32.FunctionBlock) return e;
        t = e;
      }
      return null;
    }
    _InvokeFunctionFromJS(t, e) {
      Array.isArray(e) || (e = []);
      const s = this.GetFunctionBlockByName(t.toLowerCase());
      if (!s) return null;
      if (!s.IsEnabled()) return s.GetDefaultReturnValue();
      const n = s.GetFunctionParameters();
      if (e.length < n.length) {
        e = e.slice(0);
        do {
          e.push(n[e.length].GetInitialValue());
        } while (e.length < n.length);
      }
      const i = s.GetEventBlock();
      return i.RunAsExpressionOrJSFunctionCall(i.GetSolModifiersIncludingParents(), false, s.GetReturnType(), s.GetDefaultReturnValue(), null, ...e);
    }
  };
}
var SortSolArray2;
var IsSolArrayIdentical2;
{
  const C32 = self.C3;
  C32.EventSheet = class extends C32.DefendedBase {
    constructor(e, t) {
      super(), this._eventSheetManager = e, this._runtime = e.GetRuntime(), this._name = t[0], this._events = [], this._triggers = /* @__PURE__ */ new Map(), this._fastTriggers = /* @__PURE__ */ new Map(), this._eventsByDisplayNumber = /* @__PURE__ */ new Map(), this._hasRun = false, this._shallowIncludes = [], this._deepIncludes = [], this._alreadyIncludedSheets = /* @__PURE__ */ new Set();
      for (const e2 of t[1]) this._CreateEvent(e2, null, this._events);
      this._perfRecord = this._runtime.IsDebug() ? { type: "sheet", name: this._name, totalTimeCounter: 0, children: [] } : null;
    }
    Release() {
      this._eventSheetManager = null, this._runtime = null;
    }
    _CreateEvent(e, t, s) {
      switch (e[0]) {
        case 0:
        case 3:
          this._CreateEventBlock(e, t, s);
          break;
        case 1:
          this._CreateEventVariable(e, t, s);
          break;
        case 2:
          this._CreateInclude(e, t, s);
          break;
        case 4:
          this._CreateFunctionBlock(e, t);
          break;
        case 5:
          this._CreateScriptBlock(e, t, s);
          break;
        case 6:
          this._CreateCustomACEBlock(e, t);
          break;
        default:
          throw new Error("invalid event type");
      }
    }
    _CreateEventBlock(e, t, s) {
      const n = C32.EventBlock.Create(this, t, e);
      if (n.IsOrBlock()) {
        s.push(n);
        const e2 = n.GetConditions();
        for (let t2 = 0, s2 = e2.length; t2 < s2; ++t2) e2[t2].IsTrigger() && this._InitTrigger(n, t2);
      } else n.IsTrigger() ? this._InitTrigger(n, 0) : s.push(n);
    }
    _CreateFunctionBlock(e, t) {
      const s = C32.FunctionBlock.CreateFunctionBlock(this, t, e);
      this._eventSheetManager._RegisterFunctionBlock(s);
    }
    _CreateCustomACEBlock(e, t) {
      const s = C32.FunctionBlock.CreateCustomACEBlock(this, t, e);
      this._eventSheetManager._RegisterFunctionBlock(s);
    }
    _CreateEventVariable(e, t, s) {
      const n = C32.EventVariable.Create(this, t, e);
      s.push(n);
    }
    _CreateInclude(e, t, s) {
      const n = C32.EventInclude.Create(this, t, e);
      s.push(n);
    }
    _CreateScriptBlock(e, t, s) {
      const n = C32.EventScript.Create(this, t, e);
      s.push(n);
    }
    _InitTrigger(e, t) {
      e.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(e);
      const s = e.GetConditionAt(t), n = s._GetFunc(), r = s.GetObjectClass();
      if (s.IsFastTrigger()) {
        let i = this._fastTriggers.get(r);
        i || (i = /* @__PURE__ */ new Map(), this._fastTriggers.set(r, i));
        const l = s.GetFastTriggerValue().toLowerCase();
        let o = i.get(n);
        o || (o = /* @__PURE__ */ new Map(), i.set(n, o));
        let a = o.get(l);
        a || (a = [], o.set(l, a)), a.push([e, t]);
      } else {
        let i = this._triggers.get(r);
        i || (i = { methodMap: /* @__PURE__ */ new Map(), behaviors: /* @__PURE__ */ new Map() }, this._triggers.set(r, i));
        const l = s.GetBehaviorType();
        let o;
        l ? (o = i.behaviors.get(l), o || (o = /* @__PURE__ */ new Map(), i.behaviors.set(l, o))) : o = i.methodMap;
        let a = o.get(n);
        a || (a = [], o.set(n, a)), a.push([e, t]);
      }
    }
    _PostInit() {
      const e = this._events;
      for (let t = 0, s = e.length; t < s; ++t) {
        const n = t < s - 1 && e[t + 1] instanceof C32.EventBlock && e[t + 1].IsElseBlock();
        e[t]._PostInit(n);
      }
    }
    _AddShallowInclude(e) {
      this._shallowIncludes.push(e);
    }
    _UpdateDeepIncludes() {
      C32.clearArray(this._deepIncludes), this._AddDeepIncludes(this), this._alreadyIncludedSheets.clear();
    }
    _AddDeepIncludes(e) {
      const t = e._deepIncludes, s = e._alreadyIncludedSheets;
      for (const n of this._shallowIncludes) {
        const r = n.GetIncludeSheet();
        n.IsActive() && e !== r && !s.has(r) && (s.add(r), r._AddDeepIncludes(e), t.push(r));
      }
    }
    deepIncludes() {
      return this._deepIncludes;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetName() {
      return this._name;
    }
    _RegisterEventByDisplayNumber(e, t) {
      this._eventsByDisplayNumber.set(t, e);
    }
    _GetEventByDisplayNumber(e) {
      return this._eventsByDisplayNumber.get(e) || null;
    }
    _ResetHasRunFlag() {
      this._hasRun = false;
    }
    Run() {
      if (this._hasRun) return;
      const e = this._runtime, t = e.IsCPUProfiling(), s = t ? performance.now() : 0;
      this._hasRun = true;
      const n = this.GetEventSheetManager(), r = n.GetCurrentEventStackFrame();
      for (const t2 of this._events) t2.Run(r), n.ClearSol(t2.GetSolModifiers()), n.ClearAsyncActionPromises(), e.FlushPendingInstances();
      r.Reset(null), t && (this._perfRecord.totalTimeCounter += performance.now() - s);
    }
    *DebugRun() {
      if (this._hasRun) return;
      this._hasRun = true;
      const e = this._runtime, t = this.GetEventSheetManager(), s = t.GetCurrentEventStackFrame();
      for (const n of this._events) yield* n.DebugRun(s), t.ClearSol(n.GetSolModifiers()), t.ClearAsyncActionPromises(), e.FlushPendingInstances();
      s.Reset(null);
    }
    _Trigger(e, t, s) {
      if (!t) return this._TriggerForClass(e, t, null, null);
      {
        const n = t.GetObjectClass();
        let r = false, i = this._TriggerForClass(e, t, n, s);
        r = r || i;
        for (const l of n.GetFamilies()) i = this._TriggerForClass(e, t, l, s), r = r || i;
      }
    }
    _TriggerForClass(e, t, s, n) {
      const r = this._triggers.get(s);
      if (!r) return false;
      const i = n ? r.behaviors.get(n) : r.methodMap;
      if (!i) return false;
      const l = i.get(e);
      if (!l) return false;
      let o = false;
      for (const [e2, s2] of l) {
        const n2 = this._ExecuteTrigger(t, e2, s2);
        o = o || n2;
      }
      return o;
    }
    *_DebugTrigger(e, t, s) {
      if (!t) return yield* this._DebugTriggerForClass(e, t, null, null);
      {
        const n = t.GetObjectClass();
        let r = false, i = yield* this._DebugTriggerForClass(e, t, n, s);
        r = r || i;
        for (const l of n.GetFamilies()) i = yield* this._DebugTriggerForClass(e, t, l, s), r = r || i;
      }
    }
    *_DebugTriggerForClass(e, t, s, n) {
      const r = this._triggers.get(s);
      if (!r) return false;
      const i = n ? r.behaviors.get(n) : r.methodMap;
      if (!i) return false;
      const l = i.get(e);
      if (!l) return false;
      let o = false;
      for (const [e2, s2] of l) {
        let n2;
        n2 = e2.DebugCanRunFast() ? this._ExecuteTrigger(t, e2, s2) : yield* this._DebugExecuteTrigger(t, e2, s2), o = o || n2;
      }
      return o;
    }
    _FastTrigger(e, t, s) {
      const n = t.GetObjectClass(), r = this._fastTriggers.get(n);
      if (!r) return false;
      const i = r.get(e);
      if (!i) return false;
      const l = i.get(s);
      if (!l) return false;
      let o = false;
      for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {
        const t3 = l[e2], s2 = this._ExecuteTrigger(null, t3[0], t3[1]);
        o = o || s2;
      }
      return o;
    }
    *_DebugFastTrigger(e, t, s) {
      const n = t.GetObjectClass(), r = this._fastTriggers.get(n);
      if (!r) return false;
      const i = r.get(e);
      if (!i) return false;
      const l = i.get(s);
      if (!l) return false;
      let o = false;
      for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {
        const t3 = l[e2], s2 = t3[0], n2 = t3[1];
        let r2;
        r2 = s2.DebugCanRunFast() ? this._ExecuteTrigger(null, s2, n2) : yield* this._DebugExecuteTrigger(null, s2, n2), o = o || r2;
      }
      return o;
    }
    _ExecuteTrigger(e, t, s) {
      const n = this._runtime, r = this._eventSheetManager, i = r.GetCurrentEvent(), l = r.GetEventStack(), o = r.GetTriggerDepth();
      let a = false;
      i && r.PushCleanSol(i.GetSolModifiersIncludingParents()), r.PushCleanSol(t.GetSolModifiersIncludingParents());
      const c = o > 1;
      c && r.GetLocalVarStack().Push();
      const u = l.Push(t);
      if (e) {
        t.GetConditions()[s].GetObjectClass().GetCurrentSol().SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();
      }
      let g = true;
      if (t.GetParent()) {
        const e2 = t.GetTriggerParents();
        for (let t2 = 0, s2 = e2.length; t2 < s2; ++t2) if (!e2[t2].RunPreTrigger(u)) {
          g = false;
          break;
        }
      }
      return g && (t.IsOrBlock() ? t.RunOrBlockTrigger(u, s) : t.Run(u), a = u.GetLastEventTrue()), l.Pop(), c && r.GetLocalVarStack().Pop(), r.PopSol(t.GetSolModifiersIncludingParents()), i && r.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o || (r.ClearAsyncActionPromises(), r.IsFlushingBlocked() || n.FlushPendingInstances()), a;
    }
    *_DebugExecuteTrigger(e, t, s) {
      const n = this._runtime, r = this._eventSheetManager, i = r.GetCurrentEvent(), l = r.GetEventStack(), o = r.GetTriggerDepth();
      let a = false;
      i && r.PushCleanSol(i.GetSolModifiersIncludingParents()), r.PushCleanSol(t.GetSolModifiersIncludingParents());
      const c = o > 1;
      c && r.GetLocalVarStack().Push();
      const u = l.Push(t);
      if (e) {
        t.GetConditions()[s].GetObjectClass().GetCurrentSol().SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();
      }
      let g = true;
      if (t.GetParent()) {
        const e2 = t.GetTriggerParents();
        for (let t2 = 0, s2 = e2.length; t2 < s2; ++t2) if (!(yield* e2[t2].DebugRunPreTrigger(u))) {
          g = false;
          break;
        }
      }
      return g && (t.IsOrBlock() ? yield* t.DebugRunOrBlockTrigger(u, s) : yield* t.DebugRun(u), a = u.GetLastEventTrue()), l.Pop(), c && r.GetLocalVarStack().Pop(), r.PopSol(t.GetSolModifiersIncludingParents()), i && r.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o || (r.ClearAsyncActionPromises(), r.IsFlushingBlocked() || n.FlushPendingInstances()), a;
    }
    _GetPerfRecord() {
      return this._perfRecord;
    }
  };
}
{
  let NoActions = function(t, e) {
    return true;
  };
  NoActions2 = NoActions;
  const C32 = self.C3, EMPTY_ARRAY = [];
  function* DebugNoActions(t, e) {
    return true;
  }
  C32.EventBlock = class extends C32.DefendedBase {
    constructor(t, e, n) {
      super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._scopeParent = null, this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._solModifiers = [], this._solModifiersIncludingParents = [], this._hasGotSolModifiersIncludingParents = false, this._isSolWriterAfterCnds = false, this._isTopLevelGroup = false, this._hasElseBlock = false, this._isOrBlock = !!n[2], this._isElseBlock = false, this._triggerParents = null, this._conditions = [], this._actions = [], this._subEvents = [], this._RunActions = NoActions, this._DebugRunActions = DebugNoActions, this._isGroup = false, this._isInitiallyActive = false, this._groupName = "", this._isGroupActive = false, this._containedIncludes = null, this._perfRecord = null, this._sid = n[4], this._displayNumber = n[5], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = this._runtime.IsDebug() ? { isBreakpoint: n[3][0], isBreakable: n[3][1], canRunAllConditionsFast: false, canRunAllActionsFast: false, canRunAllSubEventsFast: false, canRunSelfFast: false } : null, this.GetEventSheetManager()._RegisterEventBlock(this), 3 === n[0] && this._InitGroup(n[1]);
      let s = 0;
      for (const t2 of n[6]) {
        const e2 = C32.Condition.Create(this, t2, s++);
        this._conditions.push(e2), this._AddSolModifier(e2.GetObjectClass());
      }
      s = 0;
      for (const t2 of n[7]) {
        const e2 = C32.Action.Create(this, t2, s++);
        this._actions.push(e2);
      }
      if (9 === n.length) {
        const t2 = n[8];
        for (const e2 of t2) this._eventSheet._CreateEvent(e2, this, this._subEvents);
      }
      this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C32.Plugins.System.Cnds.Else), 0 === this._conditions.length && (this._conditions = EMPTY_ARRAY), 0 === this._actions.length && (this._actions = EMPTY_ARRAY), 0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY);
    }
    static Create(t, e, n) {
      return C32.New(C32.EventBlock, t, e, n);
    }
    _InitGroup(t) {
      this._isGroup = true, this._isInitiallyActive = !!t[0], this._isGroupActive = this._isInitiallyActive, this._groupName = t[1].toLowerCase(), this._containedIncludes = [], this.GetEventSheetManager()._RegisterGroup(this), this._runtime.IsDebug() && (this._perfRecord = { type: "group", name: t[1], totalTimeCounter: 0, children: [] });
    }
    _AddContainedInclude(t) {
      this._containedIncludes.push(t);
    }
    _AddContainerSolModifierToList(t, e) {
      for (const n of t.GetContainer().objectTypes()) e.includes(n) || e.push(n);
    }
    _AddSolModifierToList(t, e) {
      if (t) if (e.includes(t) || e.push(t), t.IsFamily()) for (const n of t.GetFamilyMembers()) n.IsInContainer() && this._AddContainerSolModifierToList(n, e);
      else t.IsInContainer() && this._AddContainerSolModifierToList(t, e);
    }
    _AddSolModifier(t) {
      this._AddSolModifierToList(t, this._solModifiers);
    }
    _AddParentSolModifier(t) {
      this._AddSolModifierToList(t, this._solModifiersIncludingParents);
    }
    SetAllSolModifiers() {
      this._solModifiers = this._runtime.GetAllObjectClasses();
    }
    _PostInit(t) {
      this._hasElseBlock = !!t, this._IdentifyTopLevelGroup(), this._IdentifyTriggerParents();
      for (const t2 of this._conditions) t2._PostInit();
      if (this._actions.length > 0) {
        let t2 = false;
        for (const e2 of this._actions) e2._PostInit(), e2.HasReturnType() && (t2 = true);
        t2 ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions = this._DebugRunActions_Fast);
      }
      const e = this._subEvents;
      for (let t2 = 0, n = e.length; t2 < n; ++t2) {
        const s = t2 < n - 1 && e[t2 + 1] instanceof C32.EventBlock && e[t2 + 1].IsElseBlock();
        e[t2]._PostInit(s);
      }
      this._debugData && this._UpdateCanRunFast(), this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord);
    }
    _GetPerfRecord() {
      return this._perfRecord;
    }
    _GetPerfRecordParent() {
      let t = this.GetParent();
      for (; t; ) {
        if (t.IsGroup()) return t;
        t = t.GetParent();
      }
      return this._eventSheet;
    }
    _UpdateCanRunFast() {
      const t = this._debugData;
      t.canRunAllConditionsFast = this._conditions.every((t2) => t2.DebugCanRunFast()), t.canRunAllActionsFast = this._actions.every((t2) => t2.DebugCanRunFast()), t.canRunAllSubEventsFast = this._subEvents.every((t2) => t2.DebugCanRunFast()), t.canRunSelfFast = t.canRunAllConditionsFast && t.canRunAllActionsFast && t.canRunAllSubEventsFast;
    }
    _UpdateCanRunFastRecursive() {
      let t = this;
      do {
        t._UpdateCanRunFast(), t = t.GetParent();
      } while (t);
    }
    _IdentifyTopLevelGroup() {
      if (!this.IsGroup()) return;
      let t = this.GetParent();
      for (this._isTopLevelGroup = true; t; ) {
        if (!t.IsGroup()) {
          this._isTopLevelGroup = false;
          break;
        }
        t = t.GetParent();
      }
    }
    _IdentifySolModifiersIncludingParents() {
      const t = this._runtime.GetAllObjectClasses();
      if (this._solModifiers === t) this._solModifiersIncludingParents = t;
      else {
        this._solModifiersIncludingParents = C32.cloneArray(this._solModifiers);
        let t2 = this.GetParent();
        for (; t2; ) {
          for (const e2 of t2._solModifiers) this._AddParentSolModifier(e2);
          t2 = t2.GetParent();
        }
        const e = this.GetEventSheetManager();
        this._solModifiers = e._DeduplicateSolModifierList(this._solModifiers), this._solModifiersIncludingParents = e._DeduplicateSolModifierList(this._solModifiersIncludingParents);
      }
    }
    _IdentifyTriggerParents() {
      if (!this.HasAnyTriggeredCondition()) return;
      this._triggerParents = [];
      let t = this.GetParent();
      for (; t; ) this._triggerParents.push(t), t = t.GetParent();
      this._triggerParents.reverse();
    }
    SetSolWriterAfterCnds() {
      this._isSolWriterAfterCnds = true, this._parent && this._parent.SetSolWriterAfterCnds();
    }
    IsSolWriterAfterCnds() {
      return this._isSolWriterAfterCnds;
    }
    GetSolModifiers() {
      return this._solModifiers;
    }
    GetSolModifiersIncludingParents() {
      return this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = true, this._IdentifySolModifiersIncludingParents()), this._solModifiersIncludingParents;
    }
    HasSolModifier(t) {
      return this._solModifiers.includes(t);
    }
    GetTriggerParents() {
      return this._triggerParents;
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    GetEventSheetManager() {
      return this._eventSheet.GetEventSheetManager();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetParent() {
      return this._parent;
    }
    _SetScopeParent(t) {
      this._scopeParent = t;
    }
    GetScopeParent() {
      return this._scopeParent || this._parent;
    }
    GetDisplayNumber() {
      return this._displayNumber;
    }
    IsDebugBreakable() {
      return this._debugData && this._debugData.isBreakable;
    }
    IsDebugBreakpoint() {
      return this.IsDebugBreakable() && this._debugData.isBreakpoint;
    }
    _SetDebugBreakpoint(t) {
      this._debugData.isBreakpoint = !!t, this._UpdateCanRunFastRecursive();
    }
    IsGroup() {
      return this._isGroup;
    }
    IsTopLevelGroup() {
      return this._isTopLevelGroup;
    }
    IsElseBlock() {
      return this._isElseBlock;
    }
    HasElseBlock() {
      return this._hasElseBlock;
    }
    GetGroupName() {
      return this._groupName;
    }
    IsGroupActive() {
      return this._isGroupActive;
    }
    ResetInitialActivation() {
      this.SetGroupActive(this._isInitiallyActive);
    }
    SetGroupActive(t) {
      if (t = !!t, !this._isGroup) throw new Error("not a group");
      if (this._isGroupActive !== t) {
        this._isGroupActive = t;
        for (const t2 of this._containedIncludes) t2.UpdateActive();
        if (this._containedIncludes.length) {
          const t2 = this._runtime.GetCurrentLayout().GetEventSheet();
          t2 && t2._UpdateDeepIncludes();
        }
      }
    }
    GetSID() {
      return this._sid;
    }
    IsOrBlock() {
      return this._isOrBlock;
    }
    IsTrigger() {
      return this._conditions.length && this._conditions[0].IsTrigger();
    }
    IsForFunctionBlock() {
      return this._scopeParent && this._scopeParent instanceof C32.FunctionBlock;
    }
    HasAnyTriggeredCondition() {
      return this.IsForFunctionBlock() || this._conditions.some((t) => t.IsTrigger());
    }
    GetConditions() {
      return this._conditions;
    }
    GetConditionCount() {
      return this._conditions.length;
    }
    GetConditionAt(t) {
      if ((t = Math.floor(t)) < 0 || t >= this._conditions.length) throw new RangeError("invalid condition index");
      return this._conditions[t];
    }
    GetConditionByDebugIndex(t) {
      return this.GetConditionAt(t);
    }
    IsFirstConditionOfType(t) {
      let e = t.GetIndex();
      if (0 === e) return true;
      --e;
      const n = t.IsSystemOrSingleGlobalCondition() ? t.GetFirstObjectParameterObjectClass() : t.GetObjectClass();
      for (; e >= 0; --e) {
        const t2 = this._conditions[e];
        if (n === t2.GetObjectClass() || t2.IsSystemOrSingleGlobalCondition() && t2.GetFirstObjectParameterObjectClass() === n) return false;
      }
      return true;
    }
    GetActions() {
      return this._actions;
    }
    GetActionCount() {
      return this._actions.length;
    }
    GetActionAt(t) {
      if ((t = Math.floor(t)) < 0 || t >= this._actions.length) throw new RangeError("invalid action index");
      return this._actions[t];
    }
    GetActionByDebugIndex(t) {
      t = Math.floor(t);
      const e = this._actions.find((e2) => e2.GetDebugIndex() === t);
      if (!e) throw new RangeError("invalid action debug index");
      return e;
    }
    _HasActionIndex(t) {
      return (t = Math.floor(t)) >= 0 && t < this._actions.length;
    }
    GetSubEvents() {
      return this._subEvents;
    }
    _GetAllLocalVariablesInScope() {
      return this._subEvents.filter((t) => t instanceof C32.EventVariable);
    }
    RunPreTrigger(t) {
      t.SetCurrentEvent(this);
      const e = this._conditions;
      let n = 0 === e.length;
      for (let s = 0, i = e.length; s < i; ++s) {
        const i2 = e[s];
        if (t.SetConditionIndex(s), i2.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
        if (i2.Run()) n = true;
        else if (!this._isOrBlock) return false;
      }
      return !this._isOrBlock || n;
    }
    RunOrBlockTrigger(t, e) {
      t.SetCurrentEvent(this), t.SetConditionIndex(e), this._conditions[e].Run() && (this._RunActions(t, 0) && this._RunSubEvents(t), t.SetLastEventTrue(true));
    }
    *DebugRunPreTrigger(t) {
      t.SetCurrentEvent(this);
      const e = this._conditions;
      let n = 0 === e.length;
      for (let s = 0, i = e.length; s < i; ++s) {
        const i2 = e[s];
        if (t.SetConditionIndex(s), i2.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
        let o;
        if (o = i2.DebugCanRunFast() ? i2.Run() : yield* i2.DebugRun(), o) n = true;
        else if (!this._isOrBlock) return false;
      }
      return !this._isOrBlock || n;
    }
    *DebugRunOrBlockTrigger(t, e) {
      t.SetCurrentEvent(this), t.SetConditionIndex(e);
      const n = this._conditions[e];
      let s;
      if (s = n.DebugCanRunFast() ? n.Run() : yield* n.DebugRun(), s) {
        let e2;
        e2 = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), e2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), t.SetLastEventTrue(true);
      }
    }
    Run(t) {
      t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? this._RunOrBlock(t) : this._RunAndBlock(t);
    }
    *DebugRun(t) {
      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? yield* this._DebugRunOrBlock(t) : yield* this._DebugRunAndBlock(t);
    }
    _RunOrBlock(t) {
      const e = this._conditions;
      let n = 0 === e.length;
      for (let s = 0, i = e.length; s < i; ++s) {
        const i2 = e[s];
        if (i2.IsTrigger()) continue;
        t.SetConditionIndex(s);
        const o = i2.Run();
        n = n || o;
      }
      t.SetLastEventTrue(n), n && (this._RunActions(t, 0) && this._RunSubEvents(t), this._hasElseBlock && t.SetElseBranchRan(true));
    }
    *_DebugRunOrBlock(t) {
      const e = this._conditions;
      let n = 0 === e.length;
      for (let s = 0, i = e.length; s < i; ++s) {
        const i2 = e[s];
        if (i2.IsTrigger()) continue;
        let o;
        t.SetConditionIndex(s), o = i2.DebugCanRunFast() ? i2.Run() : yield* i2.DebugRun(), n = n || o;
      }
      if (t.SetLastEventTrue(n), n) {
        let e2;
        e2 = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), e2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && t.SetElseBranchRan(true);
      }
    }
    _RunAndBlock(t) {
      const e = this._conditions;
      for (let n = 0, s = e.length; n < s; ++n) {
        const s2 = e[n];
        t.SetConditionIndex(n);
        if (!s2.Run()) return void t.SetLastEventTrue(false);
      }
      t.SetLastEventTrue(true), this._RunActions(t, 0) && this._RunSubEvents(t), t.GetLastEventTrue() && this._hasElseBlock && t.SetElseBranchRan(true);
    }
    *_DebugRunAndBlock(t) {
      const e = this._conditions;
      for (let n2 = 0, s = e.length; n2 < s; ++n2) {
        const s2 = e[n2];
        let i;
        if (t.SetConditionIndex(n2), i = s2.DebugCanRunFast() ? s2.Run() : yield* s2.DebugRun(), !i) return void t.SetLastEventTrue(false);
      }
      let n;
      t.SetLastEventTrue(true), n = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), n && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), t.GetLastEventTrue() && this._hasElseBlock && t.SetElseBranchRan(true);
    }
    _RunActions_Fast(t, e) {
      const n = this._actions;
      for (let s = e, i = n.length; s < i; ++s) {
        const e2 = n[s];
        t.SetActionIndex(s), e2.Run();
      }
      return true;
    }
    *_DebugRunActions_Fast(t, e) {
      const n = this._actions;
      for (let s = e, i = n.length; s < i; ++s) {
        const e2 = n[s];
        t.SetActionIndex(s), e2.DebugCanRunFast() ? e2.Run() : yield* e2.DebugRun();
      }
      return true;
    }
    _RunActions_ReturnValue(t, e) {
      const n = this.GetEventSheetManager(), s = this._actions;
      for (let i = e, o = s.length; i < o; ++i) {
        const e2 = s[i];
        t.SetActionIndex(i);
        const o2 = e2.Run();
        if (e2.CanBailOut() && true === o2) return false;
        e2.IsAsync() && o2 instanceof Promise && n.AddAsyncActionPromise(o2);
      }
      return true;
    }
    *_DebugRunActions_ReturnValue(t, e) {
      const n = this.GetEventSheetManager(), s = this._actions;
      for (let i = e, o = s.length; i < o; ++i) {
        const e2 = s[i];
        let o2;
        if (t.SetActionIndex(i), o2 = e2.DebugCanRunFast() ? e2.Run() : yield* e2.DebugRun(), e2.CanBailOut() && true === o2) return false;
        e2.IsAsync() && o2 instanceof Promise && n.AddAsyncActionPromise(o2);
      }
      return true;
    }
    _ResumeActionsAndSubEvents(t) {
      this._RunActions(t, t.GetActionIndex()) && this._RunSubEvents();
    }
    *_DebugResumeActionsAndSubEvents(t) {
      (yield* this._DebugRunActions(t, t.GetActionIndex())) && (yield* this._DebugRunSubEvents());
    }
    _RunSubEvents() {
      if (!this._subEvents.length) return;
      const t = this.IsGroup() && this._runtime.IsCPUProfiling(), e = t ? performance.now() : 0, n = this._eventStack, s = n.Push(this);
      this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(s) : this._RunSubEvents_Fast(s), n.Pop(), t && (this._perfRecord.totalTimeCounter += performance.now() - e);
    }
    _RunSubEvents_SolWriterAfterCnds(t) {
      const e = this._isGroup, n = this._isTopLevelGroup, s = this.GetEventSheetManager(), i = this._subEvents;
      for (let o = 0, r = i.length, u = r - 1; o < r; ++o) {
        const r2 = i[o], l = r2.GetSolModifiers(), a = !n || !e && o < u;
        a && s.PushCopySol(l), r2.Run(t), a ? s.PopSol(l) : s.ClearSol(l);
      }
    }
    _RunSubEvents_Fast(t) {
      const e = this._subEvents;
      for (let n = 0, s = e.length; n < s; ++n) e[n].Run(t);
    }
    *_DebugRunSubEvents() {
      if (!this._subEvents.length) return;
      const t = this._eventStack, e = t.Push(this);
      this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(e) : yield* this._DebugRunSubEvents_Fast(e), t.Pop();
    }
    *_DebugRunSubEvents_SolWriterAfterCnds(t) {
      const e = this._isGroup, n = this._isTopLevelGroup, s = this.GetEventSheetManager(), i = this._subEvents;
      for (let o = 0, r = i.length, u = r - 1; o < r; ++o) {
        const r2 = i[o], l = r2.GetSolModifiers(), a = !n || !e && o < u;
        a && s.PushCopySol(l), yield* r2.DebugRun(t), a ? s.PopSol(l) : s.ClearSol(l);
      }
    }
    *_DebugRunSubEvents_Fast(t) {
      const e = this._subEvents;
      for (let n = 0, s = e.length; n < s; ++n) yield* e[n].DebugRun(t);
    }
    Retrigger(t, e) {
      e.ResetQuick();
      const n = this._conditions;
      if (!this.IsOrBlock()) for (let s = t.GetConditionIndex() + 1, i = n.length; s < i; ++s) {
        const t2 = n[s];
        e.SetConditionIndex(s);
        if (!t2.Run()) return false;
      }
      return this._RunActions(e, 0) && this._RunSubEvents(e), true;
    }
    *DebugRetrigger(t, e) {
      e.ResetQuick();
      const n = this._conditions;
      if (!this.IsOrBlock()) for (let s2 = t.GetConditionIndex() + 1, i = n.length; s2 < i; ++s2) {
        const t2 = n[s2];
        let i2;
        if (e.SetConditionIndex(s2), i2 = t2.DebugCanRunFast() ? t2.Run() : yield* t2.DebugRun(), !i2) return false;
      }
      let s;
      return s = this.DebugCanRunActionsFast() ? this._RunActions(e, 0) : yield* this._DebugRunActions(e, 0), s && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), true;
    }
    DebugCanRunFast() {
      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast;
    }
    DebugCanRunActionsFast() {
      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast;
    }
    DebugCanRunSubEventsFast() {
      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast;
    }
    _CheckParentsOKToRun(t) {
      if (this.GetParent()) {
        const e = this.GetTriggerParents();
        for (let n = 0, s = e.length; n < s; ++n) if (!e[n].RunPreTrigger(t)) return false;
      }
      return true;
    }
    *_DebugCheckParentsOKToRun(t) {
      if (this.GetParent()) {
        const e = this.GetTriggerParents();
        for (let n = 0, s = e.length; n < s; ++n) if (!(yield* e[n].DebugRunPreTrigger(t))) return false;
      }
      return true;
    }
    _EvaluateFunctionCallParameters(t, e, n) {
      if (e.length > 0) if (n) {
        const n2 = e.map((t2) => t2.Get(0));
        t.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(n2);
      } else this._scopeParent.EvaluateFunctionParameters(e);
      else n && t.GetLocalVarStack().Push();
    }
    #t(t, e, n, s) {
      let i = null;
      if (e.copyFromObjectClass) {
        const t2 = n ? e.copyFromObjectClass.GetCurrentSol() : e.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), s2 = e.copyToObjectClass.GetCurrentSol();
        s2.SetArrayPicked(t2.GetInstances()), s2.ClearElseInstances(), n || e.copyToObjectClass.ApplySolToContainer();
      } else if (e.pickObjectClass) {
        const t2 = e.pickObjectClass.GetCurrentSol();
        t2.SetArrayPicked(e.pickInstances), t2.ClearElseInstances();
      }
      return e.pushCleanSolDynamic && (i = t.PushCleanSolDynamic(s)), i;
    }
    RunAsFunctionCall(t, e, n, s) {
      let i, o;
      const r = t.length > 0;
      let u = null;
      const l = this._runtime, a = this._eventStack, c = l.GetEventSheetManager(), h = this._scopeParent, _ = h.IsAsync(), d = c._IncTriggerDepth() > 1;
      this._EvaluateFunctionCallParameters(c, e, d), r && (n ? c.PushCopySol(t) : c.PushCleanSol(t)), null !== s && (u = this.#t(c, s, n, t));
      const g = a.Push(this);
      return n && g.SetDynamicSolModifiers(t), this._CheckParentsOKToRun(g) && (g.SetCurrentEvent(this), _ && ([o, i] = h.StartAsyncFunctionCall()), this._RunAndBlock(g), _ && h.MaybeFinishAsyncFunctionCall(o)), a.Pop(), d && c.GetLocalVarStack().Pop(), null !== u && c.PopSol(u), r && c.PopSol(t), c._DecTriggerDepth(), i;
    }
    *DebugRunAsFunctionCall(t, e, n, s) {
      let i, o;
      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
      const r = t.length > 0;
      let u = null;
      const l = this._runtime, a = this._eventStack, c = l.GetEventSheetManager(), h = this._scopeParent, _ = h.IsAsync(), d = c._IncTriggerDepth() > 1;
      if (this._EvaluateFunctionCallParameters(c, e, d), r && (n ? c.PushCopySol(t) : c.PushCleanSol(t)), null !== s) {
        if (s.copyFromObjectClass) {
          const t2 = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), e2 = s.copyToObjectClass.GetCurrentSol();
          e2.SetArrayPicked(t2.GetInstances()), e2.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();
        } else if (s.pickObjectClass) {
          const t2 = s.pickObjectClass.GetCurrentSol();
          t2.SetArrayPicked(s.pickInstances), t2.ClearElseInstances();
        }
        s.pushCleanSolDynamic && (u = c.PushCleanSolDynamic(t));
      }
      const g = a.Push(this);
      return n && g.SetDynamicSolModifiers(t), (yield* this._DebugCheckParentsOKToRun(g)) && (g.SetCurrentEvent(this), _ && ([o, i] = h.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(g), _ && h.MaybeFinishAsyncFunctionCall(o)), a.Pop(), d && c.GetLocalVarStack().Pop(), null !== u && c.PopSol(u), r && c.PopSol(t), c._DecTriggerDepth(), i;
    }
    RunAsMappedFunctionCall(t, e) {
      const n = this.GetSolModifiersIncludingParents(), s = n.length > 0, i = this._runtime, o = this._eventStack, r = i.GetEventSheetManager(), u = r._IncTriggerDepth() > 1;
      u && r.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s && (e ? r.PushCopySol(n) : r.PushCleanSol(n));
      const l = o.Push(this);
      this._CheckParentsOKToRun(l) && (l.SetCurrentEvent(this), this._RunAndBlock(l)), o.Pop(), u && r.GetLocalVarStack().Pop(), s && r.PopSol(n), r._DecTriggerDepth();
    }
    *DebugRunAsMappedFunctionCall(t, e) {
      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
      const n = this.GetSolModifiersIncludingParents(), s = n.length > 0, i = this._runtime, o = this._eventStack, r = i.GetEventSheetManager(), u = r._IncTriggerDepth() > 1;
      u && r.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s && (e ? r.PushCopySol(n) : r.PushCleanSol(n));
      const l = o.Push(this);
      (yield* this._DebugCheckParentsOKToRun(l)) && (l.SetCurrentEvent(this), yield* this._DebugRunAndBlock(l)), o.Pop(), u && r.GetLocalVarStack().Pop(), s && r.PopSol(n), r._DecTriggerDepth();
    }
    RunAsExpressionOrJSFunctionCall(t, e, n, s, i, ...o) {
      let r, u;
      const l = t.length > 0;
      let a = null;
      const c = this._runtime, h = this._eventStack, _ = c.GetEventSheetManager(), d = this._scopeParent, g = d.IsAsync(), S = _._IncTriggerDepth() > 1;
      S && _.GetLocalVarStack().Push(), o.length > 0 && this._scopeParent.SetFunctionParameters(o), l && (e ? _.PushCopySol(t) : _.PushCleanSol(t)), null !== i && (a = this.#t(_, i, e, t));
      const b = h.Push(this);
      return b.InitCallFunctionExpression(n, s), e && b.SetDynamicSolModifiers(t), h.PushExpFunc(b), c.SetDebuggingEnabled(false), this._CheckParentsOKToRun(b) && (b.SetCurrentEvent(this), g && ([u, r] = d.StartAsyncFunctionCall()), this._RunAndBlock(b), g && d.MaybeFinishAsyncFunctionCall(u)), c.SetDebuggingEnabled(true), h.Pop(), h.PopExpFunc(), S && _.GetLocalVarStack().Pop(), null !== a && _.PopSol(a), l && _.PopSol(t), _._DecTriggerDepth(), r || b.GetFunctionReturnValue();
    }
  };
}
var NoActions2;
{
  const C32 = self.C3, EMPTY_SOL_MODIFIERS = [];
  let hadUserScriptException = false;
  C32.EventScript = class extends C32.DefendedBase {
    constructor(e, t, i) {
      super();
      const r = e.GetRuntime(), n = e.GetEventSheetManager();
      this._eventSheet = e, this._eventSheetManager = n, this._runtime = e.GetRuntime(), this._parent = t;
      const s = r.GetObjectReference(i[1]);
      this._func = s, this._displayNumber = i[2], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = r.IsDebug() ? { isBreakpoint: i[3][0], isBreakable: i[3][1] } : null;
    }
    static Create(e, t, i) {
      return C32.New(C32.EventScript, e, t, i);
    }
    _PostInit() {
      const e = this._func, t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
      this._func = e.bind(null, this._runtime.GetIRuntime(), t);
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this._parent;
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    GetDisplayNumber() {
      return this._displayNumber;
    }
    IsDebugBreakable() {
      return this._debugData && this._debugData.isBreakable;
    }
    IsDebugBreakpoint() {
      return this.IsDebugBreakable() && this._debugData.isBreakpoint;
    }
    _SetDebugBreakpoint(e) {
      this._debugData.isBreakpoint = !!e;
    }
    IsElseBlock() {
      return false;
    }
    GetSolModifiers() {
      return EMPTY_SOL_MODIFIERS;
    }
    GetSolModifiersIncludingParents() {
      return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS;
    }
    Run(e) {
      e.SetCurrentEvent(this), this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript());
    }
    async _RunUserScript() {
      try {
        await this._func();
      } catch (e) {
        console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), hadUserScriptException || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), hadUserScriptException = true);
      }
    }
    *DebugRun(e) {
      e.SetCurrentEvent(this), (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.Run(e);
    }
    DebugCanRunFast() {
      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext();
    }
    static HadUserScriptException() {
      return hadUserScriptException;
    }
    static SetHadUserScriptException() {
      hadUserScriptException = true;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert;
  C32.FunctionBlock = class extends C32.DefendedBase {
    constructor(t, e, s) {
      super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._functionType = 0, this._functionName = "", this._returnType = 0, this._functionParameters = [], this._isEnabled = true, this._aceName = "", this._objectClass = null, this._hasOverrides = false, this._innerLocalVariables = [], this._isCopyPicked = false, this._isAsync = false, this._nextAsyncId = 0, this._currentAsyncId = -1, this._asyncMap = /* @__PURE__ */ new Map(), this._eventBlock = C32.EventBlock.Create(t, e, s), this._eventBlock._SetScopeParent(this);
    }
    InitFunctionBlock(t) {
      this._functionType = 0, this._functionName = t[0], this._returnType = t[1], this._functionParameters = t[2].map((t2) => C32.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[3], this._isAsync = t[4], this._isCopyPicked = t[5];
    }
    InitCustomACEBlock(t) {
      this._functionType = 1, this._aceName = t[1], this._objectClass = this._runtime.GetObjectClassByIndex(t[2]), this._eventBlock._AddSolModifier(this._objectClass), this._functionName = this._objectClass.GetName() + "." + this._aceName, this._returnType = t[3], this._functionParameters = t[4].map((t2) => C32.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[5], this._isAsync = t[6], this._isCopyPicked = t[7], this._objectClass.AddCustomAction(this);
    }
    static CreateFunctionBlock(t, e, s) {
      const n = C32.New(C32.FunctionBlock, t, e, s), i = s[1];
      return n.InitFunctionBlock(i), n;
    }
    static CreateCustomACEBlock(t, e, s) {
      const n = C32.New(C32.FunctionBlock, t, e, s), i = s[1];
      return n.InitCustomACEBlock(i), n;
    }
    _CheckOverrideState() {
      if (this._objectClass && this._objectClass.IsFamily()) {
        for (const t of this._objectClass.GetFamilyMembers()) if (t.HasOwnCustomActionByName(this._aceName)) {
          this._hasOverrides = true;
          break;
        }
      }
    }
    _PostInit() {
      for (const t of this._functionParameters) t._PostInit();
      this._eventBlock._PostInit(false);
    }
    GetFunctionType() {
      return this._functionType;
    }
    _GetAllLocalVariablesInScope() {
      return this._functionParameters;
    }
    GetFunctionParameters() {
      return this._functionParameters;
    }
    GetFunctionParameterCount() {
      return this._functionParameters.length;
    }
    _RegisterLocalVariable(t) {
      this._innerLocalVariables.push(t);
    }
    _GetAllInnerLocalVariables() {
      return this._innerLocalVariables;
    }
    EvaluateFunctionParameters(t) {
      const e = this._functionParameters;
      for (let s = 0, n = e.length; s < n; ++s) e[s].SetValue(t[s].Get(0));
    }
    SetFunctionParameters(t) {
      const e = this._functionParameters;
      for (let s = 0, n = e.length; s < n; ++s) e[s].SetValue(t[s]);
    }
    CaptureFunctionParameters() {
      return this._functionParameters.map((t) => t.GetValue());
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this._parent;
    }
    GetFunctionName() {
      return this._functionName;
    }
    GetACEName() {
      return this._aceName;
    }
    HasCustomACEOverrides() {
      return this._hasOverrides;
    }
    GetReturnType() {
      return this._returnType;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    IsEnabled() {
      return this._isEnabled;
    }
    GetDefaultReturnValue() {
      switch (this._returnType) {
        case 0:
          return null;
        case 2:
          return "";
        default:
          return 0;
      }
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    IsCopyPicked() {
      return this._isCopyPicked;
    }
    IsAsync() {
      return this._isAsync;
    }
    StartAsyncFunctionCall() {
      const t = this._nextAsyncId++;
      let e;
      this._currentAsyncId = t;
      const s = new Promise((t2) => e = t2);
      return this._asyncMap.set(t, { resolve: e, pauseCount: 0 }), [t, s];
    }
    MaybeFinishAsyncFunctionCall(t) {
      const e = this._asyncMap.get(t);
      0 === e.pauseCount && (e.resolve(), this._asyncMap.delete(t)), this._currentAsyncId = -1;
    }
    PauseCurrentAsyncFunction() {
      return this._asyncMap.get(this._currentAsyncId).pauseCount++, this._currentAsyncId;
    }
    ResumeAsyncFunction(t) {
      this._currentAsyncId = t;
      this._asyncMap.get(t).pauseCount--;
    }
    RunAsFamilyCustomActionWithOverrides(t, e) {
      const s = /* @__PURE__ */ new Map(), n = [];
      for (const t2 of this._objectClass.GetCurrentSol().GetInstances()) {
        const e2 = t2.GetObjectClass();
        if (e2.HasOwnCustomActionByName(this._aceName)) {
          const n2 = s.get(e2);
          Array.isArray(n2) ? n2.push(t2) : s.set(e2, [t2]);
        } else n.push(t2);
      }
      if (n.length > 0 && this._eventBlock.RunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n }), s.size > 0) for (const [n2, i] of s) {
        const s2 = n2.GetOwnCustomActionByName(this._aceName).GetEventBlock(), a = [.../* @__PURE__ */ new Set([...t, ...s2.GetSolModifiers()])];
        s2.RunAsFunctionCall(a, e, this._isCopyPicked, { pickObjectClass: n2, pickInstances: i });
      }
    }
    *DebugRunAsFamilyCustomActionWithOverrides(t, e) {
      const s = /* @__PURE__ */ new Map(), n = [];
      for (const t2 of this._objectClass.GetCurrentSol().GetInstances()) {
        const e2 = t2.GetObjectClass();
        if (e2.HasOwnCustomActionByName(this._aceName)) {
          const n2 = s.get(e2);
          Array.isArray(n2) ? n2.push(t2) : s.set(e2, [t2]);
        } else n.push(t2);
      }
      if (n.length > 0 && (yield* this._eventBlock.DebugRunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n })), s.size > 0) for (const [n2, i] of s) {
        const s2 = n2.GetOwnCustomActionByName(this._aceName).GetEventBlock(), a = [.../* @__PURE__ */ new Set([...t, ...s2.GetSolModifiers()])];
        yield* s2.DebugRunAsFunctionCall(a, e, this._isCopyPicked, { pickObjectClass: n2, pickInstances: i });
      }
    }
  };
}
{
  const C32 = self.C3, EMPTY_SOL_MODIFIERS = [];
  C32.EventVariable = class extends C32.DefendedBase {
    constructor(t, e, s) {
      super();
      const i = t.GetEventSheetManager();
      this._eventSheet = t, this._eventSheetManager = i, this._runtime = t.GetRuntime(), this._parent = e, this._localVarStack = i.GetLocalVarStack(), this._name = s[1], this._type = s[2], this._initialValue = s[3], this._isStatic = !!s[4], this._isConstant = !!s[5], this._isFunctionParameter = e instanceof C32.FunctionBlock, this._sid = s[6], this._jsPropName = this._runtime.GetJsPropName(s[8]), this._scriptSetter = (t2) => this._ScriptSetValue(t2), this._scriptGetter = () => this.GetTypedValue(), this._hasSingleValue = !this._parent || this._isStatic || this._isConstant, this._value = this._initialValue, this._localIndex = -1, this.IsBoolean() && (this._value = this._value ? 1 : 0), !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = i._GetNextLocalVarIndex(this)), i._RegisterEventVariable(this);
    }
    static Create(t, e, s) {
      return C32.New(C32.EventVariable, t, e, s);
    }
    _PostInit() {
      if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
        const t = this._eventSheetManager.FindFirstFunctionBlockParent(this);
        t && t._RegisterLocalVariable(this);
      }
    }
    GetName() {
      return this._name;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this.GetParent();
    }
    IsGlobal() {
      return !this.GetParent();
    }
    IsLocal() {
      return !this.IsGlobal();
    }
    IsFunctionParameter() {
      return this._isFunctionParameter;
    }
    IsStatic() {
      return this._isStatic;
    }
    IsConstant() {
      return this._isConstant;
    }
    IsNumber() {
      return 0 === this._type;
    }
    IsString() {
      return 1 === this._type;
    }
    IsBoolean() {
      return 2 === this._type;
    }
    IsElseBlock() {
      return false;
    }
    GetSID() {
      return this._sid;
    }
    GetInitialValue() {
      return this._initialValue;
    }
    GetSolModifiers() {
      return EMPTY_SOL_MODIFIERS;
    }
    Run(t) {
      !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue());
    }
    DebugCanRunFast() {
      return true;
    }
    *DebugRun(t) {
      this.Run(t);
    }
    SetValue(t) {
      this.IsNumber() ? "number" != typeof t && (t = parseFloat(t)) : this.IsString() ? "string" != typeof t && (t = t.toString()) : this.IsBoolean() && (t = t ? 1 : 0), this._hasSingleValue ? this._value = t : this._localVarStack.GetCurrent()[this._localIndex] = t;
    }
    _ScriptSetValue(t) {
      if (this.IsConstant()) throw new Error(`assignment to constant event variable '${this.GetName()}'`);
      this.SetValue(t);
    }
    GetValue() {
      return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex];
    }
    GetTypedValue() {
      let t = this.GetValue();
      return this.IsBoolean() && (t = !!t), t;
    }
    ResetToInitialValue() {
      this._value = this._initialValue;
    }
    _GetScriptInterfaceDescriptor() {
      return { configurable: false, enumerable: true, get: this._scriptGetter, set: this._scriptSetter };
    }
  };
}
{
  const C32 = self.C3, assert = self.assert, EMPTY_SOL_MODIFIERS = [];
  C32.EventInclude = class extends C32.DefendedBase {
    constructor(e, t, n) {
      super();
      const s = e.GetEventSheetManager();
      this._eventSheet = e, this._eventSheetManager = s, this._runtime = e.GetRuntime(), this._parent = t, this._includeSheet = null, this._includeSheetName = n[1], this._isActive = true;
    }
    static Create(e, t, n) {
      return C32.New(C32.EventInclude, e, t, n);
    }
    _PostInit() {
      this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName), this._eventSheet._AddShallowInclude(this);
      let e = this.GetParent();
      for (; e; ) e instanceof C32.EventBlock && e.IsGroup() && e._AddContainedInclude(this), e = e.GetParent();
      this.UpdateActive(), this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord());
    }
    GetParent() {
      return this._parent;
    }
    GetSolModifiers() {
      return EMPTY_SOL_MODIFIERS;
    }
    GetIncludeSheet() {
      return this._includeSheet;
    }
    Run(e) {
      const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();
      t && this._eventSheetManager.PushCleanSol(n), this._includeSheet.Run(), t && this._eventSheetManager.PopSol(n);
    }
    *DebugRun(e) {
      const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();
      t && this._eventSheetManager.PushCleanSol(n), yield* this._includeSheet.DebugRun(), t && this._eventSheetManager.PopSol(n);
    }
    DebugCanRunFast() {
      return false;
    }
    IsActive() {
      return this._isActive;
    }
    UpdateActive() {
      let e = this.GetParent();
      for (; e; ) {
        if (e instanceof C32.EventBlock && e.IsGroup() && !e.IsGroupActive()) return void (this._isActive = false);
        e = e.GetParent();
      }
      this._isActive = true;
    }
  };
}
{
  let WrapIndex = function(e, t) {
    return e >= t ? e % t : e < 0 ? (e <= -t && (e %= t), e < 0 && (e += t), e) : e;
  };
  WrapIndex2 = WrapIndex;
  const C32 = self.C3, assert = self.assert;
  C32.ExpNode = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._owner = e, this._runtime = e.GetRuntime();
    }
    _PostInit() {
    }
    static CreateNode(e, t) {
      const s = t[0], n = [BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode];
      return C32.New(n[s], e, t);
    }
  };
  class SystemExpressionExpNode extends C32.ExpNode {
    constructor(e, t) {
      super(e), this._systemPlugin = this._runtime.GetSystemPlugin(), this._func = this._runtime.GetObjectReference(t[1]), this._func !== C32.Plugins.System.Exps.random && this._func !== C32.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance();
    }
    GetBoundMethod() {
      return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin);
    }
  }
  class CallFunctionExpressionExpNode extends C32.ExpNode {
    constructor(e, t) {
      super(e), this._functionBlock = null, this._functionName = t[1], this._owner.SetVariesPerInstance();
    }
    _PostInit() {
      const e = this._runtime.GetEventSheetManager();
      this._functionBlock = e.GetFunctionBlockByName(this._functionName), this._functionName = null;
      const t = this._owner.GetEventBlock(), s = this._functionBlock.GetEventBlock();
      this._combinedSolModifiers = [.../* @__PURE__ */ new Set([...t.GetSolModifiersIncludingParents(), ...s.GetSolModifiersIncludingParents()])], this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers);
    }
    GetBoundMethod() {
      const e = this._functionBlock;
      if (e.IsEnabled()) {
        const t = e.GetEventBlock();
        return C32.EventBlock.prototype.RunAsExpressionOrJSFunctionCall.bind(t, this._combinedSolModifiers, e.IsCopyPicked(), e.GetReturnType(), e.GetDefaultReturnValue(), null);
      }
      {
        const t = e.GetDefaultReturnValue();
        return () => t;
      }
    }
  }
  class ObjectExpressionNode extends C32.ExpNode {
    constructor(e, t) {
      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._func = this._runtime.GetObjectReference(t[2]), this._returnsString = !!t[3], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);
    }
    GetBoundMethod() {
      return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance());
    }
    ExpObject(...e) {
      const t = this._objectClass, s = t.GetCurrentSol().GetExpressionInstances(), n = s.length;
      if (0 === n) return this._returnsString ? "" : 0;
      const r = WrapIndex(this._owner.GetSolIndex(), n);
      return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t), this._func.apply(s[r].GetSdkInstance(), e);
    }
    ExpObject_InstExpr(e, ...t) {
      const s = this._objectClass, n = s.GetInstances(), r = n.length;
      if (0 === r || "number" != typeof e) return this._returnsString ? "" : 0;
      const i = WrapIndex(e, r);
      return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s), this._func.apply(n[i].GetSdkInstance(), t);
    }
  }
  class InstVarExpressionNode extends C32.ExpNode {
    constructor(e, t) {
      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._varIndex = t[3], this._returnsString = !!t[2], this._owner._MaybeVaryFor(this._objectClass);
    }
    ExpInstVar() {
      const e = this._objectClass.GetCurrentSol().GetExpressionInstances(), t = e.length;
      if (0 === t) return this._returnsString ? "" : 0;
      return e[WrapIndex(this._owner.GetSolIndex(), t)]._GetInstanceVariableValueUnchecked(this._varIndex);
    }
    ExpInstVar_Family() {
      const e = this._objectClass, t = e.GetCurrentSol().GetExpressionInstances(), s = t.length;
      if (0 === s) return this._returnsString ? "" : 0;
      const n = t[WrapIndex(this._owner.GetSolIndex(), s)], r = n.GetObjectClass().GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
      return n._GetInstanceVariableValueUnchecked(this._varIndex + r);
    }
    ExpInstVar_InstExpr(e) {
      const t = this._objectClass, s = t.GetInstances(), n = s.length;
      if (0 === n || "number" != typeof e) return this._returnsString ? "" : 0;
      const r = s[WrapIndex(e, n)];
      let i = 0;
      return t.IsFamily() && (i = r.GetObjectClass().GetFamilyInstanceVariableOffset(t.GetFamilyIndex())), r._GetInstanceVariableValueUnchecked(this._varIndex + i);
    }
  }
  class BehaviorExpressionNode extends C32.ExpNode {
    constructor(e, t) {
      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._behaviorType = this._objectClass.GetBehaviorTypeByName(t[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(t[2]), this._func = this._runtime.GetObjectReference(t[3]), this._returnsString = !!t[4], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);
    }
    ExpBehavior(...e) {
      const t = this._objectClass, s = t.GetCurrentSol().GetExpressionInstances(), n = s.length;
      if (0 === n) return this._returnsString ? "" : 0;
      const r = WrapIndex(this._owner.GetSolIndex(), n);
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t);
      const i = s[r];
      let o = 0;
      return t.IsFamily() && (o = i.GetObjectClass().GetFamilyBehaviorOffset(t.GetFamilyIndex())), this._func.apply(i.GetBehaviorInstances()[this._behaviorIndex + o].GetSdkInstance(), e);
    }
    ExpBehavior_InstExpr(e, ...t) {
      const s = this._objectClass, n = s.GetInstances(), r = n.length;
      if (0 === r || "number" != typeof e) return this._returnsString ? "" : 0;
      const i = WrapIndex(e, r);
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s);
      const o = n[i];
      let a = 0;
      return s.IsFamily() && (a = o.GetObjectClass().GetFamilyBehaviorOffset(s.GetFamilyIndex())), this._func.apply(o.GetBehaviorInstances()[this._behaviorIndex + a].GetSdkInstance(), t);
    }
  }
  class EventVarExpNode extends C32.ExpNode {
    constructor(e, t) {
      super(e), this._eventVar = null, this._eventVarSid = t[1];
    }
    _PostInit() {
      this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);
    }
    GetVar() {
      return this._eventVar;
    }
  }
}
var WrapIndex2;
{
  let GetExpressionFunc = function(t) {
    const e = self.C3_ExpressionFuncs[t];
    if (!e) throw new Error("invalid expression number");
    return e;
  };
  GetExpressionFunc2 = GetExpressionFunc;
  const C32 = self.C3, assert = self.assert;
  C32.Parameter = class extends C32.DefendedBase {
    constructor(t, e, s) {
      super(), this._owner = t, this._index = s, this._type = e, this.Get = null, this._variesPerInstance = false, this._isConstant = false;
    }
    static Create(t, e, s) {
      const r = e[0], n = [ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter];
      return C32.New(n[r], t, r, s, e);
    }
    _PostInit() {
    }
    SetVariesPerInstance() {
      this._variesPerInstance = true;
    }
    _MaybeVaryFor(t) {
      this._variesPerInstance || t && (t.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = true));
    }
    VariesPerInstance() {
      return this._variesPerInstance;
    }
    GetIndex() {
      return this._index;
    }
    GetRuntime() {
      return this._owner.GetRuntime();
    }
    GetEventBlock() {
      return this._owner.GetEventBlock();
    }
    IsConstant() {
      return this._isConstant;
    }
    IsObjectParameter() {
      return 4 === this._type;
    }
  };
  class ExpressionParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._solIndex = 0;
      const n = r[1];
      this._expressionNumber = n[0], this._numberedNodes = [], this._expressionFunc = null;
      for (let t2 = 1, e2 = n.length; t2 < e2; ++t2) this._numberedNodes.push(C32.ExpNode.CreateNode(this, n[t2]));
      this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc(this._expressionNumber), this._isConstant = true);
    }
    _GetNode(t) {
      if (t < 0 || t >= this._numberedNodes.length) throw new RangeError("invalid numbered node");
      return this._numberedNodes[t];
    }
    _PostInit() {
      for (const t2 of this._numberedNodes) t2._PostInit();
      const t = GetExpressionFunc(this._expressionNumber);
      this._numberedNodes.length ? this._expressionFunc = t(this) : this._expressionFunc = t;
    }
    GetSolIndex() {
      return this._solIndex;
    }
    GetExpression(t) {
      return this._solIndex = t, this._expressionFunc();
    }
  }
  class StringExpressionParameter extends ExpressionParameter {
    constructor(t, e, s, r) {
      super(t, e, s, r), this.Get = this.GetStringExpression, 14 === e && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof C32.Action && this.GetEventBlock().SetSolWriterAfterCnds());
    }
    GetStringExpression(t) {
      this._solIndex = t;
      const e = this._expressionFunc();
      return "string" == typeof e ? e : "";
    }
    _GetFastTriggerValue() {
      return GetExpressionFunc(this._expressionNumber)();
    }
  }
  class LayerExpressionParameter extends ExpressionParameter {
    constructor(t, e, s, r) {
      super(t, e, s, r), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetILayer : this.Get = this.GetLayer, this._isConstant = false;
    }
    GetLayer(t) {
      this._solIndex = t;
      const e = this._expressionFunc();
      return this.GetRuntime().GetCurrentLayout().GetLayer(e);
    }
    GetILayer(t) {
      const e = this.GetLayer(t);
      return e ? e.GetILayer() : null;
    }
  }
  class ComboParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._combo = r[1], this.Get = this.GetCombo, this._isConstant = true;
    }
    GetCombo() {
      return this._combo;
    }
  }
  class BooleanParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._bool = r[1], this.Get = this.GetBoolean, this._isConstant = true;
    }
    GetBoolean() {
      return this._bool;
    }
  }
  class ObjectParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._objectClass = this.GetRuntime().GetObjectClassByIndex(r[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIObjectClass : this.Get = this.GetObjectClass;
      const n = this.GetEventBlock();
      n._AddSolModifier(this._objectClass), this._owner instanceof C32.Action ? n.SetSolWriterAfterCnds() : n.GetParent() && n.GetParent().SetSolWriterAfterCnds(), this._isConstant = true;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetIObjectClass() {
      return this._objectClass ? this._objectClass.GetIObjectClass() : null;
    }
  }
  class LayoutParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(r[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetILayout : this.Get = this.GetLayout, this._isConstant = true;
    }
    GetLayout() {
      return this._layout;
    }
    GetILayout() {
      return this._layout ? this._layout.GetILayout() : null;
    }
  }
  class TimelineParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(r[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetITimelineState : this.Get = this.GetTimeline, this._isConstant = true;
    }
    GetTimeline() {
      return this._timeline;
    }
    GetITimelineState() {
      return this._timeline ? this._timeline.GetITimelineState() : null;
    }
  }
  class FileParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._fileInfo = r[1], this.Get = this.GetFile, this._isConstant = true;
    }
    GetFile() {
      return this._fileInfo;
    }
  }
  class InstVarParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._instVarIndex = r[1];
      const n = this._owner.GetObjectClass();
      this._owner instanceof C32.Condition && this._owner.IsStatic() ? (this.Get = this.GetInstanceVariable, this._isConstant = true) : n && n.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = true);
    }
    GetInstanceVariable() {
      return this._instVarIndex;
    }
    GetFamilyInstanceVariable(t) {
      t = t || 0;
      const e = this._owner.GetObjectClass(), s = e.GetCurrentSol(), r = s.GetInstances();
      let n = null;
      if (r.length) n = r[t % r.length].GetObjectClass();
      else if (s.HasAnyElseInstances()) {
        const e2 = s.GetElseInstances();
        n = e2[t % e2.length].GetObjectClass();
      } else {
        if (!(e.GetInstanceCount() > 0)) return 0;
        {
          const s2 = e.GetInstances();
          n = s2[t % s2.length].GetObjectClass();
        }
      }
      return this._instVarIndex + n.GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
    }
  }
  class EventVarParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._eventVarSid = r[1], this._eventVar = null, t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIEventVariable : this.Get = this.GetEventVariable, this._isConstant = true;
    }
    _PostInit() {
      this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);
    }
    GetEventVariable() {
      return this._eventVar;
    }
    GetIEventVariable() {
      return null;
    }
  }
  class FunctionParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._functionBlockName = r[1], this._functionBlock = null, t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIFunction : this.Get = this.GetFunction, this._isConstant = true;
    }
    _PostInit() {
      this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName), this._functionBlockName = null;
    }
    GetFunction() {
      return this._functionBlock;
    }
    GetIFunction() {
      return null;
    }
  }
  class VariadicParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._subParams = [], this._variadicRet = [], this._isConstant = true;
      for (let t2 = 1, e2 = r.length; t2 < e2; ++t2) {
        const e3 = C32.Parameter.Create(this._owner, r[t2], 0);
        this._subParams.push(e3), this._variadicRet.push(0), e3.IsConstant() || (this._isConstant = false);
      }
      this.Get = this.GetVariadic;
    }
    _PostInit() {
      for (const t of this._subParams) t._PostInit();
    }
    GetVariadic() {
      const t = this._subParams, e = this._variadicRet;
      for (let s = 0, r = t.length; s < r; ++s) e[s] = t[s].Get(0);
      return e;
    }
  }
  class EaseParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._easeIndex = r[1], this.Get = this.GetEase, this._isConstant = true;
    }
    GetEase() {
      return this._easeIndex;
    }
  }
  class TilemapBrushParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._brushIndex = r[1], this.Get = this.GetTilemapBrush, this._isConstant = true;
    }
    GetTilemapBrush() {
      return this._brushIndex;
    }
  }
  class TemplateExpressionParameter extends ExpressionParameter {
    constructor(t, e, s, r) {
      super(t, e, s, r), this.Get = this.GetTemplateName, this._isConstant = false;
    }
    GetTemplateName() {
      return this._expressionFunc();
    }
  }
  class FlowchartParameter extends C32.Parameter {
    constructor(t, e, s, r) {
      super(t, e, s), this._flowchartDataItem = this.GetRuntime().GetFlowchartManager().GetFlowchartDataItemByName(r[1]), this.Get = this.GetFlowchartName, this._isConstant = true;
    }
    GetFlowchartName() {
      return this._flowchartDataItem.GetName();
    }
  }
}
var GetExpressionFunc2;
{
  let EvalParams = function(t, e) {
    for (let s = 0, n = t.length; s < n; ++s) e[s] = t[s].Get(0);
  };
  EvalParams2 = EvalParams;
  const C32 = self.C3, assert = self.assert;
  const EMPTY_PARAMS_ARRAY = [], noop = function() {
  };
  C32.Condition = class extends C32.DefendedBase {
    constructor(t, e, s) {
      if (super(), this._eventBlock = t, this._runtime = t.GetRuntime(), this._index = s, this._func = this._runtime.GetObjectReference(e[1]), this._isTrigger = e[3] > 0, this._isFastTrigger = 2 === e[3], this._isLooping = !!e[4], this._isInverted = !!e[5], this._isStatic = !!e[6], this._sid = e[7], this._isInOrBlock = this._eventBlock.IsOrBlock(), this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null, this._debugData = this._runtime.IsDebug() ? { isBreakpoint: e[8][0], canDebug: e[8][1] } : null, -1 === e[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(e[0]), e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds()), 10 === e.length) {
        let t2 = e[9];
        for (let e2 of t2) this._parameters.push(C32.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);
      }
      0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this._eventBlock.GetEventSheetManager()._RegisterCondition(this);
    }
    static Create(t, e, s) {
      return C32.New(C32.Condition, t, e, s);
    }
    _PostInit() {
      for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);
      this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject);
    }
    _SetSystemRunMethod() {
      const t = this._systemPlugin, e = this._systemPlugin;
      this._SetRunMethodForBoundFunc(t, e, this._RunSystem);
    }
    _SetSingleGlobalRunMethod() {
      const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);
    }
    _SetRunMethodForBoundFunc(t, e, s) {
      const n = this._func, i = this._isInverted, r = this._parameters;
      if (0 === r.length) {
        const s2 = t._GetBoundACEMethod(n, e);
        this.Run = i ? function() {
          return C32.xor(s2(), i);
        } : s2;
      } else if (1 === r.length) {
        const s2 = r[0];
        if (!i && s2.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, s2.Get(0));
        else {
          const r2 = t._GetBoundACEMethod(n, e);
          this.Run = function() {
            return C32.xor(r2(s2.Get(0)), i);
          };
        }
      } else if (2 === r.length) {
        const s2 = r[0], a = r[1];
        if (!i && s2.IsConstant() && a.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, s2.Get(0), a.Get(0));
        else {
          const r2 = t._GetBoundACEMethod(n, e);
          this.Run = function() {
            return C32.xor(r2(s2.Get(0), a.Get(0)), i);
          };
        }
      } else if (3 === r.length) {
        const s2 = r[0], a = r[1], h = r[2];
        if (!i && s2.IsConstant() && a.IsConstant() && h.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, s2.Get(0), a.Get(0), h.Get(0));
        else {
          const r2 = t._GetBoundACEMethod(n, e);
          this.Run = function() {
            return C32.xor(r2(s2.Get(0), a.Get(0), h.Get(0)), i);
          };
        }
      } else this.Run = s;
    }
    GetSID() {
      return this._sid;
    }
    _GetFunc() {
      return this._func;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetImplementationAddon() {
      return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;
    }
    GetImplementationSdkVersion() {
      const t = this.GetImplementationAddon();
      return t ? t.GetSdkVersion() : 1;
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetIndex() {
      return this._index;
    }
    GetDebugIndex() {
      return this.GetIndex();
    }
    IsTrigger() {
      return this._isTrigger;
    }
    IsFastTrigger() {
      return this._isFastTrigger;
    }
    IsInverted() {
      return this._isInverted;
    }
    IsLooping() {
      return this._isLooping;
    }
    IsStatic() {
      return this._isStatic;
    }
    IsBreakpoint() {
      return this._debugData.isBreakpoint;
    }
    IsSystemCondition() {
      return !!this._systemPlugin;
    }
    IsSystemOrSingleGlobalCondition() {
      return this.IsSystemCondition() || this._objectClass.GetPlugin().IsSingleGlobal();
    }
    GetFirstObjectParameterObjectClass() {
      for (const t of this._parameters) if (t.IsObjectParameter()) return t.GetObjectClass();
      return null;
    }
    _SetBreakpoint(t) {
      this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();
    }
    _DebugReturnsGenerator() {
      return this._debugData.canDebug;
    }
    DebugCanRunFast() {
      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();
    }
    GetSavedDataMap() {
      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
    }
    GetUnsavedDataMap() {
      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
    }
    _RunSystem() {
      const t = this._results;
      return EvalParams(this._parameters, t), C32.xor(this._func.apply(this._systemPlugin, t), this._isInverted);
    }
    *_DebugRunSystem() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._results;
        EvalParams(this._parameters, t);
        let e = this._func.apply(this._systemPlugin, t);
        return C32.IsIterator(e) && (e = yield* e), C32.xor(e, this._isInverted);
      }
      return this.Run();
    }
    _RunSingleGlobal() {
      const t = this._results;
      EvalParams(this._parameters, t);
      const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      return C32.xor(this._func.apply(e, t), this._isInverted);
    }
    *_DebugRunSingleGlobal() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._results;
        EvalParams(this._parameters, t);
        const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        let s = this._func.apply(e, t);
        return C32.IsIterator(s) && (s = yield* s), C32.xor(s, this._isInverted);
      }
      return this.Run();
    }
    _RunFastTrigger() {
      return true;
    }
    *_DebugRunFastTrigger() {
      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), true;
    }
    _GetStaticConditionThis() {
      return this._behaviorType ? this._behaviorType.GetBehavior().GetSdkVersion() >= 2 ? this._behaviorType.GetIBehaviorType() : this._behaviorType : this._objectClass.GetPlugin().GetSdkVersion() >= 2 ? this._objectClass.GetIObjectClass() : this._objectClass;
    }
    _RunStatic() {
      const t = this._results;
      EvalParams(this._parameters, t);
      const e = this._func.apply(this._GetStaticConditionThis(), t);
      return this._objectClass.ApplySolToContainer(), e;
    }
    *_DebugRunStatic() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._results;
        EvalParams(this._parameters, t);
        let e = this._func.apply(this._GetStaticConditionThis(), t);
        return C32.IsIterator(e) && (e = yield* e), this._objectClass.ApplySolToContainer(), e;
      }
      return this.Run();
    }
    _RunObject() {
      const t = this._parameters, e = this._results, s = this._objectClass.GetCurrentSol();
      for (let s2 = 0, n = t.length; s2 < n; ++s2) {
        const n2 = t[s2];
        n2.VariesPerInstance() || (e[s2] = n2.Get(0));
      }
      return s.IsSelectAll() ? this._RunObject_FirstFilter(s) : this._RunObject_NextFilter(s);
    }
    *_DebugRunObject() {
      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._RunObject();
    }
    _EvaluateVaryingParameters(t) {
      const e = this._parameters, s = this._results;
      for (let n = 0, i = e.length; n < i; ++n) {
        const i2 = e[n];
        i2.VariesPerInstance() && (s[n] = i2.Get(t));
      }
    }
    _RunObject_FirstFilter(t) {
      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = this._behaviorIndex, r = i >= 0, a = e.GetInstances(), h = this._anyParamVariesPerInstance, o = this._results, l = this._func, u = this._isInverted, _ = this._isInOrBlock && !this._isTrigger;
      t.ClearArrays();
      for (let e2 = 0, c = a.length; e2 < c; ++e2) {
        const c2 = a[e2];
        let g;
        if (h && this._EvaluateVaryingParameters(e2), r) {
          const t2 = s ? c2.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
          g = l.apply(c2.GetBehaviorInstances()[i + t2].GetSdkInstance(), o);
        } else g = l.apply(c2.GetSdkInstance(), o);
        C32.xor(g, u) ? t._PushInstance(c2) : _ && t._PushElseInstance(c2);
      }
      return e.FinishCondition(true), t._SetSelectAll(false), e.ApplySolToContainer(), t.HasAnyInstances();
    }
    _RunObject_NextFilter(t) {
      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = e.IsInContainer(), r = this._behaviorIndex, a = r >= 0, h = this._anyParamVariesPerInstance, o = this._results, l = this._func, u = this._isInverted, _ = this._isInOrBlock && !this._isTrigger, c = t._GetOwnInstances(), g = t._GetOwnElseInstances(), d = _ && !this._eventBlock.IsFirstConditionOfType(this), I = d ? g : c;
      let G = 0, b = false;
      for (let t2 = 0, e2 = I.length; t2 < e2; ++t2) {
        const e3 = I[t2];
        let m2;
        if (h && this._EvaluateVaryingParameters(t2), a) {
          const t3 = s ? e3.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
          m2 = l.apply(e3.GetBehaviorInstances()[r + t3].GetSdkInstance(), o);
        } else m2 = l.apply(e3.GetSdkInstance(), o);
        C32.xor(m2, u) ? (b = true, d ? (c.push(e3), i && e3._PushSiblingsToSolInstances()) : (I[G] = e3, i && e3._SetSiblingsToSolInstancesIndex(G), ++G)) : d ? (I[G] = e3, i && e3._SetSiblingsToSolElseInstancesIndex(G), ++G) : _ && (g.push(e3), i && e3._PushSiblingsToSolElseInstances());
      }
      C32.truncateArray(I, G), i && e._TruncateContainerSols(d, G);
      const m = b;
      return d && !b && (b = this._OrBlockCheckInstances(c)), e.FinishCondition(m || _), _ ? b : t.HasAnyInstances();
    }
    _OrBlockCheckInstances(t) {
      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = this._anyParamVariesPerInstance, r = this._behaviorIndex, a = r >= 0, h = this._results, o = this._func, l = this._isInverted;
      for (let e2 = 0, u = t.length; e2 < u; ++e2) {
        const u2 = t[e2];
        let _;
        if (i && this._EvaluateVaryingParameters(e2), a) {
          const t2 = s ? u2.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
          _ = o.apply(u2.GetBehaviorInstances()[r + t2].GetSdkInstance(), h);
        } else _ = o.apply(u2.GetSdkInstance(), h);
        if (C32.xor(_, l)) return true;
      }
      return false;
    }
    ReevaluateParameter(t, e) {
      return this._parameters[t].Get(e);
    }
    GetFastTriggerValue() {
      const t = this._parameters;
      if (!t.length) throw new Error("no parameters");
      return t[0]._GetFastTriggerValue();
    }
    _SaveToJson() {
      if (!this._savedData || !this._savedData.size) return null;
      const t = {};
      for (const [e, s] of this._savedData.entries()) {
        let n = s;
        "collmemory" === e && (n = [...s.entries()].map((t2) => [t2[0].GetUID(), t2[1].GetUID(), t2[2]])), t[e] = n;
      }
      return { "ex": t };
    }
    _LoadFromJson(t) {
      if (this._savedData && (this._savedData.clear(), this._savedData = null), !t) return;
      const e = this._runtime, s = t["ex"];
      if (s) {
        const t2 = this.GetSavedDataMap();
        t2.clear();
        for (const [n, i] of Object.entries(s)) {
          let s2 = i;
          "collmemory" === n && (s2 = C32.New(C32.PairMap, i.map((t3) => [e.GetInstanceByUID(t3[0]), e.GetInstanceByUID(t3[1]), t3[2]]).filter((t3) => t3[0] && t3[1]))), t2.set(n, s2);
        }
      }
    }
  };
}
var EvalParams2;
{
  let EvalParams = function(t, e) {
    for (let s = 0, n = t.length; s < n; ++s) e[s] = t[s].Get(0);
  };
  EvalParams2 = EvalParams;
  const C32 = self.C3, assert = self.assert;
  const EMPTY_PARAMS_ARRAY = [], noop = function() {
  }, noopGenerator = function* () {
  }, FLAG_CANPICKANYOBJECTCLASS = 1, FLAG_COPYPICKED = 2, FLAG_CUSTOM_ACE = 4, FLAG_IS_ASYNC = 8, FLAG_CAN_BAIL_OUT = 16;
  C32.Action = class extends C32.DefendedBase {
    constructor(t, e, s) {
      super(), this._eventBlock = t;
      const n = t.GetRuntime();
      this._runtime = n, this._index = s, this._sid = e.length >= 4 ? e[3] : -1, this._actionType = e.length >= 5 ? 255 & e[4] : 0, this._flags = e.length >= 5 ? e[4] >> 8 : 0, this._func = null, this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this._callFunctionName = "", this._callCustomAceObjectClass = null, this._callEventBlock = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false;
      const i = -3 === e[0], a = i ? e[2] : e[5];
      if (this._debugData = n.IsDebug() || i ? { isBreakpoint: a[0], canDebug: a[1], index: a[2] } : null, -1 === e[0]) this._systemPlugin = n.GetSystemPlugin(), this._func = n.GetObjectReference(e[1]);
      else if (-2 === e[0]) this._callFunctionName = e[1];
      else if (i) {
        const t2 = n.GetObjectReference(e[1]);
        this._func = t2, this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._flags |= 8;
      } else this._objectClass = n.GetObjectClassByIndex(e[0]), 4 & this._flags ? (this._callFunctionName = e[1], this._callCustomAceObjectClass = n.GetObjectClassByIndex(e[2])) : (e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._func = n.GetObjectReference(e[1]));
      if (7 === e.length) {
        const t2 = e[6];
        for (const e2 of t2) this._parameters.push(C32.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);
      }
      0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(), this._eventBlock.SetSolWriterAfterCnds()), this._eventBlock.GetEventSheetManager()._RegisterAction(this);
    }
    static Create(t, e, s) {
      return C32.New(C32.Action, t, e, s);
    }
    _PostInit() {
      for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);
      if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;
      else if (this._callFunctionName) 4 & this._flags ? this._SetCallCustomActionRunMethod() : this._SetCallFunctionRunMethod(), this._callFunctionName = "", this._callCustomAceObjectClass = null;
      else if (this.Run === this.RunUserScript) {
        const t = this._func, e = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
        this._func = t.bind(null, this._runtime.GetIRuntime(), e);
      } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsStatic() ? (this.Run = this._RunObject_Static, this.DebugRun = this._DebugRunObject_Static) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks, this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every((t) => t.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary, this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every((t) => t.IsConstant()) ? (EvalParams(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst);
    }
    _SetSystemRunMethod() {
      const t = this._systemPlugin, e = this._systemPlugin;
      this._SetRunMethodForBoundFunc(t, e, this._RunSystem);
    }
    _SetSingleGlobalRunMethod() {
      const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);
    }
    _SetCallFunctionRunMethod() {
      const t = this._eventBlock.GetEventSheetManager(), e = t.GetFunctionBlockByName(this._callFunctionName);
      if (e.IsEnabled()) {
        const s = !!(2 & this._flags);
        this._callEventBlock = e.GetEventBlock();
        let n = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])];
        n = t._DeduplicateSolModifierList(n);
        const i = !e.IsCopyPicked() && this._HasCopyPickedParent() ? { pushCleanSolDynamic: true } : null;
        if (this.Run = C32.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, n, this._parameters, s, i), this._runtime.IsDebug()) {
          const t2 = this;
          this.DebugRun = function* () {
            (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);
            return yield* t2._callEventBlock.DebugRunAsFunctionCall(n, t2._parameters, s, i);
          };
        } else this.DebugRun = noopGenerator;
      } else this.Run = noop, this.DebugRun = noopGenerator;
    }
    _SetCallCustomActionRunMethod() {
      const t = this._eventBlock.GetEventSheetManager(), e = t.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);
      if (e.IsEnabled()) {
        const s = !!(2 & this._flags);
        this._callEventBlock = e.GetEventBlock();
        let n = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, e.GetObjectClass()])];
        n = t._DeduplicateSolModifierList(n);
        const i = !this._objectClass.IsFamily() && !e.GetObjectClass().IsFamily(), a = !this._objectClass.IsFamily() && e.GetObjectClass().IsFamily(), r = this._objectClass.IsFamily();
        let o = null;
        if (!e.IsCopyPicked() && this._HasCopyPickedParent() && (o = o || {}, o.pushCleanSolDynamic = true), !a && s || (o = o || {}, o.copyFromObjectClass = this._objectClass, o.copyToObjectClass = e.GetObjectClass()), i || a || r && !e.HasCustomACEOverrides() ? this.Run = C32.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, n, this._parameters, s, o) : r && (this.Run = C32.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(e, n, this._parameters)), this._runtime.IsDebug()) {
          const t2 = this;
          i || a || r && !e.HasCustomACEOverrides() ? this.DebugRun = function* () {
            (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);
            return yield* t2._callEventBlock.DebugRunAsFunctionCall(n, t2._parameters, s, o);
          } : r && (this.DebugRun = function* () {
            (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);
            return yield* e.DebugRunAsFamilyCustomActionWithOverrides(n, t2._parameters);
          });
        } else this.DebugRun = noopGenerator;
      } else this.Run = noop, this.DebugRun = noopGenerator;
    }
    _SetRunMethodForBoundFunc(t, e, s) {
      const n = this._func, i = this._parameters;
      if (0 === i.length) this.Run = t._GetBoundACEMethod(n, e);
      else if (1 === i.length) {
        const s2 = i[0];
        if (s2.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, s2.Get(0));
        else {
          const i2 = t._GetBoundACEMethod(n, e);
          this.Run = function() {
            return i2(s2.Get(0));
          };
        }
      } else if (2 === i.length) {
        const s2 = i[0], a = i[1];
        if (s2.IsConstant() && a.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, s2.Get(0), a.Get(0));
        else {
          const i2 = t._GetBoundACEMethod(n, e);
          this.Run = function() {
            return i2(s2.Get(0), a.Get(0));
          };
        }
      } else if (3 === i.length) {
        const s2 = i[0], a = i[1], r = i[2];
        if (s2.IsConstant() && a.IsConstant() && r.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, s2.Get(0), a.Get(0), r.Get(0));
        else {
          const i2 = t._GetBoundACEMethod(n, e);
          this.Run = function() {
            return i2(s2.Get(0), a.Get(0), r.Get(0));
          };
        }
      } else this.Run = s;
    }
    GetSID() {
      return this._sid;
    }
    IsAsync() {
      return !!(8 & this._flags);
    }
    CanBailOut() {
      return !!(16 & this._flags);
    }
    CallBeforeAfterHooks() {
      return 1 === this._actionType;
    }
    IsStatic() {
      return 2 === this._actionType;
    }
    CanPickAnyObjectClass() {
      return !!(1 & this._flags);
    }
    HasReturnType() {
      return this.IsAsync() || this.CanBailOut();
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetImplementationAddon() {
      return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;
    }
    GetImplementationSdkVersion() {
      const t = this.GetImplementationAddon();
      return t ? t.GetSdkVersion() : 1;
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    _HasCopyPickedParent() {
      let t = this._eventBlock;
      do {
        if (t instanceof C32.FunctionBlock && t.IsCopyPicked()) return true;
        t = t.GetScopeParent();
      } while (t);
      return false;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetIndex() {
      return this._index;
    }
    GetDebugIndex() {
      return this._debugData.index;
    }
    IsBreakpoint() {
      return this._debugData.isBreakpoint;
    }
    _SetBreakpoint(t) {
      this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();
    }
    _DebugReturnsGenerator() {
      return this._debugData.canDebug;
    }
    DebugCanRunFast() {
      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();
    }
    _RunSystem() {
      const t = this._results;
      return EvalParams(this._parameters, t), this._func.apply(this._systemPlugin, t);
    }
    *_DebugRunSystem() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._results;
        EvalParams(this._parameters, t);
        return yield* this._func.apply(this._systemPlugin, t);
      }
      return this.Run();
    }
    _RunSingleGlobal() {
      const t = this._results;
      return EvalParams(this._parameters, t), this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);
    }
    *_DebugRunSingleGlobal() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._results;
        EvalParams(this._parameters, t);
        return yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);
      }
      return this.Run();
    }
    _RunObject_ParamsConst() {
      const t = this._results, e = this._objectClass.GetCurrentSol().GetInstances();
      for (let s = 0, n = e.length; s < n; ++s) this._func.apply(e[s].GetSdkInstance(), t);
    }
    *_DebugRunObject_ParamsConst() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._results, e = this._objectClass.GetCurrentSol().GetInstances();
        for (let s = 0, n = e.length; s < n; ++s) yield* this._func.apply(e[s].GetSdkInstance(), t);
      } else this._RunObject_ParamsConst();
    }
    _RunObject_ParamsDontVary() {
      const t = this._results;
      EvalParams(this._parameters, t);
      const e = this._objectClass.GetCurrentSol().GetInstances();
      for (let s = 0, n = e.length; s < n; ++s) this._func.apply(e[s].GetSdkInstance(), t);
    }
    *_DebugRunObject_ParamsDontVary() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._results;
        EvalParams(this._parameters, t);
        const e = this._objectClass.GetCurrentSol().GetInstances();
        for (let s = 0, n = e.length; s < n; ++s) yield* this._func.apply(e[s].GetSdkInstance(), t);
      } else this._RunObject_ParamsDontVary();
    }
    _RunObject_AllParamsVary() {
      const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
      for (let i = 0, a = n.length; i < a; ++i) {
        const a2 = n[i];
        for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) e[s2] = t[s2].Get(i);
        s.apply(a2.GetSdkInstance(), e);
      }
    }
    *_DebugRunObject_AllParamsVary() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
        for (let i = 0, a = n.length; i < a; ++i) {
          const a2 = n[i];
          for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) e[s2] = t[s2].Get(i);
          yield* s.apply(a2.GetSdkInstance(), e);
        }
      } else this._RunObject_AllParamsVary();
    }
    _RunObject_SomeParamsVary() {
      const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
      for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) {
        const n3 = t[s2];
        n3.VariesPerInstance() || (e[s2] = n3.Get(0));
      }
      for (let i = 0, a = n.length; i < a; ++i) {
        const a2 = n[i];
        for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) {
          const n3 = t[s2];
          n3.VariesPerInstance() && (e[s2] = n3.Get(i));
        }
        s.apply(a2.GetSdkInstance(), e);
      }
    }
    *_DebugRunObject_SomeParamsVary() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
        for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) {
          const n3 = t[s2];
          n3.VariesPerInstance() || (e[s2] = n3.Get(0));
        }
        for (let i = 0, a = n.length; i < a; ++i) {
          const a2 = n[i];
          for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) {
            const n3 = t[s2];
            n3.VariesPerInstance() && (e[s2] = n3.Get(i));
          }
          yield* s.apply(a2.GetSdkInstance(), e);
        }
      } else this._RunObject_SomeParamsVary();
    }
    _RunObject_BeforeAfterHooks() {
      const t = this._parameters, e = this._results, s = this._func, n = this._objectClass, i = n.GetSdkType(), a = n.GetCurrentSol().GetInstances();
      i.BeforeRunAction(s);
      for (let n2 = 0, i2 = a.length; n2 < i2; ++n2) {
        const i3 = a[n2];
        for (let s2 = 0, i4 = t.length; s2 < i4; ++s2) e[s2] = t[s2].Get(n2);
        s.apply(i3.GetSdkInstance(), e);
      }
      i.AfterRunAction(s);
    }
    *_DebugRunObject_BeforeAfterHooks() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._parameters, e = this._results, s = this._func, n = this._objectClass, i = n.GetSdkType(), a = n.GetCurrentSol().GetInstances();
        i.BeforeRunAction(s);
        for (let n2 = 0, i2 = a.length; n2 < i2; ++n2) {
          const i3 = a[n2];
          for (let s2 = 0, i4 = t.length; s2 < i4; ++s2) e[s2] = t[s2].Get(n2);
          yield* s.apply(i3.GetSdkInstance(), e);
        }
        i.AfterRunAction(s);
      } else this._RunObject_BeforeAfterHooks();
    }
    _GetStaticActionThis() {
      return this._behaviorType ? this._behaviorType.GetBehavior().GetSdkVersion() >= 2 ? this._behaviorType.GetIBehaviorType() : this._behaviorType : this._objectClass.GetPlugin().GetSdkVersion() >= 2 ? this._objectClass.GetIObjectClass() : this._objectClass;
    }
    _RunObject_Static() {
      const t = this._results;
      return EvalParams(this._parameters, t), this._func.apply(this._GetStaticActionThis(), t);
    }
    *_DebugRunObject_Static() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._results;
        EvalParams(this._parameters, t);
        let e = this._func.apply(this._GetStaticActionThis(), t);
        return C32.IsIterator(e) && (e = yield* e), e;
      }
      return this._RunObject_Static();
    }
    _RunBehavior() {
      const t = this._objectClass, e = t.IsFamily(), s = t.GetFamilyIndex(), n = this._parameters, i = this._anyParamVariesPerInstance, a = this._results, r = this._func, o = this._behaviorIndex, l = t.GetCurrentSol().GetInstances();
      for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {
        const e3 = n[t2];
        e3.VariesPerInstance() || (a[t2] = e3.Get(0));
      }
      for (let t2 = 0, h = l.length; t2 < h; ++t2) {
        const h2 = l[t2];
        if (i) for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) {
          const s3 = n[e2];
          s3.VariesPerInstance() && (a[e2] = s3.Get(t2));
        }
        const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;
        r.apply(h2.GetBehaviorInstances()[o + u].GetSdkInstance(), a);
      }
    }
    *_DebugRunBehavior() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._objectClass, e = t.IsFamily(), s = t.GetFamilyIndex(), n = this._parameters, i = this._anyParamVariesPerInstance, a = this._results, r = this._func, o = this._behaviorIndex, l = t.GetCurrentSol().GetInstances();
        for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {
          const e3 = n[t2];
          e3.VariesPerInstance() || (a[t2] = e3.Get(0));
        }
        for (let t2 = 0, h = l.length; t2 < h; ++t2) {
          const h2 = l[t2];
          if (i) for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) {
            const s3 = n[e2];
            s3.VariesPerInstance() && (a[e2] = s3.Get(t2));
          }
          const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;
          yield* r.apply(h2.GetBehaviorInstances()[o + u].GetSdkInstance(), a);
        }
      } else this._RunBehavior();
    }
    _RunObject_Async() {
      const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances(), i = [];
      for (let a = 0, r = n.length; a < r; ++a) {
        const r2 = n[a];
        for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) e[s2] = t[s2].Get(a);
        i.push(s.apply(r2.GetSdkInstance(), e));
      }
      return Promise.all(i);
    }
    *_DebugRunObject_Async() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances(), i = [];
        for (let a = 0, r = n.length; a < r; ++a) {
          const r2 = n[a];
          for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) e[s2] = t[s2].Get(a);
          i.push(yield* s.apply(r2.GetSdkInstance(), e));
        }
        return Promise.all(i);
      }
      return this._RunObject_Async();
    }
    _RunBehavior_Async() {
      const t = this._objectClass, e = t.IsFamily(), s = t.GetFamilyIndex(), n = this._parameters, i = this._results, a = this._func, r = this._behaviorIndex, o = t.GetCurrentSol().GetInstances(), l = [];
      for (let t2 = 0, h = o.length; t2 < h; ++t2) {
        const h2 = o[t2];
        for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) i[e2] = n[e2].Get(t2);
        const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;
        l.push(a.apply(h2.GetBehaviorInstances()[r + u].GetSdkInstance(), i));
      }
      return Promise.all(l);
    }
    *_DebugRunBehavior_Async() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t = this._objectClass, e = t.IsFamily(), s = t.GetFamilyIndex(), n = this._parameters, i = this._results, a = this._func, r = this._behaviorIndex, o = t.GetCurrentSol().GetInstances(), l = [];
        for (let t2 = 0, h = o.length; t2 < h; ++t2) {
          const h2 = o[t2];
          for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) i[e2] = n[e2].Get(t2);
          const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;
          l.push(yield* a.apply(h2.GetBehaviorInstances()[r + u].GetSdkInstance(), i));
        }
        return Promise.all(l);
      }
      return this._RunBehavior_Async();
    }
    async RunUserScript() {
      try {
        await this._func();
      } catch (t) {
        console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", t), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), C32.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), C32.EventScript.SetHadUserScriptException());
      }
    }
    *DebugRunUserScript() {
      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.RunUserScript();
    }
    _SaveToJson() {
      return this._savedData && this._savedData.size ? { "ex": C32.ToSuperJSON(this._savedData) } : null;
    }
    _LoadFromJson(t) {
      if (this._savedData && (this._savedData.clear(), this._savedData = null), !t) return;
      const e = t["ex"];
      e && (this._savedData = C32.FromSuperJSON(e));
    }
  };
}
var EvalParams2;
{
  let GetInst = function(t) {
    return t instanceof IInstance ? runtime._UnwrapScriptInterface(t) : t.GetInstance();
  }, GetWorldInfo = function(t) {
    return GetInst(t).GetWorldInfo();
  }, GetInst_SDKv2 = function(t) {
    return runtime._UnwrapScriptInterface(t);
  }, GetWorldInfo_SDKv2 = function(t) {
    return GetInst_SDKv2(t).GetWorldInfo();
  }, GetObjectClass = function(t) {
    return t instanceof IObjectClass ? runtime._UnwrapScriptInterface(t) : t;
  }, GetLayer = function(t) {
    return t instanceof ILayer ? runtime._UnwrapScriptInterface(t) : t;
  }, CollMemory_Add = function(t, e, n, o) {
    e.GetUID() < n.GetUID() ? t.Set(e, n, o) : t.Set(n, e, o);
  }, CollMemory_Remove = function(t, e, n) {
    e.GetUID() < n.GetUID() ? t.Delete(e, n) : t.Delete(n, e);
  }, CollMemory_RemoveInstance = function(t, e) {
    t.DeleteEither(e);
  }, CollMemory_Get = function(t, e, n) {
    return e.GetUID() < n.GetUID() ? t.Get(e, n) : t.Get(n, e);
  }, DoOverlapCondition = function(t, e, n, o) {
    if (!e) return false;
    const s = 0 !== n || 0 !== o, i = t.GetWorldInfo(), r = runtime.GetCollisionEngine(), a = runtime.GetCurrentCondition(), l = a.GetEventBlock().IsOrBlock(), c = a.GetObjectClass(), u = a.IsInverted(), S = e.GetCurrentSol(), f = c !== e;
    let G;
    rPickType = e, needsCollisionFinish = f && !u, rPickFromElseInstances = false;
    let d = 0, I = 0, C = false;
    S.IsSelectAll() ? (tempRect.copy(i.GetBoundingBox()), tempRect.offset(n, o), r.GetCollisionCandidates(i.GetLayer(), e, tempRect, tempCandidates2), G = tempCandidates2) : l ? runtime.IsCurrentConditionFirst() && !S._GetOwnElseInstances().length && S._GetOwnInstances().length ? G = S._GetOwnInstances() : (G = S._GetOwnElseInstances(), rPickFromElseInstances = true) : G = S._GetOwnInstances(), s && (d = i.GetX(), I = i.GetY(), i.OffsetXY(n, o), i.SetBboxChanged());
    for (const e2 of G) if (r.TestOverlap(t, e2)) {
      if (C = true, u) break;
      f && rToPick.add(e2);
    }
    return s && (i.SetXY(d, I), i.SetBboxChanged()), C32.clearArray(tempCandidates2), C;
  }, FinishCollisionConditionPicking = function(t) {
    const e = runtime.GetCurrentEvent().IsOrBlock(), n = rPickType.GetCurrentSol(), o = n._GetOwnInstances(), s = n._GetOwnElseInstances();
    n.IsSelectAll() ? (n.SetSetPicked(rToPick), e && (C32.clearArray(s), n.AddElseInstances(rToPick, rPickType.GetInstances()))) : e ? rPickFromElseInstances ? n.TransferElseInstancesToOwn(rToPick) : (n.AddElseInstances(rToPick, o), n.SetSetPicked(rToPick)) : n.SetSetPicked(rToPick), rPickType.ApplySolToContainer();
  }, FinishCollisionCondition = function(t, e) {
    needsCollisionFinish && (e && FinishCollisionConditionPicking(t), rToPick.clear(), rPickType = null, needsCollisionFinish = false);
  }, PickByUID_Normal = function(t, e) {
    const n = runtime.GetInstanceByUID(e);
    if (!n) return false;
    const o = t.GetCurrentSol();
    if (!o.IsSelectAll() && !o._GetOwnInstances().includes(n)) return false;
    if (t.IsFamily()) {
      if (n.GetObjectClass().BelongsToFamily(t)) return o.PickOne(n), t.ApplySolToContainer(), true;
    } else if (n.GetObjectClass() === t) return o.PickOne(n), t.ApplySolToContainer(), true;
    return false;
  }, PickByUID_Inverted = function(t, e) {
    const n = t.GetCurrentSol();
    if (n.IsSelectAll()) {
      n._SetSelectAll(false), n.ClearArrays();
      const o = t.GetInstances();
      for (let t2 = 0, s = o.length; t2 < s; ++t2) {
        const s2 = o[t2];
        s2.GetUID() === e ? n._PushElseInstance(s2) : n._PushInstance(s2);
      }
      return t.ApplySolToContainer(), !!n._GetOwnInstances().length;
    }
    {
      const o = n._GetOwnInstances();
      let s = 0;
      for (let t2 = 0, i = o.length; t2 < i; ++t2) {
        const i2 = o[t2];
        o[s] = i2, i2.GetUID() === e ? n._PushElseInstance(i2) : ++s;
      }
      return C32.truncateArray(o, s), t.ApplySolToContainer(), !!o.length;
    }
  };
  GetInst2 = GetInst, GetWorldInfo2 = GetWorldInfo, GetInst_SDKv22 = GetInst_SDKv2, GetWorldInfo_SDKv22 = GetWorldInfo_SDKv2, GetObjectClass2 = GetObjectClass, GetLayer2 = GetLayer, CollMemory_Add2 = CollMemory_Add, CollMemory_Remove2 = CollMemory_Remove, CollMemory_RemoveInstance2 = CollMemory_RemoveInstance, CollMemory_Get2 = CollMemory_Get, DoOverlapCondition2 = DoOverlapCondition, FinishCollisionConditionPicking2 = FinishCollisionConditionPicking, FinishCollisionCondition2 = FinishCollisionCondition, PickByUID_Normal2 = PickByUID_Normal, PickByUID_Inverted2 = PickByUID_Inverted;
  const C32 = self.C3, tempColor = new C32.Color(), AnySDK = {}, SDKv1 = {}, SDKv2 = {};
  let runtime = null;
  C32.CommonACES_SetRuntime = function(t) {
    runtime = t;
  };
  const IInstance = self.IInstance, IObjectClass = self.IObjectClass, ILayer = self.ILayer;
  SDKv1.CompareX = function(t, e) {
    return C32.compare(this.GetWorldInfo().GetX(), t, e);
  }, SDKv2.CompareX = function(t, e) {
    return C32.compare(this.x, t, e);
  }, SDKv1.CompareY = function(t, e) {
    return C32.compare(this.GetWorldInfo().GetY(), t, e);
  }, SDKv2.CompareY = function(t, e) {
    return C32.compare(this.y, t, e);
  }, SDKv1.IsOnScreen = function() {
    return this.GetWorldInfo().IsInViewport2();
  }, SDKv2.IsOnScreen = function() {
    return this.isOnScreen();
  }, AnySDK.IsOutsideLayout = function() {
    const t = GetWorldInfo(this), e = t.GetLayout(), n = t.GetBoundingBox();
    return n.getRight() < 0 || n.getBottom() < 0 || n.getLeft() > e.GetWidth() || n.getTop() > e.GetHeight();
  }, AnySDK.PickDistance = function(t, e, n) {
    const o = GetObjectClass(this).GetCurrentSol(), s = o.GetInstances();
    if (!s.length) return false;
    let i = s[0], r = i.GetWorldInfo(), a = i, l = C32.distanceSquared(r.GetX(), r.GetY(), e, n);
    for (let o2 = 1, c = s.length; o2 < c; ++o2) {
      i = s[o2], r = i.GetWorldInfo();
      const c2 = C32.distanceSquared(r.GetX(), r.GetY(), e, n);
      (0 === t && c2 < l || 1 === t && c2 > l) && (l = c2, a = i);
    }
    return o.PickOne(a), true;
  }, SDKv1.SetX = function(t) {
    const e = this.GetWorldInfo();
    e.GetX() !== t && (e.SetX(t), e.SetBboxChanged());
  }, SDKv2.SetX = function(t) {
    this.x = +t;
  }, SDKv1.SetY = function(t) {
    const e = this.GetWorldInfo();
    e.GetY() !== t && (e.SetY(t), e.SetBboxChanged());
  }, SDKv2.SetY = function(t) {
    this.y = +t;
  }, SDKv1.SetPos = function(t, e) {
    const n = this.GetWorldInfo();
    n.EqualsXY(t, e) || (n.SetXY(t, e), n.SetBboxChanged());
  }, SDKv2.SetPos = function(t, e) {
    this.setPosition(t, e);
  }, AnySDK.SetPosToObject = function(t, e) {
    if (!(t = GetObjectClass(t))) return;
    const n = GetInst(this), o = t.GetPairedInstance(n);
    if (!o) return;
    const [s, i] = o.GetImagePoint(e), r = n.GetWorldInfo();
    r.GetX() === s && r.GetY() === i || (r.SetXY(s, i), r.SetBboxChanged());
  }, AnySDK.MoveForward = function(t) {
    if (0 === t) return;
    const e = GetWorldInfo(this);
    e.OffsetXY(e.GetCosAngle() * t, e.GetSinAngle() * t), e.SetBboxChanged();
  }, SDKv1.MoveAtAngle = function(t, e) {
    if (0 === e) return;
    const n = this.GetWorldInfo();
    t = C32.toRadians(t), n.OffsetXY(Math.cos(t) * e, Math.sin(t) * e), n.SetBboxChanged();
  }, SDKv2.MoveAtAngle = function(t, e) {
    0 !== e && (t = C32.toRadians(t), this.offsetPosition(Math.cos(t) * e, Math.sin(t) * e));
  }, SDKv1.GetX = function() {
    return this.GetWorldInfo().GetX();
  }, SDKv2.GetX = function() {
    return this.x;
  }, SDKv1.GetY = function() {
    return this.GetWorldInfo().GetY();
  }, SDKv2.GetY = function() {
    return this.y;
  }, AnySDK.GetDt = function() {
    return runtime.GetDt(GetInst(this));
  }, SDKv1.CompareWidth = function(t, e) {
    return C32.compare(this.GetWorldInfo().GetWidth(), t, e);
  }, SDKv2.CompareWidth = function(t, e) {
    return C32.compare(this.width, t, e);
  }, SDKv1.CompareHeight = function(t, e) {
    return C32.compare(this.GetWorldInfo().GetHeight(), t, e);
  }, SDKv2.CompareHeight = function(t, e) {
    return C32.compare(this.height, t, e);
  }, SDKv1.SetWidth = function(t) {
    const e = this.GetWorldInfo();
    e.GetWidth() !== t && (e.SetWidth(t), e.SetBboxChanged());
  }, SDKv2.SetWidth = function(t) {
    this.width = t;
  }, SDKv1.SetHeight = function(t) {
    const e = this.GetWorldInfo();
    e.GetHeight() !== t && (e.SetHeight(t), e.SetBboxChanged());
  }, SDKv2.SetHeight = function(t) {
    this.height = t;
  }, SDKv1.SetSize = function(t, e) {
    const n = GetWorldInfo(this);
    n.GetWidth() === t && n.GetHeight() === e || (n.SetSize(t, e), n.SetBboxChanged());
  }, SDKv2.SetSize = function(t, e) {
    this.setSize(t, e);
  }, SDKv1.GetWidth = function() {
    return this.GetWorldInfo().GetWidth();
  }, SDKv2.GetWidth = function() {
    return this.width;
  }, SDKv1.GetHeight = function() {
    return this.GetWorldInfo().GetHeight();
  }, SDKv2.GetHeight = function() {
    return this.height;
  }, AnySDK.GetBboxLeft = function() {
    return GetWorldInfo(this).GetBoundingBox().getLeft();
  }, AnySDK.GetBboxTop = function() {
    return GetWorldInfo(this).GetBoundingBox().getTop();
  }, AnySDK.GetBboxRight = function() {
    return GetWorldInfo(this).GetBoundingBox().getRight();
  }, AnySDK.GetBboxBottom = function() {
    return GetWorldInfo(this).GetBoundingBox().getBottom();
  }, AnySDK.GetBboxMidX = function() {
    const t = GetWorldInfo(this).GetBoundingBox();
    return (t.getLeft() + t.getRight()) / 2;
  }, AnySDK.GetBboxMidY = function() {
    const t = GetWorldInfo(this).GetBoundingBox();
    return (t.getTop() + t.getBottom()) / 2;
  }, AnySDK.IsAngleWithin = function(t, e) {
    return C32.angleDiff(GetWorldInfo(this).GetAngle(), C32.toRadians(e)) <= C32.toRadians(t);
  }, AnySDK.IsAngleClockwiseFrom = function(t) {
    return C32.angleClockwise(GetWorldInfo(this).GetAngle(), C32.toRadians(t));
  }, AnySDK.IsBetweenAngles = function(t, e) {
    const n = C32.toRadians(t), o = C32.toRadians(e), s = GetWorldInfo(this).GetAngle();
    return !C32.angleClockwise(o, n) ? !(!C32.angleClockwise(s, n) && C32.angleClockwise(s, o)) : C32.angleClockwise(s, n) && !C32.angleClockwise(s, o);
  }, SDKv1.SetAngle = function(t) {
    const e = this.GetWorldInfo(), n = C32.clampAngle(C32.toRadians(t));
    isNaN(n) || e.GetAngle() === n || (e.SetAngle(n), e.SetBboxChanged());
  }, SDKv2.SetAngle = function(t) {
    this.angleDegrees = t;
  }, AnySDK.RotateClockwise = function(t) {
    if (isNaN(t) || 0 === t) return;
    const e = GetWorldInfo(this);
    e.SetAngle(e.GetAngle() + C32.toRadians(t)), e.SetBboxChanged();
  }, AnySDK.RotateCounterclockwise = function(t) {
    if (isNaN(t) || 0 === t) return;
    const e = GetWorldInfo(this);
    e.SetAngle(e.GetAngle() - C32.toRadians(t)), e.SetBboxChanged();
  }, AnySDK.RotateTowardAngle = function(t, e) {
    const n = GetWorldInfo(this), o = n.GetAngle(), s = C32.angleRotate(o, C32.toRadians(e), C32.toRadians(t));
    isNaN(s) || o === s || (n.SetAngle(s), n.SetBboxChanged());
  }, AnySDK.RotateTowardPosition = function(t, e, n) {
    const o = GetWorldInfo(this), s = o.GetAngle(), i = e - o.GetX(), r = n - o.GetY(), a = Math.atan2(r, i), l = C32.angleRotate(s, a, C32.toRadians(t));
    isNaN(l) || s === l || (o.SetAngle(l), o.SetBboxChanged());
  }, AnySDK.SetTowardPosition = function(t, e) {
    const n = GetWorldInfo(this), o = n.GetAngle(), s = t - n.GetX(), i = e - n.GetY(), r = Math.atan2(i, s);
    isNaN(r) || o === r || (n.SetAngle(r), n.SetBboxChanged());
  }, SDKv1.GetAngle = function() {
    return C32.toDegrees(this.GetWorldInfo().GetAngle());
  }, SDKv2.GetAngle = function() {
    return this.angleDegrees;
  }, AnySDK.CompareOpacity = function(t, e) {
    return C32.compare(C32.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6), t, e);
  }, SDKv1.IsVisible = function() {
    return this.GetWorldInfo().IsVisible();
  }, SDKv2.IsVisible = function() {
    return this.isVisible;
  }, AnySDK.SetVisible = function(t) {
    const e = GetWorldInfo(this);
    t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && (e.SetVisible(t), runtime.UpdateRender());
  }, AnySDK.SetOpacity = function(t) {
    const e = C32.clamp(t / 100, 0, 1), n = GetWorldInfo(this);
    if (n.GetTransformWithParentOpacity()) {
      if (n._GetSceneGraphInfo().GetOwnOpacity() === e) return;
    } else if (n.GetOpacity() === e) return;
    n.SetOpacity(e), runtime.UpdateRender();
  }, AnySDK.SetDefaultColor = function(t) {
    tempColor.setFromRgbValue(t);
    const e = GetWorldInfo(this);
    e.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (e.SetUnpremultipliedColor(tempColor), runtime.UpdateRender());
  }, AnySDK.GetColor = function() {
    const t = GetWorldInfo(this).GetUnpremultipliedColor();
    return C32.PackRGBAEx(t.getR(), t.getG(), t.getB(), t.getA());
  }, AnySDK.GetOpacity = function() {
    return C32.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6);
  }, AnySDK.IsOnLayer = function(t) {
    return !!(t = GetLayer(t)) && GetWorldInfo(this).GetLayer() === t;
  }, AnySDK.PickTopBottom = function(t) {
    const e = GetObjectClass(this).GetCurrentSol(), n = e.GetInstances();
    if (!n.length) return false;
    let o = n[0];
    for (let e2 = 1, s = n.length; e2 < s; ++e2) {
      const s2 = n[e2], i = s2.GetWorldInfo(), r = o.GetWorldInfo(), a = i.GetLayer().GetIndex(), l = r.GetLayer().GetIndex();
      0 === t ? (a > l || a === l && i.GetZIndex() > r.GetZIndex()) && (o = s2) : (a < l || a === l && i.GetZIndex() < r.GetZIndex()) && (o = s2);
    }
    return e.PickOne(o), true;
  }, SDKv1.CompareZElevation = function(t, e, n) {
    const o = this.GetWorldInfo(), s = 0 === t ? o.GetZElevation() : o.GetTotalZElevation();
    return C32.compare(s, e, n);
  }, SDKv2.CompareZElevation = function(t, e, n) {
    const o = 0 === t ? this.zElevation : this.totalZElevation;
    return C32.compare(o, e, n);
  }, SDKv1.MoveToTop = function() {
    this.GetWorldInfo().ZOrderMoveToTop();
  }, SDKv2.MoveToTop = function() {
    this.moveToTop();
  }, SDKv1.MoveToBottom = function() {
    this.GetWorldInfo().ZOrderMoveToBottom();
  }, SDKv2.MoveToBottom = function() {
    this.moveToBottom();
  }, AnySDK.MoveToLayer = function(t) {
    (t = GetLayer(t)) && GetWorldInfo(this).ZOrderMoveToLayer(t);
  }, AnySDK.ZMoveToObject = function(t, e) {
    const n = 0 === t;
    if (!(e = GetObjectClass(e))) return;
    const o = GetInst(this), s = e.GetFirstPicked(o);
    s && o.GetWorldInfo().ZOrderMoveAdjacentToInstance(s, n);
  }, SDKv1.SetZElevation = function(t) {
    const e = this.GetWorldInfo();
    e.GetZElevation() !== t && (e.SetZElevation(t), runtime.UpdateRender());
  }, SDKv2.SetZElevation = function(t) {
    this.zElevation = t;
  }, AnySDK.LayerNumber = function() {
    return GetWorldInfo(this).GetLayer().GetIndex();
  }, AnySDK.LayerName = function() {
    return GetWorldInfo(this).GetLayer().GetName();
  }, SDKv1.ZIndex = function() {
    return this.GetWorldInfo().GetZIndex();
  }, SDKv2.ZIndex = function() {
    return this.zIndex;
  }, SDKv1.ZElevation = function() {
    return this.GetWorldInfo().GetZElevation();
  }, SDKv2.ZElevation = function() {
    return this.zElevation;
  }, SDKv1.TotalZElevation = function() {
    return this.GetWorldInfo().GetTotalZElevation();
  }, SDKv2.TotalZElevation = function() {
    return this.totalZElevation;
  }, AnySDK.IsEffectEnabled = function(t) {
    const e = GetInst(this), n = e.GetObjectClass().GetEffectList().GetEffectTypeByName(t);
    if (!n) return;
    const o = n.GetIndex();
    return e.GetWorldInfo().GetInstanceEffectList().IsEffectIndexActive(o);
  }, AnySDK.SetEffectEnabled = function(t, e) {
    const n = GetInst(this), o = n.GetObjectClass().GetEffectList().GetEffectTypeByName(e);
    if (!o) return;
    const s = o.GetIndex(), i = 1 === t, r = n.GetWorldInfo().GetInstanceEffectList();
    r.IsEffectIndexActive(s) !== i && (r.SetEffectIndexActive(s, i), r.UpdateActiveEffects(), runtime.UpdateRender());
  }, AnySDK.SetEffectParam = function(t, e, n) {
    const o = GetInst(this), s = o.GetObjectClass().GetEffectList().GetEffectTypeByName(t);
    if (!s) return;
    e = Math.floor(e);
    const i = s.GetShaderProgram().GetParameterType(e);
    if (!i) return;
    "color" === i ? (tempColor.setFromRgbValue(n), n = tempColor) : "percent" === i && (n /= 100);
    const r = s.GetIndex(), a = o.GetWorldInfo().GetInstanceEffectList();
    a.SetEffectParameter(r, e, n) && a.IsEffectIndexActive(r) && runtime.UpdateRender();
  };
  const tempRect = C32.New(C32.Rect), tempCandidates1 = [], tempCandidates2 = [];
  let needsCollisionFinish = false, rPickType = null, rPickFromElseInstances = false;
  const rToPick = /* @__PURE__ */ new Set();
  function* DebugOnCollision(t) {
    if (!t) return false;
    const e = this.GetRuntime(), n = e.GetCollisionEngine(), o = e.GetEventSheetManager(), s = o.GetEventStack(), i = o.GetCurrentCondition(), r = i.GetObjectClass(), a = i.GetSavedDataMap(), l = i.GetUnsavedDataMap(), c = s.GetCurrentStackFrame(), u = e.GetTickCount(), S = u - 1, f = c.GetCurrentEvent(), G = s.Push(f);
    let d = a.get("collmemory");
    d || (d = C32.New(C32.PairMap), a.set("collmemory", d)), l.get("collisionCreatedDestroyCallback") || (l.set("collisionCreatedDestroyCallback", true), e.Dispatcher().addEventListener("instancedestroy", (t2) => CollMemory_RemoveInstance(d, t2.instance)));
    const I = r.GetCurrentSol(), C = t.GetCurrentSol(), h = I.GetInstances();
    let m = null;
    for (let e2 = 0; e2 < h.length; ++e2) {
      const s2 = h[e2];
      C.IsSelectAll() ? (n.GetCollisionCandidates(s2.GetWorldInfo().GetLayer(), t, s2.GetWorldInfo().GetBoundingBox(), tempCandidates1), m = tempCandidates1, n.AddRegisteredCollisionCandidates(s2, t, m)) : m = C.GetInstances();
      for (let e3 = 0; e3 < m.length; ++e3) {
        const i2 = m[e3];
        if (n.TestOverlap(s2, i2) || n.CheckRegisteredCollision(s2, i2)) {
          const e4 = CollMemory_Get(d, s2, i2);
          let n2 = false, a2 = -2;
          "number" == typeof e4 && (n2 = true, a2 = e4);
          const l2 = !n2 || a2 < S;
          if (CollMemory_Add(d, s2, i2, u), l2) {
            const e5 = f.GetSolModifiers();
            o.PushCopySol(e5);
            const n3 = r.GetCurrentSol(), a3 = t.GetCurrentSol();
            if (n3._SetSelectAll(false), a3._SetSelectAll(false), r === t) {
              const t2 = n3._GetOwnInstances();
              C32.clearArray(t2), t2.push(s2), t2.push(i2), r.ApplySolToContainer();
            } else {
              const e6 = n3._GetOwnInstances(), o2 = a3._GetOwnInstances();
              C32.clearArray(e6), C32.clearArray(o2), e6.push(s2), o2.push(i2), r.ApplySolToContainer(), t.ApplySolToContainer();
            }
            yield* f.DebugRetrigger(c, G), o.PopSol(e5);
          }
        } else CollMemory_Remove(d, s2, i2);
      }
      C32.clearArray(tempCandidates1);
    }
    return s.Pop(), false;
  }
  AnySDK.OnCollision = function(t) {
    const e = GetObjectClass(this);
    t = GetObjectClass(t);
    const n = e.GetRuntime();
    if (n.IsDebugging()) return DebugOnCollision.call(e, t);
    if (!t) return false;
    const o = n.GetCollisionEngine(), s = n.GetEventSheetManager(), i = s.GetEventStack(), r = s.GetCurrentCondition(), a = r.GetObjectClass(), l = r.GetSavedDataMap(), c = r.GetUnsavedDataMap(), u = i.GetCurrentStackFrame(), S = n.GetTickCount(), f = S - 1, G = u.GetCurrentEvent(), d = i.Push(G);
    let I = l.get("collmemory");
    I || (I = C32.New(C32.PairMap), l.set("collmemory", I)), c.get("collisionCreatedDestroyCallback") || (c.set("collisionCreatedDestroyCallback", true), n.Dispatcher().addEventListener("instancedestroy", (t2) => CollMemory_RemoveInstance(I, t2.instance)));
    const C = a.GetCurrentSol(), h = t.GetCurrentSol(), m = C.GetInstances();
    let g = null;
    for (let e2 = 0; e2 < m.length; ++e2) {
      const n2 = m[e2];
      h.IsSelectAll() ? (o.GetCollisionCandidates(n2.GetWorldInfo().GetLayer(), t, n2.GetWorldInfo().GetBoundingBox(), tempCandidates1), g = tempCandidates1, o.AddRegisteredCollisionCandidates(n2, t, g)) : g = h.GetInstances();
      for (let e3 = 0; e3 < g.length; ++e3) {
        const i2 = g[e3];
        if (o.TestOverlap(n2, i2) || o.CheckRegisteredCollision(n2, i2)) {
          const e4 = CollMemory_Get(I, n2, i2);
          let o2 = false, r2 = -2;
          "number" == typeof e4 && (o2 = true, r2 = e4);
          const l2 = !o2 || r2 < f;
          if (CollMemory_Add(I, n2, i2, S), l2) {
            const e5 = G.GetSolModifiers();
            s.PushCopySol(e5);
            const o3 = a.GetCurrentSol(), r3 = t.GetCurrentSol();
            if (o3._SetSelectAll(false), r3._SetSelectAll(false), a === t) {
              const t2 = o3._GetOwnInstances();
              C32.clearArray(t2), t2.push(n2), t2.push(i2), a.ApplySolToContainer();
            } else {
              const e6 = o3._GetOwnInstances(), s2 = r3._GetOwnInstances();
              C32.clearArray(e6), C32.clearArray(s2), e6.push(n2), s2.push(i2), a.ApplySolToContainer(), t.ApplySolToContainer();
            }
            G.Retrigger(u, d), s.PopSol(e5);
          }
        } else CollMemory_Remove(I, n2, i2);
      }
      C32.clearArray(tempCandidates1);
    }
    return i.Pop(), false;
  }, AnySDK.IsOverlapping = function(t) {
    return t = GetObjectClass(t), DoOverlapCondition(GetInst(this), t, 0, 0);
  }, AnySDK.IsOverlappingOffset = function(t, e, n) {
    return t = GetObjectClass(t), DoOverlapCondition(GetInst(this), t, e, n);
  }, AnySDK.OnHierarchyReady = function() {
    return true;
  }, AnySDK.HasParent = function() {
    return GetWorldInfo(this).HasParent();
  }, AnySDK.HasChildren = function() {
    return GetWorldInfo(this).HasChildren();
  }, AnySDK.PickParent = function(t, e) {
    const n = GetObjectClass(this);
    t = GetObjectClass(t);
    const o = n.GetRuntime(), s = this.GetCurrentSol().GetInstances();
    if (0 === s.length) return false;
    const i = t.GetCurrentSol();
    let r = i.GetInstances();
    if (i.IsSelectAll()) {
      const e2 = [...o.instancesPendingCreateForObjectClass(t)];
      e2.length > 0 && (r = r.concat(e2));
    }
    if (0 === r.length) return false;
    const a = i.IsSelectAll() ? null : new Set(r), l = /* @__PURE__ */ new Set();
    for (let n2 = 0, o2 = s.length; n2 < o2; ++n2) {
      const o3 = s[n2];
      if (1 === e) for (const e2 of o3.parents()) e2.BelongsToObjectClass(t) && (null === a || a.has(e2)) && l.add(e2);
      else {
        let n3;
        if (0 === e) {
          if (n3 = o3.GetParent(), null === n3) continue;
        } else n3 = o3.GetTopParent();
        n3.BelongsToObjectClass(t) && (null === a || a.has(n3)) && l.add(n3);
      }
    }
    return 0 !== l.size && (i.SetSetPicked(l), t.ApplySolToContainer(), true);
  }, AnySDK.PickChildren = function(t, e) {
    const n = GetObjectClass(this);
    t = GetObjectClass(t);
    const o = n.GetRuntime(), s = n.GetCurrentSol().GetInstances();
    if (0 === s.length) return false;
    const i = t.GetCurrentSol();
    let r = i.GetInstances();
    if (i.IsSelectAll()) {
      const e2 = [...o.instancesPendingCreateForObjectClass(t)];
      e2.length > 0 && (r = r.concat(e2));
    }
    if (0 === r.length) return false;
    const a = i.IsSelectAll() ? null : new Set(r), l = /* @__PURE__ */ new Set();
    for (let n2 = 0, o2 = s.length; n2 < o2; ++n2) {
      const o3 = s[n2];
      2 !== e || o3.HasChildren() || !o3.BelongsToObjectClass(t) || null !== a && !a.has(o3) || l.add(o3);
      for (const n3 of 0 === e ? o3.children() : o3.allChildren()) 2 === e && n3.HasChildren() || n3.BelongsToObjectClass(t) && (null === a || a.has(n3)) && l.add(n3);
    }
    return 0 !== l.size && (i.SetSetPicked(l), t.ApplySolToContainer(), true);
  }, AnySDK.PickNthChild = function(t, e, n) {
    const o = GetObjectClass(this);
    t = GetObjectClass(t);
    const s = o.GetRuntime(), i = o.GetCurrentSol().GetInstances();
    if (0 === i.length) return false;
    const r = t.GetCurrentSol();
    let a = r.GetInstances();
    if (r.IsSelectAll()) {
      const e2 = [...s.instancesPendingCreateForObjectClass(t)];
      e2.length > 0 && (a = a.concat(e2));
    }
    if (0 === a.length) return false;
    const l = r.IsSelectAll() ? null : new Set(a), c = [];
    for (let o2 = 0, s2 = i.length; o2 < s2; ++o2) {
      const s3 = i[o2];
      if (0 === e) {
        const e2 = s3.GetChildAt(n);
        null !== e2 && e2.BelongsToObjectClass(t) && (null === l || l.has(e2)) && c.push(e2);
      } else if (1 === e) {
        for (const e2 of s3.children()) if (e2.BelongsToObjectClass(t)) {
          if (0 === n) {
            (null === l || l.has(e2)) && c.push(e2);
            break;
          }
          --n;
        }
      }
    }
    return 0 !== c.length && (r.SetArrayPicked(c), t.ApplySolToContainer(), true);
  }, AnySDK.CompareChildCount = function(t, e, n) {
    const o = GetInst(this);
    switch (t) {
      case 0:
      default:
        return C32.compare(o.GetChildCount(), e, n);
      case 1:
        return C32.compare(o.GetAllChildCount(), e, n);
    }
  }, AnySDK.AddChild = function(t, e, n, o, s, i, r, a, l, c) {
    t = GetObjectClass(t);
    const u = GetInst(this), S = runtime.GetCurrentAction().GetObjectClass();
    for (const f of t.allCorrespondingInstances(u, S)) {
      if (!f.GetPlugin().SupportsSceneGraph()) return;
      u.AddChild(f, { transformX: e, transformY: n, transformWidth: o, transformHeight: s, transformAngle: i, transformOpacity: r, transformZElevation: a, transformVisibility: l, destroyWithParent: c });
    }
  }, AnySDK.RemoveChild = function(t) {
    t = GetObjectClass(t);
    const e = GetInst(this), n = runtime.GetCurrentAction().GetObjectClass();
    for (const o of t.allCorrespondingInstances(e, n)) e.RemoveChild(o);
  }, AnySDK.RemoveFromParent = function() {
    const t = GetInst(this);
    if (!t.HasParent()) return;
    t.GetParent().RemoveChild(t);
  }, AnySDK.ParentUID = function() {
    const t = GetInst(this).GetParent();
    return t ? t.GetUID() : -1;
  }, AnySDK.ChildCount = function() {
    return GetInst(this).GetChildCount();
  }, AnySDK.AllChildCount = function() {
    return GetInst(this).GetAllChildCount();
  }, AnySDK.SetMeshSize = function(t, e) {
    t = Math.floor(t), e = Math.floor(e);
    const n = GetWorldInfo(this);
    t < 2 || e < 2 || !isFinite(t) || !isFinite(e) ? (n.ReleaseMesh(), n.SetBboxChanged()) : n.CreateMesh(t, e);
  }, AnySDK.SetMeshPoint = function(t, e, n, o, s, i, r, a) {
    const l = GetWorldInfo(this);
    l.SetMeshPoint(t, e, { mode: 0 === n ? "absolute" : "relative", x: o, y: s, zElevation: i, u: r, v: a }) && l.SetBboxChanged();
  }, AnySDK.MeshColumns = function() {
    const t = GetWorldInfo(this);
    return t.HasMesh() ? t.GetSourceMesh().GetHSize() : 0;
  }, AnySDK.MeshRows = function() {
    const t = GetWorldInfo(this);
    return t.HasMesh() ? t.GetSourceMesh().GetVSize() : 0;
  }, AnySDK.SetElementVisible = function(t) {
    const e = GetWorldInfo(this);
    t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && e.SetVisible(t);
  }, AnySDK.SetElementCSSStyle = function(t, e) {
    this instanceof self.IInstance ? this.setElementCSSStyle(t, e) : this.SetElementCSSStyle(t, e);
  }, AnySDK.SetElementAttribute = function(t, e) {
    this instanceof self.IInstance ? this.setElementAttribute(t, "" + e) : this.SetElementAttribute(t, "" + e);
  }, AnySDK.RemoveElementAttribute = function(t) {
    this instanceof self.IInstance ? this.removeElementAttribute(t) : this.RemoveElementAttribute(t);
  }, AnySDK.SetElementFocus = function() {
    this instanceof self.IInstance ? this.focusElement() : this.FocusElement();
  }, AnySDK.SetElementBlur = function() {
    this instanceof self.IInstance ? this.blurElement() : this.BlurElement();
  }, AnySDK.IsElementFocused = function() {
    return this instanceof self.IInstance ? this.isElementFocused() : this.IsElementFocused();
  }, AnySDK.SetElementEnabled = function(t) {
    this instanceof self.IInstance ? this._setEnabled(0 !== t) : this._SetEnabled(0 !== t);
  }, AnySDK.IsElementEnabled = function() {
    return this instanceof self.IInstance ? this._isEnabled() : this._IsEnabled();
  }, SDKv1.CompareInstanceVar = function(t, e, n) {
    return C32.compare(this.GetInstance().GetInstanceVariableValue(t), e, n);
  }, SDKv2.CompareInstanceVar = function(t, e, n) {
    return C32.compare(GetInst_SDKv2(this).GetInstanceVariableValue(t), e, n);
  }, SDKv1.IsBoolInstanceVarSet = function(t) {
    return !!this.GetInstance().GetInstanceVariableValue(t);
  }, SDKv2.IsBoolInstanceVarSet = function(t) {
    return !!GetInst_SDKv2(this).GetInstanceVariableValue(t);
  }, AnySDK.PickInstVarHiLow = function(t, e) {
    const n = GetObjectClass(this), o = n.GetCurrentSol(), s = o.GetInstances();
    if (!s.length) return false;
    const i = n.IsFamily();
    let r = null, a = 0;
    for (let o2 = 0, l = s.length; o2 < l; ++o2) {
      const l2 = s[o2], c = i ? l2.GetObjectClass().GetFamilyInstanceVariableOffset(n.GetFamilyIndex()) : 0, u = l2.GetInstanceVariableValue(c + e);
      (null === r || 0 === t && u < a || 1 === t && u > a) && (a = u, r = l2);
    }
    return o.PickOne(r), true;
  }, AnySDK.PickByUID = function(t) {
    const e = GetObjectClass(this);
    return e.GetRuntime().GetCurrentCondition().IsInverted() ? PickByUID_Inverted(e, t) : PickByUID_Normal(e, t);
  }, AnySDK.HasTags = function(t) {
    const e = GetInst(this);
    if (t.includes(" ")) {
      return new Set(C32.splitStringAndNormalize(t.toLowerCase())).isSubsetOf(e.GetLowercaseTagsSet());
    }
    return !t || e.HasTag(t);
  }, AnySDK.Tags = function() {
    return GetInst(this).GetTagsString();
  }, AnySDK.TagsCount = function() {
    return GetInst(this).GetTagsSet().size;
  }, AnySDK.TagAt = function(t) {
    return GetInst(this).GetTagAt(t);
  }, AnySDK.ChangeTags = function(t, e) {
    const n = C32.splitStringAndNormalize(e), o = GetInst(this);
    if (2 === t) return void o.SetTagsSet(new Set(n));
    if (0 === n.length) return;
    const s = new Set(o.GetTagsSet());
    if (0 === t) for (const t2 of n) s.add(t2);
    else if (1 === t) for (const t2 of n) {
      if (!s.delete(t2)) {
        const e2 = t2.toLowerCase();
        for (const t3 of s) if (t3.toLowerCase() === e2) {
          s.delete(t3);
          break;
        }
      }
    }
    o.SetTagsSet(s);
  }, AnySDK.Destroy = function() {
    runtime.DestroyInstance(GetInst(this));
  }, AnySDK.OnCreated = function() {
    return true;
  }, AnySDK.OnDestroyed = function() {
    return true;
  }, SDKv1.SetInstanceVar = function(t, e) {
    this.GetInstance().SetInstanceVariableValue(t, e);
  }, SDKv2.SetInstanceVar = function(t, e) {
    GetInst_SDKv2(this).SetInstanceVariableValue(t, e);
  }, SDKv1.AddInstanceVar = function(t, e) {
    const n = this.GetInstance(), o = n.GetInstanceVariableValue(t);
    "number" == typeof o && "number" != typeof e ? e = parseFloat(e) : "string" == typeof o && "string" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o + e);
  }, SDKv2.AddInstanceVar = function(t, e) {
    const n = GetInst_SDKv2(this), o = n.GetInstanceVariableValue(t);
    "number" == typeof o && "number" != typeof e ? e = parseFloat(e) : "string" == typeof o && "string" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o + e);
  }, SDKv1.SubInstanceVar = function(t, e) {
    const n = this.GetInstance(), o = n.GetInstanceVariableValue(t);
    "number" == typeof o && ("number" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o - e));
  }, SDKv2.SubInstanceVar = function(t, e) {
    const n = GetInst_SDKv2(this), o = n.GetInstanceVariableValue(t);
    "number" == typeof o && ("number" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o - e));
  }, SDKv1.SetBoolInstanceVar = function(t, e) {
    this.GetInstance().SetInstanceVariableValue(t, e ? 1 : 0);
  }, SDKv2.SetBoolInstanceVar = function(t, e) {
    GetInst_SDKv2(this).SetInstanceVariableValue(t, e ? 1 : 0);
  }, SDKv1.ToggleBoolInstanceVar = function(t) {
    const e = this.GetInstance();
    e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);
  }, SDKv2.ToggleBoolInstanceVar = function(t) {
    const e = GetInst_SDKv2(this);
    e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);
  }, AnySDK.LoadFromJsonString = function(t) {
    let e;
    try {
      e = JSON.parse(t);
    } catch (t2) {
      return void console.error("Failed to load from JSON string: ", t2);
    }
    const n = GetInst(this), o = "state";
    runtime.ClearIntancesNeedingAfterLoad(), n._OnBeforeLoad(o), n.LoadFromJson(e, o), runtime.DoAfterLoad(o, { setFromJson: true });
  }, AnySDK.AsJSON = function() {
    return JSON.stringify(GetInst(this).SaveToJson("state"));
  }, AnySDK.ObjectTypeName = function() {
    return GetInst(this).GetObjectClass().GetName();
  }, AnySDK.Count = function() {
    const t = runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
    let e = t.GetInstanceCount();
    for (const n of runtime.instancesPendingCreateForObjectClass(t)) ++e;
    return e;
  }, AnySDK.PickedCount = function() {
    return runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length;
  }, SDKv1.GetIID = function() {
    return this.GetInstance().GetIID();
  }, SDKv2.GetIID = function() {
    return GetInst_SDKv2(this).GetIID();
  }, SDKv1.GetUID = function() {
    return this.GetInstance().GetUID();
  }, SDKv2.GetUID = function() {
    return GetInst_SDKv2(this).GetUID();
  }, AnySDK.OnInstanceSignal = function(t) {
    const e = GetInst(this);
    return t.toLowerCase() === runtime.GetEventSheetManager().GetCurrentInstanceSignalTag(e);
  }, AnySDK.InstanceSignal = function(t) {
    const e = GetInst(this);
    runtime.GetEventSheetManager().InstanceSignal(e, t);
  }, AnySDK.InstanceWaitForSignal = function(t) {
    const e = GetObjectClass(this);
    return runtime.GetEventSheetManager().AddScheduledWait().InitInstanceSignals(e.GetCurrentSol().GetInstances(), t), true;
  }, AnySDK.TemplateName = function() {
    return GetInst(this).GetTemplateName();
  }, C32.AddCommonACEs = function(t, e, n) {
    const o = t[1], s = t[3], i = t[4], r = t[5], a = t[6], l = t[7], c = t[8], u = t[10], S = t[11], f = t[12], G = t[13], d = t[14], I = t[15], C = t[16], h = e.Cnds, m = e.Acts, g = e.Exps, y = Object.assign({}, AnySDK, n >= 2 ? SDKv2 : SDKv1);
    s && (h.CompareX = y.CompareX, h.CompareY = y.CompareY, h.IsOnScreen = y.IsOnScreen, h.IsOutsideLayout = y.IsOutsideLayout, h.PickDistance = y.PickDistance, m.SetX = y.SetX, m.SetY = y.SetY, m.SetPos = y.SetPos, m.SetPosToObject = y.SetPosToObject, m.MoveForward = y.MoveForward, m.MoveAtAngle = y.MoveAtAngle, g.X = y.GetX, g.Y = y.GetY, g.dt = y.GetDt), i && (h.CompareWidth = y.CompareWidth, h.CompareHeight = y.CompareHeight, m.SetWidth = y.SetWidth, m.SetHeight = y.SetHeight, m.SetSize = y.SetSize, g.Width = y.GetWidth, g.Height = y.GetHeight, g.BBoxLeft = y.GetBboxLeft, g.BBoxTop = y.GetBboxTop, g.BBoxRight = y.GetBboxRight, g.BBoxBottom = y.GetBboxBottom, g.BBoxMidX = y.GetBboxMidX, g.BBoxMidY = y.GetBboxMidY), r && (h.AngleWithin = y.IsAngleWithin, h.IsClockwiseFrom = y.IsAngleClockwiseFrom, h.IsBetweenAngles = y.IsBetweenAngles, m.SetAngle = y.SetAngle, m.RotateClockwise = y.RotateClockwise, m.RotateCounterclockwise = y.RotateCounterclockwise, m.RotateTowardAngle = y.RotateTowardAngle, m.RotateTowardPosition = y.RotateTowardPosition, m.SetTowardPosition = y.SetTowardPosition, g.Angle = y.GetAngle), a && (h.IsVisible = y.IsVisible, h.CompareOpacity = y.CompareOpacity, m.SetVisible = y.SetVisible, m.SetOpacity = y.SetOpacity, m.SetDefaultColor = y.SetDefaultColor, g.Opacity = y.GetOpacity, g.ColorValue = y.GetColor), l && (h.IsOnLayer = y.IsOnLayer, h.PickTopBottom = y.PickTopBottom, h.CompareZElevation = y.CompareZElevation, m.MoveToTop = y.MoveToTop, m.MoveToBottom = y.MoveToBottom, m.MoveToLayer = y.MoveToLayer, m.ZMoveToObject = y.ZMoveToObject, m.SetZElevation = y.SetZElevation, g.LayerNumber = y.LayerNumber, g.LayerName = y.LayerName, g.ZIndex = y.ZIndex, g.ZElevation = y.ZElevation, g.TotalZElevation = y.TotalZElevation), c && (h.IsEffectEnabled = y.IsEffectEnabled, m.SetEffectEnabled = y.SetEffectEnabled, m.SetEffectParam = y.SetEffectParam), G && (h.OnHierarchyReady = y.OnHierarchyReady, h.HasParent = y.HasParent, h.HasChildren = y.HasChildren, h.PickParent = y.PickParent, h.PickChildren = y.PickChildren, h.PickNthChild = y.PickNthChild, h.CompareChildCount = y.CompareChildCount, m.AddChild = y.AddChild, m.RemoveChild = y.RemoveChild, m.RemoveFromParent = y.RemoveFromParent, g.ParentUID = y.ParentUID, g.ChildCount = y.ChildCount, g.AllChildCount = y.AllChildCount), d && (m.SetMeshSize = y.SetMeshSize, m.SetMeshPoint = y.SetMeshPoint, g.MeshColumns = y.MeshColumns, g.MeshRows = y.MeshRows), u && (h.IsVisible = y.IsVisible, m.SetVisible = y.SetElementVisible, m.SetCSSStyle = y.SetElementCSSStyle, m.SetElemAttribute = y.SetElementAttribute, m.RemoveElemAttribute = y.RemoveElementAttribute), S && (h.IsFocused = y.IsElementFocused, m.SetFocus = y.SetElementFocus, m.SetBlur = y.SetElementBlur), f && (h.IsEnabled = y.IsElementEnabled, m.SetEnabled = y.SetElementEnabled), I && (h.OnCollision = y.OnCollision, h.IsOverlapping = y.IsOverlapping, h.IsOverlappingOffset = y.IsOverlappingOffset, e.FinishCollisionCondition = FinishCollisionCondition), o || (h.CompareInstanceVar = y.CompareInstanceVar, h.IsBoolInstanceVarSet = y.IsBoolInstanceVarSet, h.PickInstVarHiLow = y.PickInstVarHiLow, h.PickByUID = y.PickByUID, h.HasTags = y.HasTags, m.SetInstanceVar = y.SetInstanceVar, m.AddInstanceVar = y.AddInstanceVar, m.SubInstanceVar = y.SubInstanceVar, m.SetBoolInstanceVar = y.SetBoolInstanceVar, m.ToggleBoolInstanceVar = y.ToggleBoolInstanceVar, m.ChangeTags = y.ChangeTags, h.OnCreated = y.OnCreated, h.OnDestroyed = y.OnDestroyed, m.Destroy = y.Destroy, m.LoadFromJsonString || (m.LoadFromJsonString = y.LoadFromJsonString), g.AsJSON || (g.AsJSON = y.AsJSON), g.Count = y.Count, g.PickedCount = y.PickedCount, g.IID = y.GetIID, g.UID = y.GetUID, g.ObjectTypeName = y.ObjectTypeName, g.Tags = y.Tags, g.TagsCount = y.TagsCount, g.TagAt = y.TagAt, h.OnInstanceSignal = y.OnInstanceSignal, m.InstanceSignal = y.InstanceSignal, m.InstanceWaitForSignal = y.InstanceWaitForSignal), C && (g.TemplateName = y.TemplateName);
  };
}
var GetInst2;
var GetWorldInfo2;
var GetInst_SDKv22;
var GetWorldInfo_SDKv22;
var GetObjectClass2;
var GetLayer2;
var CollMemory_Add2;
var CollMemory_Remove2;
var CollMemory_RemoveInstance2;
var CollMemory_Get2;
var DoOverlapCondition2;
var FinishCollisionConditionPicking2;
var FinishCollisionCondition2;
var PickByUID_Normal2;
var PickByUID_Inverted2;
{
  const C32 = self.C3;
  C32.ScheduledWait = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._eventSheetManager = t, this._type = "", this._time = -1, this._signalTag = "", this._isSignalled = false, this._event = null, this._actIndex = 0, this._solModifiers = [], this._dynamicSolModifiers = null, this._sols = /* @__PURE__ */ new Map(), this._pendingInstances = null, this._callingFunctionBlock = null, this._asyncId = -1, this._functionParameters = null, this._functionInnerLocalVars = null, this._shouldRelease = false;
    }
    Release() {
      this._type = "", this._time = -1, this._signalTag = "", this._event = null, this._callingFunctionBlock = null, this._functionParameters = null, this._functionInnerLocalVars = null, this._asyncId = -1, C32.clearArray(this._solModifiers), this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(), this._dynamicSolModifiers = null);
      for (const t of this._sols.values()) t.Release();
      this._sols.clear(), this._pendingInstances = null;
    }
    _Init() {
      const t = this._eventSheetManager, e = t.GetRuntime().GetAllObjectClasses(), s = t.GetCurrentEventStackFrame();
      this._event = s.GetCurrentEvent(), this._actIndex = s.GetActionIndex() + 1;
      const i = t.FindFirstFunctionBlockParent(this._event);
      i && (this._callingFunctionBlock = i, this._functionParameters = i.CaptureFunctionParameters(), this._functionInnerLocalVars = i._GetAllInnerLocalVariables().map((t2) => t2.GetValue()), i.IsAsync() && (this._asyncId = i.PauseCurrentAsyncFunction()));
      for (const t2 of e) {
        const e2 = t2.GetCurrentSol();
        e2.IsSelectAll() && !this._event.HasSolModifier(t2) || (this._solModifiers.push(t2), this._sols.set(t2, C32.New(C32.SolState, e2)));
      }
      const n = t.GetDynamicSolModifiersSet();
      this._dynamicSolModifiers = n.size > 0 ? n : null;
    }
    InitTimer(t) {
      this._type = "timer", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetGameTime() + t;
    }
    InitWallTimer(t) {
      this._type = "walltimer", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetWallTime() + t;
    }
    InitSignal(t) {
      this._type = "signal", this._Init(), this._signalTag = t.toLowerCase();
    }
    InitInstanceSignals(t, e) {
      this._type = "instance-signals", this._Init(), this._signalTag = e.toLowerCase(), this._pendingInstances = new Set(t);
    }
    InitPromise(t) {
      this._type = "promise", this._Init(), t.then(() => this.SetSignalled()).catch((t2) => {
        console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", t2), this.SetSignalled();
      });
    }
    IsTimer() {
      return "timer" === this._type;
    }
    IsWallTimer() {
      return "walltimer" === this._type;
    }
    IsSignal() {
      return "signal" === this._type;
    }
    IsInstanceSignals() {
      return "instance-signals" === this._type;
    }
    IsPromise() {
      return "promise" === this._type;
    }
    GetSignalTag() {
      return this._signalTag;
    }
    IsSignalled() {
      return this._isSignalled;
    }
    SetSignalled() {
      this._isSignalled = true;
    }
    SetInstanceSignalled(t) {
      this._pendingInstances.delete(t), 0 === this._pendingInstances.size && this.SetSignalled();
    }
    _ShouldRun() {
      return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsWallTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetWallTime() : this.IsSignalled();
    }
    _RestoreState(t) {
      t._Restore(this._event, this._actIndex);
      for (const [t2, e2] of this._sols.entries()) {
        const s = t2.GetCurrentSol();
        e2._Restore(s);
      }
      this._dynamicSolModifiers && t.SetDynamicSolModifiers([...this._dynamicSolModifiers]);
      const e = this._callingFunctionBlock;
      e && (e.SetFunctionParameters(this._functionParameters), e._GetAllInnerLocalVariables().map((t2, e2) => t2.SetValue(this._functionInnerLocalVars[e2])), e.IsAsync() && e.ResumeAsyncFunction(this._asyncId));
    }
    _Run(t) {
      this._RestoreState(t), this._event._ResumeActionsAndSubEvents(t), this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;
    }
    async _DebugRun(t) {
      this._RestoreState(t);
      for (const e of this._event._DebugResumeActionsAndSubEvents(t)) await this._eventSheetManager.GetRuntime().DebugBreak(e);
      this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;
    }
    ShouldRelease() {
      return this._shouldRelease;
    }
    RemoveInstances(t) {
      for (const e of this._sols.values()) e.RemoveInstances(t);
      if ("instance-signals" === this._type) {
        for (const e of t) this._pendingInstances.delete(e);
        0 === this._pendingInstances.size && this.SetSignalled();
      }
    }
    _SaveToJson() {
      const t = {}, e = { "wt": this._type, "t": this._time, "st": this._signalTag, "s": this._isSignalled, "ev": this._event.GetSID(), "sm": this._solModifiers.map((t2) => t2.GetSID()), "dsm": this._dynamicSolModifiers ? [...this._dynamicSolModifiers].map((t2) => t2.GetSID()) : null, "sols": t };
      this._event._HasActionIndex(this._actIndex) && (e["act"] = this._event.GetActionAt(this._actIndex).GetSID());
      for (const [e2, s] of this._sols) t[e2.GetSID().toString()] = s._SaveToJson();
      return "instance-signals" === this._type && (e["pi"] = [...this._pendingInstances].map((t2) => t2.GetUID())), e;
    }
    static _CreateFromJson(t, e) {
      const s = t.GetRuntime(), i = t.GetEventBlockBySID(e["ev"]);
      if (!i) return null;
      let n = 0;
      if (e.hasOwnProperty("act")) {
        const s2 = t.GetActionBySID(e["act"]);
        if (!s2) return null;
        n = s2.GetIndex();
      }
      const a = C32.New(C32.ScheduledWait, t);
      a._time = e["t"], e.hasOwnProperty("wt") ? a._type = e["wt"] : a._type = -1 === a._time ? "signal" : "timer", a._signalTag = e["st"], a._isSignalled = e["s"], a._event = i, a._actIndex = n;
      for (const t2 of e["sm"]) {
        const e2 = s.GetObjectClassBySID(t2);
        e2 && a._solModifiers.push(e2);
      }
      if (Array.isArray(e["dsm"])) for (const t2 of e["dsm"]) {
        const e2 = s.GetObjectClassBySID(t2);
        e2 && (a._dynamicSolModifiers || (a._dynamicSolModifiers = /* @__PURE__ */ new Set()), a._dynamicSolModifiers.add(e2));
      }
      for (const [i2, n2] of Object.entries(e["sols"])) {
        const e2 = parseInt(i2, 10), l = s.GetObjectClassBySID(e2);
        if (!l) continue;
        const o = C32.New(C32.SolState, null);
        o._LoadFromJson(t, n2), a._sols.set(l, o);
      }
      if ("instance-signals" === a._type) {
        a._pendingInstances = /* @__PURE__ */ new Set();
        for (const t2 of e["pi"]) {
          const e2 = s.GetInstanceByUID(t2);
          e2 && a._pendingInstances.add(e2);
        }
      }
      return a;
    }
  };
}
{
  const C32 = self.C3;
  C32.SolState = class extends C32.DefendedBase {
    constructor(s) {
      super(), this._objectClass = null, this._isSelectAll = true, this._instances = [], s && (this._objectClass = s.GetObjectClass(), this._isSelectAll = s.IsSelectAll(), C32.shallowAssignArray(this._instances, s._GetOwnInstances()));
    }
    Release() {
      this._objectClass = null, C32.clearArray(this._instances);
    }
    _Restore(s) {
      s._SetSelectAll(this._isSelectAll), C32.shallowAssignArray(s._GetOwnInstances(), this._instances);
    }
    RemoveInstances(s) {
      C32.arrayRemoveAllInSet(this._instances, s);
    }
    _SaveToJson() {
      return { "sa": this._isSelectAll, "insts": this._instances.map((s) => s.GetUID()) };
    }
    _LoadFromJson(s, e) {
      const t = s.GetRuntime();
      this._isSelectAll = !!e["sa"], C32.clearArray(this._instances);
      for (const s2 of e["insts"]) {
        const e2 = t.GetInstanceByUID(s2);
        e2 && this._instances.push(e2);
      }
    }
  };
}
{
  let GetNextParamMap = function(t, e) {
    let s = t.get(e);
    return s || (s = /* @__PURE__ */ new Map(), t.set(e, s)), s;
  };
  GetNextParamMap2 = GetNextParamMap;
  const C32 = self.C3;
  C32.SDKPluginBase = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._runtime = t.runtime, this._id = t.id, this._name = t.name ?? "", this._isSingleGlobal = !!t.isSingleGlobal, this._isWorldType = !!t.isWorld, this._isRotatable = !!t.isRotatable, this._mustPredraw = !!t.mustPredraw, this._hasEffects = !!t.hasEffects, this._supportsSceneGraph = !!t.supportsSceneGraph, this._supportsMesh = !!t.supportsMesh, this._isHTMLElementType = !!t.isHTMLElementType, this._is3d = !!t.is3d, this._sdkVersion = t.sdkVersion, this._exportData = t.exportData, this._singleGlobalObjectClass = null, this._boundACEMethodCache = /* @__PURE__ */ new Map(), this._boundACEMethodCache_1param = /* @__PURE__ */ new Map(), this._boundACEMethodCache_2params = /* @__PURE__ */ new Map(), this._boundACEMethodCache_3params = /* @__PURE__ */ new Map(), this._scriptInterfaceClass = t.scriptInterfaceClass, this._iPlugin = null;
    }
    Release() {
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetID() {
      return this._id;
    }
    GetName() {
      return this._name;
    }
    OnCreate() {
    }
    GetConstructor() {
      return this.GetSdkVersion() >= 2 ? this._iPlugin.constructor : this.constructor;
    }
    GetSdkVersion() {
      return this._sdkVersion;
    }
    GetScriptInterfaceClass(t = false) {
      let e = this._scriptInterfaceClass;
      return t && "function" != typeof e && this.GetSdkVersion() >= 2 && (e = globalThis.ISDKPluginBase), e;
    }
    GetExportData() {
      return this._exportData;
    }
    IsSingleGlobal() {
      return this._isSingleGlobal;
    }
    IsWorldType() {
      return this._isWorldType;
    }
    IsHTMLElementType() {
      return this._isHTMLElementType;
    }
    Is3D() {
      return this._is3d;
    }
    IsRotatable() {
      return this._isRotatable;
    }
    MustPreDraw() {
      return this._mustPredraw;
    }
    HasEffects() {
      return this._hasEffects;
    }
    SupportsSceneGraph() {
      return this._supportsSceneGraph;
    }
    SupportsMesh() {
      return this._supportsMesh;
    }
    _GetBoundACEMethod(t, e) {
      if (!e) throw new Error("missing 'this' binding");
      let s = this._boundACEMethodCache.get(t);
      return s || (s = t.bind(e), this._boundACEMethodCache.set(t, s), s);
    }
    _GetBoundACEMethod_1param(t, e, s) {
      if (!e) throw new Error("missing 'this' binding");
      const i = GetNextParamMap(this._boundACEMethodCache_1param, t);
      let n = i.get(s);
      return n || (n = t.bind(e, s), i.set(s, n), n);
    }
    _GetBoundACEMethod_2params(t, e, s, i) {
      if (!e) throw new Error("missing 'this' binding");
      const n = GetNextParamMap(this._boundACEMethodCache_2params, t), r = GetNextParamMap(n, s);
      let a = r.get(i);
      return a || (a = t.bind(e, s, i), r.set(i, a), a);
    }
    _GetBoundACEMethod_3params(t, e, s, i, n) {
      if (!e) throw new Error("missing 'this' binding");
      const r = GetNextParamMap(this._boundACEMethodCache_3params, t), a = GetNextParamMap(r, s), l = GetNextParamMap(a, i);
      let o = l.get(n);
      return o || (o = t.bind(e, s, i, n), l.set(n, o), o);
    }
    _SetSingleGlobalObjectClass(t) {
      if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
      this._singleGlobalObjectClass = t;
    }
    GetSingleGlobalObjectClass() {
      if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
      return this._singleGlobalObjectClass;
    }
    GetSingleGlobalInstance() {
      if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
      return this._singleGlobalObjectClass.GetSingleGlobalInstance();
    }
    _InitScriptInterface() {
      const t = this.GetSdkVersion();
      C32.AddonManager._PushInitObject(this, t);
      const e = this.GetScriptInterfaceClass(true);
      if (e) {
        if (this._iPlugin = new e(), !(this._iPlugin instanceof self.IPlugin)) throw new TypeError("plugin class must derive from IPlugin");
      } else this._iPlugin = new self.IPlugin();
      C32.AddonManager._PopInitObject(t);
    }
    GetIPlugin() {
      return this._iPlugin;
    }
  };
}
var GetNextParamMap2;
{
  const C32 = self.C3;
  C32.SDKDOMPluginBase = class extends C32.SDKPluginBase {
    constructor(e, s) {
      super(e), this._domComponentId = s, this._nextElementId = 0, this._instMap = /* @__PURE__ */ new Map(), this.AddElementMessageHandler("elem-focused", (e2) => e2._OnElemFocused()), this.AddElementMessageHandler("elem-blurred", (e2) => {
        e2 && e2._OnElemBlurred();
      });
    }
    Release() {
      super.Release();
    }
    _AddElement(e) {
      const s = this._nextElementId++;
      return this._instMap.set(s, e), s;
    }
    _RemoveElement(e) {
      this._instMap.delete(e);
    }
    AddElementMessageHandler(e, s) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, (e2) => {
        const t = this._instMap.get(e2["elementId"]);
        s(t, e2);
      });
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKTypeBase = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();
    }
    Release() {
      this._objectClass = null, this._runtime = null, this._plugin = null;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetPlugin() {
      return this._plugin;
    }
    GetImageInfo() {
      return this._objectClass.GetImageInfo();
    }
    OnCreate() {
    }
    FinishCondition(e) {
    }
    BeforeRunAction(e) {
    }
    AfterRunAction(e) {
    }
    LoadTextures(e) {
    }
    ReleaseTextures() {
    }
    OnDynamicTextureLoadComplete() {
    }
    PreloadTexturesWithInstances(e) {
    }
    LoadTilemapData() {
    }
    GetScriptInterfaceClass() {
      return null;
    }
    DispatchScriptEvent(e, t, s) {
      const n = C32.New(C32.Event, e, t);
      n.objectClass = this, s && Object.assign(n, s), this.GetObjectClass().DispatchUserScriptEvent(n);
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKInstanceBase = class extends C32.DefendedBase {
    constructor(e, t) {
      super(), this._inst = e, this._domComponentId = t, this._wrapperComponentId = null, this._runtime = e.GetRuntime(), this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._tickFunc = null, this._tick2Func = null, this._isTicking = false, this._isTicking2 = false, this._disposables = null, this._wasReleased = false;
    }
    Release() {
      this._wasReleased = true, this._StopTicking(), this._StopTicking2(), this._tickFunc = null, this._tick2Func = null, this._disposables && (this._disposables.Release(), this._disposables = null), this._inst = null, this._runtime = null, this._objectClass = null, this._sdkType = null;
    }
    WasReleased() {
      return this._wasReleased;
    }
    GetInstance() {
      return this._inst;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetPlugin() {
      return this._sdkType.GetPlugin();
    }
    GetSdkType() {
      return this._sdkType;
    }
    GetScriptInterface() {
      return this._inst.GetInterfaceClass();
    }
    Trigger(e) {
      return this._runtime.Trigger(e, this._inst, null);
    }
    DebugTrigger(e) {
      return this._runtime.DebugTrigger(e, this._inst, null);
    }
    TriggerAsync(e) {
      return this._runtime.TriggerAsync(e, this._inst, null);
    }
    FastTrigger(e, t) {
      return this._runtime.FastTrigger(e, this._inst, t);
    }
    DebugFastTrigger(e, t) {
      return this._runtime.DebugFastTrigger(e, this._inst, t);
    }
    ScheduleTriggers(e) {
      return this._runtime.ScheduleTriggers(e);
    }
    AddDOMMessageHandler(e, t) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t);
    }
    AddDOMMessageHandlers(e) {
      for (const [t, i] of e) this.AddDOMMessageHandler(t, i);
    }
    PostToDOM(e, t) {
      this._runtime.PostComponentMessageToDOM(this._domComponentId, e, t);
    }
    PostToDOMAsync(e, t) {
      return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, e, t);
    }
    _PostToDOMMaybeSync(e, t) {
      if (!this._runtime.IsInWorker()) return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({ "type": "event", "component": this._domComponentId, "handler": e, "data": t, "responseId": null });
      this.PostToDOM(e, t);
    }
    SetWrapperExtensionComponentId(e) {
      if (!e) throw new Error("cannot set empty component id");
      this._wrapperComponentId = e;
    }
    IsWrapperExtensionAvailable() {
      if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
      return this._runtime.HasWrapperComponentId(this._wrapperComponentId);
    }
    AddWrapperExtensionMessageHandler(e, t) {
      if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
      this._runtime.AddWrapperExtensionMessageHandler(this._wrapperComponentId, e, t);
    }
    AddWrapperExtensionMessageHandlers(e) {
      for (const [t, i] of e) this.AddWrapperExtensionMessageHandler(t, i);
    }
    SendWrapperExtensionMessage(e, t) {
      if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
      this._runtime.SendWrapperExtensionMessage(this._wrapperComponentId, e, t);
    }
    SendWrapperExtensionMessageAsync(e, t) {
      if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
      return this._runtime.SendWrapperExtensionMessageAsync(this._wrapperComponentId, e, t);
    }
    Tick() {
    }
    Tick2() {
    }
    _StartTicking() {
      if (!this._isTicking) {
        if (!this._tickFunc) if (this._runtime.IsDebug()) {
          const e = globalThis.C3Debugger, t = this.GetPlugin();
          this._tickFunc = () => {
            const i = performance.now();
            this.Tick(), e.AddIndividualPluginTickTime(t, performance.now() - i);
          };
        } else this._tickFunc = () => this.Tick();
        this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = true;
      }
    }
    _StopTicking() {
      this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking = false);
    }
    IsTicking() {
      return this._isTicking;
    }
    _StartTicking2() {
      if (!this._isTicking2) {
        if (!this._tick2Func) if (this._runtime.IsDebug()) {
          const e = globalThis.C3Debugger, t = this.GetPlugin();
          this._tick2Func = () => {
            const i = performance.now();
            this.Tick2(), e.AddIndividualPluginTickTime(t, performance.now() - i);
          };
        } else this._tick2Func = () => this.Tick2();
        this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func), this._isTicking2 = true;
      }
    }
    _StopTicking2() {
      this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = false);
    }
    IsTicking2() {
      return this._isTicking2;
    }
    GetDebuggerProperties() {
      return [];
    }
    SaveToJson() {
      return null;
    }
    LoadFromJson(e) {
    }
    GetPropertyValueByIndex(e) {
    }
    SetPropertyValueByIndex(e, t) {
    }
    OffsetPropertyValueByIndex(e, t, i) {
      if (0 === t) return;
      const n = this.GetPropertyValueByIndex(e);
      if ("number" != typeof n) throw new Error("expected number");
      this.SetPropertyValueByIndex(e, n + t, i);
    }
    SetPropertyColorOffsetValueByIndex(e, t, i, n) {
    }
    CallAction(e, ...t) {
      e.call(this, ...t);
    }
    CallExpression(e, ...t) {
      return e.call(this, ...t);
    }
    GetScriptInterfaceClass() {
      return null;
    }
    DispatchScriptEvent(e, t, i) {
      if (!this._inst.HasScriptInterface()) return;
      const n = this.GetScriptInterface(), s = C32.New(C32.Event, e, t);
      s.instance = n, i && Object.assign(s, i), n.dispatchEvent(s);
    }
    MustPreDraw() {
      return false;
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKWorldInstanceBase = class extends C32.SDKInstanceBase {
    constructor(e, t) {
      super(e, t), this._worldInfo = e.GetWorldInfo(), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;
    }
    Release() {
      if (this._renderercontextlost_handler) {
        const e = this._runtime.Dispatcher();
        e.removeEventListener("renderercontextlost", this._renderercontextlost_handler), e.removeEventListener("renderercontextrestored", this._renderercontextrestored_handler), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;
      }
      this._worldInfo = null, super.Release();
    }
    HandleWebGLContextLoss() {
      this.HandleRendererContextLoss();
    }
    OnWebGLContextLost() {
    }
    OnWebGLContextRestored() {
    }
    HandleRendererContextLoss() {
      if (this._renderercontextlost_handler) return;
      this._renderercontextlost_handler = () => this.OnRendererContextLost(), this._renderercontextrestored_handler = () => this.OnRendererContextRestored();
      const e = this._runtime.Dispatcher();
      e.addEventListener("renderercontextlost", this._renderercontextlost_handler), e.addEventListener("renderercontextrestored", this._renderercontextrestored_handler);
    }
    OnRendererContextLost() {
      this.OnWebGLContextLost();
    }
    OnRendererContextRestored() {
      this.OnWebGLContextRestored();
    }
    GetWorldInfo() {
      return this._worldInfo;
    }
    IsOriginalSizeKnown() {
      return false;
    }
    GetOriginalWidth() {
      if (!this.IsOriginalSizeKnown()) throw new Error("original size not known");
      const e = this.GetCurrentImageInfo();
      if (e) return e.GetWidth();
    }
    GetOriginalHeight() {
      if (!this.IsOriginalSizeKnown()) throw new Error("original size not known");
      const e = this.GetCurrentImageInfo();
      if (e) return e.GetHeight();
    }
    GetCurrentImageInfo() {
      return null;
    }
    GetCurrentSurfaceSize() {
      const e = this.GetCurrentImageInfo();
      if (e) {
        const t = e.GetTexture();
        if (t) return [t.GetWidth(), t.GetHeight()];
      }
      return [100, 100];
    }
    GetCurrentTexRect() {
      const e = this.GetCurrentImageInfo();
      return e ? e.GetTexRect() : null;
    }
    GetCurrentTexQuad() {
      const e = this.GetCurrentImageInfo();
      return e ? e.GetTexQuad() : null;
    }
    IsCurrentTexRotated() {
      const e = this.GetCurrentImageInfo();
      return !!e && e.IsRotated();
    }
    GetImagePoint(e) {
      const t = this._inst.GetWorldInfo();
      return [t.GetX(), t.GetY(), t.GetTotalZElevation()];
    }
    LoadTilemapData(e, t, r) {
    }
    TestPointOverlapTile(e, t) {
    }
    RendersToOwnZPlane() {
      return true;
    }
  };
}
{
  const C32 = self.C3, tempRect = C32.New(C32.Rect);
  C32.SDKDOMInstanceBase = class extends C32.SDKWorldInstanceBase {
    constructor(t, e) {
      super(t, e), this._elementId = this.GetPlugin()._AddElement(this), this._isElementShowing = true, this._elemHasFocus = false, this._autoFontSize = false, this._autoFontSizeOffset = -0.2, this._lastRect = C32.New(C32.Rect, 0, 0, -1, -1);
      const s = this._runtime.GetCanvasManager();
      this._lastWindowWidth = s.GetLastWidth(), this._lastWindowHeight = s.GetLastHeight(), this._lastHTMLIndex = -1, this._lastHTMLZIndex = -1, this._isPendingUpdateState = false, this._StartTicking();
    }
    Release() {
      this.GetPlugin()._RemoveElement(this._elementId), this.PostToDOMElement("destroy"), this._elementId = -1, super.Release();
    }
    _GetElementInDOMMode() {
      if (this._runtime.IsInWorker()) throw new Error("not valid in worker mode");
      return this._PostToDOMElementMaybeSync("get-element");
    }
    PostToDOMElement(t, e) {
      e || (e = {}), e["elementId"] = this._elementId, this.PostToDOM(t, e);
    }
    _PostToDOMElementMaybeSync(t, e) {
      return e || (e = {}), e["elementId"] = this._elementId, this._PostToDOMMaybeSync(t, e);
    }
    PostToDOMElementAsync(t, e) {
      return e || (e = {}), e["elementId"] = this._elementId, this.PostToDOMAsync(t, e);
    }
    CreateElement(t) {
      t || (t = {});
      const e = this.GetWorldInfo();
      t["elementId"] = this._elementId, t["isVisible"] = e.IsVisible(), t["htmlIndex"] = e.GetLayer().GetHTMLIndex(), t["htmlZIndex"] = e.GetHTMLZIndex(), Object.assign(t, this.GetElementState()), this._isElementShowing = !!t["isVisible"], this._PostToDOMMaybeSync("create", t), this._UpdatePosition(true);
    }
    SetElementVisible(t) {
      t = !!t, this._isElementShowing !== t && (this._isElementShowing = t, this.PostToDOMElement("set-visible", { "isVisible": t }));
    }
    Tick() {
      this._UpdatePosition(false);
    }
    _ShouldPreserveElement() {
      const t = this._runtime.GetCanvasManager().GetFullscreenMode();
      return "Android" === C32.Platform.OS && ("scale-inner" === t || "scale-outer" === t || "crop" === t);
    }
    _UpdatePosition(t) {
      if (this.GetInstance().IsDestroyed()) return;
      const e = this.GetWorldInfo(), s = e.GetLayer(), i = e.GetBoundingBox();
      let [n, l] = s.LayerToCanvasCss(i.getLeft(), i.getTop()), [o, h] = s.LayerToCanvasCss(i.getRight(), i.getBottom());
      const a = this._runtime.GetCanvasManager(), d = a.GetCssWidth(), m = a.GetCssHeight();
      if (!e.IsVisible() || !s.IsVisible()) return void this.SetElementVisible(false);
      if (!this._ShouldPreserveElement() && (o <= 0 || h <= 0 || n >= d || l >= m)) return void this.SetElementVisible(false);
      tempRect.set(n, l, o, h);
      const r = a.GetLastWidth(), _ = a.GetLastHeight(), c = s.GetHTMLIndex(), u = e.GetHTMLZIndex();
      if (!t && tempRect.equals(this._lastRect) && this._lastWindowWidth === r && this._lastWindowHeight === _ && this._lastHTMLIndex === c && this._lastHTMLZIndex === u) return void this.SetElementVisible(true);
      this._lastRect.copy(tempRect), this._lastWindowWidth = r, this._lastWindowHeight = _, this._lastHTMLIndex = c, this._lastHTMLZIndex = u, this.SetElementVisible(true);
      let M = null;
      this._autoFontSize && (M = s.GetDisplayScale() + this._autoFontSizeOffset), this._PostToDOMElementMaybeSync("update-position", { "left": Math.round(this._lastRect.getLeft()), "top": Math.round(this._lastRect.getTop()), "width": Math.round(this._lastRect.width()), "height": Math.round(this._lastRect.height()), "htmlIndex": c, "htmlZIndex": u, "fontSize": M });
    }
    FocusElement() {
      this._PostToDOMElementMaybeSync("focus", { "focus": true });
    }
    BlurElement() {
      this._PostToDOMElementMaybeSync("focus", { "focus": false });
    }
    _OnElemFocused() {
      this._elemHasFocus = true;
    }
    _OnElemBlurred() {
      this._elemHasFocus = false;
    }
    IsElementFocused() {
      return this._elemHasFocus;
    }
    SetElementCSSStyle(t, e) {
      this.PostToDOMElement("set-css-style", { "prop": C32.CSSToCamelCase(t), "val": e });
    }
    SetElementAttribute(t, e) {
      this.PostToDOMElement("set-attribute", { "name": t, "val": e });
    }
    RemoveElementAttribute(t) {
      this.PostToDOMElement("remove-attribute", { "name": t });
    }
    UpdateElementState() {
      this._isPendingUpdateState || (this._isPendingUpdateState = true, Promise.resolve().then(() => {
        this._isPendingUpdateState = false, this.PostToDOMElement("update-state", this.GetElementState());
      }));
    }
    GetElementState() {
    }
    GetElementId() {
      return this._elementId;
    }
  };
}
{
  const C32 = self.C3, IBehavior = self.IBehavior;
  C32.SDKBehaviorBase = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e.runtime, this._id = e.id, this._name = e.name ?? "", this._myObjectClasses = C32.New(C32.ArraySet), this._myInstances = C32.New(C32.ArraySet), this._sdkVersion = e.sdkVersion, this._scriptInterfaceClass = e.scriptInterfaceClass, this._iBehavior = null;
    }
    Release() {
      this._myInstances.Release(), this._myObjectClasses.Release(), this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetID() {
      return this._id;
    }
    GetName() {
      return this._name;
    }
    OnCreate() {
    }
    GetSdkVersion() {
      return this._sdkVersion;
    }
    GetScriptInterfaceClass(e = false) {
      let s = this._scriptInterfaceClass;
      return e && "function" != typeof s && this.GetSdkVersion() >= 2 && (s = globalThis.ISDKBehaviorBase), s;
    }
    _AddObjectClass(e) {
      this._myObjectClasses.Add(e);
    }
    GetObjectClasses() {
      return this._myObjectClasses.GetArray();
    }
    _AddInstance(e) {
      this._myInstances.Add(e);
    }
    _RemoveInstance(e) {
      this._myInstances.Delete(e);
    }
    GetInstances() {
      return this._myInstances.GetArray();
    }
    _InitScriptInterface() {
      const e = this.GetSdkVersion();
      C32.AddonManager._PushInitObject(this, e);
      const s = this.GetScriptInterfaceClass(true);
      if (s) {
        if (this._iBehavior = new s(), !(this._iBehavior instanceof IBehavior)) throw new TypeError("behavior class must derive from IBehavior");
      } else this._iBehavior = new IBehavior();
      C32.AddonManager._PopInitObject(e);
    }
    GetIBehavior() {
      return this._iBehavior;
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKBehaviorTypeBase = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e.GetRuntime(), this._behaviorType = e, this._objectClass = e.GetObjectClass(), this._behavior = e.GetBehavior(), this._behavior._AddObjectClass(this._objectClass);
    }
    Release() {
      this._runtime = null, this._behaviorType = null, this._objectClass = null, this._behavior = null;
    }
    OnCreate() {
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehavior() {
      return this._behavior;
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKBehaviorInstanceBase = class extends C32.DefendedBase {
    constructor(t, i) {
      super(), this._behInst = t, this._domComponentId = i, this._inst = t.GetObjectInstance(), this._runtime = t.GetRuntime(), this._behaviorType = t.GetBehaviorType(), this._sdkType = this._behaviorType.GetSdkType(), this._isTicking = false, this._isTicking2 = false, this._isPostTicking = false, this._disposables = null;
    }
    Release() {
      this._StopTicking(), this._StopTicking2(), this._StopPostTicking(), this._disposables && (this._disposables.Release(), this._disposables = null), this._behInst = null, this._inst = null, this._runtime = null, this._behaviorType = null, this._sdkType = null;
    }
    GetBehavior() {
      return this._behaviorType.GetBehavior();
    }
    GetBehaviorInstance() {
      return this._behInst;
    }
    GetObjectInstance() {
      return this._inst;
    }
    GetObjectClass() {
      return this._inst.GetObjectClass();
    }
    GetWorldInfo() {
      return this._inst.GetWorldInfo();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetSdkType() {
      return this._sdkType;
    }
    GetScriptInterface() {
      return this._behInst.GetScriptInterface();
    }
    Trigger(t) {
      return this._runtime.Trigger(t, this._inst, this._behaviorType);
    }
    DebugTrigger(t) {
      return this._runtime.DebugTrigger(t, this._inst, this._behaviorType);
    }
    TriggerAsync(t) {
      return this._runtime.TriggerAsync(t, this._inst, this._behaviorType);
    }
    PostCreate() {
    }
    Tick() {
    }
    Tick2() {
    }
    PostTick() {
    }
    _StartTicking() {
      this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = true);
    }
    _StopTicking() {
      this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = false);
    }
    IsTicking() {
      return this._isTicking;
    }
    _StartTicking2() {
      this._isTicking2 || (this._runtime._AddBehInstToTick2(this), this._isTicking2 = true);
    }
    _StopTicking2() {
      this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = false);
    }
    IsTicking2() {
      return this._isTicking2;
    }
    _StartPostTicking() {
      this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = true);
    }
    _StopPostTicking() {
      this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = false);
    }
    IsPostTicking() {
      return this._isPostTicking;
    }
    GetDebuggerProperties() {
      return [];
    }
    AddDOMMessageHandler(t, i) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, t, i);
    }
    OnSpriteFrameChanged(t, i) {
    }
    SaveToJson() {
      return null;
    }
    LoadFromJson(t) {
    }
    GetPropertyValueByIndex(t) {
    }
    SetPropertyValueByIndex(t, i) {
    }
    OffsetPropertyValueByIndex(t, i) {
      if (0 === i) return;
      const e = this.GetPropertyValueByIndex(t);
      if ("number" != typeof e) throw new Error("expected number");
      this.SetPropertyValueByIndex(t, e + i);
    }
    SetPropertyColorOffsetValueByIndex(t, i, e, s) {
    }
    CallAction(t, ...i) {
      t.call(this, ...i);
    }
    CallExpression(t, ...i) {
      return t.call(this, ...i);
    }
    GetScriptInterfaceClass() {
      return null;
    }
    DispatchScriptEvent(t, i, e) {
      if (!this._behInst.HasScriptInterface()) return;
      const s = this.GetScriptInterface(), n = C32.New(C32.Event, t, i);
      n.behaviorInstance = s, n.instance = s.instance, e && Object.assign(n, e), s.dispatchEvent(n);
    }
  };
}
{
  let ValidateInternalAPIToken = function(t) {
    if (t !== internalApiToken) throw new Error("invalid internal API token");
  };
  ValidateInternalAPIToken2 = ValidateInternalAPIToken;
  const C32 = self.C3;
  C32.Plugins = {}, C32.Behaviors = {};
  const internalApiToken = C32._GetInternalAPIToken();
  let initObjectStack = [], initObjectStack2 = [], initPropertiesStack = [], originalPushInitObject = null, originalPopInitObject = null, originalGetInitObject = null, originalGetInitObject2 = null;
  const pluginsByCtor = /* @__PURE__ */ new Map(), behaviorsByCtor = /* @__PURE__ */ new Map();
  C32.AddonManager = class extends C32.DefendedBase {
    #t = null;
    #e = [];
    #i = null;
    #n = [];
    #r = /* @__PURE__ */ new Map();
    #o = null;
    #a = null;
    #s;
    constructor(t, e) {
      super(), this.#t = t, this.#s = new Set(e);
    }
    CreatePlugin(t) {
      const e = t[19], i = this.#t.GetObjectReference(t[0]);
      if (!i) throw new Error("missing plugin");
      C32.AddCommonACEs(t, i, e);
      const n = e >= 2 ? C32.SDKPluginBase : i, r = C32.New(n, { runtime: this.#t, isSingleGlobal: t[1], isWorld: t[2], isRotatable: t[5], hasEffects: t[8], mustPredraw: t[9], supportsSceneGraph: t[13], supportsMesh: t[14], isHTMLElementType: t[17], is3d: t[18], sdkVersion: e, id: t[20], name: t[21], scriptInterfaceClass: e >= 2 ? i : null, exportData: t[22] });
      r.OnCreate(), this.#e.push(r), pluginsByCtor.set(i, r);
    }
    CreateSystemPlugin() {
      this.#i = C32.New(C32.Plugins.System, { runtime: this.#t, isSingleGlobal: true }), this.#i.OnCreate();
    }
    CreateBehavior(t) {
      const e = t[1], i = t[2], n = t[3], r = this.#t.GetObjectReference(t[0]);
      if (!r) throw new Error("missing behavior");
      this.#r.set(r, () => {
        const t2 = e >= 2 ? C32.SDKBehaviorBase : r, o = C32.New(t2, { runtime: this.#t, id: i, name: n, sdkVersion: e, scriptInterfaceClass: e >= 2 ? r : null });
        o.OnCreate(), this.#n.push(o), behaviorsByCtor.set(r, o), !this.#o && C32.Behaviors.solid && o instanceof C32.Behaviors.solid ? this.#o = o : !this.#a && C32.Behaviors.jumpthru && o instanceof C32.Behaviors.jumpthru && (this.#a = o), o._InitScriptInterface();
      });
    }
    _DelayCreateBehavior(t) {
      const e = this.#r.get(t);
      e && (e(), this.#r.delete(t));
    }
    static _PushInitObject(t, e = 1) {
      if (C32.AddonManager._PushInitObject !== originalPushInitObject) throw new Error("invalid method");
      1 === e && initObjectStack.push(t), initObjectStack2.push(t);
    }
    static _PopInitObject(t = 1) {
      if (C32.AddonManager._PopInitObject !== originalPopInitObject) throw new Error("invalid method");
      1 === t && initObjectStack.pop(), initObjectStack2.pop();
    }
    static _GetInitObject() {
      if (C32.AddonManager._GetInitObject !== originalGetInitObject) throw new Error("invalid method");
      if (0 === initObjectStack.length) throw new Error("no init object set");
      return initObjectStack.at(-1);
    }
    static _GetInitObject2(t) {
      if (C32.AddonManager._GetInitObject2 !== originalGetInitObject2) throw new Error("invalid method");
      if (ValidateInternalAPIToken(t), 0 === initObjectStack2.length) throw new Error("no init object set");
      return initObjectStack2.at(-1);
    }
    static _PushInitProperties(t) {
      initPropertiesStack.push(t);
    }
    static _PopInitProperties() {
      initPropertiesStack.pop();
    }
    static _GetInitProperties() {
      if (0 === initPropertiesStack.length) throw new Error("no init properties set");
      return initPropertiesStack.at(-1);
    }
    _InitAddonScriptInterfaces() {
      for (const t of this.#e) t._InitScriptInterface();
    }
    static GetPluginByConstructorFunction(t) {
      return pluginsByCtor.get(t) || null;
    }
    static GetBehaviorByConstructorFunction(t) {
      return behaviorsByCtor.get(t) || null;
    }
    GetSystemPlugin() {
      return this.#i;
    }
    GetSolidBehavior() {
      return this.#o;
    }
    GetJumpthruBehavior() {
      return this.#a;
    }
    HasWrapperComponentId(t) {
      return this.#s.has(t);
    }
  }, originalPushInitObject = C32.AddonManager._PushInitObject, originalPopInitObject = C32.AddonManager._PopInitObject, originalGetInitObject = C32.AddonManager._GetInitObject, originalGetInitObject2 = C32.AddonManager._GetInitObject2;
}
var ValidateInternalAPIToken2;
{
  const C32 = self.C3, allImageInfos = /* @__PURE__ */ new Set();
  C32.ImageInfo = class extends C32.DefendedBase {
    constructor() {
      super(), this._generation = 0, this._url = "", this._size = 0, this._offsetX = 0, this._offsetY = 0, this._width = 0, this._height = 0, this._isRotated = false, this._hasMetaData = false, this._imageAsset = null, this._textureState = "", this._rcTex = C32.New(C32.Rect), this._quadTex = C32.New(C32.Quad), this._blobUrl = "", this._iImageInfo = new self.IImageInfo(this), allImageInfos.add(this);
    }
    Release() {
      this.ReleaseTexture(), this._imageAsset && 0 === this._imageAsset.GetRefCount() && this._imageAsset.Release(), this._imageAsset = null, allImageInfos.delete(this), this.ReleaseBlobURL();
    }
    static OnRendererContextLost() {
      for (const t of allImageInfos) t._textureState = "", t._rcTex.set(0, 0, 0, 0), t._quadTex.setFromRect(t._rcTex);
    }
    LoadData(t) {
      this._url = t[0], this._size = t[1], this._offsetX = t[2], this._offsetY = t[3], this._width = t[4], this._height = t[5], this._isRotated = t[6], this._hasMetaData = true;
    }
    LoadDynamicAsset(t, e, s) {
      if (s = !!s, this._imageAsset) throw new Error("already loaded asset");
      this._url = e;
      const i = { isTiled: s };
      return C32.IsAbsoluteURL(e) && (i.loadPolicy = "remote"), this.LoadAsset(t, i), this._imageAsset.Load();
    }
    LoadDynamicBlobAsset(t, e) {
      if (this._imageAsset) throw new Error("already loaded asset");
      this._url = "", this._size = e.size, this._imageAsset = C32.New(C32.ImageAsset, t.GetAssetManager(), { blob: e, size: this._size, loadPolicy: "local" });
    }
    ReplaceWith(t) {
      if (t === this) throw new Error("cannot replace with self");
      this._generation++, this.ReleaseTexture(), this._url = t._url, this._size = t._size, this._offsetX = t._offsetX, this._offsetY = t._offsetY, this._width = t._width, this._height = t._height, this._isRotated = t._isRotated, this._hasMetaData = t._hasMetaData, this._imageAsset = t._imageAsset, this._textureState = t._textureState, this._rcTex = t._rcTex, this._quadTex = t._quadTex, this.ReleaseBlobURL();
    }
    GetURL() {
      return this._url;
    }
    GetSize() {
      return this._size;
    }
    GetOffsetX() {
      return this._offsetX;
    }
    GetOffsetY() {
      return this._offsetY;
    }
    IsRotated() {
      return this._isRotated;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetSheetWidth() {
      return this._imageAsset.GetWidth();
    }
    GetSheetHeight() {
      return this._imageAsset.GetHeight();
    }
    LoadAsset(t, e) {
      if (this._imageAsset) throw new Error("already got asset");
      e = Object.assign({}, e, { url: this.GetURL(), size: this.GetSize() }), this._imageAsset = t.LoadImage(e);
    }
    IsLoaded() {
      return this._imageAsset && this._imageAsset.IsLoaded();
    }
    async LoadStaticTexture(t, e) {
      if (!this._imageAsset) throw new Error("no asset");
      if (this._textureState) throw new Error("already loaded texture");
      const s = this._generation;
      this._textureState = "loading";
      const i = await this._imageAsset.LoadStaticTexture(t, e);
      if (this._generation !== s) return null;
      if (!i) return this._textureState = "", null;
      this._textureState = "loaded", this._hasMetaData || (this._width = i.GetWidth(), this._height = i.GetHeight(), this._hasMetaData = true);
      const h = this._isRotated ? this._height : this._width, a = this._isRotated ? this._width : this._height;
      return this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + h, this._offsetY + a), this._rcTex.divide(i.GetWidth(), i.GetHeight()), this._quadTex.setFromRect(this._rcTex), this._isRotated && this._quadTex.rotatePointsAnticlockwise(), i;
    }
    ReleaseTexture() {
      this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = "", this._rcTex.set(0, 0, 0, 0), this._quadTex.setFromRect(this._rcTex));
    }
    GetTexture() {
      return this._imageAsset && "loaded" === this._textureState ? this._imageAsset.GetTexture() : null;
    }
    GetTexRect() {
      return this._rcTex;
    }
    GetTexQuad() {
      return this._quadTex;
    }
    GetIImageInfo() {
      return this._iImageInfo;
    }
    GetImageAsset() {
      return this._imageAsset;
    }
    async ExtractImageToCanvas(t) {
      t || (t = await this._imageAsset.LoadToDrawable()), this._hasMetaData || (this._width = t.width, this._height = t.height, this._hasMetaData = true);
      const e = C32.CreateCanvas(this._width, this._height), s = e.getContext("2d");
      return this._isRotated ? (s.rotate(Math.PI / -2), s.translate(-this._height, 0), s.drawImage(t, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : s.drawImage(t, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height), e;
    }
    async ExtractImageToBlobURL(t) {
      if (this._blobUrl) return this._blobUrl;
      const e = await this.ExtractImageToCanvas(t), s = await C32.CanvasToBlob(e);
      return this._blobUrl = URL.createObjectURL(s), this._blobUrl;
    }
    ReleaseBlobURL() {
      this._blobUrl && (URL.revokeObjectURL(this._blobUrl), this._blobUrl = "");
    }
  };
}
{
  const C32 = self.C3;
  C32.AnimationInfo = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._name = e[0], this._speed = e[1], this._isLooping = !!e[2], this._repeatCount = e[3], this._repeatTo = e[4], this._isPingPong = !!e[5], this._sid = e[6], this._frames = e[7].map((e2) => C32.New(C32.AnimationFrameInfo, e2)), this._iAnimation = new self.IAnimation(this);
    }
    static CreateDynamic(e, t) {
      const r = C32.New(C32.AnimationInfo, [t, 0, false, 0, 0, false, Math.floor(1e15 * Math.random()), []]);
      return r._frames.push(C32.AnimationFrameInfo.CreateDynamic(e)), r;
    }
    Release() {
      for (const e of this._frames) e.Release();
      C32.clearArray(this._frames);
    }
    LoadAllAssets(e) {
      for (const t of this._frames) t.GetImageInfo().LoadAsset(e);
    }
    LoadAllTextures(e, t) {
      return Promise.all(this._frames.map((r) => r.GetImageInfo().LoadStaticTexture(e, t)));
    }
    ReleaseAllTextures() {
      for (const e of this._frames) e.GetImageInfo().ReleaseTexture();
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetFrameCount() {
      return this._frames.length;
    }
    GetFrames() {
      return this._frames;
    }
    GetFrameAt(e) {
      if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
      return this._frames[e];
    }
    InsertFrameAt(e, t) {
      (t = Math.floor(t)) < 0 ? this._frames.unshift(e) : t >= this._frames.length ? this._frames.push(e) : this._frames.splice(t, 0, e);
    }
    RemoveFrameAt(e) {
      if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
      this._frames[e].Release(), this._frames.splice(e, 1);
    }
    GetFrameIndexByTag(e) {
      for (let t = 0, r = this._frames.length; t < r; ++t) if (C32.equalsNoCase(this._frames[t].GetTag(), e)) return t;
      return -1;
    }
    FrameTagOrIndexToIndex(e) {
      if ("string" == typeof e) {
        const t = this.GetFrameIndexByTag(e);
        if (-1 === t) throw new Error(`cannot find animation frame with tag ${e}`);
        return t;
      }
      return e;
    }
    GetSpeed() {
      return this._speed;
    }
    IsLooping() {
      return this._isLooping;
    }
    GetRepeatCount() {
      return this._repeatCount;
    }
    GetRepeatTo() {
      return this._repeatTo;
    }
    IsPingPong() {
      return this._isPingPong;
    }
    GetIAnimation() {
      return this._iAnimation;
    }
  };
}
{
  const C32 = self.C3, EMPTY_IMAGE_BLOB = (() => {
    const t = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC"), i = new Uint8Array(t.length);
    for (let e = 0, n = t.length; e < n; ++e) i[e] = t.charCodeAt(e);
    return new Blob([i], { type: "image/png" });
  })();
  C32.AnimationFrameInfo = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._imageInfo = C32.New(C32.ImageInfo), this._imageInfo.LoadData(t), this._duration = t[7], this._origin = C32.New(C32.Vector2, t[8], t[9]), this._imagePoints = t[10].map((t2) => C32.New(C32.ImagePoint, this, t2)), this._imagePointsByName = /* @__PURE__ */ new Map();
      for (const t2 of this._imagePoints) this._imagePointsByName.set(t2.GetName().toLowerCase(), t2);
      this._collisionPoly = null;
      const i = t[11];
      i.length >= 6 && (this._collisionPoly = C32.New(C32.CollisionPoly, i)), this._tag = t[12] ? t[12] : "", this._iAnimationFrame = new self.IAnimationFrame(this);
    }
    static CreateDynamic(t) {
      const i = C32.New(C32.AnimationFrameInfo, ["", 0, 0, 0, 100, 100, false, 1, 0, 0, [], [], ""]);
      return i._imageInfo.LoadDynamicBlobAsset(t, EMPTY_IMAGE_BLOB), i;
    }
    Release() {
      this._collisionPoly && (this._collisionPoly.Release(), this._collisionPoly = null), this._imageInfo.Release(), this._imageInfo = null;
    }
    GetImageInfo() {
      return this._imageInfo;
    }
    GetDuration() {
      return this._duration;
    }
    GetOriginX() {
      return this._origin.getX();
    }
    GetOriginY() {
      return this._origin.getY();
    }
    GetCollisionPoly() {
      return this._collisionPoly;
    }
    GetImagePointByName(t) {
      return this._imagePointsByName.get(t.toLowerCase()) || null;
    }
    GetImagePointByIndex(t) {
      return (t = Math.floor(t)) < 0 || t >= this._imagePoints.length ? null : this._imagePoints[t];
    }
    GetImagePointCount() {
      return this._imagePoints.length;
    }
    GetTag() {
      return this._tag;
    }
    GetIAnimationFrame() {
      return this._iAnimationFrame;
    }
  };
}
{
  const C32 = self.C3;
  C32.ImagePoint = class extends C32.DefendedBase {
    constructor(e, t) {
      super(), this._afi = e, this._name = t[0], this._pos = C32.New(C32.Vector2, t[1], t[2]);
    }
    Release() {
    }
    GetName() {
      return this._name;
    }
    GetX() {
      return this._pos.getX();
    }
    GetY() {
      return this._pos.getY();
    }
    GetVec2() {
      return this._pos;
    }
  };
}
{
  const C32 = globalThis.C3, C3Debugger = globalThis.C3Debugger, IObjectClass = globalThis.IObjectClass, IObjectType = globalThis.IObjectType, IFamily = globalThis.IFamily, assert = globalThis.assert;
  C32.ObjectClass = class extends C32.DefendedBase {
    constructor(t, e, s) {
      super();
      const i = t.GetObjectReference(s[1]);
      this._runtime = t, this._plugin = C32.AddonManager.GetPluginByConstructorFunction(i), this._sdkType = null, this._instSdkCtor = i.Instance, this._index = e, this._sid = s[11], this._name = s[0], this._jsPropName = this._runtime.GetJsPropName(s[14]), this._isGlobal = !!s[9], this._isFamily = !!s[2], this._isOnLoaderLayout = !!s[10], this._instVars = s[3].map((e2) => ({ sid: e2[0], type: e2[1], name: e2[2], jsPropName: t.GetJsPropName(e2[3]) })), this._behaviorsCount = s[4], this._effectsCount = s[5], this._isWorldType = this._plugin.IsWorldType(), this._dispatcher = C32.New(C32.Event.Dispatcher), this._effectList = null;
      const [n, a] = t.GetCollisionEngine().GetCollisionCellSize();
      if (this._collisionGrid = C32.New(C32.SparseGrid, n, a), this._anyCollisionCellChanged = true, this._familyMembers = null, this._familyMembersSet = null, this._familyIndex = -1, this._families = null, this._familiesSet = null, this._familyInstVarMap = null, this._familyBehaviorMap = null, this._familyEffectMap = null, this._isInContainer = false, this._container = null, this._behaviorTypes = s[8].map((t2) => C32.BehaviorType.Create(this, t2)), this._behaviorTypesIncludingInherited = [], this._behaviorsByName = /* @__PURE__ */ new Map(), this._behaviorNameToIndex = /* @__PURE__ */ new Map(), this._usedBehaviorCtors = /* @__PURE__ */ new Set(), this._customActionMap = /* @__PURE__ */ new Map(), this._solStack = C32.New(C32.SolStack, this), this._defaultInstanceData = null, this._defaultLayerIndex = 0, this._isContained = false, this._container = null, this._imageInfo = null, this._animations = null, this._animationsByName = null, this._animationsBySid = null, this._textureRefCount = 0, this._savedData = /* @__PURE__ */ new Map(), this._instances = [], this._worldInfosByLayer = /* @__PURE__ */ new Map(), this._iidsStale = true, this._plugin.HasEffects() && (this._effectList = C32.New(C32.EffectList, this, s[12])), s[6] && (this._imageInfo = C32.New(C32.ImageInfo), this._imageInfo.LoadData(s[6])), s[7]) {
        this._animations = s[7].map((t2) => C32.New(C32.AnimationInfo, t2)), this._animationsByName = /* @__PURE__ */ new Map(), this._animationsBySid = /* @__PURE__ */ new Map();
        for (const t2 of this._animations) this._animationsByName.set(t2.GetName().toLowerCase(), t2), this._animationsBySid.set(t2.GetSID(), t2);
      }
      this._isFamily ? (this._familyMembers = [], this._familyMembersSet = /* @__PURE__ */ new Set(), this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = /* @__PURE__ */ new Set(), this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);
      const r = this._plugin.GetSdkVersion();
      if (r < 2 && (this._sdkType = C32.New(i.Type, this, s[15]), !(this._sdkType instanceof C32.SDKTypeBase))) throw new Error("v1 sdk type must derive from SDKTypeBase");
      let o;
      if (this._iObjectClass = null, this._instanceUserScriptClass = null, this._userScriptDispatcher = C32.New(C32.Event.Dispatcher), C32.AddonManager._PushInitObject(this, r), r >= 2 ? (o = i.Type, o || (o = globalThis.ISDKObjectTypeBase)) : o = this._sdkType.GetScriptInterfaceClass(), o && !this._isFamily) {
        if (this._iObjectClass = new o(r < 2 ? this : null), r < 2 && !(this._iObjectClass instanceof IObjectType)) throw new TypeError("script interface class must derive from IObjectType");
        if (r >= 2 && !(this._iObjectClass instanceof globalThis.ISDKObjectTypeBase)) throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
      } else {
        const t2 = this._isFamily ? IFamily : IObjectType;
        this._iObjectClass = new t2();
      }
      if (C32.AddonManager._PopInitObject(r), s[13]) {
        const t2 = s[13];
        if (t2) {
          const e2 = t2[0], s2 = t2[1], i2 = t2[2];
          this._sdkType.LoadTilemapData(e2, s2, i2);
        }
      }
      this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate(), this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(s)), this._loadInstancesJson = null;
    }
    static Create(t, e, s) {
      return C32.New(C32.ObjectClass, t, e, s);
    }
    Release() {
      if (this._dispatcher.Release(), this._dispatcher = null, this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null), this._animations) {
        for (const t of this._animations) t.Release();
        C32.clearArray(this._animations), this._animationsByName.clear(), this._animationsBySid.clear();
      }
      this._loadInstancesJson = null, this._solStack.Release(), this._solStack = null, this._savedData.clear(), this._container = null, this._runtime = null;
    }
    _LoadFamily(t) {
      for (let e = 1, s = t.length; e < s; ++e) {
        const s2 = this._runtime.GetObjectClassByIndex(t[e]);
        this._familyMembers.push(s2), this._familyMembersSet.add(s2), s2._families.push(this), s2._familiesSet.add(this);
      }
    }
    _SetContainer(t) {
      this._isInContainer = true, this._container = t;
    }
    IsInContainer() {
      return this._isInContainer;
    }
    GetContainer() {
      return this._container;
    }
    _OnAfterCreate() {
      let t = 0;
      if (!this._isFamily) for (const e of this._families) for (const s of e.GetBehaviorTypes()) {
        const e2 = s.GetName().toLowerCase();
        this._behaviorsByName.set(e2, s), this._behaviorNameToIndex.set(e2, t), this._behaviorTypesIncludingInherited.push(s), ++t;
      }
      for (const e of this.GetBehaviorTypes()) {
        const s = e.GetName().toLowerCase();
        this._behaviorsByName.set(s, e), this._behaviorNameToIndex.set(s, t), this._behaviorTypesIncludingInherited.push(e), ++t;
      }
      for (const t2 of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(t2.GetBehavior().constructor);
      if (!this._isFamily && this._families.length) {
        const t2 = this._runtime.GetFamilyCount();
        C32.extendArray(this._familyInstVarMap, t2, 0), C32.extendArray(this._familyBehaviorMap, t2, 0), C32.extendArray(this._familyEffectMap, t2, 0);
        const e = [];
        let s = 0, i = 0, n = 0;
        for (const t3 of this._families) {
          const a = t3.GetFamilyIndex();
          this._familyInstVarMap[a] = s, s += t3.GetInstanceVariablesCount(), this._familyBehaviorMap[a] = i, i += t3.GetBehaviorTypesCount(), this._familyEffectMap[a] = n, n += t3.GetEffectTypesCount();
          const r = t3.GetEffectList();
          if (r && this._effectList) for (const t4 of r.GetAllEffectTypes()) e.push(t4.Clone(this._effectList));
        }
        this._effectList && this._effectList.PrependEffectTypes(e);
      }
    }
    _CreateSingleGlobalInstance(t) {
      const e = C32.IsFiniteNumber(t[17]) ? t[17] : this._runtime._GetNewUID(), s = C32.New(C32.Instance, { runtime: this._runtime, objectType: this, uid: e });
      s._CreateSdkInstance(t[16], []), this._runtime._MapInstanceByUID(e, s), this._instances.push(s);
    }
    GetSdkType() {
      return this._sdkType;
    }
    IsOnLoaderLayout() {
      return this._isOnLoaderLayout;
    }
    Dispatcher() {
      return this._dispatcher;
    }
    OnCreate() {
      this._isFamily || (this._sdkType ? this._sdkType.OnCreate() : this._iObjectClass._onCreate());
    }
    HasLoadedTextures() {
      return this._textureRefCount > 0;
    }
    async LoadTextures(t) {
      this._isFamily || (this._textureRefCount++, 1 === this._textureRefCount && (this._sdkType ? await this._sdkType.LoadTextures(t) : await this._iObjectClass._loadTextures(this._runtime.GetCanvasManager().GetIRenderer())));
    }
    ReleaseTextures() {
      if (!this._isFamily) {
        if (this._textureRefCount--, this._textureRefCount < 0) throw new Error("released textures too many times");
        0 === this._textureRefCount && (this._sdkType ? this._sdkType.ReleaseTextures() : this._iObjectClass._releaseTextures(this._runtime.GetCanvasManager().GetIRenderer()));
      }
    }
    OnDynamicTextureLoadComplete() {
      if (this._isFamily) throw new Error("not applicable to family");
      this._sdkType ? this._sdkType.OnDynamicTextureLoadComplete() : this._iObjectClass._onDynamicTextureLoadComplete();
    }
    async PreloadTexturesWithInstances(t) {
      this._isFamily || (this._sdkType ? await this._sdkType.PreloadTexturesWithInstances(t) : await this._iObjectClass._preloadTexturesWithInstances(this._runtime.GetCanvasManager().GetIRenderer()));
    }
    GetRuntime() {
      return this._runtime;
    }
    GetPlugin() {
      return this._plugin;
    }
    GetInstanceSdkCtor() {
      return this._instSdkCtor;
    }
    GetName() {
      return this._name;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
    GetIndex() {
      return this._index;
    }
    GetSID() {
      return this._sid;
    }
    IsFamily() {
      return this._isFamily;
    }
    IsGlobal() {
      return this._isGlobal;
    }
    IsWorldType() {
      return this._isWorldType;
    }
    GetFamilyIndex() {
      return this._familyIndex;
    }
    GetBehaviorTypes() {
      return this._behaviorTypes;
    }
    GetBehaviorTypesCount() {
      return this._behaviorsCount;
    }
    UsesBehaviorByCtor(t) {
      return t && this._usedBehaviorCtors.has(t);
    }
    GetInstanceVariablesCount() {
      return this._instVars.length;
    }
    GetInstanceVariableSIDs() {
      return this._instVars.map((t) => t.sid);
    }
    GetInstanceVariableIndexBySID(t) {
      return this._instVars.findIndex((e) => e.sid === t);
    }
    GetInstanceVariableIndexByName(t) {
      return this._instVars.findIndex((e) => e.name === t);
    }
    _GetAllInstanceVariableNames() {
      return this._instVars.map((t) => t.name);
    }
    _GetAllInstanceVariableJsPropNames() {
      return this._instVars.map((t) => t.jsPropName);
    }
    GetInstanceVariableType(t) {
      if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError("invalid instance variable index");
      return this._instVars[t].type;
    }
    GetInstanceVariableName(t) {
      if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError("invalid instance variable index");
      return this._instVars[t].name;
    }
    GetEffectTypesCount() {
      return this._effectsCount;
    }
    GetBehaviorTypesIncludingInherited() {
      return this._behaviorTypesIncludingInherited;
    }
    GetBehaviorTypeByName(t) {
      return this._behaviorsByName.get(t.toLowerCase()) || null;
    }
    GetBehaviorIndexByName(t) {
      const e = this._behaviorNameToIndex.get(t.toLowerCase());
      return void 0 === e ? -1 : e;
    }
    GetEffectList() {
      return this._effectList;
    }
    HasEffects() {
      return this._plugin.HasEffects();
    }
    UsesEffects() {
      return this._effectList && this._effectList.HasAnyEffectType();
    }
    GetSolStack() {
      return this._solStack;
    }
    GetCurrentSol() {
      return this._solStack.GetCurrentSol();
    }
    GetImageInfo() {
      return this._imageInfo;
    }
    SetDefaultInstanceData(t) {
      this._defaultInstanceData = t;
    }
    GetDefaultInstanceData() {
      return this._defaultInstanceData;
    }
    _SetDefaultLayerIndex(t) {
      this._defaultLayerIndex = t;
    }
    GetDefaultLayerIndex() {
      return this._defaultLayerIndex;
    }
    GetAnimations() {
      return this._animations;
    }
    GetAnimationCount() {
      return this._animations.length;
    }
    GetFamilies() {
      return this._families;
    }
    BelongsToFamily(t) {
      return this._familiesSet.has(t);
    }
    GetFamilyMembers() {
      return this._familyMembers;
    }
    FamilyHasMember(t) {
      return this._familyMembersSet.has(t);
    }
    GetFamilyBehaviorOffset(t) {
      return this._familyBehaviorMap[t];
    }
    GetFamilyInstanceVariableOffset(t) {
      return this._familyInstVarMap[t];
    }
    AddCustomAction(t) {
      this._customActionMap.set(t.GetACEName().toLowerCase(), t);
    }
    HasOwnCustomActionByName(t) {
      return !!this.GetOwnCustomActionByName(t);
    }
    GetOwnCustomActionByName(t) {
      const e = this._customActionMap.get(t.toLowerCase());
      return e && e.IsEnabled() ? e : null;
    }
    GetAllAnimations() {
      return this._animations;
    }
    GetAnimationByName(t) {
      if (!this._animations) throw new Error("no animations");
      return this._animationsByName.get(t.toLowerCase()) || null;
    }
    GetAnimationBySID(t) {
      if (!this._animations) throw new Error("no animations");
      return this._animationsBySid.get(t) || null;
    }
    AddAnimation(t) {
      if (this.GetAnimationByName(t)) throw new Error(`animation name '${t}' already exists`);
      const e = C32.AnimationInfo.CreateDynamic(this.GetRuntime(), t);
      return this._animations.push(e), this._animationsByName.set(e.GetName().toLowerCase(), e), this._animationsBySid.set(e.GetSID(), e), e;
    }
    RemoveAnimation(t) {
      const e = this.GetAnimationByName(t);
      if (!e) throw new Error(`animation name '${t}' does not exist`);
      if (1 === this._animations.length) throw new Error("cannot remove last animation");
      const s = this._animations.indexOf(e);
      this._animations.splice(s, 1), this._animationsByName.delete(e.GetName().toLowerCase()), this._animationsBySid.delete(e.GetSID()), e.Release();
    }
    GetFirstAnimation() {
      if (!this._animations) throw new Error("no animations");
      return this._animations[0];
    }
    GetFirstAnimationFrame() {
      return this.GetFirstAnimation().GetFrameAt(0);
    }
    GetDefaultInstanceSize() {
      if (this._animations) {
        const t = this.GetFirstAnimationFrame().GetImageInfo();
        return [t.GetWidth(), t.GetHeight()];
      }
      return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100];
    }
    GetSingleGlobalInstance() {
      if (!this._plugin.IsSingleGlobal()) throw new Error("not a single-global plugin");
      return this._instances[0];
    }
    GetInstances() {
      return this._instances;
    }
    *instances() {
      yield* this._instances;
    }
    *instancesIncludingPendingCreate() {
      yield* this._instances, yield* this._runtime.instancesPendingCreateForObjectClass(this);
    }
    GetInstanceCount() {
      return this._instances.length;
    }
    _AddInstance(t) {
      this._instances.push(t);
    }
    _SetIIDsStale() {
      this._iidsStale = true;
    }
    _UpdateIIDs() {
      if (!this._iidsStale || this._isFamily) return;
      const t = this._instances;
      let e = 0;
      for (let s2 = t.length; e < s2; ++e) t[e]._SetIID(e);
      const s = this._runtime._GetInstancesPendingCreate();
      for (const t2 of s) t2.GetObjectClass() === this && t2._SetIID(e++);
      this._iidsStale = false;
    }
    GetInstanceByIID(t) {
      const e = this._instances;
      if (t < e.length) return e[t];
      t -= e.length;
      const s = this._runtime._GetInstancesPendingCreate();
      for (const e2 of s) if (e2.GetObjectClass() === this) {
        if (0 === t) return e2;
        --t;
      }
      return null;
    }
    GetFirstPicked(t) {
      if (t && t.IsInContainer() && t.GetObjectClass() !== this) {
        for (const e2 of t.siblings()) if (e2.GetObjectClass() === this) return e2;
      }
      const e = this.GetCurrentSol().GetInstances();
      return e.length ? e[0] : null;
    }
    GetPairedInstance(t) {
      const e = this.GetCurrentSol().GetInstances();
      return e.length > 0 ? e[t.GetIID() % e.length] : null;
    }
    *allCorrespondingInstances(t, e) {
      const s = this.GetCurrentSol().GetInstances(), i = s.length, n = e.GetCurrentSol(), a = e.GetCurrentSol().GetInstances(), r = a.length;
      let o = t.GetIID();
      !e.IsFamily() && n.IsSelectAll() || (o = a.indexOf(t));
      const h = Math.ceil(i / r), l = i % r;
      let _ = 0, c = 0;
      0 === l || o < l ? (_ = o * h, c = h) : (_ = l * h + (o - l) * (h - 1), c = h - 1);
      for (let t2 = _, e2 = _ + c; t2 < e2; ++t2) yield s[t2];
    }
    FinishCondition(t) {
      this._sdkType?.FinishCondition(t);
    }
    ApplySolToContainer() {
      if (!this._isInContainer || this._isFamily) return;
      this._UpdateIIDs();
      const t = this.GetCurrentSol(), e = t._GetOwnInstances(), s = t.IsSelectAll(), i = this._runtime.GetCurrentEventStackFrame(), n = i && i.GetCurrentEvent() && i.GetCurrentEvent().IsOrBlock();
      for (const i2 of this._container.objectTypes()) {
        if (i2 === this) continue;
        i2._UpdateIIDs();
        const a = i2.GetCurrentSol();
        if (a._SetSelectAll(s), !s) {
          const s2 = a._GetOwnInstances();
          C32.clearArray(s2);
          for (const t2 of e) s2.push(i2.GetInstanceByIID(t2.GetIID()));
          if (n) {
            const e2 = t._GetOwnElseInstances(), s3 = a._GetOwnElseInstances();
            C32.clearArray(s3);
            for (const t2 of e2) s3.push(i2.GetInstanceByIID(t2.GetIID()));
          }
        }
      }
    }
    _TruncateContainerSols(t, e) {
      for (const s of this.GetContainer().objectTypes()) {
        const i = s.GetCurrentSol();
        t ? C32.truncateArray(i._GetOwnElseInstances(), e) : C32.truncateArray(i._GetOwnInstances(), e);
      }
    }
    _GetCollisionCellGrid() {
      return this._collisionGrid;
    }
    _SetAnyCollisionCellChanged(t) {
      this._anyCollisionCellChanged = !!t;
    }
    _UpdateAllCollisionCells() {
      if (this._anyCollisionCellChanged && this._isWorldType) {
        for (const t of this._instances) t.GetWorldInfo()._UpdateCollisionCell();
        for (const t of this._runtime._GetInstancesPendingCreate()) t.GetObjectClass() === this && t.GetWorldInfo()._UpdateCollisionCell();
        this._anyCollisionCellChanged = false;
      }
    }
    _OnWorldInstanceLayerChanged(t, e, s) {
      if (e) {
        const s2 = this._worldInfosByLayer.get(e);
        s2 && (s2.delete(t), 0 === s2.size && this._worldInfosByLayer.delete(e));
      }
      if (s) {
        let e2 = this._worldInfosByLayer.get(s);
        e2 || (e2 = /* @__PURE__ */ new Set(), this._worldInfosByLayer.set(s, e2)), e2.add(t);
      }
    }
    *layersHasInstancesOn() {
      if (this.IsFamily()) {
        const t = /* @__PURE__ */ new Set();
        for (const e of this._familyMembers) for (const s of e.layersHasInstancesOn()) t.add(s);
        yield* t.values();
      } else for (const t of this._worldInfosByLayer.keys()) t.WasReleased() || (yield t);
    }
    GetSavedDataMap() {
      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
    }
    HasSolidBehavior() {
      return this.UsesBehaviorByCtor(C32.Behaviors.solid);
    }
    HasJumpthruBehavior() {
      return this.UsesBehaviorByCtor(C32.Behaviors.jumpthru);
    }
    HasNoSaveBehavior() {
      return this.UsesBehaviorByCtor(C32.Behaviors.NoSave);
    }
    HasPersistBehavior() {
      return this.UsesBehaviorByCtor(C32.Behaviors.Persist);
    }
    _SaveToJson() {
      const t = { "instances": this._instances.map((t2) => t2.SaveToJson()) };
      return this._savedData && this._savedData.size && (t["ex"] = C32.ToSuperJSON(this._savedData)), t;
    }
    _LoadFromJson(t, e) {
      this._savedData && (this._savedData.clear(), this._savedData = null);
      const s = t["ex"];
      s && (this._savedData = C32.FromSuperJSON(s));
      const i = this._instances, n = t["instances"];
      for (let t2 = 0, e2 = Math.min(i.length, n.length); t2 < e2; ++t2) i[t2].LoadFromJson(n[t2]);
      for (let t2 = n.length, e2 = i.length; t2 < e2; ++t2) this._runtime.DestroyInstance(i[t2]);
      for (let t2 = i.length, s2 = n.length; t2 < s2; ++t2) {
        const s3 = n[t2];
        let i2 = null;
        if (this.IsWorldType() && (i2 = this._runtime.GetMainRunningLayout().GetLayerBySID(s3["w"]["l"]), !i2)) continue;
        const a = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, i2, false, 0, 0, true);
        a.LoadFromJson(s3), e && e.add(a);
      }
      this._loadInstancesJson = n, this._SetIIDsStale();
    }
    _GetLoadInstancesJson() {
      return this._loadInstancesJson;
    }
    _ClearLoadInstancesJson() {
      this._loadInstancesJson = null;
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
      for (let t = 0, e = this._instances; t < e; ++t) this._instances[t]._SetupSceneGraphConnectionsOnChangeOfLayout();
    }
    GetIObjectClass() {
      return this._iObjectClass;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    _GetUserScriptInstanceClass() {
      return this._instanceUserScriptClass;
    }
    _SetUserScriptInstanceClass(t) {
      this._instanceUserScriptClass = t;
    }
    DispatchUserScriptEvent(t) {
      const e = this._runtime, s = e.IsDebug() && !e.GetEventSheetManager().IsInEventEngine();
      s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(t), s && C3Debugger.AddScriptTime();
    }
  };
}
{
  const C32 = self.C3;
  C32.Container = class extends C32.DefendedBase {
    constructor(e, t) {
      super(), this._runtime = e, this._objectTypes = t;
      for (const e2 of this._objectTypes) e2._SetContainer(this);
    }
    Release() {
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectTypes() {
      return this._objectTypes;
    }
    objectTypes() {
      return this._objectTypes;
    }
    HasAnyWorldType() {
      return this._objectTypes.some((e) => e.IsWorldType());
    }
  };
}
{
  const C32 = self.C3, C3Debugger = self.C3Debugger, IInstance = self.IInstance, originalAddonManager = C32.AddonManager, EMPTY_ARRAY = [], EMPTY_SET = /* @__PURE__ */ new Set();
  let nextPuid = 0;
  const savedDataMaps = /* @__PURE__ */ new WeakMap(), FLAG_DESTROYED = 1, FLAG_TILEMAP = 2, FLAG_MUST_PREDRAW = 4, FLAG_SOLID_ENABLED = 8, FLAG_SOLID_USES_INSTANCE_TAGS = 16, FLAG_JUMPTHRU_ENABLED = 32, FLAG_MUST_MITIGATE_Z_FIGHTING = 32, FLAG_IS_DRAWING_WITH_EFFECTS = 64;
  C32.Instance = class extends C32.DefendedBase {
    #t = null;
    constructor(t) {
      if (C32.AddonManager !== originalAddonManager) throw new Error("invalid addon manager");
      super(), this._runtime = t.runtime, this._objectType = t.objectType, this._worldInfo = null, this._sdkInst = null, this._iScriptInterface = null, this._iid = 0, this._uid = t.uid, this._puid = nextPuid++, this._flags = 0;
      const e = C32.splitStringAndNormalize(t.tags);
      e.length > 0 && this.SetTagsSet(new Set(e)), this._instVarValues = EMPTY_ARRAY, this._behaviorInstances = EMPTY_ARRAY;
      const s = this._objectType.GetBehaviorTypesIncludingInherited();
      s.length > 0 && (this._behaviorInstances = s.map((t2, e2) => C32.New(C32.BehaviorInstance, { runtime: this._runtime, behaviorType: t2, instance: this, index: e2 }))), this._siblings = this._objectType.IsInContainer() ? [] : null, this._timeScale = -1, this._dispatcher = null;
      const n = this.GetPlugin();
      if (n.MustPreDraw() && (this._flags |= 4), n.IsWorldType()) if (this._worldInfo = C32.New(C32.WorldInfo, this, t.layer), t.worldData) this._worldInfo.Init(t.worldData);
      else {
        this._worldInfo.InitNoData();
        const [t2, e2] = this._objectType.GetDefaultInstanceSize();
        this._worldInfo.SetSize(t2, e2), this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters();
      }
      t.instVarData ? this._LoadInstanceVariableData(t.instVarData) : this._LoadDefaultInstanceVariables();
    }
    Release() {
      if (this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behaviorInstances.length > 0) {
        for (const t2 of this._behaviorInstances) t2.Release();
        C32.clearArray(this._behaviorInstances);
      }
      this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null);
      const t = savedDataMaps.get(this);
      t && (t.clear(), savedDataMaps.delete(this)), this._siblings && C32.clearArray(this._siblings), this._dispatcher && (this._dispatcher.Release(), this._dispatcher = null), this.#t && (this.#t.originalTags.clear(), this.#t.lowercaseTags.clear()), this.#t = null, this._runtime = null, this._objectType = null, this._instVarValues.length > 0 && C32.clearArray(this._instVarValues), this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null);
    }
    _LoadInstanceVariableData(t) {
      t.length > 0 && (this._instVarValues = [], C32.shallowAssignArray(this._instVarValues, t));
    }
    _LoadDefaultInstanceVariables() {
      const t = this._objectType.GetInstanceVariablesCount();
      if (0 === t) return;
      this._instVarValues = [];
      const e = [0, 0, ""];
      for (let s = 0; s < t; ++s) this._instVarValues.push(e[this._objectType.GetInstanceVariableType(s)]);
    }
    _CreateSdkInstance(t, e) {
      if (this._sdkInst) throw new Error("already got sdk instance");
      for (let t2 = 0, s = this._behaviorInstances.length; t2 < s; ++t2) {
        this._behaviorInstances[t2]._CreateSdkInstance(e ? e[t2] : null);
      }
      if (this.GetPlugin().GetSdkVersion() < 2) {
        if (this._sdkInst = C32.New(this._objectType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C32.SDKInstanceBase)) throw new Error("sdk type must derive from SDKInstanceBase");
        !this.GetPlugin().IsWorldType() && this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
      } else {
        const e2 = this.GetPlugin().GetScriptInterfaceClass();
        this._InitUserScriptInterface(e2.Instance, t);
      }
    }
    GetSdkInstance() {
      return this._sdkInst ?? this._iScriptInterface;
    }
    GetWorldInfo() {
      return this._worldInfo;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTimeScale() {
      return this._timeScale;
    }
    GetActiveTimeScale() {
      const t = this._timeScale;
      return -1 === t ? this.GetRuntime().GetTimeScale() : t;
    }
    SetTimeScale(t) {
      ((t = +t) < 0 || !isFinite(t)) && (t = 0), this._timeScale = t, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, true);
    }
    RestoreTimeScale() {
      this._timeScale = -1, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, false);
    }
    GetInstanceGameTime() {
      return this._runtime._GetInstanceGameTime(this);
    }
    Dispatcher() {
      return this._dispatcher || (this._dispatcher = C32.New(C32.Event.Dispatcher)), this._dispatcher;
    }
    Draw(t) {
      this._sdkInst ? this._sdkInst.Draw(t) : this._iScriptInterface._draw(this._runtime.GetCanvasManager().GetIRenderer());
    }
    OnCreate(t) {
      this._sdkInst.OnCreate(t);
    }
    _SetHasTilemap() {
      this._flags |= 2;
    }
    HasTilemap() {
      return !!(2 & this._flags);
    }
    _MarkDestroyed() {
      this._flags |= 1;
    }
    IsDestroyed() {
      return !!(1 & this._flags);
    }
    MustPreDraw() {
      return !!(4 & this._flags) || (this._sdkInst ? this._sdkInst.MustPreDraw() : this._iScriptInterface._mustPreDraw());
    }
    SetMustMitigateZFighting() {
      this._flags |= 32;
    }
    MustMitigateZFighting() {
      return !!(32 & this._flags);
    }
    _IsSolidEnabled() {
      return !!(8 & this._flags);
    }
    _SetSolidEnabled(t) {
      t ? this._flags |= 8 : this._flags &= -9;
    }
    _IsSolidUsingInstanceTags() {
      return !!(16 & this._flags);
    }
    _SetSolidUsingInstanceTags(t) {
      t ? this._flags |= 16 : this._flags &= -17;
    }
    _IsJumpthruEnabled() {
      return !!(32 & this._flags);
    }
    _SetJumpthruEnabled(t) {
      t ? this._flags |= 32 : this._flags &= -33;
    }
    _IsDrawingWithEffects() {
      return !!(64 & this._flags);
    }
    _SetIsDrawingWithEffects(t) {
      t ? this._flags |= 64 : this._flags &= -65;
    }
    SetFlag(t, e) {
      t <<= 16, e ? this._flags |= t : this._flags &= ~t;
    }
    GetFlag(t) {
      return !!(this._flags & t << 16);
    }
    GetCurrentImageInfo() {
      return this._sdkInst ? this._sdkInst.GetCurrentImageInfo() : null;
    }
    GetCurrentSurfaceSize() {
      return this._sdkInst ? this._sdkInst.GetCurrentSurfaceSize() : null;
    }
    GetCurrentTexRect() {
      return this._sdkInst ? this._sdkInst.GetCurrentTexRect() : null;
    }
    GetCurrentTexQuad() {
      return this._sdkInst ? this._sdkInst.GetCurrentTexQuad() : null;
    }
    IsCurrentTexRotated() {
      return !!this._sdkInst && this._sdkInst.IsCurrentTexRotated();
    }
    GetImagePoint(t) {
      return this._sdkInst ? this._sdkInst.GetImagePoint(t) : [this._iScriptInterface.x, this._iScriptInterface.y, this._iScriptInterface.totalZElevation];
    }
    GetObjectClass() {
      return this._objectType;
    }
    RendersToOwnZPlane() {
      return this._sdkInst ? this._sdkInst.RendersToOwnZPlane() : this._iScriptInterface._rendersToOwnZPlane();
    }
    BelongsToObjectClass(t) {
      return t.IsFamily() ? t.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === t;
    }
    CollectInstancesToPick(t, e, s) {
      const n = (e2, s2) => {
        const n2 = s2 || e2.GetObjectClass(), i = t.get(n2);
        i ? i.add(e2) : t.set(n2, /* @__PURE__ */ new Set([e2]));
      };
      if (n(this, e), this.IsInContainer()) for (const t2 of this.siblings()) n(t2);
      if (s) for (const t2 of this.allChildren()) n(t2);
    }
    VerifySupportsSceneGraph() {
      if (!this.GetPlugin().SupportsSceneGraph()) throw new Error("object does not support scene graph");
    }
    HasParent() {
      return null !== this.GetParent();
    }
    GetParent() {
      const t = this.GetWorldInfo();
      if (!t) return null;
      const e = t.GetParent();
      return e ? e.GetInstance() : null;
    }
    GetTopParent() {
      const t = this.GetWorldInfo();
      if (!t) return null;
      const e = t.GetTopParent();
      return e ? e.GetInstance() : null;
    }
    *parents() {
      const t = this.GetWorldInfo();
      if (t) for (const e of t.parents()) yield e.GetInstance();
    }
    HasChild(t) {
      if (!t) return false;
      for (const e of this.children()) if (e === t) return true;
      return false;
    }
    HasChildren() {
      const t = this.GetWorldInfo();
      return !!t && t.HasChildren();
    }
    GetChildrenOfObjectClass(t) {
      const e = this.GetWorldInfo();
      if (!e) return [];
      const s = t.GetName();
      return e.GetChildren().map((t2) => t2.GetInstance()).filter((t2) => t2.GetObjectClass().GetName() === s);
    }
    GetChildren() {
      const t = this.GetWorldInfo();
      return t ? t.GetChildren().map((t2) => t2.GetInstance()) : [];
    }
    *children() {
      const t = this.GetWorldInfo();
      if (t) for (const e of t.children()) yield e.GetInstance();
    }
    *allChildren() {
      const t = this.GetWorldInfo();
      if (t) for (const e of t.allChildren()) yield e.GetInstance();
    }
    GetChildCount() {
      const t = this.GetWorldInfo();
      return t ? t.GetChildCount() : 0;
    }
    GetParentCount() {
      return [...this.parents()].length;
    }
    GetAllChildCount() {
      const t = this.GetWorldInfo();
      return t ? t.GetAllChildCount() : 0;
    }
    GetChildAt(t) {
      const e = this.GetWorldInfo();
      if (!e) return null;
      const s = e.GetChildAt(t);
      return s ? s.GetInstance() : null;
    }
    GetIndexInParent() {
      const t = this.GetWorldInfo();
      if (!t) return NaN;
      const e = t.GetParent();
      return e ? e.GetChildIndex(t) : NaN;
    }
    HasChildWithUID(t) {
      for (const e of this.GetWorldInfo().GetChildren()) if (e.GetInstance().GetUID() === t) return true;
      return false;
    }
    AddChild(t, e) {
      this.VerifySupportsSceneGraph(), t.VerifySupportsSceneGraph(), this.GetWorldInfo().AddChild(t.GetWorldInfo(), e || {});
    }
    RemoveChild(t) {
      const e = this.GetWorldInfo();
      e && e.RemoveChild(t.GetWorldInfo());
    }
    GetDestroyWithParent() {
      const t = this.GetWorldInfo();
      return !!t && t.GetDestroyWithParent();
    }
    SetupInitialSceneGraphConnections() {
      const t = this.GetWorldInfo();
      if (!t) return;
      const e = t.GetSceneGraphChildrenExportData();
      if (e) for (const t2 of e) {
        const e2 = this._runtime.GetInstanceByUID(t2[2]);
        if (e2) {
          const s = t2[3];
          this.AddChild(e2, { transformX: !!(1 & s), transformY: !!(s >> 1 & 1), transformWidth: !!(s >> 2 & 1), transformHeight: !!(s >> 3 & 1), transformAngle: !!(s >> 4 & 1), destroyWithParent: !!(s >> 5 & 1), transformZElevation: !!(s >> 6 & 1), transformOpacity: !!(s >> 7 & 1), transformVisibility: !!(s >> 8 & 1) });
        }
      }
    }
    SetupPersistedSceneGraphConnections(t, e) {
      const s = t.get(this);
      if (s) for (const t2 of s["sceneGraphJson"]["children"]) {
        const s2 = e.get(t2["index"]);
        if (!s2) continue;
        const n = t2["flags"];
        this.AddChild(s2, { transformX: !!(1 & n), transformY: !!(n >> 1 & 1), transformWidth: !!(n >> 2 & 1), transformHeight: !!(n >> 3 & 1), transformAngle: !!(n >> 4 & 1), destroyWithParent: !!(n >> 5 & 1), transformZElevation: !!(n >> 6 & 1), transformOpacity: !!(n >> 7 & 1), transformVisibility: !!(n >> 8 & 1) });
      }
    }
    GetTemplateName() {
      const t = this._runtime.GetTemplateManager();
      return t ? t.GetInstanceTemplateName(this) : "";
    }
    IsInContainer() {
      return null !== this._siblings;
    }
    _ClearSiblings() {
      C32.clearArray(this._siblings);
    }
    _AddSibling(t) {
      this._siblings.push(t);
    }
    GetSiblings() {
      return this._siblings;
    }
    HasSibling(t) {
      return !!this.GetSibling(t);
    }
    GetSibling(t) {
      const e = this.siblings();
      if (null === e || 0 === e.length) return false;
      for (const s of e) if (s.GetObjectClass() === t) return s;
      return null;
    }
    siblings() {
      return this._siblings;
    }
    SetSiblingsSinglePicked() {
      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol().SetSinglePicked(t);
    }
    _PushSiblingsToSolInstances() {
      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushInstance(t);
    }
    _SetSiblingsToSolInstancesIndex(t) {
      for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnInstances()[t] = e;
    }
    _PushSiblingsToSolElseInstances() {
      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushElseInstance(t);
    }
    _SetSiblingsToSolElseInstancesIndex(t) {
      for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[t] = e;
    }
    GetPlugin() {
      return this._objectType.GetPlugin();
    }
    _SetIID(t) {
      this._iid = t;
    }
    GetIID() {
      return this._objectType._UpdateIIDs(), this._iid;
    }
    GetUID() {
      return this._uid;
    }
    SetUID(t) {
      this._uid = t;
    }
    GetPUID() {
      return this._puid;
    }
    SetTagsSet(t) {
      if (this.#t && (this.#t.originalTags.clear(), this.#t.lowercaseTags.clear()), 0 === t.size) this.#t = null;
      else {
        this.#t || (this.#t = { originalTags: /* @__PURE__ */ new Set(), lowercaseTags: /* @__PURE__ */ new Set() });
        for (const e of t) {
          const t2 = e.toLowerCase();
          this.#t.lowercaseTags.has(t2) || (this.#t.originalTags.add(e), this.#t.lowercaseTags.add(t2));
        }
      }
    }
    GetTagsSet() {
      return this.#t ? this.#t.originalTags : EMPTY_SET;
    }
    GetLowercaseTagsSet() {
      return this.#t ? this.#t.lowercaseTags : EMPTY_SET;
    }
    _GetLowercaseTagsSetMaybeNull() {
      return this.#t ? this.#t.lowercaseTags : null;
    }
    HasTag(t) {
      return !!this.#t && this.#t.lowercaseTags.has(t.toLowerCase());
    }
    GetTagsString() {
      return Array.from(this.GetTagsSet()).join(" ");
    }
    GetTagAt(t) {
      t = Math.floor(t);
      for (const e of this.GetTagsSet()) {
        if (0 === t) return e;
        --t;
      }
      return "";
    }
    GetBehaviorInstances() {
      return this._behaviorInstances;
    }
    GetBehaviorInstanceFromCtor(t) {
      if (!t) return null;
      for (const e of this._behaviorInstances) if (e.GetBehavior() instanceof t) return e;
      return null;
    }
    GetBehaviorSdkInstanceFromCtor(t) {
      if (!t) return null;
      const e = this.GetBehaviorInstanceFromCtor(t);
      return e ? e.GetSdkInstance() : null;
    }
    GetBehaviorIndexBySID(t) {
      const e = this._behaviorInstances;
      for (let s = 0, n = e.length; s < n; ++s) if (e[s].GetBehaviorType().GetSID() === t) return s;
      return -1;
    }
    GetAllInstanceVariableValues() {
      return this._instVarValues;
    }
    _GetAllInstanceVariableNames() {
      return this._objectType._GetAllInstanceVariableNames();
    }
    GetInstanceVariableCount() {
      return this._instVarValues.length;
    }
    GetInstanceVariableValue(t) {
      t |= 0;
      const e = this._instVarValues;
      if (t < 0 || t >= e.length) throw new RangeError("invalid instance variable");
      return e[t];
    }
    _GetInstanceVariableValueUnchecked(t) {
      return this._instVarValues[t];
    }
    _GetInstanceVariableTypedValue(t) {
      const e = this._instVarValues[t];
      return 0 === this._objectType.GetInstanceVariableType(t) ? !!e : e;
    }
    SetInstanceVariableValue(t, e) {
      t |= 0;
      const s = this._instVarValues;
      if (t < 0 || t >= s.length) throw new RangeError("invalid instance variable");
      switch (this._objectType.GetInstanceVariableType(t)) {
        case 0:
          s[t] = e ? 1 : 0;
          break;
        case 1:
          s[t] = "number" == typeof e ? e : parseFloat(e);
          break;
        case 2:
          s[t] = "string" == typeof e ? e : e.toString();
          break;
        default:
          throw new Error("unknown instance variable type");
      }
    }
    SetInstanceVariableOffset(t, e) {
      if (0 === e) return;
      t |= 0;
      const s = this._instVarValues;
      if (t < 0 || t >= s.length) throw new RangeError("invalid instance variable");
      const n = s[t];
      if ("number" != typeof n) throw "boolean" == typeof n ? new Error("can not set offset of boolean variable") : "string" == typeof n ? new Error("can not set offset of string variable") : new Error("unknown instance variable type");
      s[t] += "number" == typeof e ? e : parseFloat(e);
    }
    GetSavedDataMap() {
      let t = savedDataMaps.get(this);
      return t || (t = /* @__PURE__ */ new Map(), savedDataMaps.set(this, t), t);
    }
    _HasAnyCreateDestroyHandler(t) {
      const e = this.GetObjectClass();
      if (e.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;
      for (const s of e.GetFamilies()) if (s.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;
      return !!this._runtime.UserScriptDispatcher().HasAnyHandlerFor(t);
    }
    _TriggerOnCreatedOnSelfAndRelated(t = void 0) {
      const e = t ?? /* @__PURE__ */ new Set();
      if (e.has(this)) return;
      e.add(this);
      const s = this.GetWorldInfo();
      if (s && s.HasChildren()) {
        for (const t2 of this.allChildren()) if (e.add(t2), t2.IsInContainer()) for (const s2 of t2.siblings()) e.add(s2);
      }
      if (this.IsInContainer()) for (const t2 of this.siblings()) t2._TriggerOnCreatedOnSelfAndRelated(e);
      if (!t) {
        for (const t2 of e.values()) t2._TriggerOnCreated();
        this._OnHierarchyReady();
      }
    }
    _OnCreatedCommon() {
      this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
      for (const t of this._behaviorInstances) t.PostCreate();
    }
    _OnCreatedForLoadingSavegame() {
      this._OnCreatedCommon();
    }
    _TriggerOnCreated() {
      if (this._OnCreatedCommon(), this._HasAnyCreateDestroyHandler("instancecreate")) {
        const t = this.GetObjectClass(), e = new C32.Event("instancecreate");
        e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);
        for (const s of t.GetFamilies()) s.DispatchUserScriptEvent(e);
        this._runtime.DispatchUserScriptEvent(e);
      }
      this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnCreated, this, null);
    }
    _OnHierarchyReady() {
      if (this.GetPlugin().SupportsSceneGraph()) {
        if (this.DispatchUserScriptEvent(new C32.Event("hierarchyready")), this._HasAnyCreateDestroyHandler("hierarchyready")) {
          const t = this.GetObjectClass(), e = new C32.Event("hierarchyready");
          e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);
          for (const s of t.GetFamilies()) s.DispatchUserScriptEvent(e);
          this._runtime.DispatchUserScriptEvent(e);
        }
        this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnHierarchyReady, this, null);
      }
    }
    _TriggerOnDestroyed() {
      this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnDestroyed, this, null);
    }
    _FireDestroyedScriptEvents(t) {
      if (this._iScriptInterface) {
        const e2 = new C32.Event("destroy");
        e2.isEndingLayout = t, this.DispatchUserScriptEvent(e2);
      }
      if (!this._HasAnyCreateDestroyHandler("instancedestroy")) return;
      const e = this.GetObjectClass(), s = new C32.Event("instancedestroy");
      s.instance = this.GetInterfaceClass(), s.isEndingLayout = t, e.DispatchUserScriptEvent(s);
      for (const t2 of e.GetFamilies()) t2.DispatchUserScriptEvent(s);
      this._runtime.DispatchUserScriptEvent(s);
    }
    _GetDebuggerProperties() {
      return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();
    }
    SaveToJson(t = "full", e = null) {
      const s = {};
      "full" === t ? s["uid"] = this.GetUID() : s["c3"] = true;
      const n = this.GetTagsSet();
      if (n.size > 0 && (s["tags"] = Array.from(n)), "visual-state" !== t) {
        const e2 = savedDataMaps.get(this);
        if (e2 && e2.size && (s["ex"] = C32.ToSuperJSON(e2)), -1 !== this.GetTimeScale() && (s["mts"] = this.GetTimeScale()), this._objectType.GetInstanceVariablesCount() > 0) {
          const t2 = {}, e3 = this._objectType.GetInstanceVariableSIDs();
          for (let s2 = 0, n2 = this._instVarValues.length; s2 < n2; ++s2) t2[e3[s2].toString()] = this._instVarValues[s2];
          s["ivs"] = t2;
        }
        if (this._behaviorInstances.length) {
          const e3 = {};
          for (const s2 of this._behaviorInstances) {
            const n2 = s2.SaveToJson(t);
            n2 && (e3[s2.GetBehaviorType().GetSID().toString()] = n2);
          }
          s["behs"] = e3;
        }
      }
      this._worldInfo && (s["w"] = this._worldInfo._SaveToJson(t, e));
      const i = this._sdkInst ? this._sdkInst.SaveToJson() : this._iScriptInterface._saveToJson();
      return i && (s["data"] = i), s;
    }
    _OnBeforeLoad(t = "full", e = null) {
      this._worldInfo && this._worldInfo._OnBeforeLoad(t);
    }
    _OnAfterLoad(t, e = "full", s = null) {
      this._worldInfo && this._worldInfo._OnAfterLoad(t, e, s);
    }
    _OnAfterLoad2(t, e = "full", s = null) {
      this._worldInfo && this._worldInfo._OnAfterLoad2(t, e, s);
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
      this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout();
    }
    LoadFromJson(t, e = "full", s = null) {
      if ("full" === e) this._uid = t["uid"];
      else if (!t["c3"]) return;
      if (this.SetTagsSet(new Set(t["tags"] ?? [])), "visual-state" !== e) {
        let e2 = savedDataMaps.get(this);
        e2 && (e2.clear(), savedDataMaps.delete(this));
        const s2 = t["ex"];
        s2 && (e2 = C32.FromSuperJSON(s2), savedDataMaps.set(this, e2)), this._timeScale = t.hasOwnProperty("mts") ? t["mts"] : -1;
        const n2 = t["ivs"];
        if (n2) for (const [t2, e3] of Object.entries(n2)) {
          const s3 = parseInt(t2, 10), n3 = this._objectType.GetInstanceVariableIndexBySID(s3);
          if (n3 < 0 || n3 >= this._instVarValues.length) continue;
          let i = e3;
          null === i && (i = NaN), this._instVarValues[n3] = i;
        }
      }
      if (this.GetPlugin().IsWorldType()) {
        const n2 = t["w"];
        if (n2) {
          const t2 = n2["l"];
          if (this._worldInfo.GetLayer().GetSID() !== t2) {
            const s2 = this._worldInfo.GetLayer(), n3 = s2.GetLayout().GetLayerBySID(t2);
            n3 ? (this._worldInfo._SetLayer(n3), s2._RemoveInstance(this, true), n3._AddInstance(this, true), n3.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged()) : "full" === e && this._runtime.DestroyInstance(this);
          }
          this._worldInfo._LoadFromJson(n2, e, s);
        }
      }
      if ("visual-state" !== e) {
        const s2 = t["behs"];
        if (s2) for (const [t2, n2] of Object.entries(s2)) {
          const s3 = parseInt(t2, 10), i = this.GetBehaviorIndexBySID(s3);
          i < 0 || i >= this._behaviorInstances.length || this._behaviorInstances[i].LoadFromJson(n2, e);
        }
      }
      const n = t["data"];
      n && (this._sdkInst ? this._sdkInst.LoadFromJson(n, e) : this._iScriptInterface._loadFromJson(n));
    }
    MoveToLayerWithSID(t) {
      if (this._worldInfo.GetLayer().GetSID() === t) return;
      const e = this._worldInfo.GetLayer(), s = e.GetLayout().GetLayerBySID(t);
      s && (this._worldInfo._SetLayer(s), e._RemoveInstance(this, true), s._AddInstance(this, true), s.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged());
    }
    GetInterfaceClass() {
      return this._iScriptInterface || this._InitUserScriptInterface();
    }
    HasScriptInterface() {
      return !!this._iScriptInterface;
    }
    _InitUserScriptInterface(t, e) {
      const s = this._worldInfo ? t ? self.ISDKWorldInstanceBase : self.IWorldInstance : t ? self.ISDKInstanceBase : self.IInstance, n = t || this._sdkInst.GetScriptInterfaceClass(), i = this._objectType._GetUserScriptInstanceClass(), r = i || n || s, a = this.GetPlugin().GetSdkVersion();
      if (C32.AddonManager._PushInitObject(this, a), C32.AddonManager._PushInitProperties(e), this._iScriptInterface = new r(), C32.AddonManager._PopInitProperties(), C32.AddonManager._PopInitObject(a), n && !(this._iScriptInterface instanceof s)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);
      if (i) {
        const t2 = n || s;
        if (!(this._iScriptInterface instanceof t2)) throw new TypeError(`setInstanceClass(): class '${i.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
      }
      return this._iScriptInterface;
    }
    _GetInstVarsScriptDescriptor(t) {
      if (0 === this._instVarValues.length) return;
      const e = {}, s = this._objectType._GetAllInstanceVariableJsPropNames();
      for (let t2 = 0, n2 = s.length; t2 < n2; ++t2) e[s[t2]] = { configurable: false, enumerable: true, get: C32.Instance.prototype._GetInstanceVariableTypedValue.bind(this, t2), set: C32.Instance.prototype.SetInstanceVariableValue.bind(this, t2) };
      const n = Object.create(Object.prototype, e);
      t.instVars = { value: n, writable: false };
    }
    _GetBehaviorsScriptDescriptor(t) {
      const e = this._behaviorInstances;
      if (0 === e.length) return;
      const s = {};
      for (const t2 of e) s[t2.GetBehaviorType().GetJsPropName()] = { value: t2.GetScriptInterface(), writable: false };
      const n = Object.create(Object.prototype, s);
      t.behaviors = { value: n, writable: false };
    }
    DispatchUserScriptEvent(t) {
      if (!this.HasScriptInterface()) return;
      const e = this.GetInterfaceClass();
      t.instance = e;
      const s = this._runtime, n = s.IsDebug() && !s.GetEventSheetManager().IsInEventEngine();
      n && C3Debugger.StartMeasuringScriptTime(), e.dispatchEvent(t), n && C3Debugger.AddScriptTime();
    }
  };
}
{
  const C32 = self.C3, updatedInstances = /* @__PURE__ */ new Map();
  C32.SceneGraphInfo = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._owner = t, this._parent = null, this._children = [], this._startWidth = t.GetWidth(), this._startHeight = t.GetHeight(), this._startScaleX = 1, this._startScaleY = 1, this._parentStartAngle = 0, this._ownOpacity = 1, this._startOpacity = t.GetOpacity(), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, this._on_instance_create = (e) => {
        if (e.instance !== this._parent.GetInstance()) return;
        t.GetRuntime().Dispatcher().removeEventListener("instancecreate", this._on_instance_create);
        const n = this._parent.GetInstance().GetSdkInstance();
        this._originalSizeKnown = !!n.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? n.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? n.GetOriginalHeight() : NaN;
      };
    }
    Release() {
      this._parent = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, C32.clearArray(this._children);
    }
    SetParent(t) {
      if (this._ownOpacity = this._owner.GetOpacity(), this._startOpacity = this._ownOpacity, this._parent = t, this._parentStartAngle = t ? t.GetAngle() : 0, this._parent) {
        const t2 = this._owner.GetRuntime();
        if (this._parent.GetInstance().GetPlugin().GetSdkVersion() < 2) {
          const e = this._parent.GetInstance().GetSdkInstance();
          e ? (this._originalSizeKnown = !!e.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? e.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? e.GetOriginalHeight() : NaN) : this._parent.GetInstance().IsDestroyed() || t2.Dispatcher().addEventListener("instancecreate", this._on_instance_create);
        } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;
      } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;
    }
    GetParent() {
      return this._parent;
    }
    HasChildren() {
      return this._children.length > 0;
    }
    GetChildren() {
      return this._children;
    }
    _MaybeSortChildren() {
      this.HasChildren() && 1 !== this._children.length && (this._tmpSceneGraphChildrenIndexes ? this._children.sort((t, e) => {
        const n = this._tmpSceneGraphChildrenIndexes.get(t.GetInstance()), s = this._tmpSceneGraphChildrenIndexes.get(e.GetInstance());
        return C32.IsFiniteNumber(n) && C32.IsFiniteNumber(s) ? n - s : 0;
      }) : this._children.sort((t, e) => {
        const n = t._GetSceneGraphInfo()._GetIndexInParent(), s = e._GetSceneGraphInfo()._GetIndexInParent();
        return C32.IsFiniteNumber(n) && C32.IsFiniteNumber(s) ? n - s : 0;
      }));
    }
    _GetIndexInParent() {
      return this._indexInParent;
    }
    GetStartScaleX() {
      return this._startScaleX;
    }
    SetStartScaleX(t) {
      this._startScaleX = t;
    }
    GetStartScaleY() {
      return this._startScaleY;
    }
    SetStartScaleY(t) {
      this._startScaleY = t;
    }
    GetStartOpacity() {
      return this._startOpacity;
    }
    GetOwnOpacity() {
      return this._ownOpacity;
    }
    SetOwnOpacity(t) {
      this._ownOpacity = t;
    }
    _GetStartWidth() {
      return 0 === this._startWidth ? Number.EPSILON : this._startWidth;
    }
    _GetStartHeight() {
      return 0 === this._startHeight ? Number.EPSILON : this._startHeight;
    }
    GetParentScaleX() {
      if (this._owner.GetTransformWithParentWidth()) {
        const t = this._parent;
        let e = t.GetWidth(), n = t._GetSceneGraphInfo()._GetStartWidth();
        return 0 === e && (e = Number.EPSILON), n === Number.EPSILON && e === Number.EPSILON ? 1 : n === Number.EPSILON && e !== Number.EPSILON && this._originalSizeKnown ? 1 + e / this._originalWidth : e / n;
      }
      return 1;
    }
    GetParentScaleY() {
      if (this._owner.GetTransformWithParentHeight()) {
        const t = this._parent;
        let e = t.GetHeight(), n = t._GetSceneGraphInfo()._GetStartHeight();
        return 0 === e && (e = Number.EPSILON), n === Number.EPSILON && e === Number.EPSILON ? 1 : n === Number.EPSILON && e !== Number.EPSILON && this._originalSizeKnown ? 1 + e / this._originalHeight : e / n;
      }
      return 1;
    }
    GetParentStartAngle() {
      return 0;
    }
    _SaveToJsonProperties() {
      return { "sw": this._startWidth, "sh": this._startHeight, "sx": this._startScaleX, "sy": this._startScaleY, "psa": this._parentStartAngle, "oo": this._ownOpacity, "so": this._startOpacity, "pi": this._owner.GetInstance().GetIndexInParent() };
    }
    _SaveToJson(t, e = null) {
      const n = this._SaveToJsonProperties();
      return e && e["selfOnly"] ? Object.assign(n, { "p": null, "c": [] }) : Object.assign(n, { "p": this._GetParentJson(t), "c": this._GetChildrenJson(t) });
    }
    _GetFlagsString(t) {
      let e = "";
      return t.GetTransformWithParentX() && (e += "x"), t.GetTransformWithParentY() && (e += "y"), t.GetTransformWithParentWidth() && (e += "w"), t.GetTransformWithParentHeight() && (e += "h"), t.GetTransformWithParentAngle() && (e += "a"), t.GetTransformWithParentZElevation() && (e += "z"), t.GetDestroyWithParent() && (e += "d"), t.GetTransformWithParentOpacity() && (e += "o"), t.GetTransformWithParentVisibility() && (e += "v"), e;
    }
    _GetParentJson(t) {
      return this._parent ? !this._parent.GetInstance() || this._parent.GetInstance().IsDestroyed() ? null : this._GetInstanceJson(this._parent, this._owner, t) : null;
    }
    _GetChildrenJson(t) {
      return this._children.map((e) => this._GetInstanceJson(e, e, t)).filter((t2) => t2);
    }
    _GetInstanceJson(t, e, n) {
      const s = t.GetInstance();
      if (s && s.IsDestroyed()) return null;
      const i = {};
      return i["uid"] = s.GetUID(), i["f"] = this._GetFlagsString(e), i["offsets"] = e._SaveSceneGraphPropertiesToJson(), i["data"] = C32.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(s), i["oci"] = s.GetObjectClass().GetIndex(), "state" === n ? (i["inst"] = s.SaveToJson("full", { "selfOnly": true }), i["instIndex"] = NaN) : (i["instIndex"] = s.GetObjectClass().GetInstances().indexOf(s), i["inst"] = null), i;
    }
    _LoadFromJson(t) {
      this._startWidth = t["sw"], this._startHeight = t["sh"], this._startScaleX = t["sx"], this._startScaleY = t["sy"], this._parentStartAngle = t["psa"], this._ownOpacity = t["oo"], this._startOpacity = t["so"], this._indexInParent = C32.IsFiniteNumber(t["pi"]) ? t["pi"] : NaN;
    }
    _SetTmpSceneGraphChildren(t, e, n, s) {
      if (!t && !e) {
        if (s?.setFromJson) {
          if (this._tmpSceneGraphChildren) for (const t2 of this._tmpSceneGraphChildren) t2.IsDestroyed() || t2.HasParent() || t2.GetRuntime().DestroyInstance(t2);
        } else if (this._tmpSceneGraphChildren) {
          for (const t2 of this._tmpSceneGraphChildren) if (n["c"] && n["c"].length) {
            if (!n["c"].some((e2) => e2["uid"] === t2.GetUID())) continue;
            t2.IsDestroyed() || t2.HasParent() || t2.GetRuntime().DestroyInstance(t2);
          }
        }
      }
      this._tmpSceneGraphChildren = t, this._tmpSceneGraphChildrenIndexes = e;
    }
    _GetInstanceByUID(t) {
      const e = this._owner.GetRuntime();
      return updatedInstances.has(t) ? updatedInstances.get(t) : e.GetInstanceByUID(t);
    }
    _OnAfterLoad(t, e) {
      const n = this._owner, s = n.GetRuntime(), i = e?.processedWorldInfo ?? /* @__PURE__ */ new Set();
      if (t["p"] && !this._parent) {
        const a2 = t["p"]["uid"], r2 = this._GetInstanceByUID(a2);
        if (r2) {
          const a3 = r2.GetWorldInfo();
          if (r2.HasChild(n.GetInstance())) this._parent = a3;
          else {
            r2.HasChildWithUID(n.GetInstance().GetUID()) ? (s.DestroyInstance(n.GetInstance()), s._RemoveInstanceFromUIDMap(n.GetInstance().GetUID()), updatedInstances.delete(n.GetInstance().GetUID())) : r2.AddChild(n.GetInstance(), this._GetFlagsObj(t["p"]["f"])), i.has(n) || (n._LoadSceneGraphPropertiesFromJson(t["p"]["offsets"]), this._LoadInstancePropertiesFromJson(r2, t["p"], e), this._UpdateUIDInstanceMap(r2, r2.GetUID(), n.GetRuntime(), e)), i.add(n);
            r2.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren();
          }
        } else if (C32.IsFiniteNumber(t["p"]["oci"])) {
          const i2 = s.CreateInstance(s.GetObjectClassByIndex(t["p"]["oci"]), n.GetLayer(), 0, 0, true);
          if (i2) {
            const a3 = this._GetInstanceData(t["p"], s);
            a3 && i2.LoadFromJson(a3);
            const r3 = i2.GetWorldInfo(), h = !!e?.setFromJson;
            r3.GetLayer().SortAndAddInstancesByZIndex(i2, false, h), i2.AddChild(n.GetInstance(), this._GetFlagsObj(t["p"]["f"])), updatedInstances.set(i2.GetUID(), i2), this._UpdateUIDInstanceMap(i2, i2.GetUID(), s, e);
            i2.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren();
          }
        }
      }
      const a = [];
      for (const e2 of t["c"]) {
        const t2 = e2["uid"], n2 = this._GetInstanceByUID(t2);
        n2 && a.push(n2);
      }
      let r = 0;
      for (const h of t["c"]) {
        const c = h["uid"], o = this._GetInstanceByUID(c);
        if (o) {
          if (this._tmpSceneGraphChildren) {
            if (this._tmpSceneGraphChildren.includes(o)) {
              const s3 = o;
              if (s3.GetObjectClass() !== o.GetObjectClass()) {
                r++;
                continue;
              }
              if (s3.IsDestroyed()) {
                r++;
                continue;
              }
              const h2 = t["c"][r];
              if (!e?.setFromJson && this._HasAllChildrenOfType(s3, a, n)) {
                if (n.GetInstance().GetChildAt(r)) {
                  const a2 = s3.GetObjectClass().GetIndex(), c2 = h2["oci"], o2 = n.GetInstance().GetChildAt(r).GetObjectClass().GetIndex();
                  if (a2 !== c2 || c2 !== o2) {
                    this._RefreshAllChildren(t["c"], n, i, e);
                    break;
                  }
                  this._UpdateInstance(r, h2, n, i, e);
                } else this._UpdateInstance(r, h2, n, i, e);
                r++;
                continue;
              }
              if (s3.HasParent() && s3.GetParent() !== n.GetInstance()) {
                const t2 = this._CreateNewChildInstance(h2, e);
                this._AddAndSetChildInstance(t2, h2, i, e), r++;
                continue;
              }
              this._AddAndSetChildInstance(s3.GetWorldInfo(), h2, i, e, true), r++;
              continue;
            }
            if (this._tmpSceneGraphChildren[r]) {
              const s3 = this._tmpSceneGraphChildren[r];
              if (s3.GetObjectClass() !== o.GetObjectClass()) {
                r++;
                continue;
              }
              if (s3.IsDestroyed()) {
                r++;
                continue;
              }
              const h2 = t["c"][r];
              if (!e?.setFromJson && this._HasAllChildrenOfType(s3, a, n)) {
                if (n.GetInstance().GetChildAt(r)) {
                  const a2 = s3.GetObjectClass().GetIndex(), c2 = h2["oci"], o2 = n.GetInstance().GetChildAt(r).GetObjectClass().GetIndex();
                  if (a2 !== c2 || c2 !== o2) {
                    this._RefreshAllChildren(t["c"], n, i, e);
                    break;
                  }
                  this._UpdateInstance(r, h2, n, i, e);
                } else this._UpdateInstance(r, h2, n, i, e);
                r++;
                continue;
              }
              if (s3.HasParent() && s3.GetParent() !== n.GetInstance()) {
                const t2 = this._CreateNewChildInstance(h2, e);
                this._AddAndSetChildInstance(t2, h2, i, e), r++;
                continue;
              }
              this._AddAndSetChildInstance(s3.GetWorldInfo(), h2, i, e, true), r++;
              continue;
            }
          }
          const s2 = o.GetObjectClass();
          if (this._GetInstancesOfObjectClassCount(a, s2) === n.GetInstance().GetChildrenOfObjectClass(s2).length) {
            for (const t2 of n.GetInstance().GetChildren()) {
              if (t2.GetObjectClass() !== s2) continue;
              const n2 = t2.GetWorldInfo();
              if (n2 && !i.has(n2)) {
                i.add(n2), n2._LoadSceneGraphPropertiesFromJson(h["offsets"]), this._LoadInstancePropertiesFromJson(t2, h, e);
                break;
              }
            }
            r++;
            continue;
          }
          if (o.HasParent() && o.GetParent() !== n.GetInstance()) {
            const t2 = this._CreateNewChildInstance(h, e);
            this._AddAndSetChildInstance(t2, h, i, e), r++;
            continue;
          }
          this._AddAndSetChildInstance(o.GetWorldInfo(), h, i, e);
        } else if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[r]) {
          const c2 = this._tmpSceneGraphChildren[r], o2 = s.GetObjectClassByIndex(this._GetObjectClassIndex(h));
          if (c2.GetObjectClass() !== o2) {
            r++;
            continue;
          }
          if (c2.IsDestroyed()) {
            r++;
            continue;
          }
          const d = t["c"][r];
          if (!e?.setFromJson && this._HasAllChildrenOfType(c2, a, n)) {
            if (n.GetInstance().GetChildAt(r)) {
              const s2 = c2.GetObjectClass().GetIndex(), a2 = d["oci"], h2 = n.GetInstance().GetChildAt(r).GetObjectClass().GetIndex();
              if (s2 !== a2 || a2 !== h2) {
                this._RefreshAllChildren(t["c"], n, i, e);
                break;
              }
              this._UpdateInstance(r, d, n, i, e);
            } else this._UpdateInstance(r, d, n, i, e);
            r++;
            continue;
          }
          if (c2.HasParent() && c2.GetParent() !== n.GetInstance()) {
            const t2 = this._CreateNewChildInstance(d, e);
            this._AddAndSetChildInstance(t2, d, i, e), r++;
            continue;
          }
          this._AddAndSetChildInstance(c2.GetWorldInfo(), d, i, e);
        } else {
          const t2 = this._CreateNewChildInstance(h, e);
          this._AddAndSetChildInstance(t2, h, i, e);
        }
        r++;
      }
    }
    _RefreshAllChildren(t, e, n, s) {
      const i = e.GetRuntime();
      for (const t2 of e.GetInstance().children()) t2 && !t2.IsDestroyed() && (i.DestroyInstance(t2), i._RemoveInstanceFromUIDMap(t2.GetUID()), updatedInstances.delete(t2.GetUID()));
      this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren = []), this._tmpSceneGraphChildrenIndexes && (this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());
      Object.assign({}, s, { "assignZIndex": false });
      for (const e2 of t) {
        const t2 = this._CreateNewChildInstance(e2, s);
        this._AddAndSetChildInstance(t2, e2, n, s), this._tmpSceneGraphChildren.push(t2.GetInstance()), this._tmpSceneGraphChildrenIndexes.set(t2.GetInstance(), this._tmpSceneGraphChildren.length - 1);
      }
      e._GetSceneGraphInfo()._MaybeSortChildren();
    }
    _HasAllChildrenOfType(t, e, n) {
      const s = t.GetObjectClass();
      return this._GetInstancesOfObjectClassCount(e, s) === n.GetInstance().GetChildrenOfObjectClass(s).length;
    }
    _UpdateInstance(t, e, n, s, i) {
      const a = n.GetInstance().GetChildAt(t);
      if (!a) return;
      const r = a.GetWorldInfo();
      r && (s.has(r) || (r._LoadSceneGraphPropertiesFromJson(e["offsets"]), this._LoadInstancePropertiesFromJson(a, e, i)), s.add(r));
    }
    _GetFlagsObj(t) {
      const e = {};
      return e.transformX = t.includes("x"), e.transformY = t.includes("y"), e.transformWidth = t.includes("w"), e.transformHeight = t.includes("h"), e.transformAngle = t.includes("a"), e.transformZElevation = t.includes("z"), e.destroyWithParent = t.includes("d"), e.transformOpacity = t.includes("o"), e.transformVisibility = t.includes("v"), e;
    }
    _GetObjectClassIndex(t) {
      return C32.IsFiniteNumber(t["oci"]) ? t["oci"] : t[1];
    }
    _CreateNewChildInstance(t, e) {
      if (!C32.IsFiniteNumber(t["oci"])) return;
      const n = this._owner, s = n.GetRuntime();
      let i;
      const a = !e.hasOwnProperty("createHierarchy") || e["createHierarchy"];
      if (i = t["data"] ? s.CreateInstanceFromData(t["data"], n.GetLayer(), false, 0, 0, false, a) : s.CreateInstance(s.GetObjectClassByIndex(t["oci"]), n.GetLayer(), 0, 0, a), !i) return;
      const r = this._GetInstanceData(t, s);
      r && i.LoadFromJson(r);
      const h = i.GetWorldInfo(), c = !!e?.setFromJson;
      return h.GetLayer().SortAndAddInstancesByZIndex(i, true, c), h;
    }
    _UpdateUIDInstanceMap(t, e, n, s) {
      if (this._GetInstanceByUID(e) && !s?.setFromJson) {
        const s2 = this._GetInstanceByUID(e);
        s2 !== t && n.DestroyInstance(s2);
      }
      n._RemoveInstanceFromUIDMap(e), n._MapInstanceByUID(e, t);
    }
    _AddAndSetChildInstance(t, e, n, s, i = true) {
      const a = this._owner, r = a.AddChild(t, this._GetFlagsObj(e["f"]));
      r && i ? (n.has(t) || (t._LoadSceneGraphPropertiesFromJson(e["offsets"]), this._LoadInstancePropertiesFromJson(t.GetInstance(), e, s)), n.add(t)) : r && (updatedInstances.set(t.GetInstance().GetUID(), t.GetInstance()), this._UpdateUIDInstanceMap(t.GetInstance(), e["uid"], a.GetRuntime(), s)), this._MaybeSortChildren();
    }
    _LoadInstancePropertiesFromJson(t, e, n) {
      let s = this._GetInstanceData(e, this._owner.GetRuntime());
      if (!s) return;
      const i = !n.hasOwnProperty("clearChildren") || n["clearChildren"], a = !n.hasOwnProperty("assignZIndex") || n["assignZIndex"], r = t.GetRuntime();
      if (updatedInstances.set(t.GetUID(), t), s = JSON.parse(JSON.stringify(s)), i && t.GetUID() !== s["uid"]) {
        for (const e2 of t.children()) e2 && !e2.IsDestroyed() && (r.DestroyInstance(e2), r._RemoveInstanceFromUIDMap(e2.GetUID()), updatedInstances.delete(e2.GetUID()));
        if (s["w"]?.["sgi"] && s["w"]["sgi"]["c"]?.length) for (const e2 of s["w"]["sgi"]["c"]) {
          const s2 = Object.assign({}, n, { "clearChildren": false, "createHierarchy": false }), i2 = this._CreateNewChildInstance(e2, s2);
          updatedInstances.set(i2.GetInstance().GetUID(), i2.GetInstance()), t.AddChild(i2.GetInstance(), this._GetFlagsObj(e2["f"])), i2._LoadSceneGraphPropertiesFromJson(e2["offsets"]), this._LoadInstancePropertiesFromJson(i2.GetInstance(), e2, s2);
        }
      }
      const h = s["w"]?.["zi"], c = s["w"]?.["l"];
      s["w"] = null, t.LoadFromJson(s), n?.setFromJson || (C32.IsFiniteNumber(h) && a && t.GetWorldInfo()._SetZIndex(h), C32.IsFiniteNumber(c) && t.MoveToLayerWithSID(c)), this._UpdateUIDInstanceMap(t, s["uid"], r, n);
    }
    _GetInstancesOfObjectClassCount(t, e) {
      return t.filter((t2) => t2.GetObjectClass().GetName() === e.GetName()).length;
    }
    _GetInstanceData(t, e) {
      if (C32.IsFiniteNumber(t["instIndex"])) {
        const n = e.GetObjectClassByIndex(t["oci"])._GetLoadInstancesJson();
        return n ? n[t["instIndex"]] : null;
      }
      return C32.IsString(t["inst"]) ? JSON.parse(t["inst"]) : t["inst"] ? t["inst"] : void 0;
    }
    static GetSceneGraphInstanceDataFromInstance(t) {
      let e = t.GetWorldInfo().GetLayer().GetInitialInstanceData(t.GetUID());
      if (!e) return null;
      e = JSON.parse(JSON.stringify(e));
      const n = [];
      for (const e2 of [...t.GetChildren()]) {
        const t2 = e2.GetWorldInfo();
        n.push([t2.GetLayout().GetSID(), t2.GetLayer().GetIndex(), e2.GetUID(), C32.SceneGraphInfo._GetFlagsNumber(t2), e2.GetObjectClass().IsInContainer() ? 1 : 0, t2.GetZIndex(), C32.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(e2)]);
      }
      return C32.IsArray(e[0][14]) ? e[0][14][1] = n : (e[0][14] = [], e[0][14][0] = C32.SceneGraphInfo._GetDefaultFlagsNumber(), e[0][14][1] = n, e[0][14][2] = t.GetWorldInfo().GetZIndex()), e;
    }
    static _GetFlagsNumber(t) {
      let e = 0;
      return e |= Number(t.GetTransformWithParentVisibility()) << 8, e |= Number(t.GetTransformWithParentOpacity()) << 7, e |= Number(t.GetTransformWithParentZElevation()) << 6, e |= Number(t.GetDestroyWithParent()) << 5, e |= Number(t.GetTransformWithParentAngle()) << 4, e |= Number(t.GetTransformWithParentHeight()) << 3, e |= Number(t.GetTransformWithParentWidth()) << 2, e |= Number(t.GetTransformWithParentY()) << 1, e |= Number(t.GetTransformWithParentX()) | 0, e;
    }
    static _GetDefaultFlagsNumber(t) {
      let e = 0;
      return e |= 256, e |= 128, e |= 64, e |= 32, e |= 16, e |= 8, e |= 4, e |= 2, e |= 1, 511;
    }
    static ClearUpdatedInstances() {
      updatedInstances.clear();
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad), bboxChangeEvent = C32.New(C32.Event, "bboxchange", false), tempColor = C32.New(C32.Color, 0, 0, 0, 0), tempCollisionPoly = C32.New(C32.CollisionPoly), DEFAULT_COLOR = C32.New(C32.Color, 1, 1, 1, 1), DEFAULT_RENDER_CELLS = C32.New(C32.Rect, 0, 0, -1, -1), DEFAULT_COLLISION_CELLS = C32.New(C32.Rect, 0, 0, -1, -1), VALID_SET_MESH_POINT_MODES = /* @__PURE__ */ new Set(["absolute", "relative"]), EMPTY_ARRAY = [];
  let enableUpdateRendererStateGroup = true;
  const FLAG_IS_VISIBLE = 1, FLAG_BBOX_CHANGED = 2, FLAG_ENABLE_BBOX_CHANGED_EVENT = 4, FLAG_COLLISION_ENABLED = 8, FLAG_COLLISION_CELL_CHANGED = 16, FLAG_SOLID_FILTER_INCLUSIVE = 32, FLAG_HAS_ANY_ACTIVE_EFFECT = 64, FLAG_IS_ROTATABLE = 128, FLAG_DESTROYED = 256, FLAG_DESTROY_WITH_PARENT = 512, FLAG_TRANSFORM_WITH_PARENT_X = 1024, FLAG_TRANSFORM_WITH_PARENT_Y = 2048, FLAG_TRANSFORM_WITH_PARENT_W = 4096, FLAG_TRANSFORM_WITH_PARENT_H = 8192, FLAG_TRANSFORM_WITH_PARENT_A = 16384, FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768, FLAG_TRANSFORM_WITH_PARENT_OPACITY = 1 << 22, FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 1 << 23, MASK_ALL_SCENE_GRAPH_FLAGS = 12647936, FLAG_MESH_CHANGED = 65536, FLAG_PHYSICS_BODY_CHANGED = 1 << 17, FLAG_SIN_COS_ANGLE_CHANGED = 1 << 18, FLAG_USE_POINTS_SHADER_PROGRAM = 1 << 19, FLAG_DRAW_BACK_FACE_ONLY = 1 << 20, FLAG_DRAW_NON_BACK_FACES_ONLY = 1 << 21, FLAG_ENABLE_BACK_FACE_CULLING = 1 << 24, FLAG_BLEND_MODE_BIT_OFFSET = 26, FLAG_BLEND_MODE_MASK = 31 << 26, sceneGraphExportDataMap = /* @__PURE__ */ new WeakMap(), sceneGraphZIndexMap = /* @__PURE__ */ new WeakMap();
  C32.WorldInfo = class extends C32.DefendedBase {
    constructor(t, e) {
      super(), this._inst = t, this._objectClass = t.GetObjectClass(), this._runtime = t.GetRuntime(), this._layer = e, this._objectClass._OnWorldInstanceLayerChanged(this, null, e), this._zIndex = -1, this._htmlZIndex = -1, this._flags = 196635, this._objectClass.GetPlugin().IsRotatable() && (this._flags |= 128), this._x = NaN, this._y = NaN, this._zElevation = NaN, this._w = NaN, this._h = NaN, this._depth = NaN, this._a = NaN, this._sinA = NaN, this._cosA = NaN, this._ox = NaN, this._oy = NaN, this._boundingBox = C32.New(C32.Rect), this._boundingQuad = C32.New(C32.Quad), this._collisionCells = DEFAULT_COLLISION_CELLS, this._renderCells = DEFAULT_RENDER_CELLS, this._sourceCollisionPoly = null, this._transformedPolyInfo = null, this._solidFilterTags = null, this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR, this._stateGroup = null, this._instanceEffectList = null, this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C32.New(C32.InstanceEffectList, this._inst, this)), this._sceneGraphInfo = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._tmpHierarchyPosition = -1, this._meshInfo = null;
    }
    _MarkDestroyed() {
      this._flags |= 256;
    }
    IsDestroyed() {
      return !!(256 & this._flags);
    }
    Release() {
      if (this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, null), this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null), this._sourceCollisionPoly = null, this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null), this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null), this.ReleaseMesh(), this._instanceEffectList && this._instanceEffectList.Release(), this.HasParent() && this.GetParent().RemoveChild(this), this.HasChildren()) {
        const t = [...this.GetChildren()];
        for (const e of t) this.RemoveChild(e);
      }
      this._ReleaseSceneGraphInfo(), this._ReleaseTmpSceneGraphInfo(), sceneGraphExportDataMap.delete(this), sceneGraphZIndexMap.delete(this), this._inst = null, this._objectClass = null, this._runtime = null, this._layer = null;
    }
    Init(t) {
      if (enableUpdateRendererStateGroup = false, this.SetXY(t[0], t[1]), this.SetZElevation(t[2]), this.SetSize(t[3], t[4]), this._depth = 0, this.IsRotatable() ? this.SetAngle(t[6]) : this._a = 0, tempColor.setFromJSON(t[7]), this._SetColor(tempColor), this.SetOriginX(t[8]), this.SetOriginY(t[9]), this.SetBlendMode(t[10]), this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(t[12]), t[14] && sceneGraphExportDataMap.set(this, { childrenData: t[14][1], zIndexData: t[14][2] }), t[15]) {
        const e = t[15];
        this.CreateMesh(e[0], e[1]);
        const s = this.GetSourceMesh(), i = e[2];
        for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {
          const e3 = i[t2];
          for (let i2 = 0, n = e3.length; i2 < n; ++i2) {
            const n2 = e3[i2], r = s.GetMeshPointAt(i2, t2);
            r.SetX(n2[0]), r.SetY(n2[1]), r.SetZElevation(n2[2]), r.SetU(n2[3]), r.SetV(n2[4]);
          }
        }
      }
      if (t[16]) {
        const e = t[16][0], s = t[16][1], i = !!s, n = !i, r = this._runtime.GetTemplateManager();
        i && r && r.MapInstanceToTemplateName(this.GetInstance(), s), n && r && r.MapInstanceToTemplateName(this.GetInstance(), e);
      }
      enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup();
    }
    InitNoData() {
      this._x = 0, this._y = 0, this._zElevation = 0, this._w = 0, this._h = 0, this._depth = 0, this._a = 0, this._sinA = 0, this._cosA = 1, this._ox = 0, this._oy = 0, this._UpdateRendererStateGroup();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetInstance() {
      return this._inst;
    }
    _GetParentOffsetAngle() {
      return this.GetTransformWithParentAngle() ? this._MaybeReflectAngleForMirrorFlip(this.GetParent()._GetAngleNoReflect() - this._sceneGraphInfo.GetParentStartAngle()) : 0;
    }
    SetX(t) {
      if (t = +t, this.GetTransformWithParentX()) {
        const e = this._sceneGraphInfo, s = t - this.GetX(), i = -this._GetParentOffsetAngle();
        0 === i ? this._x += s / e.GetParentScaleX() : (this._x += Math.cos(i) * s / e.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(i) * s / e.GetParentScaleY()));
      } else this._x = t;
    }
    OffsetX(t, e = false) {
      t = +t, e ? this._x += t : this.GetTransformWithParentX() ? this.SetX(this.GetX() + t) : this._x += t;
    }
    GetX() {
      if (this.GetTransformWithParentX()) {
        let t = this._x;
        const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();
        return 0 === i ? t *= e.GetParentScaleX() : (t = t * e.GetParentScaleX() * Math.cos(i), this.GetTransformWithParentY() && (t -= this._y * e.GetParentScaleY() * Math.sin(i))), s.GetX() + t;
      }
      return this._x;
    }
    SetY(t) {
      if (t = +t, this.GetTransformWithParentY()) {
        const e = this._sceneGraphInfo, s = t - this.GetY(), i = -this._GetParentOffsetAngle();
        0 === i ? this._y += s / e.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(i) * s / e.GetParentScaleX()), this._y += Math.cos(i) * s / e.GetParentScaleY());
      } else this._y = t;
    }
    OffsetY(t, e = false) {
      t = +t, e ? this._y += t : this.GetTransformWithParentY() ? this.SetY(this.GetY() + t) : this._y += t;
    }
    GetY() {
      if (this.GetTransformWithParentY()) {
        let t = this._y;
        const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();
        return 0 === i ? t *= e.GetParentScaleY() : (t = t * e.GetParentScaleY() * Math.cos(i), this.GetTransformWithParentX() && (t += this._x * e.GetParentScaleX() * Math.sin(i))), s.GetY() + t;
      }
      return this._y;
    }
    SetXY(t, e) {
      if (t = +t, e = +e, this.GetTransformWithParentXOrY()) {
        const s = this.GetTransformWithParentX(), i = this.GetTransformWithParentY(), n = this._sceneGraphInfo, r = t - this.GetX(), h = e - this.GetY(), a = -this._GetParentOffsetAngle();
        if (0 === a) s ? this._x += r / n.GetParentScaleX() : this._x = t, i ? this._y += h / n.GetParentScaleY() : this._y = e;
        else {
          const o = Math.sin(a), l = Math.cos(a);
          s ? this._x += i ? (l * r - o * h) / n.GetParentScaleX() : l * r / n.GetParentScaleX() : this._x = t, i ? this._y += s ? (o * r + l * h) / n.GetParentScaleY() : l * h / n.GetParentScaleY() : this._y = e;
        }
      } else this._x = t, this._y = e;
    }
    GetXY() {
      return [this.GetX(), this.GetY()];
    }
    OffsetXY(t, e) {
      t = +t, e = +e, this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + t, this.GetY() + e) : (this._x += t, this._y += e);
    }
    EqualsXY(t, e) {
      return this.GetX() === t && this.GetY() === e;
    }
    SetZElevation(t) {
      if (t = +t, this.GetTransformWithParentZElevation() && (t -= this.GetParent().GetZElevation()), this._zElevation === t) return;
      this._zElevation = t, this._UpdateZElevation();
      const e = this.GetLayer();
      0 !== this._zElevation && e._SetAnyInstanceZElevated(), e.SetZIndicesChanged(this);
    }
    _UpdateZElevation() {
      if (this._UpdateRendererStateGroup(), this.HasChildren()) {
        const t = this.GetChildren();
        for (let e = 0, s = t.length; e < s; e++) {
          const s2 = t[e];
          s2.GetTransformWithParentZElevation() && s2._UpdateZElevation();
        }
      }
    }
    OffsetZElevation(t) {
      this.SetZElevation(this.GetZElevation() + t);
    }
    GetZElevation() {
      return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation;
    }
    GetTotalZElevation() {
      return this.GetLayer().GetZElevation() + this.GetZElevation();
    }
    IsOriginalSizeKnown() {
      return this.GetInstance().GetPlugin().GetSdkVersion() < 2 && this.GetInstance().GetSdkInstance().IsOriginalSizeKnown();
    }
    SetWidth(t) {
      if (t = +t, this.GetTransformWithParentWidth()) {
        const e = this.GetWidth();
        0 === e ? this._w = Number.EPSILON : this._w *= t / e;
      } else this._w = t;
      this._MarkSinCosAngleChanged();
    }
    OffsetWidth(t, e) {
      t = +t, e ? this._w += t : this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + t) : this._w += t, this._MarkSinCosAngleChanged();
    }
    GetWidth() {
      if (this.GetTransformWithParentWidth()) {
        const t = this.GetParent(), e = t.GetWidth();
        return t._GetSceneGraphInfo()._GetStartWidth() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + e) * this._w : e * this._w;
      }
      return this._w;
    }
    SetHeight(t) {
      if (t = +t, this.GetTransformWithParentHeight()) {
        const e = this.GetHeight();
        0 === e ? this._h = Number.EPSILON : this._h *= t / e;
      } else this._h = t;
      this._MarkSinCosAngleChanged();
    }
    OffsetHeight(t, e) {
      t = +t, e ? this._h += t : this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + t) : this._h += t, this._MarkSinCosAngleChanged();
    }
    GetHeight() {
      if (this.GetTransformWithParentHeight()) {
        const t = this.GetParent(), e = t.GetHeight();
        return t._GetSceneGraphInfo()._GetStartHeight() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + e) * this._h : e * this._h;
      }
      return this._h;
    }
    SetSize(t, e) {
      if (t = +t, e = +e, this.GetTransformWithParentWidth()) {
        const e2 = this.GetWidth();
        0 === e2 ? this._w = Number.EPSILON : this._w *= t / e2;
      } else this._w = t;
      if (this.GetTransformWithParentHeight()) {
        const t2 = this.GetHeight();
        0 === t2 ? this._h = Number.EPSILON : this._h *= e / t2;
      } else this._h = e;
      this._MarkSinCosAngleChanged();
    }
    GetSize() {
      return [this.GetWidth(), this.GetHeight()];
    }
    GetDepth() {
      return this._depth;
    }
    SetDepth(t) {
      if (t < 0) throw new RangeError("invalid depth");
      this._depth = t;
    }
    GetSceneGraphScale() {
      if (this.HasParent()) {
        const t = this._sceneGraphInfo;
        return Math.min(t.GetParentScaleX(), t.GetParentScaleY());
      }
      return 1;
    }
    IsRotatable() {
      return !!(128 & this._flags);
    }
    SetAngle(t) {
      t = +t, this.IsRotatable() && (this.GetTransformWithParentAngle() && (t -= this.GetParent().GetAngle()), t = C32.clampAngle(t), this._a !== t && (this._a = t, this._MarkSinCosAngleChanged()));
    }
    OffsetAngle(t) {
      0 !== (t = +t) && this.IsRotatable() && (this._a = C32.clampAngle(this._a + t), this._MarkSinCosAngleChanged());
    }
    _MarkSinCosAngleChanged() {
      if (this._flags |= 262144, this.HasChildren()) {
        const t = this.GetChildren();
        for (let e = 0, s = t.length; e < s; e++) t[e]._MarkSinCosAngleChanged();
      }
    }
    GetAngle() {
      return this.GetTransformWithParentAngle() && this.IsRotatable() ? this._MaybeReflectAngleForMirrorFlip(C32.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a)) : this._a;
    }
    _GetAngleNoReflect() {
      return this.GetTransformWithParentAngle() && this.IsRotatable() ? C32.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a) : this._a;
    }
    _MaybeReflectAngleForMirrorFlip(t) {
      return this.GetTransformWithParentWidth() && this.GetTopParent().GetWidth() < 0 && (t = C32.clampAngle(C32.angleReflect(t, this.GetTopParent().GetAngle() + Math.PI))), this.GetTransformWithParentHeight() && this.GetTopParent().GetHeight() < 0 && (t = C32.angleReflect(t, this.GetTopParent().GetAngle())), t;
    }
    _NeedsReflectAngleForMirrorOrFlip() {
      const t = this.GetParent();
      return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0) || !!(this.GetTransformWithParentHeight() && t.GetHeight() < 0);
    }
    _NeedsReflectAngleForMirrorAndFlip() {
      const t = this.GetParent();
      return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0 && this.GetTransformWithParentHeight() && t.GetHeight() < 0);
    }
    _MaybeUpdateSinCosAngle() {
      const t = this._flags;
      if (!(262144 & t)) return;
      const e = this.GetAngle();
      this._sinA = Math.sin(e), this._cosA = Math.cos(e), this._flags = -262145 & t;
    }
    GetSinAngle() {
      return this._MaybeUpdateSinCosAngle(), this._sinA;
    }
    GetCosAngle() {
      return this._MaybeUpdateSinCosAngle(), this._cosA;
    }
    SetOriginX(t) {
      this._ox = +t;
    }
    OffsetOriginX(t) {
      this._ox += +t;
    }
    GetOriginX() {
      return this._ox;
    }
    SetOriginY(t) {
      this._oy = +t;
    }
    OffsetOriginY(t) {
      this._oy += +t;
    }
    GetOriginY() {
      return this._oy;
    }
    _SetColor(t) {
      this._color.equals(t) || (this._color === DEFAULT_COLOR ? (this._color = C32.New(C32.Color, t), this._colorPremultiplied = C32.New(C32.Color, t), this._colorPremultiplied.premultiply()) : t.equalsRgba(1, 1, 1, 1) ? (this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR) : (this._color.set(t), this._colorPremultiplied.set(t), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup());
    }
    SetOpacity(t) {
      if (t = C32.clamp(+t, 0, 1), this.GetTransformWithParentOpacity()) {
        if (this._GetSceneGraphInfo().GetOwnOpacity() === t) return;
        this._GetSceneGraphInfo().SetOwnOpacity(t), t = this.GetOpacity();
      } else if (this._color.a === t) return;
      this._SetColorWithOpacity(t);
    }
    _SetOpacityOfChildren() {
      if (!this.HasChildren()) return;
      const t = this.GetChildren();
      for (let e = 0, s = t.length; e < s; e++) {
        const s2 = t[e];
        s2._SetColorWithOpacity(s2.GetOpacity());
      }
    }
    _SetColorWithOpacity(t) {
      tempColor.copyRgb(this._color), tempColor.a = t, this._SetColor(tempColor), this._SetOpacityOfChildren();
    }
    OffsetOpacity(t) {
      this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + t) : this.SetOpacity(this.GetOpacity() + t);
    }
    GetOpacity() {
      return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a;
    }
    SetUnpremultipliedColor(t) {
      this._color.equalsIgnoringAlpha(t) || (tempColor.copyRgb(t), tempColor.a = this.GetOpacity(), this._SetColor(tempColor));
    }
    SetUnpremultipliedColorRGB(t, e, s) {
      tempColor.setRgb(t, e, s), this.SetUnpremultipliedColor(tempColor);
    }
    OffsetUnpremultipliedColorRGB(t, e, s) {
      0 === t && 0 === e && 0 === s || (tempColor.copyRgb(this._color), tempColor.r += t, tempColor.g += e, tempColor.b += s, this.SetUnpremultipliedColor(tempColor));
    }
    GetUnpremultipliedColor() {
      return this._color;
    }
    GetPremultipliedColor() {
      return this._colorPremultiplied;
    }
    GetDestroyWithParent() {
      return !!(512 & this._flags);
    }
    SetDestroyWithParent(t) {
      this._SetFlag(512, t);
    }
    GetTransformWithParentX() {
      return !!(1024 & this._flags);
    }
    SetTransformWithParentX(t) {
      this._SetFlag(1024, t);
    }
    GetTransformWithParentY() {
      return !!(2048 & this._flags);
    }
    GetTransformWithParentXOrY() {
      return !!(3072 & this._flags);
    }
    SetTransformWithParentY(t) {
      this._SetFlag(2048, t);
    }
    GetTransformWithParentWidth() {
      return !!(4096 & this._flags);
    }
    SetTransformWithParentWidth(t) {
      this._SetFlag(4096, t);
    }
    GetTransformWithParentHeight() {
      return !!(8192 & this._flags);
    }
    SetTransformWithParentHeight(t) {
      this._SetFlag(8192, t);
    }
    GetTransformWithParentAngle() {
      return !!(16384 & this._flags);
    }
    SetTransformWithParentAngle(t) {
      this._SetFlag(16384, t);
    }
    GetTransformWithParentZElevation() {
      return !!(32768 & this._flags);
    }
    SetTransformWithParentZElevation(t) {
      this._SetFlag(32768, t);
    }
    GetTransformWithParentOpacity() {
      return !!(4194304 & this._flags);
    }
    SetTransformWithParentOpacity(t) {
      this._SetFlag(4194304, t);
    }
    GetTransformWithParentVisibility() {
      return !!(8388608 & this._flags);
    }
    SetTransformWithParentVisibility(t) {
      this._SetFlag(8388608, t);
    }
    _ClearAllSceneGraphFlags() {
      this._flags &= -12647937;
    }
    AddChild(t, e) {
      if (t === this) return false;
      if (t.HasParent()) return false;
      if (this._HasChildRecursive(t)) return false;
      if (this._HasAnyParent(t)) return false;
      const s = t.GetX(), i = t.GetY(), n = t.GetWidth(), r = t.GetHeight(), h = t.GetAngle(), a = t.GetZElevation(), o = t.GetOpacity();
      t._SetParent(this), t.SetTransformWithParentX(e.transformX), t.SetTransformWithParentY(e.transformY), t.SetTransformWithParentWidth(e.transformWidth), t.SetTransformWithParentHeight(e.transformHeight), t.SetTransformWithParentAngle(e.transformAngle), t.SetTransformWithParentZElevation(e.transformZElevation), t.SetTransformWithParentOpacity(e.transformOpacity), t.SetTransformWithParentVisibility(e.transformVisibility), t.SetDestroyWithParent(e.destroyWithParent);
      const l = s - this.GetX(), _ = i - this.GetY(), G = -this.GetAngle(), c = Math.cos(G), d = Math.sin(G);
      if (e.transformX && (e.transformAngle ? t._x = l * c - _ * d : t._x = l, e.transformWidth)) {
        const e2 = this.GetWidth() / this._sceneGraphInfo._GetStartWidth();
        0 !== e2 && (t._x /= e2);
      }
      if (e.transformY && (e.transformAngle ? t._y = l * d + _ * c : t._y = _, e.transformHeight)) {
        const e2 = this.GetHeight() / this._sceneGraphInfo._GetStartHeight();
        0 !== e2 && (t._y /= e2);
      }
      if (e.transformWidth) {
        const e2 = this.GetWidth();
        0 === e2 || e2 === Number.EPSILON ? (t._w = 1, t._sceneGraphInfo.SetStartScaleX(1)) : (t._w = n / this.GetWidth(), t._sceneGraphInfo.SetStartScaleX(t._w));
      }
      if (e.transformHeight) {
        const e2 = this.GetHeight();
        0 === e2 || e2 === Number.EPSILON ? (t._h = 1, t._sceneGraphInfo.SetStartScaleY(1)) : (t._h = r / this.GetHeight(), t._sceneGraphInfo.SetStartScaleY(t._h));
      }
      return e.transformAngle && (t._a = h - this.GetAngle()), e.transformZElevation && (t._zElevation = a - this.GetZElevation()), e.transformOpacity && t._sceneGraphInfo.SetOwnOpacity(o), e.transformVisibility && t.SetVisible(this.IsVisible()), this._AddChildToSceneGraphInfo(t), this.SetBboxChanged(), this._SetOpacityOfChildren(), true;
    }
    RemoveChild(t) {
      if (t.GetParent() !== this) return;
      const e = t.GetX(), s = t.GetY(), i = t.GetWidth(), n = t.GetHeight(), r = t.GetAngle(), h = t.GetZElevation(), a = t.GetOpacity();
      t._SetParent(null), t._ClearAllSceneGraphFlags(), t.SetXY(e, s), t.SetSize(i, n), t.SetAngle(r), t.SetZElevation(h), t.SetOpacity(a), this._RemoveChildFromSceneGraphInfo(t), this.SetBboxChanged();
    }
    GetTmpHierarchyPosition() {
      return this._tmpHierarchyPosition;
    }
    _ResetAllSceneGraphState() {
      this._BuildTmpSceneGraphData();
      const t = [...this.children()];
      for (const e2 of t) this.RemoveChild(e2);
      const e = this.GetParent();
      e && e.RemoveChild(this), this._ClearAllSceneGraphFlags();
    }
    _BuildTmpSceneGraphData() {
      if (this._SetTmpHierarchyPosition(), !this._tmpSceneGraphChildren) {
        const t2 = [...this.children()];
        t2.length && (this._tmpSceneGraphChildren = [], this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());
        let e = 0;
        for (const s of t2) {
          const t3 = s.GetInstance();
          this._tmpSceneGraphChildren.push(t3), this._tmpSceneGraphChildrenIndexes.set(t3, e), e++;
        }
      }
      const t = this.GetParent();
      t && t._BuildTmpSceneGraphData();
    }
    _SetTmpHierarchyPosition() {
      if (-1 !== this._tmpHierarchyPosition) return;
      const t = [...this.parents()];
      this._tmpHierarchyPosition = t.length;
      for (const e2 of t) e2._SetTmpHierarchyPosition();
      const e = [...this.children()];
      for (const t2 of e) t2._SetTmpHierarchyPosition();
    }
    _ReleaseTmpSceneGraphInfo() {
      this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null;
      const t = this.GetParent();
      t && t._ReleaseTmpSceneGraphInfo(), this._tmpHierarchyPosition = -1;
    }
    HasParent() {
      return null !== this.GetParent();
    }
    GetParent() {
      const t = this._sceneGraphInfo;
      return null !== t ? t.GetParent() : null;
    }
    GetTopParent() {
      let t = this;
      for (; t.HasParent(); ) t = t.GetParent();
      return t;
    }
    *parents() {
      let t = this.GetParent();
      for (; t; ) yield t, t = t.GetParent();
    }
    HasChild(t) {
      return this.GetChildren().includes(t);
    }
    HasChildren() {
      const t = this._sceneGraphInfo;
      return null !== t && t.HasChildren();
    }
    GetChildren() {
      const t = this._sceneGraphInfo;
      return null !== t ? t.GetChildren() : EMPTY_ARRAY;
    }
    children() {
      return this.GetChildren();
    }
    *allChildren() {
      for (const t of this.children()) yield t, yield* t.allChildren();
    }
    GetChildCount() {
      return this.GetChildren().length;
    }
    GetAllChildCount() {
      return [...this.allChildren()].length;
    }
    GetChildAt(t) {
      const e = this.GetChildren();
      return (t = Math.floor(+t)) < 0 || t >= e.length ? null : e[t];
    }
    GetChildIndex(t) {
      if (!t) return NaN;
      const e = this.GetChildren();
      if (!e) return NaN;
      for (let s = 0; s < e.length; s++) if (t === e[s]) return s;
      return NaN;
    }
    _CreateSceneGraphInfo(t) {
      this._sceneGraphInfo || (this._sceneGraphInfo = C32.New(C32.SceneGraphInfo, this)), t && this._sceneGraphInfo.SetParent(t);
    }
    _GetSceneGraphInfo() {
      return this._sceneGraphInfo;
    }
    _ReleaseSceneGraphInfo() {
      this._sceneGraphInfo && (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null);
    }
    _SetParent(t) {
      t ? (t._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(t)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo());
    }
    _HasAnyParent(t) {
      if (!this.HasParent()) return false;
      const e = this.GetParent();
      return e === t || e._HasAnyParent(t);
    }
    _HasChildRecursive(t) {
      if (this.HasChild(t)) return true;
      for (const e of this.GetChildren()) if (e._HasChildRecursive(t)) return true;
      return false;
    }
    _AddChildToSceneGraphInfo(t) {
      this._sceneGraphInfo.GetChildren().push(t);
    }
    _RemoveChildFromSceneGraphInfo(t) {
      const e = this._sceneGraphInfo.GetChildren(), s = e.indexOf(t);
      -1 !== s && e.splice(s, 1), 0 !== e.length || this.HasParent() || this._ReleaseSceneGraphInfo(), t.HasChildren() || t._ReleaseSceneGraphInfo();
    }
    GetSceneGraphChildrenExportData() {
      const t = sceneGraphExportDataMap.get(this);
      return t ? t.childrenData : null;
    }
    GetSceneGraphZIndexExportData() {
      const t = sceneGraphExportDataMap.get(this);
      return t ? t.zIndexData : NaN;
    }
    GetSceneGraphZIndex() {
      const t = sceneGraphZIndexMap.get(this);
      return C32.IsFiniteNumber(t) ? t : NaN;
    }
    SetSceneGraphZIndex(t) {
      sceneGraphZIndexMap.set(this, t);
    }
    SetUsePointsShaderProgram() {
      this._SetFlag(524288, true), this._UpdateRendererStateGroup();
    }
    _UpdateRendererStateGroup() {
      if (!enableUpdateRendererStateGroup) return;
      const t = this._runtime.GetRenderer();
      let e;
      this._stateGroup && t.ReleaseStateGroup(this._stateGroup), e = 524288 & this._flags ? t.GetPointsRenderingProgram() || "<point>" : t.GetTextureFillShaderProgram() || "<default>", this._stateGroup = t.AcquireStateGroup(e, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation(), this.IsBackFaceCulling() ? 1 : 0, 0);
    }
    GetRendererStateGroup() {
      return this._stateGroup;
    }
    HasDefaultColor() {
      return this._color === DEFAULT_COLOR;
    }
    SetBlendMode(t) {
      if ((t |= 0) < 0 || t > 31) throw new RangeError("invalid blend mode");
      this.GetBlendMode() !== t && (this._flags = -2080374785 & this._flags | t << 26, this._UpdateRendererStateGroup());
    }
    GetBlendMode() {
      return (2080374784 & this._flags) >> 26;
    }
    _SetLayer(t, e) {
      const s = e && this._layer !== t;
      s && this._RemoveFromRenderCells(), this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, t), this._layer = t, s && this._UpdateRenderCell(), 0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated();
    }
    GetLayer() {
      return this._layer;
    }
    GetLayout() {
      return this.GetLayer().GetLayout();
    }
    _SetZIndex(t) {
      this._zIndex = 0 | t;
    }
    GetZIndex() {
      return this._layer._UpdateZIndices(), this._zIndex;
    }
    _SetHTMLZIndex(t) {
      this._htmlZIndex = 0 | t;
    }
    GetHTMLZIndex() {
      return this._layer._UpdateHTMLZIndices(), this._htmlZIndex;
    }
    _GetLastCachedZIndex() {
      return this._zIndex;
    }
    _SetFlag(t, e) {
      e ? this._flags |= t : this._flags &= ~t;
    }
    IsVisible() {
      return !!(1 & this._flags);
    }
    SetVisible(t) {
      if (this._SetFlag(1, t), this.HasChildren()) for (const e of this.GetChildren()) e.GetTransformWithParentVisibility() && e.SetVisible(t);
    }
    IsCollisionEnabled() {
      return !!(8 & this._flags);
    }
    SetCollisionEnabled(t) {
      t = !!t, this.IsCollisionEnabled() !== t && (this._SetFlag(8, t), t ? this.SetBboxChanged() : this._RemoveFromCollisionCells());
    }
    SetSolidCollisionFilter(t, e) {
      this._SetFlag(32, t), this._solidFilterTags && this._solidFilterTags.clear();
      for (const t2 of e) this._solidFilterTags || (this._solidFilterTags = /* @__PURE__ */ new Set()), this._solidFilterTags.add(t2.toLowerCase());
      this._solidFilterTags && 0 === this._solidFilterTags.size && (this._solidFilterTags = null);
    }
    IsSolidCollisionAllowed(t) {
      const e = t._IsSolidUsingInstanceTags() ? t._GetLowercaseTagsSetMaybeNull() : t.GetSavedDataMap().get("solidTags"), s = !!(32 & this._flags), i = this._solidFilterTags;
      if (!e || !i) return !s;
      for (const t2 of i) if (e.has(t2)) return s;
      return !s;
    }
    SetBboxChanged() {
      if (this._flags |= 65554, this._objectClass._SetAnyCollisionCellChanged(true), this._runtime.UpdateRender(), this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags &= -3, this._UpdateRenderCell()), 4 & this._flags && this._inst.Dispatcher().dispatchEvent(bboxChangeEvent), null !== this._sceneGraphInfo) {
        const t = this._sceneGraphInfo.GetChildren();
        for (let e = 0, s = t.length; e < s; ++e) t[e].SetBboxChanged();
      }
    }
    CalculateBbox(t, e, s) {
      const i = this.GetX(), n = this.GetY(), r = this.GetWidth(), h = this.GetHeight(), a = this.GetAngle();
      t.setWH(i - this._ox * r, n - this._oy * h, r, h), s && this.HasMesh() && this._ExpandBboxForMesh(t), 0 === a ? e.setFromRect(t) : (t.offset(-i, -n), e.setFromRotatedRectPrecalc(t, this.GetSinAngle(), this.GetCosAngle()), e.offset(i, n), e.getBoundingBox(t)), t.normalize();
    }
    _UpdateBbox() {
      const t = this._flags;
      2 & t && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags = -3 & t);
    }
    GetBoundingBox() {
      return this._UpdateBbox(), this._boundingBox;
    }
    GetBoundingQuad() {
      return this._UpdateBbox(), this._boundingQuad;
    }
    PixelRoundQuad(t) {
      const e = this.GetX(), s = this.GetY(), i = Math.round(e) - e, n = Math.round(s) - s;
      return 0 === i && 0 === n ? t : (tempQuad.copy(t), tempQuad.offset(i, n), tempQuad);
    }
    OverwriteBoundingBox(t) {
      this._boundingBox.copy(t), this._boundingQuad.setFromRect(this._boundingBox), this._flags &= -3, this._UpdateCollisionCell(), this._UpdateRenderCell();
    }
    SetBboxChangeEventEnabled(t) {
      this._SetFlag(4, t);
    }
    IsBboxChangeEventEnabled() {
      return !!(4 & this._flags);
    }
    IsInViewport(t, e, s) {
      return e && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || s ? t.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated();
    }
    _IsInViewport_ZElevated() {
      const t = this.GetLayer(), e = this.GetTotalZElevation();
      return !(e >= t.Get2DCameraZ()) && (t.GetViewportForZ(e, tempRect), tempRect.intersectsRect(this.GetBoundingBox()));
    }
    IsInViewport3D(t) {
      const e = this.GetBoundingBox(), s = e.getLeft(), i = e.getRight(), n = e.getTop(), r = e.getBottom(), h = this.GetTotalZElevation(), a = h + this.GetDepth();
      return t.ContainsAABB(s, n, h, i, r, a);
    }
    IsInViewport2() {
      const t = this.GetLayer();
      if (t.Has3DCamera()) return this.IsInViewport3D(t._GetViewFrustum());
      {
        const e = t.GetLayout();
        return this.IsInViewport(t.GetViewport(), e.HasVanishingPointOutsideViewport(), e.IsOrthographicProjection());
      }
    }
    _SetDrawBackFaceOnly(t) {
      this._SetFlag(1048576, t);
    }
    _SetDrawNonBackFacesOnly(t) {
      this._SetFlag(2097152, t);
    }
    IsDrawBackFaceOnly() {
      return !!(1048576 & this._flags);
    }
    IsDrawNonBackFacesOnly() {
      return !!(2097152 & this._flags);
    }
    SetBackFaceCulling(t) {
      (t = !!t) !== this.IsBackFaceCulling() && (this._SetFlag(16777216, t), this._UpdateRendererStateGroup());
    }
    IsBackFaceCulling() {
      return !!(16777216 & this._flags);
    }
    SetSourceCollisionPoly(t) {
      this._sourceCollisionPoly = t, this._DiscardTransformedCollisionPoly(), this.HasMesh() && (this._meshInfo.meshPoly = null);
    }
    GetSourceCollisionPoly() {
      return this._sourceCollisionPoly;
    }
    HasOwnCollisionPoly() {
      return null !== this._sourceCollisionPoly || this.HasMesh();
    }
    GetTransformedCollisionPoly() {
      return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle());
    }
    GetCustomTransformedCollisionPoly(t, e, s) {
      let i = 0, n = 1;
      return 0 !== s && (i = Math.sin(s), n = Math.cos(s)), this._GetCustomTransformedCollisionPolyPrecalc(t, e, s, i, n);
    }
    _GetCustomTransformedCollisionPolyPrecalc(t, e, s, i, n) {
      let r = this._transformedPolyInfo;
      null === r && (r = { poly: C32.New(C32.CollisionPoly), width: NaN, height: NaN, angle: NaN }, this._transformedPolyInfo = r);
      const h = r.poly;
      if (r.width === t && r.height === e && r.angle === s) return h;
      const a = this._sourceCollisionPoly;
      if (this.HasMesh()) {
        const s2 = this.GetOriginX(), r2 = this.GetOriginY(), o = this.GetSourceMesh();
        let l = this._meshInfo.meshPoly;
        l || (a ? (tempCollisionPoly.copy(a), tempCollisionPoly.offset(s2, r2)) : tempCollisionPoly.setDefaultPoints(), l = o.InsertPolyMeshVertices(tempCollisionPoly), this._meshInfo.meshPoly = l), o.TransformCollisionPoly(l, h), h.offset(-s2, -r2), h.transformPrecalc(t, e, i, n);
      } else a ? (h.copy(a), h.transformPrecalc(t, e, i, n)) : h.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
      return r.width = t, r.height = e, r.angle = s, h;
    }
    _DiscardTransformedCollisionPoly() {
      this.SetPhysicsBodyChanged(true);
      const t = this._transformedPolyInfo;
      null !== t && (t.width = NaN);
    }
    CreateMesh(t, e) {
      if (t = Math.floor(t), e = Math.floor(e), !this.GetInstance().GetPlugin().SupportsMesh()) throw new Error("object does not support mesh");
      this.ReleaseMesh(), this._meshInfo = { sourceMesh: C32.New(C32.Gfx.Mesh, t, e), transformedMesh: C32.New(C32.Gfx.Mesh, t, e), meshPoly: null };
    }
    HasMesh() {
      return null !== this._meshInfo;
    }
    GetSourceMesh() {
      if (!this.HasMesh()) throw new Error("no mesh");
      return this._meshInfo.sourceMesh;
    }
    GetTransformedMesh() {
      if (!this.HasMesh()) throw new Error("no mesh");
      return this._meshInfo.transformedMesh;
    }
    SetMeshChanged(t) {
      this._SetFlag(65536, t);
    }
    IsMeshChanged() {
      return !!(65536 & this._flags);
    }
    SetPhysicsBodyChanged(t) {
      this._SetFlag(131072, t);
    }
    IsPhysicsBodyChanged() {
      return !!(131072 & this._flags);
    }
    _ExpandBboxForMesh(t) {
      const e = this._meshInfo.sourceMesh, s = Math.min(e.GetMinX(), 0), i = Math.min(e.GetMinY(), 0), n = Math.max(e.GetMaxX(), 1), r = Math.max(e.GetMaxY(), 1), h = t.width(), a = t.height();
      t.offsetLeft(s * h), t.offsetTop(i * a), t.offsetRight((n - 1) * h), t.offsetBottom((r - 1) * a), this._depth = e.GetMaxZ();
    }
    ReleaseMesh() {
      this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly());
    }
    SetMeshPoint(t, e, s) {
      t = Math.floor(t), e = Math.floor(e);
      const i = s.mode || "absolute";
      if (!VALID_SET_MESH_POINT_MODES.has(i)) throw new Error("invalid mode");
      const n = "relative" === i;
      let r = s.x, h = s.y;
      const a = s.zElevation;
      let o = "number" == typeof s.u ? s.u : n ? 0 : -1, l = "number" == typeof s.v ? s.v : n ? 0 : -1;
      if (!this.HasMesh()) return false;
      const _ = this.GetSourceMesh(), G = _.GetMeshPointAt(t, e);
      if (null === G) return false;
      let c = false;
      return "number" == typeof a && G.GetZElevation() !== a && (G.SetZElevation(a), c = true), n && (r += t / (_.GetHSize() - 1), h += e / (_.GetVSize() - 1)), -1 !== o || n ? (n && (o += t / (_.GetHSize() - 1)), o = C32.clamp(o, 0, 1)) : o = G.GetU(), -1 !== l || n ? (n && (l += e / (_.GetVSize() - 1)), l = C32.clamp(l, 0, 1)) : l = G.GetV(), G.GetX() === r && G.GetY() === h && G.GetU() === o && G.GetV() === l ? c : (G.SetX(r), G.SetY(h), G.SetU(o), G.SetV(l), this._DiscardTransformedCollisionPoly(), true);
    }
    HasTilemap() {
      return this._inst.HasTilemap();
    }
    ContainsPoint(t, e) {
      return !!this.GetBoundingBox().containsPoint(t, e) && (!!this.GetBoundingQuad().containsPoint(t, e) && (this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(t, e) : !this.HasOwnCollisionPoly() || this.GetTransformedCollisionPoly().containsPoint(t - this.GetX(), e - this.GetY())));
    }
    _IsCollisionCellChanged() {
      return !!(16 & this._flags);
    }
    _UpdateCollisionCell() {
      if (!this._IsCollisionCellChanged() || !this.IsCollisionEnabled() || this.IsDestroyed()) return;
      const t = this.GetBoundingBox(), e = this._objectClass._GetCollisionCellGrid(), s = this._collisionCells;
      if (tempRect.set(e.XToCell(t.getLeft()), e.YToCell(t.getTop()), e.XToCell(t.getRight()), e.YToCell(t.getBottom())), s.equals(tempRect)) return;
      const i = this._inst;
      s === DEFAULT_COLLISION_CELLS ? (e.Update(i, null, tempRect), this._collisionCells = C32.New(C32.Rect, tempRect)) : (e.Update(i, s, tempRect), s.copy(tempRect)), this._flags &= -17;
    }
    _SetCollisionCellChanged() {
      this._flags |= 16;
    }
    _RemoveFromCollisionCells() {
      const t = this._collisionCells;
      t !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst, t, null), this._collisionCells = DEFAULT_COLLISION_CELLS);
    }
    _UpdateRenderCell() {
      const t = this.GetLayer();
      if (!t.UsesRenderCells() || this.IsDestroyed()) return;
      const e = t.GetRenderGrid(), s = this.GetBoundingBox(), i = this._renderCells;
      if (tempRect.set(e.XToCell(s.getLeft()), e.YToCell(s.getTop()), e.XToCell(s.getRight()), e.YToCell(s.getBottom())), i.equals(tempRect)) return;
      const n = this._inst;
      i === DEFAULT_RENDER_CELLS ? (e.Update(n, null, tempRect), this._renderCells = C32.New(C32.Rect, tempRect)) : (e.Update(n, i, tempRect), i.copy(tempRect)), t.SetRenderListStale();
    }
    _RemoveFromRenderCells() {
      const t = this._renderCells;
      t !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, t, null), this._renderCells = DEFAULT_RENDER_CELLS);
    }
    GetRenderCellRange() {
      return this._renderCells;
    }
    ZOrderMoveToTop() {
      if (this.IsDestroyed()) return;
      const t = this._inst, e = this._layer, s = e._GetInstances();
      s.length && s.at(-1) === t || (e._RemoveInstance(t, false), e._AddInstance(t, false), this._runtime.UpdateRender());
    }
    ZOrderMoveToBottom() {
      if (this.IsDestroyed()) return;
      const t = this._inst, e = this._layer, s = e._GetInstances();
      s.length && s[0] === t || (e._RemoveInstance(t, false), e._PrependInstance(t, false), this._runtime.UpdateRender());
    }
    ZOrderMoveToLayer(t) {
      if (this.IsDestroyed()) return;
      const e = this._inst, s = this._layer;
      if (s.GetLayout() !== t.GetLayout()) throw new Error("layer from different layout");
      t !== s && (s._RemoveInstance(e, true), this._SetLayer(t), t._AddInstance(e, true), this._runtime.UpdateRender());
    }
    ZOrderMoveAdjacentToInstance(t, e) {
      if (this.IsDestroyed()) return;
      const s = this._inst;
      let i = false;
      const n = this._layer;
      if (t.GetUID() === s.GetUID()) return;
      const r = t.GetWorldInfo();
      if (!r) throw new Error("expected world instance");
      const h = r.GetLayer();
      n.GetIndex() !== h.GetIndex() && (n._RemoveInstance(s, true), this._SetLayer(h), h._AddInstance(s, true), i = true);
      const a = h.MoveInstanceAdjacent(s, t, !!e);
      (i || a) && this._runtime.UpdateRender();
    }
    GetInstanceEffectList() {
      return this._instanceEffectList;
    }
    _SetHasAnyActiveEffect(t) {
      this._SetFlag(64, t);
    }
    HasAnyActiveEffect() {
      return !!(64 & this._flags);
    }
    _SaveToJson(t, e = null) {
      const s = { "x": this.GetX(), "y": this.GetY(), "w": this.GetWidth(), "h": this.GetHeight(), "l": this.GetLayer().GetSID(), "zi": this.GetZIndex() };
      0 !== this.GetZElevation() && (s["ze"] = this.GetZElevation()), 0 !== this.GetAngle() && (s["a"] = this._GetAngleNoReflect()), this.HasDefaultColor() || (s["c"] = this._color.toJSON()), 0.5 !== this.GetOriginX() && (s["oX"] = this.GetOriginX()), 0.5 !== this.GetOriginY() && (s["oY"] = this.GetOriginY()), 0 !== this.GetBlendMode() && (s["bm"] = this.GetBlendMode()), this.IsVisible() || (s["v"] = this.IsVisible()), this.IsCollisionEnabled() || (s["ce"] = this.IsCollisionEnabled()), this.IsBboxChangeEventEnabled() && (s["be"] = this.IsBboxChangeEventEnabled()), this._instanceEffectList && (s["fx"] = this._instanceEffectList._SaveToJson());
      const i = !!(32 & this._flags);
      return i && (s["sfi"] = i), this._solidFilterTags && (s["sft"] = [...this._solidFilterTags].join(" ")), this._sceneGraphInfo && "visual-state" !== t && (s["sgi"] = this._sceneGraphInfo._SaveToJson(t, e), sceneGraphExportDataMap.has(this) && (s["sgcd"] = sceneGraphExportDataMap.get(this).childrenData, s["sgzid"] = sceneGraphExportDataMap.get(this).zIndexData)), this.HasMesh() && (s["mesh"] = this.GetSourceMesh().SaveToJson()), s;
    }
    _SaveSceneGraphPropertiesToJson() {
      return { "x": this._x, "y": this._y, "z": this._zElevation, "w": this._w, "h": this._h, "a": this._a, "sgi": this._GetSceneGraphInfo() ? this._GetSceneGraphInfo()._SaveToJsonProperties() : null };
    }
    _LoadSceneGraphPropertiesFromJson(t) {
      t && (this._x = t["x"], this._y = t["y"], this._zElevation = t["z"], this._w = t["w"], this._h = t["h"], this._a = t["a"], t["sgi"] && this._GetSceneGraphInfo() && this._GetSceneGraphInfo()._LoadFromJson(t["sgi"]), this._MarkSinCosAngleChanged(), this.SetBboxChanged());
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
      this._ReleaseTmpSceneGraphInfo(), this._ResetAllSceneGraphState(), this._CreateSceneGraphInfo(null), this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes);
    }
    _OnBeforeLoad(t) {
      "visual-state" !== t && this._ResetAllSceneGraphState();
    }
    _OnAfterLoad(t, e = "full", s = null) {
      if (t.hasOwnProperty("sgi") && "visual-state" !== e) {
        if (this.IsDestroyed()) return;
        this._sceneGraphInfo._OnAfterLoad(t["sgi"], s);
      }
    }
    _OnAfterLoad2(t, e = "full", s = null) {
      if ("visual-state" !== e) if (this.IsDestroyed()) this._ReleaseTmpSceneGraphInfo();
      else {
        if (t.hasOwnProperty("sgi")) this._sceneGraphInfo._SetTmpSceneGraphChildren(null, null, t["sgi"], s);
        else if (s?.setFromJson && this._tmpSceneGraphChildren) for (const t2 of this._tmpSceneGraphChildren) t2.IsDestroyed() || this._runtime.DestroyInstance(t2);
        this._ReleaseTmpSceneGraphInfo(), this.SetBboxChanged();
      }
    }
    _LoadFromJson(t, e, s = null) {
      if (enableUpdateRendererStateGroup = false, this.SetX(t["x"]), this.SetY(t["y"]), this.SetWidth(t["w"]), this.SetHeight(t["h"]), this._SetZIndex(t["zi"]), this.SetZElevation(t.hasOwnProperty("ze") ? t["ze"] : 0), this.SetAngle(t.hasOwnProperty("a") ? t["a"] : 0), t.hasOwnProperty("c") ? tempColor.setFromJSON(t["c"]) : t.hasOwnProperty("o") ? (tempColor.copyRgb(this._color), tempColor.a = t["o"]) : tempColor.setRgba(1, 1, 1, 1), this._SetColor(tempColor), this.SetOriginX(t.hasOwnProperty("oX") ? t["oX"] : 0.5), this.SetOriginY(t.hasOwnProperty("oY") ? t["oY"] : 0.5), this.SetBlendMode(t.hasOwnProperty("bm") ? t["bm"] : 0), this.SetVisible(!t.hasOwnProperty("v") || t["v"]), this.SetCollisionEnabled(!t.hasOwnProperty("ce") || t["ce"]), this.SetBboxChangeEventEnabled(!!t.hasOwnProperty("be") && t["be"]), this.SetSolidCollisionFilter(!!t.hasOwnProperty("sfi") && t["sfi"], t.hasOwnProperty("sft") ? t["sft"] : ""), this._instanceEffectList && t.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(t["fx"]), t.hasOwnProperty("sgi") && "visual-state" !== e) {
        this._CreateSceneGraphInfo(null);
        const e2 = this._sceneGraphInfo, s2 = t["sgi"];
        e2._LoadFromJson(s2), e2._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes), this._SetSceneGraphExportData(t["sgcd"], t["sgzid"]);
      }
      if (t.hasOwnProperty("mesh")) {
        const e2 = t["mesh"];
        this.CreateMesh(e2["cols"], e2["rows"]), this.GetSourceMesh().LoadFromJson(e2);
      } else this.ReleaseMesh();
      this.SetBboxChanged(), enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup(), "visual-state" !== e && this._runtime.AddInstanceNeedingAfterLoad(this.GetInstance(), t);
    }
    _SetSceneGraphExportData(t, e) {
      t && C32.IsFiniteNumber(e) && sceneGraphExportDataMap.set(this, { childrenData: t, zIndexData: e });
    }
  };
}
{
  const C32 = self.C3;
  C32.BehaviorType = class extends C32.DefendedBase {
    constructor(e, t) {
      super();
      const s = e.GetRuntime(), i = s.GetObjectReference(t[1]);
      s.GetAddonManager()._DelayCreateBehavior(i), this._runtime = s, this._objectClass = e, this._behavior = C32.AddonManager.GetBehaviorByConstructorFunction(i), this._sdkType = null, this._iBehaviorType = null, this._instSdkCtor = i.Instance, this._sid = t[2], this._name = t[0], this._jsPropName = this._runtime.GetJsPropName(t[3]);
      const r = this._behavior.GetSdkVersion();
      if (r < 2 && (this._sdkType = C32.New(i.Type, this), !(this._sdkType instanceof C32.SDKBehaviorTypeBase))) throw new Error("v1 sdk type must derive from SDKBehaviorBase");
      if (C32.AddonManager._PushInitObject(this, r), r >= 2) {
        const e2 = i.Type ?? globalThis.ISDKBehaviorTypeBase;
        if (this._iBehaviorType = new e2(), !(this._iBehaviorType instanceof globalThis.ISDKBehaviorTypeBase)) throw new Error("script interface class must derive from ISDKBehaviorTypeBase");
      } else this._iBehaviorType = new globalThis.IBehaviorType();
      C32.AddonManager._PopInitObject(r), this.OnCreate();
    }
    static Create(e, t) {
      return C32.New(C32.BehaviorType, e, t);
    }
    Release() {
      this._runtime = null, this._behavior = null, this._sdkType && (this._sdkType.Release(), this._sdkType = null), this._instSdkCtor = null;
    }
    GetSdkType() {
      return this._sdkType;
    }
    OnCreate() {
      this._sdkType ? this._sdkType.OnCreate() : this._iBehaviorType && this._iBehaviorType._onCreate();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetBehavior() {
      return this._behavior;
    }
    GetInstanceSdkCtor() {
      return this._instSdkCtor;
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetIBehaviorType() {
      return this._iBehaviorType;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
  };
}
{
  const C32 = self.C3, IBehaviorInstance = self.IBehaviorInstance;
  C32.BehaviorInstance = class extends C32.DefendedBase {
    constructor(t) {
      super(), this._runtime = t.runtime, this._behaviorType = t.behaviorType, this._behavior = this._behaviorType.GetBehavior(), this._inst = t.instance, this._index = t.index, this._sdkInst = null, this._iScriptInterface = null, this._behavior._AddInstance(this._inst);
    }
    Release() {
      this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behavior._RemoveInstance(this._inst), this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null), this._runtime = null, this._behaviorType = null, this._behavior = null, this._inst = null;
    }
    _CreateSdkInstance(t) {
      if (this._sdkInst) throw new Error("already got sdk instance");
      if (this.GetBehavior().GetSdkVersion() < 2) {
        if (this._sdkInst = C32.New(this._behaviorType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C32.SDKBehaviorInstanceBase)) throw new Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
      } else {
        const e = this.GetBehavior().GetScriptInterfaceClass();
        this._InitScriptInterface(e.Instance, t);
      }
    }
    GetSdkInstance() {
      return this._sdkInst ?? this._iScriptInterface;
    }
    GetObjectInstance() {
      return this._inst;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetBehavior() {
      return this._behavior;
    }
    _GetIndex() {
      return this._index;
    }
    PostCreate() {
      this._sdkInst ? this._sdkInst.PostCreate() : this._iScriptInterface._postCreate();
    }
    OnSpriteFrameChanged(t, e) {
      this._sdkInst && this._sdkInst.OnSpriteFrameChanged(t, e);
    }
    _GetDebuggerProperties() {
      return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();
    }
    SaveToJson(t = "full") {
      return this._sdkInst ? this._sdkInst.SaveToJson(t) : this._iScriptInterface._saveToJson(t);
    }
    LoadFromJson(t, e = "full") {
      if (this._sdkInst) return this._sdkInst.LoadFromJson(t, e);
      this._iScriptInterface._loadFromJson(t, e);
    }
    static SortByTickSequence(t, e, s) {
      const n = globalThis.ISDKBehaviorInstanceBase;
      let i, r;
      i = e instanceof n ? t._UnwrapScriptInterface(e) : e.GetBehaviorInstance(), r = s instanceof n ? t._UnwrapScriptInterface(s) : s.GetBehaviorInstance();
      const a = i.GetObjectInstance(), h = r.GetObjectInstance(), c = a.GetObjectClass().GetIndex(), o = h.GetObjectClass().GetIndex();
      if (c !== o) return c - o;
      const I = a.GetPUID(), _ = h.GetPUID();
      return I !== _ ? I - _ : i._GetIndex() - r._GetIndex();
    }
    _InitScriptInterface(t, e) {
      const s = IBehaviorInstance, n = t ?? this._sdkInst.GetScriptInterfaceClass(), i = n || s, r = this.GetBehavior().GetSdkVersion();
      if (C32.AddonManager._PushInitObject(this, r), C32.AddonManager._PushInitProperties(e), this._iScriptInterface = new i(), C32.AddonManager._PopInitProperties(), C32.AddonManager._PopInitObject(r), n && !(this._iScriptInterface instanceof s)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);
      return this._iScriptInterface;
    }
    GetScriptInterface() {
      return this._iScriptInterface || this._InitScriptInterface();
    }
    HasScriptInterface() {
      return !!this._iScriptInterface;
    }
  };
}
{
  const C32 = self.C3;
  C32.EffectList = class extends C32.DefendedBase {
    constructor(e, t) {
      super(), this._owner = e, this._allEffectTypes = [], this._activeEffectTypes = [], this._effectTypesByName = /* @__PURE__ */ new Map(), this._effectParams = [], this._effectParamBuffers = [], this._allInstanceEffectLists = /* @__PURE__ */ new Set(), this._preservesOpaqueness = true;
      for (const e2 of t) {
        const t2 = C32.New(C32.EffectType, this, e2, this._allEffectTypes.length);
        this._allEffectTypes.push(t2), this._effectTypesByName.set(t2.GetName().toLowerCase(), t2), e2.length >= 3 && this._effectParams.push(this._LoadSingleEffectParameters(t2, e2[2]));
      }
      this.GetRuntime()._AddEffectList(this);
    }
    Release() {
      this.GetRuntime()._RemoveEffectList(this);
      for (const e of this._effectParamBuffers) e.Release();
      C32.clearArray(this._effectParamBuffers), C32.clearArray(this._allEffectTypes), C32.clearArray(this._activeEffectTypes), this._effectTypesByName.clear(), C32.clearArray(this._effectParams), this._owner = null;
    }
    _AddInstanceEffectList(e) {
      this._allInstanceEffectLists.add(e);
    }
    _RemoveInstanceEffectList(e) {
      this._allInstanceEffectLists.delete(e);
    }
    _InitRenderer(e) {
      e.IsWebGPU() && (this._effectParamBuffers = this._allEffectTypes.map((e2) => {
        const t = e2.GetShaderProgram();
        return t.GetCustomParametersByteSize() > 0 ? C32.New(C32.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;
      }), this._UpdateAllEffectParamBuffers());
      for (const t of this._allInstanceEffectLists) t._InitRenderer(e);
    }
    PrependEffectTypes(e) {
      if (e.length) {
        this._allEffectTypes = e.concat(this._allEffectTypes);
        for (const t of e) this._effectTypesByName.set(t.GetName().toLowerCase(), t);
        for (let e2 = 0, t = this._allEffectTypes.length; e2 < t; ++e2) this._allEffectTypes[e2]._SetIndex(e2);
      }
    }
    _LoadSingleEffectParameters(e, t) {
      e.SetActive(t[0]);
      const s = t.slice(1);
      for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {
        const t3 = s[e2];
        if (Array.isArray(t3)) {
          const f = C32.New(C32.Color);
          f.setFromJSON(t3), s[e2] = f;
        }
      }
      return s;
    }
    GetOwner() {
      return this._owner;
    }
    GetRuntime() {
      return this._owner.GetRuntime();
    }
    UpdateActiveEffects() {
      C32.clearArray(this._activeEffectTypes);
      let e = true;
      for (const t of this._allEffectTypes) t.IsActive() && (this._activeEffectTypes.push(t), t.GetShaderProgram().PreservesOpaqueness() || (e = false));
      this._preservesOpaqueness = e;
    }
    GetAllEffectTypes() {
      return this._allEffectTypes;
    }
    HasAnyEffectType() {
      return this._allEffectTypes.length > 0;
    }
    GetEffectTypeByName(e) {
      return this._effectTypesByName.get(e.toLowerCase()) || null;
    }
    GetEffectTypeByIndex(e) {
      if ((e = Math.floor(+e)) < 0 || e >= this._allEffectTypes.length) throw new RangeError("invalid effect type index");
      return this._allEffectTypes[e];
    }
    IsEffectIndexActive(e) {
      return this.GetEffectTypeByIndex(e).IsActive();
    }
    SetEffectIndexActive(e, t) {
      this.GetEffectTypeByIndex(e).SetActive(t);
    }
    GetActiveEffectTypes() {
      return this._activeEffectTypes;
    }
    HasAnyActiveEffect() {
      return this._activeEffectTypes.length > 0;
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness;
    }
    GetEffectParametersForIndex(e) {
      return this._effectParams[e];
    }
    _GetEffectChainShaderParametersForIndex(e) {
      return e < this._effectParamBuffers.length ? this._effectParamBuffers[e] : this._effectParams[e];
    }
    GetEffectParameter(e, t) {
      if (e < 0 || e >= this._effectParams.length) return null;
      const s = this._effectParams[e];
      return t < 0 || t >= s.length ? null : s[t];
    }
    SetEffectParameter(e, t, s) {
      if (e < 0 || e >= this._effectParams.length) return false;
      const f = this._effectParams[e];
      if (t < 0 || t >= f.length) return false;
      const r = f[t];
      if (r instanceof C32.Color) {
        if (r.equalsIgnoringAlpha(s)) return false;
        r.copyRgb(s);
      } else {
        if (r === s) return false;
        f[t] = s;
      }
      return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s), true;
    }
    _UpdateAllEffectParamBuffers() {
      const e = this._effectParams, t = this._effectParamBuffers;
      for (let s = 0, f = Math.min(e.length, t.length); s < f; ++s) {
        const f2 = t[s], r = e[s];
        for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) f2.SetParameterValue(e2, r[e2]);
      }
    }
    static SaveFxParamToJson(e) {
      return e && e instanceof C32.Color ? { "t": "color", "v": e.toJSON() } : e;
    }
    static LoadFxParamFromJson(e) {
      if (null === e) return NaN;
      if ("object" == typeof e) {
        if ("color" === e["t"]) {
          const t = C32.New(C32.Color);
          return t.setFromJSON(e["v"]), t;
        }
        throw new Error("invalid effect parameter type");
      }
      return e;
    }
    static SaveFxParamsToJson(e) {
      return e.map(C32.EffectList.SaveFxParamToJson);
    }
    static LoadFxParamsFromJson(e) {
      return e.map(C32.EffectList.LoadFxParamFromJson);
    }
    SaveToJson() {
      return this._allEffectTypes.map((e) => ({ "name": e.GetName(), "active": e.IsActive(), "params": C32.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));
    }
    LoadFromJson(e) {
      for (const t of e) {
        const e2 = this.GetEffectTypeByName(t["name"]);
        e2 && (e2.SetActive(t["active"]), this._effectParams[e2.GetIndex()] = C32.EffectList.LoadFxParamsFromJson(t["params"]));
      }
      this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();
    }
  };
}
{
  const C32 = self.C3;
  C32.EffectType = class extends C32.DefendedBase {
    constructor(e, t, r) {
      super(), this._effectList = e, this._id = t[0], this._name = t[1], this._index = r, this._shaderProgram = null, this._isActive = true;
    }
    Release() {
      this._effectList = null, this._shaderProgram = null;
    }
    Clone(e) {
      const t = C32.New(C32.EffectType, e, [this._id, this._name], -1);
      return t._shaderProgram = this._shaderProgram, t._isActive = this._isActive, t;
    }
    _InitRenderer(e) {
      const t = e.GetShaderProgramByName(this._id);
      if (!t) throw new Error("failed to find shader program '" + this._id + "'");
      this._shaderProgram = t;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetName() {
      return this._name;
    }
    _SetIndex(e) {
      this._index = e;
    }
    GetIndex() {
      return this._index;
    }
    GetOwner() {
      return this._effectList.GetOwner();
    }
    GetRuntime() {
      return this._effectList.GetRuntime();
    }
    SetActive(e) {
      this._isActive = !!e;
    }
    IsActive() {
      return this._isActive;
    }
    GetShaderProgram() {
      return this._shaderProgram;
    }
    GetDefaultParameterValues() {
      const e = [];
      for (let t = 0, r = this._shaderProgram.GetParameterCount(); t < r; ++t) {
        const r2 = this._shaderProgram.GetParameterType(t);
        if ("float" === r2 || "percent" === r2) e.push(0);
        else {
          if ("color" !== r2) throw new TypeError("unknown effect parameter type");
          e.push(C32.New(C32.Color, 1, 1, 1, 1));
        }
      }
      return e;
    }
  };
}
{
  const C32 = self.C3;
  C32.InstanceEffectList = class extends C32.DefendedBase {
    constructor(e, t) {
      super(), this._inst = e, this._wi = t, this._effectList = e.GetObjectClass().GetEffectList(), this._needsRebuildSteps = true, this._wasDefaultColor = true, this._was3D = false, this._wasRotatedOrNegativeSize = false, this._wasTexRotated = false, this._wasMustPreDraw = false, this._effectChain = C32.New(C32.Gfx.EffectChain, e.GetRuntime().GetCanvasManager().GetEffectChainManager(), { drawContent: (e2, t2) => {
        const s = t2.GetContentObject(), f = s.GetWorldInfo();
        e2.SetColor(f.GetPremultipliedColor()), e2.SetCurrentZ(f.GetTotalZElevation()), s.Draw(e2), e2.SetCurrentZ(0);
      }, getSourceTextureInfo: (e2) => {
        const t2 = e2.GetCurrentTexRect(), [s, f] = e2.GetCurrentSurfaceSize();
        return { srcTexRect: t2, srcWidth: s, srcHeight: f };
      }, getShaderParameters: (e2) => this._GetEffectChainShaderParametersForIndex(e2) }), this._activeEffectFlags = [], this._activeEffectTypes = [], this._preservesOpaqueness = true, this._effectParams = [], this._effectParamBuffers = [], this._InitRenderer(e.GetRuntime().GetRenderer());
      for (let e2 = 0, t2 = this._effectList.GetAllEffectTypes().length; e2 < t2; ++e2) this._activeEffectFlags.push(true);
      this.UpdateActiveEffects(), this._effectList._AddInstanceEffectList(this);
    }
    Release() {
      this._effectList._RemoveInstanceEffectList(this);
      for (const e of this._effectParamBuffers) e && e.Release();
      C32.clearArray(this._effectParamBuffers), this._effectChain.Release(), this._effectChain = null, C32.clearArray(this._activeEffectFlags), C32.clearArray(this._activeEffectTypes), C32.clearArray(this._effectParams), this._inst = null, this._effectList = null;
    }
    _InitRenderer(e) {
      e.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map((e2) => {
        const t = e2.GetShaderProgram();
        return t.GetCustomParametersByteSize() > 0 ? C32.New(C32.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;
      }));
    }
    _LoadEffectParameters(e) {
      let t = 0;
      for (const s of e) this._effectParams.push(this._LoadSingleEffectParameters(t, s)), ++t;
      this._UpdateAllEffectParamBuffers(), this.UpdateActiveEffects();
    }
    _LoadSingleEffectParameters(e, t) {
      this._activeEffectFlags[e] = t[0];
      const s = t.slice(1);
      for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {
        const t3 = s[e2];
        if (Array.isArray(t3)) {
          const f = C32.New(C32.Color);
          f.setFromJSON(t3), s[e2] = f;
        }
      }
      return s;
    }
    LoadDefaultEffectParameters() {
      for (const e of this._effectList.GetAllEffectTypes()) this._effectParams.push(e.GetDefaultParameterValues());
      this._UpdateAllEffectParamBuffers();
    }
    GetOwner() {
      return this._owner;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      return this._MaybeRebuildEffectChainSteps(), this._effectChain;
    }
    GetRuntime() {
      return this._inst.GetRuntime();
    }
    UpdateActiveEffects() {
      C32.clearArray(this._activeEffectTypes);
      const e = this._wi, t = this._effectList.GetAllEffectTypes(), s = this._activeEffectTypes, f = this._activeEffectFlags;
      let a = true;
      for (let e2 = 0, r = t.length; e2 < r; ++e2) if (f[e2]) {
        const f2 = t[e2];
        s.push(f2), f2.GetShaderProgram().PreservesOpaqueness() || (a = false);
      }
      this._preservesOpaqueness = a, e._SetHasAnyActiveEffect(!!s.length), this._needsRebuildSteps = true;
    }
    _MaybeRebuildEffectChainSteps() {
      const e = this._inst, t = this._wi, s = t.HasDefaultColor(), f = e.GetPlugin().Is3D(), a = 0 !== t.GetAngle() || 0 !== t.GetLayer().GetAngle() || t.GetWidth() < 0 || t.GetHeight() < 0, r = e.IsCurrentTexRotated(), i = e.MustPreDraw();
      (this._needsRebuildSteps || s !== this._wasDefaultColor || f !== this._was3D || a !== this._wasRotatedOrNegativeSize || r !== this._wasTexRotated || i !== this._wasMustPreDraw || this._effectChain.NeedsRebuild()) && (this._effectChain.BuildSteps(this._activeEffectTypes.map((e2) => e2.GetShaderProgram()), { indexMap: this._activeEffectTypes.map((e2) => e2.GetIndex()), forcePreDraw: !s || i, is3D: f, isSourceTextureRotated: r, isRotatedOrNegativeSizeInstance: a }), this._needsRebuildSteps = false, this._wasDefaultColor = s, this._was3D = f, this._wasRotatedOrNegativeSize = a, this._wasTexRotated = r, this._wasMustPreDraw = i);
    }
    GetActiveEffectTypes() {
      return this._activeEffectTypes;
    }
    GetEffectParametersForIndex(e) {
      return this._effectParams[e];
    }
    _GetEffectChainShaderParametersForIndex(e) {
      return e < this._effectParamBuffers.length ? this._effectParamBuffers[e] : this._effectParams[e];
    }
    GetEffectParameter(e, t) {
      if (e < 0 || e >= this._effectParams.length) return null;
      const s = this._effectParams[e];
      return t < 0 || t >= s.length ? null : s[t];
    }
    SetEffectParameter(e, t, s) {
      if (e < 0 || e >= this._effectParams.length) return false;
      const f = this._effectParams[e];
      if (t < 0 || t >= f.length) return false;
      const a = f[t];
      if (a instanceof C32.Color) {
        if (a.equalsIgnoringAlpha(s)) return false;
        a.copyRgb(s);
      } else {
        if (a === s) return false;
        f[t] = s;
      }
      return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s), true;
    }
    _UpdateAllEffectParamBuffers() {
      const e = this._effectParams, t = this._effectParamBuffers;
      for (let s = 0, f = t.length; s < f; ++s) {
        const f2 = t[s], a = e[s];
        for (let e2 = 0, t2 = a.length; e2 < t2; ++e2) f2.SetParameterValue(e2, a[e2]);
      }
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness;
    }
    HasAnyActiveBackgroundBlendingEffect() {
      return this._activeEffectTypes.some((e) => e.GetShaderProgram().BlendsBackground());
    }
    IsEffectIndexActive(e) {
      return this._activeEffectFlags[e];
    }
    SetEffectIndexActive(e, t) {
      this._activeEffectFlags[e] = !!t;
    }
    GetAllEffectTypes() {
      return this._effectList.GetAllEffectTypes();
    }
    _SaveToJson() {
      return this._effectList.GetAllEffectTypes().map((e) => ({ "name": e.GetName(), "active": this._activeEffectFlags[e.GetIndex()], "params": C32.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));
    }
    _LoadFromJson(e) {
      for (const t of e) {
        const e2 = this._effectList.GetEffectTypeByName(t["name"]);
        e2 && (this._activeEffectFlags[e2.GetIndex()] = t["active"], this._effectParams[e2.GetIndex()] = C32.EffectList.LoadFxParamsFromJson(t["params"]));
      }
      this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();
    }
  };
}
{
  const C32 = self.C3, tempCandidates = [], tileCollRectCandidates = [], tempJumpthruRet = [], tempPolyA = C32.New(C32.CollisionPoly), tempPolyB = C32.New(C32.CollisionPoly), tempQuad = C32.New(C32.Quad), tempRect = C32.New(C32.Rect), tempRect2 = C32.New(C32.Rect);
  let tempPolyC = null, tempRect3 = null, tempQuadB = null;
  C32.CollisionEngine = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e, this._collisionCellWidth = 0, this._collisionCellHeight = 0, this._registeredCollisions = [], this._collisionCheckCount = 0, this._collisionCheckSec = 0, this._polyCheckCount = 0, this._polyCheckSec = 0, this._iCollisionEngine = new self.ICollisionEngine(this);
    }
    Release() {
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetICollisionEngine() {
      return this._iCollisionEngine;
    }
    _Update1sStats() {
      this._collisionCheckSec = this._collisionCheckCount, this._collisionCheckCount = 0, this._polyCheckSec = this._polyCheckCount, this._polyCheckCount = 0;
    }
    Get1secCollisionChecks() {
      return this._collisionCheckSec;
    }
    Get1secPolyChecks() {
      return this._polyCheckSec;
    }
    RegisterCollision(e, t) {
      const s = e.GetWorldInfo(), n = t.GetWorldInfo();
      s && n && s.IsCollisionEnabled() && n.IsCollisionEnabled() && this._registeredCollisions.push([e, t]);
    }
    AddRegisteredCollisionCandidates(e, t, s) {
      for (const [n, l] of this._registeredCollisions) {
        let o = null;
        if (e === n) o = l;
        else {
          if (e !== l) continue;
          o = n;
        }
        o.BelongsToObjectClass(t) && (s.includes(o) || s.push(o));
      }
    }
    CheckRegisteredCollision(e, t) {
      if (!this._registeredCollisions.length) return false;
      for (const [s, n] of this._registeredCollisions) if (e === s && t === n || e === n && t === s) return true;
      return false;
    }
    ClearRegisteredCollisions() {
      C32.clearArray(this._registeredCollisions);
    }
    TestOverlap(e, t) {
      if (!e || !t || e === t) return false;
      const s = e.GetWorldInfo(), n = t.GetWorldInfo();
      if (!s.IsCollisionEnabled() || !n.IsCollisionEnabled()) return false;
      this._collisionCheckCount++;
      const l = s.GetLayer(), o = n.GetLayer();
      return l.IsTransformCompatibleWith(o) ? this._TestOverlap_SameLayers(s, n) : this._TestOverlap_DifferentLayers(s, n);
    }
    _TestOverlap_SameLayers(e, t) {
      if (!e.GetBoundingBox().intersectsRect(t.GetBoundingBox())) return false;
      if (this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad())) return false;
      if (e.HasTilemap() && t.HasTilemap()) return false;
      if (e.HasTilemap()) return this.TestTilemapOverlap(e, t);
      if (t.HasTilemap()) return this.TestTilemapOverlap(t, e);
      if (!e.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly()) return true;
      const s = e.GetTransformedCollisionPoly(), n = t.GetTransformedCollisionPoly();
      return s.intersectsPoly(n, t.GetX() - e.GetX(), t.GetY() - e.GetY());
    }
    _TestOverlap_DifferentLayers(e, t) {
      const s = e.HasTilemap(), n = t.HasTilemap();
      if (s && !n) return this.TestTilemapOverlapDifferentLayers(e, t);
      if (n && !s) return this.TestTilemapOverlapDifferentLayers(t, e);
      if (n || s) return false;
      {
        const s2 = e.GetLayer(), n2 = t.GetLayer();
        tempPolyA.copy(e.GetTransformedCollisionPoly()), tempPolyB.copy(t.GetTransformedCollisionPoly());
        const l = tempPolyA.pointsArr();
        for (let t2 = 0, n3 = l.length; t2 < n3; t2 += 2) {
          const n4 = t2 + 1, o2 = l[t2], i = l[n4], [r, a] = s2.LayerToCanvasCss(o2 + e.GetX(), i + e.GetY());
          l[t2] = r, l[n4] = a;
        }
        const o = tempPolyB.pointsArr();
        for (let e2 = 0, s3 = o.length; e2 < s3; e2 += 2) {
          const s4 = e2 + 1, l2 = o[e2], i = o[s4], [r, a] = n2.LayerToCanvasCss(l2 + t.GetX(), i + t.GetY());
          o[e2] = r, o[s4] = a;
        }
        return tempPolyA.setBboxChanged(), tempPolyB.setBboxChanged(), this._polyCheckCount++, tempPolyA.intersectsPoly(tempPolyB, 0, 0);
      }
    }
    TestTilemapOverlapDifferentLayers(e, t) {
      const s = e.GetLayer(), n = t.GetLayer();
      tempPolyC || (tempPolyC = C32.New(C32.CollisionPoly)), tempRect3 || (tempRect3 = C32.New(C32.Rect)), tempQuadB || (tempQuadB = C32.New(C32.Quad));
      const l = t.GetX(), o = t.GetY(), [i, r] = n.LayerToCanvasCss(l, o), [a, c] = s.CanvasCssToLayer(i, r), C = a - l, d = c - o;
      if (tempRect3.copy(t.GetBoundingBox()), tempRect3.offset(C, d), !e.GetBoundingBox().intersectsRect(tempRect3)) return false;
      if (tempQuadB.copy(t.GetBoundingQuad()), tempQuadB.offset(C, d), this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(tempQuadB)) return false;
      tempPolyC.copy(t.GetTransformedCollisionPoly());
      const u = tempPolyC.pointsArr();
      for (let e2 = 0, t2 = u.length; e2 < t2; e2 += 2) {
        const t3 = e2 + 1;
        u[e2] += C, u[t3] += d;
      }
      return tempPolyC.setBboxChanged(), this.TestTilemapOverlap(e, t, a, c, tempPolyC, tempRect3, tempQuadB);
    }
    TestTilemapOverlap(e, t, s, n, l, o, i) {
      const r = void 0 !== o ? o : t.GetBoundingBox(), a = e.GetX(), c = e.GetY(), C = e.GetInstance().GetSdkInstance(), d = void 0 !== s ? s : t.GetX(), u = void 0 !== n ? n : t.GetY(), h = t.HasOwnCollisionPoly(), p = void 0 !== i ? i : t.GetBoundingQuad(), f = tileCollRectCandidates;
      C.GetCollisionRectCandidates(r, f);
      for (let e2 = 0, s2 = f.length; e2 < s2; ++e2) {
        const s3 = f[e2], n2 = s3.GetRect();
        if (this._collisionCheckCount++, r.intersectsRectOffset(n2, a, c) && (tempQuad.setFromRect(n2), tempQuad.offset(a, c), tempQuad.intersectsQuad(p))) if (h) {
          const e3 = void 0 !== l ? l : t.GetTransformedCollisionPoly();
          let o2 = d, i2 = u;
          void 0 !== l && (o2 = t.GetX(), i2 = t.GetY());
          const r2 = s3.GetPoly();
          if (r2) {
            if (this._polyCheckCount++, r2.intersectsPoly(e3, o2 - (a + n2.getLeft()), i2 - (c + n2.getTop()))) return C32.clearArray(f), true;
          } else if (tempPolyA.setFromQuad(tempQuad, 0, 0), tempPolyA.intersectsPoly(e3, o2, i2)) return C32.clearArray(f), true;
        } else {
          const e3 = s3.GetPoly();
          if (!e3) return C32.clearArray(f), true;
          if (tempPolyA.setFromQuad(p, 0, 0), e3.intersectsPoly(tempPolyA, -(a + n2.getLeft()), -(c + n2.getTop()))) return C32.clearArray(f), true;
        }
      }
      return C32.clearArray(f), false;
    }
    TestAndSelectCanvasPointOverlap(e, t, s) {
      const n = e.GetCurrentSol(), l = this._runtime.GetCurrentEvent();
      if (!l) throw new Error("cannot call outside event");
      const o = l.IsOrBlock(), i = new C32.LayerStateCache();
      if (n.IsSelectAll()) {
        s || (n._SetSelectAll(false), C32.clearArray(n._GetOwnInstances())), o && C32.clearArray(n._GetOwnElseInstances());
        for (const l2 of e.GetInstances()) {
          const e2 = l2.GetWorldInfo(), r = e2.GetLayer();
          let a = false;
          if (i.IsInteractive(r) && e2.IsInViewport2() && (a = t.some(([t2, s2]) => {
            const [n2, l3] = i.CanvasCssToLayer(r, t2, s2, e2.GetTotalZElevation());
            return e2.ContainsPoint(n2, l3);
          })), a) {
            if (s) return false;
            n._PushInstance(l2);
          } else o && n._PushElseInstance(l2);
        }
      } else {
        let e2, r = false;
        o && !l.IsFirstConditionOfType(this._runtime.GetCurrentCondition()) ? this._runtime.IsCurrentConditionFirst() && !n._GetOwnElseInstances().length && n._GetOwnInstances().length ? e2 = n._GetOwnInstances() : (e2 = n._GetOwnElseInstances(), r = true) : e2 = n._GetOwnInstances();
        let a = 0;
        for (let l2 = 0, c = e2.length; l2 < c; ++l2) {
          const c2 = e2[l2], C = c2.GetWorldInfo(), d = C.GetLayer();
          let u = false;
          if (i.IsInteractive(d) && C.IsInViewport2() && (u = t.some(([e3, t2]) => {
            const [s2, n2] = i.CanvasCssToLayer(d, e3, t2, C.GetTotalZElevation());
            return C.ContainsPoint(s2, n2);
          })), u) {
            if (s) return false;
            r ? n._PushInstance(c2) : e2[a++] = c2;
          } else r ? e2[a++] = c2 : o && n._PushElseInstance(c2);
        }
        s || (e2.length = a);
      }
      return e.ApplySolToContainer(), i.Release(), !!s || n.HasAnyInstances();
    }
    _ObjectClassCanUseCollisionCells(e, t) {
      if (!e) return true;
      for (const s of t.layersHasInstancesOn()) if (!e.IsTransformCompatibleWith(s)) return false;
      return true;
    }
    GetCollisionCandidates(e, t, s, n) {
      if (t.IsFamily()) for (const l of t.GetFamilyMembers()) this._ObjectClassCanUseCollisionCells(e, l) ? (l._UpdateAllCollisionCells(), l._GetCollisionCellGrid().QueryRange(s, n)) : C32.appendArray(n, l.GetInstances());
      else this._ObjectClassCanUseCollisionCells(e, t) ? (t._UpdateAllCollisionCells(), t._GetCollisionCellGrid().QueryRange(s, n)) : C32.appendArray(n, t.GetInstances());
    }
    GetObjectClassesCollisionCandidates(e, t, s, n) {
      for (const l of t) this.GetCollisionCandidates(e, l, s, n);
    }
    GetSolidCollisionCandidates(e, t, s) {
      const n = this._runtime.GetSolidBehavior();
      n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t, s);
    }
    GetJumpthruCollisionCandidates(e, t, s) {
      const n = this._runtime.GetJumpthruBehavior();
      n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t, s);
    }
    IsSolidCollisionAllowed(e, t) {
      return e._IsSolidEnabled() && (!t || t.GetWorldInfo().IsSolidCollisionAllowed(e));
    }
    TestOverlapSolid(e) {
      const t = e.GetWorldInfo();
      this.GetSolidCollisionCandidates(t.GetLayer(), t.GetBoundingBox(), tempCandidates);
      for (const t2 of tempCandidates) if (this.IsSolidCollisionAllowed(t2, e) && this.TestOverlap(e, t2)) return C32.clearArray(tempCandidates), t2;
      return C32.clearArray(tempCandidates), null;
    }
    TestRectOverlapSolid(e, t) {
      this.GetSolidCollisionCandidates(null, e, tempCandidates);
      for (const s of tempCandidates) if (this.IsSolidCollisionAllowed(s, t) && this.TestRectOverlap(e, s)) return C32.clearArray(tempCandidates), s;
      return C32.clearArray(tempCandidates), null;
    }
    TestOverlapJumpthru(e, t) {
      let s = null;
      t && (s = tempJumpthruRet, C32.clearArray(s));
      const n = e.GetWorldInfo();
      this.GetJumpthruCollisionCandidates(n.GetLayer(), n.GetBoundingBox(), tempCandidates);
      for (const n2 of tempCandidates) if (n2._IsJumpthruEnabled() && this.TestOverlap(e, n2)) {
        if (!t) return C32.clearArray(tempCandidates), n2;
        s.push(n2);
      }
      return C32.clearArray(tempCandidates), s;
    }
    PushOut(e, t, s, n, l) {
      n = n || 50;
      const o = e.GetWorldInfo(), i = o.GetX(), r = o.GetY();
      for (let a = 0; a < n; ++a) if (o.SetXY(i + t * a, r + s * a), o.SetBboxChanged(), !this.TestOverlap(e, l)) return true;
      return o.SetXY(i, r), o.SetBboxChanged(), false;
    }
    PushOutSolid(e, t, s, n, l, o) {
      n = n || 50;
      const i = e.GetWorldInfo(), r = i.GetX(), a = i.GetY();
      let c = null, C = null;
      for (let d = 0; d < n; ++d) if (i.SetXY(r + t * d, a + s * d), i.SetBboxChanged(), !this.TestOverlap(e, c)) {
        if (c = this.TestOverlapSolid(e), c) C = c;
        else if (l && (c = o ? this.TestOverlap(e, o) ? o : null : this.TestOverlapJumpthru(e), c && (C = c)), !c) return C && this.PushInFractional(e, t, s, C, 16, true), true;
      }
      return i.SetXY(r, a), i.SetBboxChanged(), false;
    }
    PushOutSolidAxis(e, t, s, n) {
      n = n || 50;
      const l = e.GetWorldInfo(), o = l.GetX(), i = l.GetY();
      let r = null, a = null;
      for (let c = 0; c < n; ++c) for (let n2 = 0; n2 < 2; ++n2) {
        const C = 2 * n2 - 1;
        if (l.SetXY(o + t * c * C, i + s * c * C), l.SetBboxChanged(), !this.TestOverlap(e, r)) {
          if (r = this.TestOverlapSolid(e), !r) return a && this.PushInFractional(e, t * C, s * C, a, 16, true), true;
          a = r;
        }
      }
      return l.SetXY(o, i), l.SetBboxChanged(), false;
    }
    PushInFractional(e, t, s, n, l, o) {
      let i = 2, r = false, a = false;
      const c = e.GetWorldInfo();
      let C = c.GetX(), d = c.GetY();
      for (; i <= l; ) {
        const l2 = 1 / i;
        i *= 2, c.OffsetXY(t * l2 * (r ? 1 : -1), s * l2 * (r ? 1 : -1)), c.SetBboxChanged(), this.TestOverlap(e, n) || o && this.TestOverlapSolid(e) ? (r = true, a = true) : (r = false, a = false, C = c.GetX(), d = c.GetY());
      }
      a && (c.SetXY(C, d), c.SetBboxChanged());
    }
    PushOutSolidNearest(e, t = 100) {
      let s = 0;
      const n = e.GetWorldInfo(), l = n.GetX(), o = n.GetY();
      let i = 0, r = this.TestOverlapSolid(e);
      if (!r) return true;
      for (; s <= t; ) {
        let t2 = 0, a = 0;
        switch (i) {
          case 0:
            t2 = 0, a = -1, s++;
            break;
          case 1:
            t2 = 1, a = -1;
            break;
          case 2:
            t2 = 1, a = 0;
            break;
          case 3:
            t2 = 1, a = 1;
            break;
          case 4:
            t2 = 0, a = 1;
            break;
          case 5:
            t2 = -1, a = 1;
            break;
          case 6:
            t2 = -1, a = 0;
            break;
          case 7:
            t2 = -1, a = -1;
        }
        if (i = (i + 1) % 8, n.SetXY(Math.floor(l + t2 * s), Math.floor(o + a * s)), n.SetBboxChanged(), !this.TestOverlap(e, r) && (r = this.TestOverlapSolid(e), !r)) return true;
      }
      return n.SetXY(l, o), n.SetBboxChanged(), false;
    }
    CalculateBounceAngle(e, t, s, n) {
      const l = e.GetWorldInfo(), o = l.GetX(), i = l.GetY(), r = Math.max(10, C32.distanceTo(t, s, o, i)), a = C32.angleTo(t, s, o, i), c = n || this.TestOverlapSolid(e);
      if (!c) return C32.clampAngle(a + Math.PI);
      let C = c, d = 0, u = 0;
      const h = C32.toRadians(5);
      let p;
      for (p = 1; p < 36; ++p) {
        const o2 = a - p * h;
        if (l.SetXY(t + Math.cos(o2) * r, s + Math.sin(o2) * r), l.SetBboxChanged(), !this.TestOverlap(e, C) && (C = n ? null : this.TestOverlapSolid(e), !C)) {
          d = o2;
          break;
        }
      }
      for (36 === p && (d = C32.clampAngle(a + Math.PI)), C = c, p = 1; p < 36; ++p) {
        const o2 = a + p * h;
        if (l.SetXY(t + Math.cos(o2) * r, s + Math.sin(o2) * r), l.SetBboxChanged(), !this.TestOverlap(e, C) && (C = n ? null : this.TestOverlapSolid(e), !C)) {
          u = o2;
          break;
        }
      }
      if (36 === p && (u = C32.clampAngle(a + Math.PI)), l.SetXY(o, i), l.SetBboxChanged(), u === d) return u;
      const f = C32.angleDiff(u, d) / 2;
      let G;
      G = C32.angleClockwise(u, d) ? C32.clampAngle(d + f + Math.PI) : C32.clampAngle(u + f);
      const m = Math.cos(a), y = Math.sin(a), g = Math.cos(G), T = Math.sin(G), _ = m * g + y * T, I = m - 2 * _ * g, S = y - 2 * _ * T;
      return C32.angleTo(0, 0, I, S);
    }
    TestSegmentOverlap(e, t, s, n, l) {
      if (!l) return false;
      const o = l.GetWorldInfo();
      if (!o.IsCollisionEnabled()) return false;
      if (this._collisionCheckCount++, tempRect.set(Math.min(e, s), Math.min(t, n), Math.max(e, s), Math.max(t, n)), !o.GetBoundingBox().intersectsRect(tempRect)) return false;
      if (l.HasTilemap()) return this._TestSegmentOverlapTilemap(e, t, s, n, l, o);
      if (this._polyCheckCount++, !o.GetBoundingQuad().intersectsSegment(e, t, s, n)) return false;
      if (!o.HasOwnCollisionPoly()) return true;
      return o.GetTransformedCollisionPoly().intersectsSegment(o.GetX(), o.GetY(), e, t, s, n);
    }
    _TestSegmentOverlapTilemap(e, t, s, n, l, o) {
      const i = o.GetX(), r = o.GetY(), a = l.GetSdkInstance(), c = tileCollRectCandidates;
      tempRect2.set(e, t, s, n), tempRect2.normalize(), a.GetCollisionRectCandidates(tempRect2, c);
      for (let l2 = 0, o2 = c.length; l2 < o2; ++l2) {
        const o3 = c[l2], a2 = o3.GetRect();
        if (this._collisionCheckCount++, tempRect.intersectsRectOffset(a2, i, r) && (tempQuad.setFromRect(a2), tempQuad.offset(i, r), tempQuad.intersectsSegment(e, t, s, n))) {
          const l3 = o3.GetPoly();
          if (!l3) return C32.clearArray(c), true;
          if (this._polyCheckCount++, l3.intersectsSegment(i + a2.getLeft(), r + a2.getTop(), e, t, s, n)) return C32.clearArray(c), true;
        }
      }
      return C32.clearArray(c), false;
    }
    TestRectOverlap(e, t) {
      if (!t) return false;
      const s = t.GetWorldInfo();
      if (!s.IsCollisionEnabled()) return false;
      if (this._collisionCheckCount++, !s.GetBoundingBox().intersectsRect(e)) return false;
      if (t.HasTilemap()) return this._TestRectOverlapTilemap(e, t, s);
      if (this._polyCheckCount++, tempQuad.setFromRect(e), !s.GetBoundingQuad().intersectsQuad(tempQuad)) return false;
      if (!s.HasOwnCollisionPoly()) return true;
      const n = tempPolyA;
      n.setFromRect(e, s.GetX(), s.GetY());
      const l = s.GetTransformedCollisionPoly();
      return n.intersectsPoly(l, 0, 0);
    }
    _TestRectOverlapTilemap(e, t, s) {
      const n = s.GetX(), l = s.GetY(), o = t.GetSdkInstance(), i = tileCollRectCandidates;
      o.GetCollisionRectCandidates(e, i);
      for (let t2 = 0, s2 = i.length; t2 < s2; ++t2) {
        const s3 = i[t2], o2 = s3.GetRect();
        if (this._collisionCheckCount++, e.intersectsRectOffset(o2, n, l)) {
          const t3 = s3.GetPoly();
          if (!t3) return C32.clearArray(i), true;
          if (this._polyCheckCount++, tempPolyA.setFromRect(e, 0, 0), t3.intersectsPoly(tempPolyA, -(n + o2.getLeft()), -(l + o2.getTop()))) return C32.clearArray(i), true;
        }
      }
      return C32.clearArray(i), false;
    }
    TestRayIntersectsInstance(e, t) {
      if (!e) return;
      const s = e.GetWorldInfo();
      s.IsCollisionEnabled() && (this._collisionCheckCount++, s.GetBoundingBox().intersectsRect(t.rect) && (e.HasTilemap() ? this._TestRayIntersectsTilemap(e, s, t) : (this._polyCheckCount++, s.HasOwnCollisionPoly() ? t.TestInstancePoly(e, s.GetX(), s.GetY(), s.GetTransformedCollisionPoly()) : t.TestInstanceQuad(e, s.GetBoundingQuad()))));
    }
    _TestRayIntersectsTilemap(e, t, s) {
      const n = t.GetX(), l = t.GetY(), o = tileCollRectCandidates;
      e.GetSdkInstance().GetCollisionRectCandidates(s.rect, o);
      for (let i = 0, r = o.length; i < r; i++) {
        const r2 = o[i], a = r2.GetRect();
        if (this._collisionCheckCount++, s.rect.intersectsRectOffset(a, n, l)) {
          const o2 = r2.GetPoly();
          this._polyCheckCount++, o2 ? s.TestInstancePoly(e, n + a.getLeft(), l + a.getTop(), o2) : s.TestInstanceRect(e, t.GetX(), t.GetY(), a);
        }
      }
      C32.clearArray(o);
    }
    SetCollisionCellSize(e, t) {
      if (e === this._collisionCellWidth && t === this._collisionCellHeight) return;
      this._collisionCellWidth = e, this._collisionCellHeight = t;
      const s = this._runtime.GetAllObjectClasses();
      for (const n of s) if (n.IsWorldType()) {
        for (const e2 of n.instancesIncludingPendingCreate()) e2.GetWorldInfo()._RemoveFromCollisionCells();
        n._GetCollisionCellGrid().SetCellSize(e, t), n._SetAnyCollisionCellChanged();
        for (const e2 of n.instancesIncludingPendingCreate()) {
          const t2 = e2.GetWorldInfo();
          t2._SetCollisionCellChanged(), t2._UpdateCollisionCell();
        }
      }
    }
    GetCollisionCellSize() {
      return [this._collisionCellWidth, this._collisionCellHeight];
    }
    _InitCollisionCellSize(e, t) {
      this._collisionCellWidth = e, this._collisionCellHeight = t;
    }
  };
}
{
  const C32 = self.C3;
  C32.SparseGrid = class extends C32.DefendedBase {
    constructor(t, e) {
      super(), this._cellWidth = t, this._cellHeight = e, this._cells = C32.New(C32.PairMap);
    }
    Release() {
      this._cells.Release(), this._cells = null;
    }
    SetCellSize(t, e) {
      if (!this._cells.IsEmpty()) throw new Error("grid not empty");
      this._cellWidth = t, this._cellHeight = e;
    }
    GetCell(t, e, l) {
      let i = this._cells.Get(t, e);
      return i || (l ? (i = C32.New(C32.GridCell, this, t, e), this._cells.Set(t, e, i), i) : null);
    }
    XToCell(t) {
      const e = Math.floor(t / this._cellWidth);
      return isFinite(e) ? e : 0;
    }
    YToCell(t) {
      const e = Math.floor(t / this._cellHeight);
      return isFinite(e) ? e : 0;
    }
    Update(t, e, l) {
      if (e) for (let i = e.getLeft(), s = e.getRight(); i <= s; ++i) for (let s2 = e.getTop(), o = e.getBottom(); s2 <= o; ++s2) {
        if (l && l.containsPoint(i, s2)) continue;
        const e2 = this.GetCell(i, s2, false);
        e2 && (e2.Remove(t), e2.IsEmpty() && this._cells.Delete(i, s2));
      }
      if (l) for (let i = l.getLeft(), s = l.getRight(); i <= s; ++i) for (let s2 = l.getTop(), o = l.getBottom(); s2 <= o; ++s2) e && e.containsPoint(i, s2) || this.GetCell(i, s2, true).Insert(t);
    }
    QueryRange(t, e) {
      let l = this.XToCell(t.getLeft());
      const i = this.YToCell(t.getTop()), s = this.XToCell(t.getRight()), o = this.YToCell(t.getBottom());
      if (isFinite(s) && isFinite(o)) for (; l <= s; ++l) for (let t2 = i; t2 <= o; ++t2) {
        const i2 = this.GetCell(l, t2, false);
        i2 && i2.Dump(e);
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.GridCell = class extends C32.DefendedBase {
    constructor(s, e, t) {
      super(), this._grid = s, this._x = e, this._y = t, this._instances = C32.New(C32.ArraySet);
    }
    Release() {
      this._instances.Release(), this._instances = null, this._grid = null;
    }
    IsEmpty() {
      return this._instances.IsEmpty();
    }
    Insert(s) {
      this._instances.Add(s);
    }
    Remove(s) {
      this._instances.Delete(s);
    }
    Dump(s) {
      C32.appendArray(s, this._instances.GetArray());
    }
  };
}
{
  const C32 = self.C3, PADDING = 1e-6, NO_HIT = 2;
  C32.Ray = class {
    constructor() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, this.rect = new C32.Rect(), this.hitFraction = 2, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0;
    }
    DidCollide() {
      return this.hitFraction < 1.000001;
    }
    Reset() {
      this.hitFraction = 2;
    }
    Set(t, i, s, h) {
      return this.x1 = t, this.y1 = i, this.x2 = s, this.y2 = h, this.dx = s - t, this.dy = h - i, this.rect.set(t, i, s, h), this.rect.normalize(), this.hitFraction = 2, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0, this;
    }
    Complete() {
      if (false === this.DidCollide()) return;
      const t = this.dx * this.hitFraction, i = this.dy * this.hitFraction, s = C32.hypot2DFast(t, i), h = t / s, e = i / s;
      this.distance = s - PADDING, this.hitX = this.x1 + h * this.distance, this.hitY = this.y1 + e * this.distance, this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2, this.normalX = Math.cos(this.hitNormal), this.normalY = Math.sin(this.hitNormal);
      const n = h * this.normalX + e * this.normalY;
      if (this.reflectionX = h - 2 * this.normalX * n, this.reflectionY = e - 2 * this.normalY * n, n > 0) {
        const t2 = Math.PI;
        this.hitNormal = C32.clampAngle(this.hitNormal + t2), this.normalX = -this.normalX, this.normalY = -this.normalY;
      }
    }
    TestInstanceSegment(t, i, s, h, e) {
      const n = C32.rayIntersect(this.x1, this.y1, this.x2, this.y2, i, s, h, e);
      n >= 0 && n < this.hitFraction && (this.hitFraction = n, this.hitUid = t.GetUID(), this.hitNormalDx = i - h, this.hitNormalDy = s - e);
    }
    TestInstanceRect(t, i, s, h) {
      const e = i + h.getLeft(), n = i + h.getRight(), a = s + h.getTop(), o = s + h.getBottom();
      this.TestInstanceSegment(t, e, a, n, a), this.TestInstanceSegment(t, n, a, n, o), this.TestInstanceSegment(t, n, o, e, o), this.TestInstanceSegment(t, e, o, e, a);
    }
    TestInstanceQuad(t, i) {
      const s = i.getTlx(), h = i.getTly(), e = i.getTrx(), n = i.getTry(), a = i.getBrx(), o = i.getBry(), r = i.getBlx(), l = i.getBly();
      this.TestInstanceSegment(t, s, h, e, n), this.TestInstanceSegment(t, e, n, a, o), this.TestInstanceSegment(t, a, o, r, l), this.TestInstanceSegment(t, r, l, s, h);
    }
    TestInstancePoly(t, i, s, h) {
      const e = h.pointsArr();
      for (let h2 = 0, n = e.length; h2 < n; h2 += 2) {
        const a = (h2 + 2) % n, o = e[h2] + i, r = e[h2 + 1] + s, l = e[a] + i, c = e[a + 1] + s;
        this.TestInstanceSegment(t, o, r, l, c);
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.LayerStateCache = class {
    constructor() {
      this._layerCache = /* @__PURE__ */ new Map();
    }
    Release() {
      for (const e of this._layerCache.values()) e.layerPts.Clear();
      this._layerCache.clear();
    }
    _GetLayerCache(e) {
      let a = this._layerCache.get(e);
      return void 0 === a && (a = { isInteractive: null, layerPts: new C32.PairMap() }, this._layerCache.set(e, a)), a;
    }
    IsInteractive(e) {
      const a = this._GetLayerCache(e);
      return null === a.isInteractive && (a.isInteractive = e.IsSelfAndParentsInteractive()), a.isInteractive;
    }
    CanvasCssToLayer(e, a, t, s) {
      if (0 !== s) return e.CanvasCssToLayer(a, t, s);
      const r = this._GetLayerCache(e);
      let n = r.layerPts.Get(a, t);
      return void 0 === n && (n = e.CanvasCssToLayer(a, t, s), r.layerPts.Set(a, t, n)), n;
    }
  };
}
{
  const C32 = self.C3, VALID_FULLSCREEN_MODES = /* @__PURE__ */ new Set(["off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale"]), VALID_FULLSCREEN_SCALING_QUALITIES = /* @__PURE__ */ new Set(["high", "low"]), glMatrix = self.glMatrix, mat4 = glMatrix.mat4, vec3 = glMatrix.vec3, tempProjection = mat4.create(), PERCENTTEXT_WIDTH = 300, PERCENTTEXT_HEIGHT = 200, PROGRESSBAR_WIDTH = 120, PROGRESSBAR_HEIGHT = 8, tempQuad = C32.New(C32.Quad), tempRect = C32.New(C32.Rect), SPLASH_MIN_DISPLAY_TIME = 3e3, SPLASH_AFTER_FADEOUT_WAIT_TIME = 200, SPLASH_FADE_DURATION = 300;
  C32.CanvasManager = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e, this._canvasLayers = [], this._isWebGPUEnabled = false, this._webglRenderer = null, this._webgpuRenderer = null, this._iRenderer = null, this._gpuPreference = "high-performance", this._isLimitedToWebGL1 = false, this._multitexturingMode = "auto", this._windowInnerWidth = 0, this._windowInnerHeight = 0, this._cssDisplayMode = "", this._canvasCssWidth = 0, this._canvasCssHeight = 0, this._canvasDeviceWidth = 0, this._canvasDeviceHeight = 0, this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this._zAxisScale = "normalized", this._initFieldOfView = 0, this._zNear = 1, this._zFar = 1e4, this._enableMipmaps = true, this._textureAnisotropy = 0, this._drawWidth = 0, this._drawHeight = 0, this._fullscreenMode = "letterbox-scale", this._documentFullscreenMode = "letterbox-scale", this._deviceTransformOffX = 0, this._deviceTransformOffY = 0, this._defaultProjectionMatrix = mat4.create(), this._wantFullscreenScalingQuality = "high", this._fullscreenScalingQuality = this._wantFullscreenScalingQuality, this._isDocumentFullscreen = false, this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets = /* @__PURE__ */ new Set(), this._shaderData = self["C3_Shaders"], this._effectChainManager = C32.New(C32.Gfx.EffectChainManager, { getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()], getRenderTarget: () => this.GetEffectCompositorRenderTarget(), releaseRenderTarget: (e2) => this.ReleaseEffectCompositorRenderTarget(e2), getTime: () => this.GetRuntime().GetGameTime(), redraw: () => this.GetRuntime().UpdateRender() }), this._gpuTimeStartFrame = 0, this._gpuTimeEndFrame = 0, this._gpuLastUtilisation = NaN, this._gpuFrameTimingsBuffer = null, this._layersGpuProfile = /* @__PURE__ */ new Map(), this._gpuCurUtilisation = NaN, this._webgpuFrameTimings = /* @__PURE__ */ new Map(), this._snapshotFormat = "", this._snapshotQuality = 1, this._snapshotArea = C32.New(C32.Rect), this._snapshotUrl = "", this._snapshotPromise = null, this._snapshotResolve = null, this._isPastingToDrawingCanvas = 0, this._loaderStartTime = 0, this._rafId = -1, this._loadingProgress = 0, this._loadingprogress_handler = (e2) => this._loadingProgress = e2.progress, this._percentText = null, this._splashTextures = { logo: null, powered: null, website: null }, this._splashFrameNumber = 0, this._splashFadeInFinishTime = 0, this._splashFadeOutStartTime = 0, this._splashState = "fade-in", this._splashDoneResolve = null, this._splashDonePromise = new Promise((e2) => this._splashDoneResolve = e2);
    }
    _SetGPUPowerPreference(e) {
      this._gpuPreference = e;
    }
    _SetWebGPUEnabled(e) {
      this._isWebGPUEnabled = !!e;
    }
    _SetZAxisScale(e) {
      this._zAxisScale = e;
    }
    GetZAxisScale() {
      return this._zAxisScale;
    }
    _SetInitFieldOfView(e) {
      this._initFieldOfView = e;
    }
    _SetZDistances(e, t) {
      this._zNear = e, this._zFar = t;
    }
    _SetLimitedToWebGL1(e) {
      this._isLimitedToWebGL1 = !!e;
    }
    _SetMultitexturingMode(e) {
      this._multitexturingMode = e;
    }
    async CreateCanvas(e) {
      let t = e["canvas"];
      this._canvasLayers.push({ canvas: t, ctx: null }), this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", (e2) => this._OnWindowResize(e2)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", (e2) => this._OnFullscreenChange(e2)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", (e2) => this._OnFullscreenError(e2)), t.addEventListener("webglcontextlost", (e2) => this._OnWebGLContextLost(e2)), t.addEventListener("webglcontextrestored", (e2) => this._OnWebGLContextRestored(e2)), this._isDocumentFullscreen = !!e["isFullscreen"], this._cssDisplayMode = e["cssDisplayMode"];
      const s = navigator["gpu"] && this._isWebGPUEnabled;
      let i = false;
      if (s) try {
        await this._InitWebGPUContext(true);
      } catch (e2) {
        this._MaybeLogRendererError("WebGPU", e2), this._webgpuRenderer = null;
      }
      if (!this.GetRenderer()) try {
        await this._InitWebGLContext(true);
      } catch (e2) {
        this._MaybeLogRendererError("WebGL", e2), this._webglRenderer = null;
      }
      if (this.GetRenderer() || (i = true), !this.GetRenderer() && s) try {
        await this._InitWebGPUContext(false);
      } catch (e2) {
        this._MaybeLogRendererError("WebGPU", e2), this._webgpuRenderer = null;
      }
      if (!this.GetRenderer()) try {
        await this._InitWebGLContext(false);
      } catch (e2) {
        this._MaybeLogRendererError("WebGL", e2), this._webglRenderer = null;
      }
      const r = this.GetRenderer();
      if (!r) throw new Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
      r.SetHasMajorPerformanceCaveat(i), this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = () => this._OnWebGPUDeviceLost(), this._webgpuRenderer.ondevicerestored = () => this._OnWebGPUDeviceRestored()), "normalized" === this._zAxisScale ? r.SetZAxisScaleNormalized() : (r.SetZAxisScaleRegular(), r.SetFovY(this._initFieldOfView)), this.SetSize(e["windowInnerWidth"], e["windowInnerHeight"], true), await this._InitRenderer();
    }
    _MaybeLogRendererError(e, t) {
      t && "string" == typeof t.message && t.message.startsWith("renderer-unavailable") || console.error(`Error creating ${e} renderer: `, t);
    }
    async _InitWebGPUContext(e) {
      const t = { nearZ: this._zNear, farZ: this._zFar };
      let s = true;
      "no" === this._multitexturingMode ? s = false : "auto" === this._multitexturingMode && (s = C32.Platform.IsDesktop);
      let i = "nearest";
      this._runtime.UsesAnyCrossSampling() && "nearest" !== this._runtime.GetSampling() && (i = "bilinear");
      const r = { powerPreference: this._gpuPreference, depth: this._runtime.Uses3DFeatures(), failIfMajorPerformanceCaveat: e, usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(), canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(), backTextureSampling: i, canSampleDepth: this._runtime.UsesAnyDepthSampling(), isMultiTexturingAllowed: s };
      this._webgpuRenderer = C32.New(C32.Gfx.WebGPURenderer, t), await this._webgpuRenderer.Create(this._canvasLayers[0].canvas, r);
    }
    async _InitWebGLContext(e) {
      const t = { alpha: true, powerPreference: this._gpuPreference, enableGpuProfiling: "xbox-uwp-webview2" !== this._runtime.GetExportType(), depth: this._runtime.Uses3DFeatures(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), failIfMajorPerformanceCaveat: e, nearZ: this._zNear, farZ: this._zFar };
      this._isLimitedToWebGL1 && (t.maxWebGLVersion = 1), this._webglRenderer = C32.New(C32.Gfx.WebGLRenderer, this._canvasLayers[0].canvas, t), await this._webglRenderer.InitState();
    }
    async _InitWebGPU() {
      if (this._shaderData) {
        const e = [];
        for (const [t, s] of Object.entries(this._shaderData)) {
          s.src = s.wgsl;
          const i = C32.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource(this._webgpuRenderer.IsColorDataF16());
          e.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i, name: t }, s)));
        }
        await Promise.all(e);
      }
    }
    async _InitWebGL() {
      if (this._shaderData) {
        const e = [];
        for (const [t, s] of Object.entries(this._shaderData)) {
          let i;
          if (s.glslWebGL2 && this._webglRenderer.GetWebGLVersionNumber() >= 2) s.src = s.glslWebGL2, i = C32.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();
          else {
            if (!s.glsl) throw new Error(`shader '${t}' does not support WebGL 1`);
            s.src = s.glsl, i = C32.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();
          }
          e.push(this._webglRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i, name: t }, s)));
        }
        await Promise.all(e), this._webglRenderer.ResetLastProgram(), this._webglRenderer.SetTextureFillMode();
      }
      this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C32.New(C32.Gfx.WebGLQueryResultBuffer, this._webglRenderer));
    }
    async _InitRenderer() {
      this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
      const e = this.GetRenderer();
      e.SetMipmapsEnabled(this._enableMipmaps), e.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
      for (const t of this._runtime._GetAllEffectLists()) {
        for (const s of t.GetAllEffectTypes()) s._InitRenderer(e);
        t._InitRenderer(e), t.UpdateActiveEffects();
      }
      this._iRenderer = new self.IRenderer(this._runtime, e);
    }
    Release() {
      this._runtime = null, this._webglRenderer = null, this._canvasLayers.length = 0;
    }
    IsInWorker() {
      return this._runtime.IsInWorker();
    }
    _OnWindowResize(e) {
      const t = this._runtime;
      if (t.IsExportToVideo()) return;
      const s = e["devicePixelRatio"];
      this.IsInWorker() && (self.devicePixelRatio = s), t._SetDevicePixelRatio(s), this._isDocumentFullscreen = !!e["isFullscreen"], this._cssDisplayMode = e["cssDisplayMode"], this.SetSize(e["innerWidth"], e["innerHeight"]), t.UpdateRender();
      const i = new C32.Event("window-resize");
      i.data = e, t.Dispatcher().dispatchEventAndWaitAsyncSequential(i);
      const r = new C32.Event("resize");
      r.cssWidth = this.GetCssWidth(), r.cssHeight = this.GetCssHeight(), r.deviceWidth = this.GetDeviceWidth(), r.deviceHeight = this.GetDeviceHeight(), t.DispatchUserScriptEvent(r), this._runtime.GetCurrentLayout()?.BoundScrolling(), t.IsDebug() && (t.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && t.Render();
    }
    _OnFullscreenChange(e) {
      this._isDocumentFullscreen = !!e["isFullscreen"], this.SetSize(e["innerWidth"], e["innerHeight"], true), this._runtime.UpdateRender();
    }
    _OnFullscreenError(e) {
      this._isDocumentFullscreen = !!e["isFullscreen"], this.SetSize(e["innerWidth"], e["innerHeight"], true), this._runtime.UpdateRender();
    }
    SetSize(e, t, s = false) {
      if (e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0) throw new Error("invalid size");
      if (this._windowInnerWidth === e && this._windowInnerHeight === t && !s) return;
      this._windowInnerWidth = e, this._windowInnerHeight = t;
      const i = this.GetCurrentFullscreenMode();
      "letterbox-scale" === i ? this._CalculateLetterboxScale(e, t) : "letterbox-integer-scale" === i ? this._CalculateLetterboxIntegerScale(e, t) : "off" === i ? this._CalculateFixedSizeCanvas(e, t) : this._CalculateFullsizeCanvas(e, t), this._UpdateFullscreenScalingQuality(i);
      for (const { canvas: e2 } of this._canvasLayers) e2.width = this._canvasDeviceWidth, e2.height = this._canvasDeviceHeight;
      this._runtime.PostComponentMessageToDOM("canvas", "update-size", { "marginLeft": this._canvasCssOffsetX, "marginTop": this._canvasCssOffsetY, "styleWidth": this._canvasCssWidth, "styleHeight": this._canvasCssHeight, "displayScale": this.GetDisplayScale() });
      const r = this.GetRenderer();
      r.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, true);
      for (const e2 of this._availableAdditionalRenderTargets) r.DeleteRenderTarget(e2);
      C32.clearArray(this._availableAdditionalRenderTargets), this.UpdateDefaultProjectionMatrix();
      const a = this._runtime.GetLayoutManager();
      a.SetAllLayerProjectionChanged(), a.SetAllLayerMVChanged();
    }
    UpdateDefaultProjectionMatrix() {
      this.GetRenderer().CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight());
    }
    GetDefaultProjectionMatrix() {
      return this._defaultProjectionMatrix;
    }
    _CalculateLetterboxScale(e, t) {
      const s = this._runtime.GetDevicePixelRatio(), i = this._runtime.GetOriginalViewportWidth(), r = this._runtime.GetOriginalViewportHeight(), a = i / r;
      if (e / t > a) {
        const s2 = t * a;
        this._canvasCssWidth = Math.round(s2), this._canvasCssHeight = t, this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0;
      } else {
        const s2 = e / a;
        this._canvasCssWidth = e, this._canvasCssHeight = Math.round(s2), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2);
      }
      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._runtime.SetViewportSize(i, r);
    }
    _CalculateLetterboxIntegerScale(e, t) {
      const s = this._runtime.GetDevicePixelRatio();
      1 !== s && (e += 1, t += 1);
      const i = this._runtime.GetOriginalViewportWidth(), r = this._runtime.GetOriginalViewportHeight(), a = i / r;
      let n;
      if (e / t > a) {
        n = t * a * s / i;
      } else {
        n = e / a * s / r;
      }
      n > 1 ? n = Math.floor(n) : n < 1 && (n = 1 / Math.ceil(1 / n)), this._canvasDeviceWidth = Math.round(i * n), this._canvasDeviceHeight = Math.round(r * n), this._canvasCssWidth = this._canvasDeviceWidth / s, this._canvasCssHeight = this._canvasDeviceHeight / s, this._canvasCssOffsetX = Math.max(Math.floor((e - this._canvasCssWidth) / 2), 0), this._canvasCssOffsetY = Math.max(Math.floor((t - this._canvasCssHeight) / 2), 0), this._runtime.SetViewportSize(i, r);
    }
    _CalculateFullsizeCanvas(e, t) {
      const s = this._runtime.GetDevicePixelRatio();
      this._canvasCssWidth = e, this._canvasCssHeight = t, this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0;
      const i = this.GetDisplayScale();
      this._runtime.SetViewportSize(this._canvasCssWidth / i, this._canvasCssHeight / i);
    }
    _CalculateFixedSizeCanvas(e, t) {
      const s = this._runtime.GetDevicePixelRatio();
      this._canvasCssWidth = this._runtime.GetViewportWidth(), this._canvasCssHeight = this._runtime.GetViewportHeight(), this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2)) : (this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0), this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight());
    }
    _UpdateFullscreenScalingQuality(e) {
      if ("high" === this._wantFullscreenScalingQuality) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
      else {
        let t, s;
        if ("off" === this.GetCurrentFullscreenMode() ? (t = this._runtime.GetViewportWidth(), s = this._runtime.GetViewportHeight()) : (t = this._runtime.GetOriginalViewportWidth(), s = this._runtime.GetOriginalViewportHeight()), this._canvasDeviceWidth < t || this._canvasDeviceHeight < s) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
        else if (this._drawWidth = t, this._drawHeight = s, this._fullscreenScalingQuality = "low", "scale-inner" === e) {
          const e2 = t / s, i = this._windowInnerWidth / this._windowInnerHeight;
          i < e2 ? this._drawWidth = this._drawHeight * i : i > e2 && (this._drawHeight = this._drawWidth / i);
        } else if ("scale-outer" === e) {
          const e2 = t / s, i = this._windowInnerWidth / this._windowInnerHeight;
          i > e2 ? this._drawWidth = this._drawHeight * i : i < e2 && (this._drawHeight = this._drawWidth / i);
        }
      }
    }
    GetRuntime() {
      return this._runtime;
    }
    GetMainCanvas() {
      return this._canvasLayers[0].canvas;
    }
    GetEffectChainManager() {
      return this._effectChainManager;
    }
    IsDocumentFullscreen() {
      return this._isDocumentFullscreen;
    }
    GetCssDisplayMode() {
      return this._cssDisplayMode;
    }
    SetFullscreenMode(e) {
      if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error("invalid fullscreen mode");
      this._fullscreenMode = e;
      const t = this._runtime.GetLayoutManager();
      t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
    }
    GetFullscreenMode() {
      return this._fullscreenMode;
    }
    SetDocumentFullscreenMode(e) {
      if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error("invalid fullscreen mode");
      this._documentFullscreenMode = e;
      const t = this._runtime.GetLayoutManager();
      t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
    }
    GetDocumentFullscreenMode() {
      return this._documentFullscreenMode;
    }
    GetCurrentFullscreenMode() {
      return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode();
    }
    SetFullscreenScalingQuality(e) {
      if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(e)) throw new Error("invalid fullscreen scaling quality");
      this._wantFullscreenScalingQuality = e, this._runtime.GetLayoutManager().SetAllLayerProjectionChanged();
    }
    GetSetFullscreenScalingQuality() {
      return this._wantFullscreenScalingQuality;
    }
    GetCurrentFullscreenScalingQuality() {
      return this._fullscreenScalingQuality;
    }
    static _FullscreenModeNumberToString(e) {
      switch (e) {
        case 0:
          return "off";
        case 1:
          return "crop";
        case 2:
          return "scale-inner";
        case 3:
          return "scale-outer";
        case 4:
          return "letterbox-scale";
        case 5:
          return "letterbox-integer-scale";
        default:
          throw new Error("invalid fullscreen mode");
      }
    }
    GetLastWidth() {
      return this._windowInnerWidth;
    }
    GetLastHeight() {
      return this._windowInnerHeight;
    }
    GetDrawWidth() {
      return this._drawWidth;
    }
    GetDrawHeight() {
      return this._drawHeight;
    }
    SetMipmapsEnabled(e) {
      this._enableMipmaps = !!e;
    }
    GetMipmapsEnabled() {
      return this._enableMipmaps;
    }
    _SetTextureAnisotropy(e) {
      this._textureAnisotropy = e;
    }
    GetTextureAnisotropy() {
      return this._textureAnisotropy;
    }
    IsRendererContextLost() {
      return this.GetRenderer().IsContextLost();
    }
    _OnWebGLContextLost(e) {
      console.log("[Construct] WebGL context lost"), e.preventDefault(), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._webglRenderer.OnContextLost(), this._runtime._OnRendererContextLost();
    }
    _OnWebGPUDeviceLost() {
      console.log("[Construct] WebGPU device lost"), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._runtime._OnRendererContextLost();
    }
    async _OnWebGLContextRestored(e) {
      await this._webglRenderer.OnContextRestored(), await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log("[Construct] WebGL context restored");
    }
    async _OnWebGPUDeviceRestored() {
      await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log("[Construct] WebGPU device restored");
    }
    GetWebGLRenderer() {
      return this._webglRenderer;
    }
    GetWebGPURenderer() {
      return this._webgpuRenderer;
    }
    GetRenderer() {
      return this._webgpuRenderer || this._webglRenderer;
    }
    GetIRenderer() {
      return this._iRenderer;
    }
    GetRendererString() {
      let e = "";
      return e = this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber(), this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (e += "-software"), e;
    }
    GetRendererDetailString() {
      return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
    }
    GetRenderScale() {
      return "low" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale();
    }
    GetDisplayScale() {
      const e = this.GetCurrentFullscreenMode();
      if ("off" === e || "crop" === e) return 1;
      const t = this._runtime.GetOriginalViewportWidth(), s = this._runtime.GetOriginalViewportHeight(), i = t / s, r = this._canvasDeviceWidth / this._canvasDeviceHeight;
      return "scale-inner" !== e && r > i || "scale-inner" === e && r < i ? this._canvasCssHeight / s : this._canvasCssWidth / t;
    }
    GetEffectLayerScaleParam() {
      return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale();
    }
    GetEffectDevicePixelRatioParam() {
      return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio();
    }
    SetDeviceTransformOffset(e, t) {
      this._deviceTransformOffX = e, this._deviceTransformOffY = t;
    }
    SetDeviceTransform(e, t, s, i = true) {
      t = t || this._drawWidth, s = s || this._drawHeight;
      const r = t / 2 + this._deviceTransformOffX, a = s / 2 + this._deviceTransformOffY;
      if (i) {
        let i2 = this.GetDefaultProjectionMatrix();
        t === this._drawWidth && s === this._drawHeight || (e.CalculatePerspectiveMatrix(tempProjection, t / s), i2 = tempProjection), e.SetProjectionMatrix(i2);
      }
      const n = e.CalculateLookAtModelView2(r, a, e.GetDefaultCameraZ(s), r, a, 0, s);
      e.SetModelViewMatrix(n);
    }
    SetCssTransform(e, t = true) {
      const s = this.GetCssWidth(), i = this.GetCssHeight(), r = s / 2, a = i / 2;
      t && e.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
      const n = e.CalculateLookAtModelView2(r, a, e.GetDefaultCameraZ(i), r, a, 0, i);
      e.SetModelViewMatrix(n);
    }
    GetDeviceWidth() {
      return this._canvasDeviceWidth;
    }
    GetDeviceHeight() {
      return this._canvasDeviceHeight;
    }
    GetCssWidth() {
      return this._canvasCssWidth;
    }
    GetCssHeight() {
      return this._canvasCssHeight;
    }
    GetCanvasClientX() {
      return this._canvasCssOffsetX;
    }
    GetCanvasClientY() {
      return this._canvasCssOffsetY;
    }
    GetHTMLLayerCount() {
      return this._canvasLayers.length;
    }
    _CanUseImageBitmapRenderingContext() {
      return "undefined" != typeof OffscreenCanvas && this.GetMainCanvas() instanceof OffscreenCanvas && ("Chromium" !== C32.Platform.BrowserEngine || C32.Platform.BrowserVersionNumber >= 124);
    }
    async SetHTMLLayerCount(e, t = false) {
      if (e < 1) throw new Error("invalid HTML layer count");
      if (this._canvasLayers.length === e) return;
      const s = { "count": e, "layersDomState": this._runtime.GetLayoutManager().GetMainRunningLayout()._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()), "immediate": t, "marginLeft": this._canvasCssOffsetX, "marginTop": this._canvasCssOffsetY, "styleWidth": this._canvasCssWidth, "styleHeight": this._canvasCssHeight };
      let i;
      if (i = this.IsInWorker() ? await this._runtime.PostComponentMessageToDOMAsync("canvas", "set-html-layer-count", s) : self["c3_runtimeInterface"]["_OnSetHTMLLayerCount"](s), e < this._canvasLayers.length) this._canvasLayers.length = e;
      else for (const e2 of i["addedCanvases"]) {
        e2.width = this._canvasDeviceWidth, e2.height = this._canvasDeviceHeight;
        const t2 = this._CanUseImageBitmapRenderingContext() ? "bitmaprenderer" : "2d", s2 = e2.getContext(t2);
        if (!s2) throw new Error(`failed to acquire '${t2}' canvas context`);
        this._canvasLayers.push({ canvas: e2, ctx: s2 });
      }
      this._runtime.UpdateRender();
    }
    BlitMainCanvasToHTMLLayerCanvas(e) {
      if (e >= this._canvasLayers.length) return;
      const t = this.GetMainCanvas(), s = this._canvasLayers[e].ctx;
      this._CanUseImageBitmapRenderingContext() ? s["transferFromImageBitmap"](t["transferToImageBitmap"]()) : (s.globalCompositeOperation = "copy", s.drawImage(t, 0, 0));
    }
    GetAdditionalRenderTarget(e) {
      e.depth = this._runtime.Uses3DFeatures();
      const t = this._availableAdditionalRenderTargets, s = t.findIndex((t2) => t2.IsCompatibleWithOptions(e));
      let i;
      return -1 !== s ? (i = t[s], t.splice(s, 1)) : i = this.GetRenderer().CreateRenderTarget(e), this._usedAdditionalRenderTargets.add(i), i;
    }
    ReleaseAdditionalRenderTarget(e) {
      if (!this._usedAdditionalRenderTargets.has(e)) throw new Error("render target not in use");
      this._usedAdditionalRenderTargets.delete(e), this._availableAdditionalRenderTargets.push(e);
    }
    GetEffectCompositorRenderTarget() {
      const e = { sampling: this._runtime.GetSampling() };
      return "low" === this.GetCurrentFullscreenScalingQuality() && (e.width = this.GetDrawWidth(), e.height = this.GetDrawHeight()), this.GetAdditionalRenderTarget(e);
    }
    ReleaseEffectCompositorRenderTarget(e) {
      this.ReleaseAdditionalRenderTarget(e);
    }
    *activeLayersGpuProfiles() {
      for (const e of this._runtime.GetLayoutManager().runningLayouts()) for (const t of e.GetLayers()) {
        const e2 = this._layersGpuProfile.get(t);
        e2 && (yield e2);
      }
    }
    GetLayerTimingsBuffer(e) {
      if (!this.GetRenderer().SupportsGPUProfiling()) return null;
      let t = this._layersGpuProfile.get(e);
      return t || (t = { layer: e, name: e.GetName(), timingsBuffer: C32.New(C32.Gfx.WebGLQueryResultBuffer, this._webglRenderer), curUtilisation: 0, lastTotalUtilisation: 0, lastSelfUtilisation: 0 }, this._layersGpuProfile.set(e, t)), t.timingsBuffer;
    }
    _Update1sFrameRange() {
      const e = this.GetRenderer();
      if (e.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
        this._gpuTimeEndFrame = e.GetFrameNumber(), this._gpuCurUtilisation = NaN;
        for (const e2 of this.activeLayersGpuProfiles()) e2.curUtilisation = NaN;
      }
    }
    _UpdateTick() {
      this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL(), this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU();
    }
    _UpdateTick_WebGL() {
      if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {
        if (this._runtime.IsDebug()) {
          for (const e of this.activeLayersGpuProfiles()) if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(e.curUtilisation)) return;
        }
        if (this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1), this._runtime.IsDebug()) {
          const e = /* @__PURE__ */ new Map();
          for (const t2 of this.activeLayersGpuProfiles()) t2.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), t2.lastTotalUtilisation = Math.min(t2.curUtilisation, 1), e.set(t2.layer, t2.lastTotalUtilisation);
          for (const t2 of this.activeLayersGpuProfiles()) {
            const s2 = t2.layer, i = (e.get(s2) || 0) - s2.GetSubLayers().reduce((t3, s3) => t3 + (e.get(s3) || 0), 0);
            t2.lastSelfUtilisation = C32.clamp(i, 0, 1);
          }
          const t = this._runtime.GetMainRunningLayout(), s = this._gpuLastUtilisation - t._GetRootLayers().reduce((t2, s2) => t2 + (e.get(s2) || 0), 0);
          self.C3Debugger.UpdateGPUProfile(C32.clamp(s, 0, 1), this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()]);
        }
        this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;
      }
    }
    GetGPUFrameTimingsBuffer() {
      return this._gpuFrameTimingsBuffer;
    }
    _UpdateTick_WebGPU() {
      if (0 === this._gpuTimeEndFrame) return;
      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {
        const t2 = this._webgpuFrameTimings.get(e2);
        if (t2 && !t2.HasResult()) return;
      }
      const e = this._runtime.GetMainRunningLayout(), t = C32.MakeFilledArray(e.GetLayerCount() + 1, 0);
      let s = 0;
      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {
        const i = this._webgpuFrameTimings.get(e2);
        if (!i) continue;
        const r = i.GetResult();
        let a = BigInt(0), n = BigInt(0);
        const h = BigInt(0);
        for (let e3 = 0, s2 = Math.min(t.length, r.length / 2); e3 < s2; ++e3) {
          const s3 = r[2 * e3], i2 = r[2 * e3 + 1];
          s3 !== h && (a === h || s3 < a) && (a = s3), i2 > n && (n = i2);
          const o = Number(i2 - s3) / 1e9;
          t[e3] += o;
        }
        s += Number(n - a) / 1e9;
      }
      if (this._gpuLastUtilisation = C32.clamp(s, 0, 1), this._runtime.IsDebug()) {
        const s2 = e.GetLayers(), i = /* @__PURE__ */ new Map();
        for (let e2 = 0, r2 = Math.min(s2.length, t.length - 1); e2 < r2; ++e2) {
          const r3 = t[e2 + 1];
          i.set(s2[e2], r3);
        }
        const r = [], a = /* @__PURE__ */ new Map();
        for (const [e2, t2] of i) {
          const s3 = [...e2.selfAndAllSubLayers()].reduce((e3, t3) => e3 + (i.get(t3) || 0), 0);
          a.set(e2, s3), r.push({ name: e2.GetName(), lastSelfUtilisation: C32.clamp(t2, 0, 1), lastTotalUtilisation: C32.clamp(s3, 0, 1) });
        }
        const n = this._gpuLastUtilisation - e._GetRootLayers().reduce((e2, t2) => e2 + (a.get(t2) || 0), 0);
        self.C3Debugger.UpdateGPUProfile(C32.clamp(n, 0, 1), this._gpuLastUtilisation, r);
      }
      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) this._webgpuFrameTimings.delete(e2);
      this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;
    }
    _AddWebGPUFrameTiming(e) {
      this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), e);
    }
    GetGPUUtilisation() {
      return this._gpuLastUtilisation;
    }
    SnapshotCanvas(e, t, s, i, r, a) {
      return this._snapshotFormat = e, this._snapshotQuality = t, this._snapshotArea.setWH(s, i, r, a), this._snapshotPromise || (this._snapshotPromise = new Promise((e2) => {
        this._snapshotResolve = e2;
      })), this._snapshotPromise;
    }
    _MaybeTakeSnapshot() {
      if (!this._snapshotFormat) return;
      let e = this.GetMainCanvas();
      const t = this._snapshotArea, s = C32.clamp(Math.floor(t.getLeft()), 0, e.width), i = C32.clamp(Math.floor(t.getTop()), 0, e.height);
      let r = t.width();
      r = 0 === r ? e.width - s : C32.clamp(Math.floor(r), 0, e.width - s);
      let a = t.height();
      if (a = 0 === a ? e.height - i : C32.clamp(Math.floor(a), 0, e.height - i), (0 !== s || 0 !== i || r !== e.width || a !== e.height) && r > 0 && a > 0) {
        const t2 = C32.CreateCanvas(r, a);
        t2.getContext("2d").drawImage(e, s, i, r, a, 0, 0, r, a), e = t2;
      }
      C32.CanvasToBlob(e, this._snapshotFormat, this._snapshotQuality).then((e2) => {
        this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl), this._snapshotUrl = URL.createObjectURL(e2), this._snapshotPromise = null, this._snapshotResolve(e2);
      }), this._snapshotFormat = "", this._snapshotQuality = 1;
    }
    GetCanvasSnapshotUrl() {
      return this._snapshotUrl;
    }
    SetIsPastingToDrawingCanvas(e) {
      e ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--;
    }
    IsPastingToDrawingCanvas() {
      return this._isPastingToDrawingCanvas > 0;
    }
    InitLoadingScreen(e) {
      const t = this.GetRenderer();
      if (2 === e) this._percentText = C32.New(C32.Gfx.RendererText, this.GetRenderer()), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment("center"), this._percentText.SetVerticalAlignment("center"), this._percentText.SetSize(300, 200);
      else if (0 === e) {
        const e2 = this._runtime.GetLoadingLogoAsset();
        e2 && e2.LoadStaticTexture(t).catch((e3) => console.warn("[C3 runtime] Failed to create texture for loading logo: ", e3));
      } else 4 === e && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then((e2) => {
        "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.logo = e2;
      }).catch((e2) => console.warn("Failed to load splash image: ", e2)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then((e2) => {
        "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.powered = e2;
      }).catch((e2) => console.warn("Failed to load splash image: ", e2)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then((e2) => {
        "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.website = e2;
      }).catch((e2) => console.warn("Failed to load splash image: ", e2)));
    }
    async _LoadSvgSplashImage(e) {
      e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();
      const t = await C32.FetchBlob(e), s = await this._runtime.RasterSvgImage(t, 2048, 2048);
      return await this.GetRenderer().CreateStaticTextureAsync(s, { mipMapQuality: "high" });
    }
    async _LoadBitmapSplashImage(e) {
      e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();
      const t = await C32.FetchBlob(e);
      return await this.GetRenderer().CreateStaticTextureAsync(t, { mipMapQuality: "high" });
    }
    HideCordovaSplashScreen() {
      this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash");
    }
    StartLoadingScreen() {
      this._loaderStartTime = Date.now(), this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
      3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen();
    }
    async EndLoadingScreen() {
      const e = this.GetRenderer();
      this._loadingProgress = 1;
      const t = this._runtime.GetLoaderStyle();
      4 === t && await this._splashDonePromise, this._splashDoneResolve = null, this._splashDonePromise = null, -1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1), this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler), this._loadingprogress_handler = null, this._percentText && (this._percentText.Release(), this._percentText = null), this._runtime.ReleaseLoadingLogoAsset(), e.Start(), this._splashTextures.logo && (e.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null), this._splashTextures.powered && (e.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null), this._splashTextures.website && (e.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null), e.ClearRgba(0, 0, 0, 0), e.Finish(), this._splashState = "done", this._gpuTimeStartFrame = e.GetFrameNumber(), 3 === t && this.HideCordovaSplashScreen();
    }
    _DrawLoadingScreen() {
      if (-1 === this._rafId) return;
      const e = this.GetRenderer();
      e.Start(), this._rafId = -1;
      const t = this._runtime.GetAssetManager().HasHadErrorLoading(), s = this._runtime.GetLoaderStyle();
      if (3 !== s && (this.SetCssTransform(e), e.ClearRgba(0, 0, 0, 0), e.ResetColor(), e.SetTextureFillMode(), e.SetTexture(null)), 0 === s) this._DrawProgressBarAndLogoLoadingScreen(t);
      else if (1 === s) this._DrawProgressBarLoadingScreen(t, 120, 0);
      else if (2 === s) this._DrawPercentTextLoadingScreen(t);
      else if (3 === s) C32.noop();
      else {
        if (4 !== s) throw new Error("invalid loader style");
        this._DrawSplashLoadingScreen(t);
      }
      e.Finish(), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
    }
    _DrawPercentTextLoadingScreen(e) {
      e ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(0.6, 0.6, 0.6), this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
      const t = this._canvasCssWidth / 2, s = this._canvasCssHeight / 2;
      tempQuad.setRect(t - 150, s - 100, t + 150, s + 100);
      const i = this.GetRenderer();
      i.SetTexture(this._percentText.GetTexture()), i.Quad3(tempQuad, this._percentText.GetTexRect());
    }
    _DrawProgressBarLoadingScreen(e, t, s) {
      const i = this.GetRenderer();
      i.SetColorFillMode(), e ? i.SetColorRgba(1, 0, 0, 1) : i.SetColorRgba(0.118, 0.565, 1, 1);
      const r = this._canvasCssWidth / 2, a = this._canvasCssHeight / 2, n = t / 2;
      tempRect.setWH(r - n, a - 4 + s, Math.floor(t * this._loadingProgress), 8), i.Rect(tempRect), tempRect.setWH(r - n, a - 4 + s, t, 8), tempRect.offset(-0.5, -0.5), tempRect.inflate(0.5, 0.5), i.SetColorRgba(0, 0, 0, 1), i.LineRect2(tempRect), tempRect.inflate(1, 1), i.SetColorRgba(1, 1, 1, 1), i.LineRect2(tempRect);
    }
    _DrawProgressBarAndLogoLoadingScreen(e) {
      const t = this.GetRenderer(), s = this._runtime.GetLoadingLogoAsset();
      if (!s) return void this._DrawProgressBarLoadingScreen(e, 120, 0);
      const i = s.GetTexture();
      if (!i) return void this._DrawProgressBarLoadingScreen(e, 120, 0);
      const r = i.GetWidth(), a = i.GetHeight(), n = this._canvasCssWidth / 2, h = this._canvasCssHeight / 2, o = r / 2, l = a / 2;
      tempQuad.setRect(n - o, h - l, n + o, h + l), t.SetTexture(i), t.Quad(tempQuad), this._DrawProgressBarLoadingScreen(e, r, l + 16);
    }
    _DrawSplashLoadingScreen(e) {
      const t = this.GetRenderer(), s = this._splashTextures.logo, i = this._splashTextures.powered, r = this._splashTextures.website, a = Date.now();
      0 === this._splashFrameNumber && (this._loaderStartTime = a);
      const n = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(), h = n ? 0 : 200, o = n ? 0 : 3e3;
      let l = 1;
      "fade-in" === this._splashState ? l = Math.min((a - this._loaderStartTime) / 300, 1) : "fade-out" === this._splashState && (l = Math.max(1 - (a - this._splashFadeOutStartTime) / 300, 0)), t.SetColorFillMode(), t.SetColorRgba(0.231 * l, 0.251 * l, 0.271 * l, l), tempRect.set(0, 0, this._canvasCssWidth, this._canvasCssHeight), t.Rect(tempRect);
      const c = Math.ceil(this._canvasCssWidth), _ = Math.ceil(this._canvasCssHeight);
      let d, u;
      this._canvasCssHeight > 256 ? (t.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d = c, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.8 * _ - u / 2, d, u), t.Rect(tempRect), e ? t.SetColorRgba(l, 0, 0, l) : t.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d = c * this._loadingProgress, tempRect.setWH(0.5 * c - d / 2, 0.8 * _ - u / 2, d, u), t.Rect(tempRect), t.SetColorRgba(l, l, l, l), t.SetTextureFillMode(), i && (d = 1.5 * C32.clamp(0.22 * _, 105, 0.6 * c), u = d / 8, tempRect.setWH(0.5 * c - d / 2, 0.2 * _ - u / 2, d, u), t.SetTexture(i), t.Rect(tempRect)), s && (d = Math.min(0.395 * _, 0.95 * c), u = d, tempRect.setWH(0.5 * c - d / 2, 0.485 * _ - u / 2, d, u), t.SetTexture(s), t.Rect(tempRect)), r && (d = 1.5 * C32.clamp(0.22 * _, 105, 0.6 * c), u = d / 8, tempRect.setWH(0.5 * c - d / 2, 0.868 * _ - u / 2, d, u), t.SetTexture(r), t.Rect(tempRect))) : (t.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d = c, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.85 * _ - u / 2, d, u), t.Rect(tempRect), e ? t.SetColorRgba(l, 0, 0, l) : t.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d = c * this._loadingProgress, tempRect.setWH(0.5 * c - d / 2, 0.85 * _ - u / 2, d, u), t.Rect(tempRect), t.SetColorRgba(l, l, l, l), t.SetTextureFillMode(), s && (d = 0.55 * _, u = d, tempRect.setWH(0.5 * c - d / 2, 0.45 * _ - u / 2, d, u), t.SetTexture(s), t.Rect(tempRect))), this._splashFrameNumber++, "fade-in" === this._splashState && a - this._loaderStartTime >= 300 && this._splashFrameNumber >= 2 && (this._splashState = "wait", this._splashFadeInFinishTime = a), "wait" === this._splashState && a - this._splashFadeInFinishTime >= o && this._loadingProgress >= 1 && (this._splashState = "fade-out", this._splashFadeOutStartTime = a), ("fade-out" === this._splashState && a - this._splashFadeOutStartTime >= 300 + h || n && this._loadingProgress >= 1 && a - this._loaderStartTime < 500) && this._splashDoneResolve();
    }
  };
}
{
  const C32 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, ISDKBehaviorInstanceBase = self.ISDKBehaviorInstanceBase, DEFAULT_RUNTIME_OPTS = { "messagePort": null, "runtimeBaseUrl": "", "headless": false, "hasDom": true, "isInWorker": false, "useAudio": true, "exportType": "" };
  let ife = true;
  C32.Runtime = class extends C32.DefendedBase {
    constructor(e) {
      e = Object.assign({}, DEFAULT_RUNTIME_OPTS, e), super(), this._messagePort = e["messagePort"], this._runtimeBaseUrl = e["runtimeBaseUrl"], this._previewUrl = e["previewUrl"], this._isHeadless = !!e["headless"], this._hasDom = !!e["hasDom"], this._isInWorker = !!e["isInWorker"], ife = e["ife"], this._useAudio = !!e["useAudio"], this._exportType = e["exportType"], this._isiOSCordova = !!e["isiOSCordova"], this._isiOSWebView = !!e["isiOSWebView"], this._isWindowsWebView2 = !!e["isWindowsWebView2"], this._isAnyWebView2Wrapper = !!e["isAnyWebView2Wrapper"], this._isFBInstantAvailable = !!e["isFBInstantAvailable"], this._isDebug = !("preview" !== this._exportType || !e["isDebug"]), this._breakpointsEnabled = this._isDebug, this._isDebugging = this._isDebug, this._debuggingDisabled = 0, this._additionalLoadPromises = [], this._additionalCreatePromises = [], this._isUsingCreatePromises = false, this._projectName = "", this._projectVersion = "", this._projectUniqueId = "", this._appId = "", this._exportTimestamp = 0, this._originalViewportWidth = 0, this._originalViewportHeight = 0, this._devicePixelRatio = self.devicePixelRatio, this._parallaxXorigin = 0, this._parallaxYorigin = 0, this._viewportWidth = 0, this._viewportHeight = 0, this._loaderStyle = 0, this._usesLoaderLayout = false, this._isLoading = true, this._usesAnyBackgroundBlending = false, this._usesAnyCrossSampling = false, this._usesAnyDepthSampling = false, this._loadingLogoAsset = null, this._assetManager = C32.New(C32.AssetManager, this, e), this._layoutManager = C32.New(C32.LayoutManager, this), this._eventSheetManager = C32.New(C32.EventSheetManager, this), this._addonManager = C32.New(C32.AddonManager, this, e["wrapperComponentIds"]), this._collisionEngine = C32.New(C32.CollisionEngine, this), this._timelineManager = C32.New(C32.TimelineManager, this), this._transitionManager = C32.New(C32.TransitionManager, this), this._templateManager = C32.New(C32.TemplateManager, this), this._flowchartManager = C32.New(C32.FlowchartManager, this), this._textIconManager = C32.New(C32.TextIconManager, { getIconSetMeta: (e2) => this._GetTextIconSetMeta(e2), getIconSetContent: (e2) => this._GetTextIconSetContent(e2) }), this._iconChangeHandlers = /* @__PURE__ */ new Map(), this._allObjectClasses = [], this._objectClassesByName = /* @__PURE__ */ new Map(), this._objectClassesBySid = /* @__PURE__ */ new Map(), this._familyCount = 0, this._allContainers = [], this._allEffectLists = /* @__PURE__ */ new Set(), this._currentLayoutStack = [], this._instancesPendingCreate = [], this._instancesPendingDestroy = /* @__PURE__ */ new Map(), this._hasPendingInstances = false, this._isFlushingPendingInstances = false, this._objectCount = 0, this._nextUid = 0, this._instancesByUid = /* @__PURE__ */ new Map(), this._instancesPendingRelease = /* @__PURE__ */ new Set(), this._instancesPendingReleaseAffectedObjectClasses = /* @__PURE__ */ new Set(), this._objectReferenceTable = [], this._jsPropNameTable = [], this._canvasManager = null, this._uses3dFeatures = false, this._framerateMode = "vsync", this._sampling = "trilinear", this._isPixelRoundingEnabled = false, this._needRender = true, this._pauseOnBlur = false, this._isPausedOnBlur = false, this._exportToVideo = null, this._tickCallbacks = { normal: (e2) => {
        this._rafId = -1, this._ruafId = -1, this.Tick(e2);
      }, tickOnly: (e2) => {
        this._ruafId = -1, this.Tick(e2, false, "skip-render");
      }, renderOnly: () => {
        this._rafId = -1, this.Render();
      } }, this._rafId = -1, this._ruafId = -1, this._tickCount = 0, this._tickCountNoSave = 0, this._hasStarted = false, this._isInTick = false, this._hasStartedTicking = false, this._isLayoutFirstTick = true, this._isAutoSuspendEnabled = true, this._isPageVisibilitySuspended = false, this._suspendCount = 0, this._scheduleTriggersThrottle = new C32.PromiseThrottle(1), this._randomNumberCallback = () => Math.random(), this._startTime = 0, this._lastTickTime = 0, this._dtRaw = 0, this._dt1 = 0, this._dt = 0, this._timeScale = 1, this._maxDt = 1 / 30, this._minDt = 0, this._gameTime = C32.New(C32.KahanSum), this._gameTimeRaw = C32.New(C32.KahanSum), this._wallTime = C32.New(C32.KahanSum), this._instanceTimes = /* @__PURE__ */ new Map(), this._fpsFrameCount = -1, this._fpsLastTime = 0, this._fps = 0, this._tpsTickCount = -1, this._tps = 0, this._mainThreadTimeCounter = 0, this._mainThreadTime = 0, this._isLoadingState = false, this._saveToSlotName = "", this._saveToJsonString = false, this._loadFromSlotName = "", this._loadFromJson = null, this._lastSaveJson = "", this._projectStorage = null, this._savegamesStorage = null, this._dispatcher = C32.New(C32.Event.Dispatcher), this._domEventHandlers = /* @__PURE__ */ new Map(), this._pendingResponsePromises = /* @__PURE__ */ new Map(), this._nextDomResponseId = 0, this._didRequestDeviceOrientationEvent = false, this._didRequestDeviceMotionEvent = false, this._isReadyToHandleEvents = false, this._waitingToHandleEvents = [], this._eventObjects = { "pretick": C32.New(C32.Event, "pretick", false), "tick": C32.New(C32.Event, "tick", false), "tick2": C32.New(C32.Event, "tick2", false), "instancecreate": C32.New(C32.Event, "instancecreate", false), "instancedestroy": C32.New(C32.Event, "instancedestroy", false), "beforelayoutchange": C32.New(C32.Event, "beforelayoutchange", false), "layoutchange": C32.New(C32.Event, "layoutchange", false), "beforerender": C32.New(C32.Event, "beforerender", false), "afterrender": C32.New(C32.Event, "afterrender", false) }, this._eventObjects["instancecreate"].instance = null, this._eventObjects["instancedestroy"].instance = null, this._userScriptDispatcher = C32.New(C32.Event.Dispatcher), this._userScriptEventObjects = null;
      const t = (e2, t2) => C32.BehaviorInstance.SortByTickSequence(this, e2, t2);
      this._behInstsToTick = C32.New(C32.RedBlackSet, t), this._behInstsToPostTick = C32.New(C32.RedBlackSet, t), this._behInstsToTick2 = C32.New(C32.RedBlackSet, t), this._jobScheduler = C32.New(C32.JobSchedulerRuntime, this, e["jobScheduler"]), e["canvas"] && (this._canvasManager = C32.New(C32.CanvasManager, this)), this._messagePort.onmessage = (e2) => this["_OnMessageFromDOM"](e2.data), this.AddDOMComponentMessageHandler("runtime", "visibilitychange", (e2) => this._OnVisibilityChange(e2)), this.AddDOMComponentMessageHandler("runtime", "wrapper-extension-message", (e2) => this._OnWrapperExtensionMessage(e2)), this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo()), this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", (e2) => this._InvokeFunctionFromJS(e2)), this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self["goToLastErrorScript"]), this.AddDOMComponentMessageHandler("runtime", "offline-audio-render-completed", (e2) => this._OnOfflineAudioRenderCompleted(e2)), this._dispatcher.addEventListener("window-blur", (e2) => this._OnWindowBlur(e2)), this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus()), this._timelineManager.AddRuntimeListeners(), this._templateManager.AddRuntimeListeners(), this._iRuntime = null, this._constructVersionCode = 0, this._interfaceMap = /* @__PURE__ */ new WeakMap(), this._commonScriptInterfaces = { keyboard: null, mouse: null, touch: null, timelineController: null }, this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), this._instancesNeedingAfterLoadArray = [];
    }
    static Create(e) {
      return C32.New(C32.Runtime, e);
    }
    Release() {
      C32.clearArray(this._allObjectClasses), this._objectClassesByName.clear(), this._objectClassesBySid.clear(), this._layoutManager.Release(), this._layoutManager = null, this._eventSheetManager.Release(), this._eventSheetManager = null, this._addonManager.Release(), this._addonManager = null, this._assetManager.Release(), this._assetManager = null, this._collisionEngine.Release(), this._collisionEngine = null, this._timelineManager.Release(), this._timelineManager = null, this._transitionManager.Release(), this._transitionManager = null, this._templateManager.Release(), this._templateManager = null, this._flowchartManager.Release(), this._flowchartManager = null, this._textIconManager.Release(), this._textIconManager = null, this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null), this._dispatcher.Release(), this._dispatcher = null, this._tickEvent = null;
    }
    "_OnMessageFromDOM"(e) {
      const t = e["type"];
      if ("event" === t) this._OnEventFromDOM(e);
      else {
        if ("result" !== t) throw new Error(`unknown message '${t}'`);
        this._OnResultFromDOM(e);
      }
    }
    _OnEventFromDOM(e) {
      if (!this._isReadyToHandleEvents) return void this._waitingToHandleEvents.push(e);
      const t = e["component"], s = e["handler"], i = e["data"], n = e["dispatchOpts"], a = !(!n || !n["dispatchRuntimeEvent"]), r = !(!n || !n["dispatchUserScriptEvent"]), o = e["responseId"];
      if ("runtime" === t) {
        if (a) {
          const e2 = new C32.Event(s);
          e2.data = i, this._dispatcher.dispatchEventAndWaitAsyncSequential(e2);
        }
        if (r) {
          const e2 = new C32.Event(s, true);
          if (i) for (const [t2, s2] of Object.entries(i)) e2[t2] = s2;
          this.DispatchUserScriptEvent(e2);
        }
      }
      const h = this._domEventHandlers.get(t);
      if (!h) return void (a || r || console.warn(`[Runtime] No DOM event handlers for component '${t}'`));
      const l = h.get(s);
      if (!l) return void (a || r || console.warn(`[Runtime] No DOM handler '${s}' for component '${t}'`));
      let c = null;
      try {
        c = l(i);
      } catch (e2) {
        return console.error(`Exception in '${t}' handler '${s}':`, e2), void (null !== o && this._PostResultToDOM(o, false, "" + e2));
      }
      null !== o && (c && c.then ? c.then((e2) => this._PostResultToDOM(o, true, e2)).catch((e2) => {
        console.error(`Rejection from '${t}' handler '${s}':`, e2), this._PostResultToDOM(o, false, "" + e2);
      }) : this._PostResultToDOM(o, true, c));
    }
    _PostResultToDOM(e, t, s) {
      this._messagePort.postMessage({ "type": "result", "responseId": e, "isOk": t, "result": s });
    }
    _OnResultFromDOM(e) {
      const t = e["responseId"], s = e["isOk"], i = e["result"], n = this._pendingResponsePromises.get(t);
      s ? n.resolve(i) : n.reject(i), this._pendingResponsePromises.delete(t);
    }
    AddDOMComponentMessageHandler(e, t, s) {
      let i = this._domEventHandlers.get(e);
      if (i || (i = /* @__PURE__ */ new Map(), this._domEventHandlers.set(e, i)), i.has(t)) throw new Error(`[Runtime] Component '${e}' already has handler '${t}'`);
      i.set(t, s);
    }
    PostComponentMessageToDOM(e, t, s, i) {
      this._messagePort.postMessage({ "type": "event", "component": e, "handler": t, "data": s, "responseId": null }, i);
    }
    PostComponentMessageToDOMAsync(e, t, s, i) {
      const n = this._nextDomResponseId++, a = new Promise((e2, t2) => {
        this._pendingResponsePromises.set(n, { resolve: e2, reject: t2 });
      });
      return this._messagePort.postMessage({ "type": "event", "component": e, "handler": t, "data": s, "responseId": n }, i), a;
    }
    SendWrapperExtensionMessage(e, t, s, i = -1) {
      this.PostComponentMessageToDOM("runtime", "send-wrapper-extension-message", { "componentId": e, "messageId": t, "params": s, "asyncId": i });
    }
    SendRawWrapperExtensionMessage(e) {
      this.PostComponentMessageToDOM("runtime", "send-raw-wrapper-extension-message", e);
    }
    SendWrapperExtensionMessageAsync(e, t, s) {
      const i = this._nextDomResponseId++, n = new Promise((e2, t2) => {
        this._pendingResponsePromises.set(i, { resolve: e2, reject: t2 });
      });
      return this.SendWrapperExtensionMessage(e, t, s, i), n;
    }
    _OnWrapperExtensionMessage(e) {
      if (-1 !== e["asyncId"]) {
        const t = e["asyncId"];
        this._pendingResponsePromises.get(t).resolve(e["params"]), this._pendingResponsePromises.delete(t);
      } else this._OnEventFromDOM({ "component": "wrapper-extension:" + e["componentId"], "handler": e["messageId"], "data": e["params"], "responseId": null });
    }
    AddWrapperExtensionMessageHandler(e, t, s) {
      this.AddDOMComponentMessageHandler("wrapper-extension:" + e, t, s);
    }
    HasWrapperComponentId(e) {
      return this._addonManager.HasWrapperComponentId(e);
    }
    PostToDebugger(e) {
      if (!this.IsDebug()) throw new Error("not in debug mode");
      this.PostComponentMessageToDOM("runtime", "post-to-debugger", e);
    }
    async Init(e) {
      C32.CommonACES_SetRuntime(this), this.IsDebug() ? await C3Debugger.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
      const t = await this._assetManager.FetchJson("data.json");
      if (await this._LoadDataJson(t), await this._InitialiseCanvas(e), this.IsPreview() || console.info("%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net", "font-weight: bold"), this.GetWebGLRenderer()) {
        const e2 = this.GetWebGLRenderer();
        console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGL ${e2.GetWebGLVersionNumber()} [${e2.GetUnmaskedRenderer()}]`);
      } else this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGPU [${this.GetWebGPURenderer().GetAdapterInfoString()}]`);
      this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."), this._isReadyToHandleEvents = true;
      for (const e2 of this._waitingToHandleEvents) this._OnEventFromDOM(e2);
      C32.clearArray(this._waitingToHandleEvents), this._canvasManager && this._canvasManager.StartLoadingScreen();
      for (const t2 of e["runOnStartupFunctions"]) this._additionalLoadPromises.push(this._RunOnStartupFunction(t2));
      if (await Promise.all([this._assetManager.WaitForAllToLoad(false), ...this._additionalLoadPromises]), C32.clearArray(this._additionalLoadPromises), !this._assetManager.HasHadErrorLoading()) return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new C32.Event("beforeruntimestart")), await this.Start(), this._messagePort.postMessage({ "type": "runtime-ready" }), this;
      this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
    }
    async _RunOnStartupFunction(e) {
      try {
        await e(this._iRuntime);
      } catch (e2) {
        console.error("[C3 runtime] Error in runOnStartup function: ", e2);
      }
    }
    async _LoadDataJson(e) {
      const t = e["project"];
      this._projectName = t[0], this._projectVersion = t[16], this._projectUniqueId = t[31], this._appId = t[38], this._exportTimestamp = t[36];
      const s = t[39] || "loading-logo.png";
      this._isPixelRoundingEnabled = !!t[9], this._originalViewportWidth = this._viewportWidth = t[10], this._originalViewportHeight = this._viewportHeight = t[11], this._collisionEngine._InitCollisionCellSize(this._originalViewportWidth, this._originalViewportHeight), this._parallaxXorigin = this._originalViewportWidth / 2, this._parallaxYorigin = this._originalViewportHeight / 2, this._framerateMode = t[37], this._uses3dFeatures = !!t[40], this._sampling = t[14], this._usesAnyBackgroundBlending = t[15], this._usesAnyCrossSampling = t[42], this._usesAnyDepthSampling = t[17], this._usesLoaderLayout = !!t[18], this._loaderStyle = t[19], this._nextUid = t[21], this._pauseOnBlur = t[22], this._constructVersionCode = t[51];
      const i = this._assetManager;
      i._SetAudioFiles(t[7], t[25]), i._SetMediaSubfolder(t[8]), i._SetFontsSubfolder(t[32]), i._SetIconsSubfolder(t[28]), i._SetWebFonts(t[29]), i._SetExportedFileList(t[45]), 0 === this._loaderStyle && s && (this._loadingLogoAsset = i.LoadImage({ url: s })), this._canvasManager && (this._canvasManager.SetFullscreenMode(C32.CanvasManager._FullscreenModeNumberToString(t[12])), this._canvasManager.SetFullscreenScalingQuality(t[23] ? "high" : "low"), this._canvasManager.SetMipmapsEnabled(0 !== t[24]), this._canvasManager._SetGPUPowerPreference(t[34]), this._canvasManager._SetTextureAnisotropy(t[41]), this._canvasManager._SetWebGPUEnabled(t[13]), this._canvasManager._SetZAxisScale(t[30]), this._canvasManager._SetZDistances(t[46], t[47]), this._canvasManager._SetInitFieldOfView(t[26]), this._canvasManager._SetLimitedToWebGL1(t[48]), this._canvasManager._SetMultitexturingMode(t[50]));
      const n = t[43];
      n && await this._LoadExportToVideoData(n), this._InitScriptInterfaces(), this._addonManager.CreateSystemPlugin(), this._objectReferenceTable = self.C3_GetObjectRefTable();
      const a = t[2];
      for (const e2 of a[1]) this._addonManager.CreateBehavior(e2);
      for (const e2 of a[0]) this._addonManager.CreatePlugin(e2);
      this._objectReferenceTable = self.C3_GetObjectRefTable(), this._LoadJsPropNameTable(), this._addonManager._InitAddonScriptInterfaces();
      for (const e2 of t[3]) {
        const t2 = C32.ObjectClass.Create(this, this._allObjectClasses.length, e2);
        this._allObjectClasses.push(t2), this._objectClassesByName.set(t2.GetName().toLowerCase(), t2), this._objectClassesBySid.set(t2.GetSID(), t2);
      }
      for (const e2 of t[4]) {
        this._allObjectClasses[e2[0]]._LoadFamily(e2);
      }
      for (const e2 of t[27]) {
        const t2 = e2.map((e3) => this._allObjectClasses[e3]);
        this._allContainers.push(C32.New(C32.Container, this, t2));
      }
      this._InitObjectsScriptInterface();
      for (const e2 of this._allObjectClasses) e2._OnAfterCreate();
      for (const e2 of t[5]) this._layoutManager.Create(e2);
      const r = t[1];
      if (r) {
        const e2 = this._layoutManager.GetLayoutByName(r);
        e2 && this._layoutManager.SetFirstLayout(e2);
      }
      for (const e2 of t[35]) this._transitionManager.Create(e2);
      for (const e2 of t[33]) this._timelineManager.Create(e2);
      for (const e2 of t[44]) this._templateManager.Create(e2);
      this._templateManager.HasTemplates() || (this._templateManager.Release(), this._templateManager = null);
      for (const e2 of t[49]) this._flowchartManager.Create(e2);
      this._flowchartManager.HasFlowcharts() || (this._flowchartManager.Release(), this._flowchartManager = null);
      for (const e2 of t[6]) this._eventSheetManager.Create(e2);
      this._eventSheetManager._PostInit(), this._InitGlobalVariableScriptInterface(), C32.clearArray(this._objectReferenceTable), this.FlushPendingInstances();
      let o = "any";
      const h = t[20];
      1 === h ? o = "portrait" : 2 === h && (o = "landscape"), this.PostComponentMessageToDOM("runtime", "set-target-orientation", { "targetOrientation": o });
    }
    async _LoadExportToVideoData(e) {
      const t = e["format"];
      "image-sequence" === t ? this._exportToVideo = new self.C3ExportToImageSequence(this, e) : "image-sequence-gif" === t ? this._exportToVideo = new self.C3ExportToGIF(this, e) : "webm" === t ? this._exportToVideo = new self.C3ExportToWebMVideo(this, e) : "mp4" === t && (this._exportToVideo = new self.C3ExportToMP4Video(this, e)), this._framerateMode = "unlimited-frame", this._canvasManager.SetFullscreenMode("off"), this._devicePixelRatio = 1, self.devicePixelRatio = 1, await this.PostComponentMessageToDOMAsync("runtime", "set-exporting-to-video", { "message": this._exportToVideo.GetExportingMessageForPercent(0), "duration": this._exportToVideo.GetDuration() });
    }
    GetLoaderStyle() {
      return this._loaderStyle;
    }
    IsExportToVideo() {
      return null !== this._exportToVideo;
    }
    GetExportVideoDuration() {
      return this._exportToVideo.GetDuration();
    }
    GetExportVideoFramerate() {
      return this._exportToVideo.GetFramerate();
    }
    _InitExportToVideo() {
      return this._exportToVideo.Init({ width: this._canvasManager.GetDeviceWidth(), height: this._canvasManager.GetDeviceHeight() });
    }
    _ExportToVideoAddFrame() {
      const e = this._tickCount / this.GetExportVideoFramerate();
      return this._exportToVideo.AddFrame(this._canvasManager.GetMainCanvas(), e);
    }
    _ExportToVideoAddKeyframe() {
      this._exportToVideo && this._exportToVideo.AddKeyframe();
    }
    _OnOfflineAudioRenderCompleted(e) {
      this._exportToVideo.OnOfflineAudioRenderCompleted(e);
    }
    _ExportToVideoFinish() {
      return this._exportToVideo.Finish();
    }
    IsFBInstantAvailable() {
      return this._isFBInstantAvailable;
    }
    IsLoading() {
      return this._isLoading;
    }
    AddLoadPromise(e) {
      this._additionalLoadPromises.push(e);
    }
    SetUsingCreatePromises(e) {
      this._isUsingCreatePromises = !!e;
    }
    AddCreatePromise(e) {
      this._isUsingCreatePromises && this._additionalCreatePromises.push(e);
    }
    GetCreatePromises() {
      return this._additionalCreatePromises;
    }
    _GetNextFamilyIndex() {
      return this._familyCount++;
    }
    GetFamilyCount() {
      return this._familyCount;
    }
    _AddEffectList(e) {
      this._allEffectLists.add(e);
    }
    _RemoveEffectList(e) {
      this._allEffectLists.delete(e);
    }
    _GetAllEffectLists() {
      return this._allEffectLists;
    }
    async _InitialiseCanvas(e) {
      this._canvasManager && (await this._canvasManager.CreateCanvas(e), this._canvasManager.InitLoadingScreen(this._loaderStyle));
    }
    async Start() {
      this._hasStarted = true, this._startTime = Date.now();
      let e = null;
      const t = new Promise((t2) => e = t2);
      if (this._usesLoaderLayout) {
        for (const e2 of this._allObjectClasses) e2.IsFamily() || e2.IsOnLoaderLayout() || !e2.IsWorldType() || e2.OnCreate();
        (async () => {
          await this._assetManager.WaitForAllToLoad(true), await t, this._isLoading = false, this._OnLoadFinished();
        })();
      } else this._isLoading = false;
      this._assetManager.SetInitialLoadFinished(), this.IsDebug() && C3Debugger.RuntimeInit(ife);
      for (const e2 of this._layoutManager.GetAllLayouts()) e2._CreateGlobalNonWorlds();
      this.IsExportToVideo() && await this._InitExportToVideo();
      const s = this._layoutManager.GetFirstLayout();
      await s._Load(null, this.GetRenderer()), await s._StartRunning(true), this._fpsLastTime = performance.now(), e(), this._usesLoaderLayout || this._OnLoadFinished();
      (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking"))["isSuspended"] && !this.IsExportToVideo() ? (this._suspendCount++, this._isPageVisibilitySuspended = true) : this.Tick();
    }
    _OnLoadFinished() {
      this.Trigger(C32.Plugins.System.Cnds.OnLoadFinished, null, null), this.PostComponentMessageToDOM("runtime", "register-sw");
    }
    GetObjectReference(e) {
      e = Math.floor(e);
      const t = this._objectReferenceTable;
      if (e < 0 || e >= t.length) throw new Error("invalid object reference");
      return t[e];
    }
    _LoadJsPropNameTable() {
      for (const e of self.C3_JsPropNameTable) {
        const t = C32.first(Object.keys(e));
        this._jsPropNameTable.push(t);
      }
    }
    GetJsPropName(e) {
      e = Math.floor(e);
      const t = this._jsPropNameTable;
      if (e < 0 || e >= t.length) throw new Error("invalid prop reference");
      return t[e];
    }
    HasDOM() {
      return this._hasDom;
    }
    IsHeadless() {
      return this._isHeadless;
    }
    IsInWorker() {
      return this._isInWorker;
    }
    GetRuntimeBaseURL() {
      return this._runtimeBaseUrl;
    }
    GetPreviewURL() {
      return this._previewUrl;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetEventStack() {
      return this._eventSheetManager.GetEventStack();
    }
    GetCurrentEventStackFrame() {
      return this._eventSheetManager.GetCurrentEventStackFrame();
    }
    GetCurrentEvent() {
      return this._eventSheetManager.GetCurrentEvent();
    }
    GetCurrentCondition() {
      return this._eventSheetManager.GetCurrentCondition();
    }
    IsCurrentConditionFirst() {
      return 0 === this.GetCurrentEventStackFrame().GetConditionIndex();
    }
    GetCurrentAction() {
      return this._eventSheetManager.GetCurrentAction();
    }
    GetAddonManager() {
      return this._addonManager;
    }
    GetSystemPlugin() {
      return this._addonManager.GetSystemPlugin();
    }
    GetObjectClassByIndex(e) {
      if ((e = Math.floor(e)) < 0 || e >= this._allObjectClasses.length) throw new RangeError("invalid index");
      return this._allObjectClasses[e];
    }
    GetObjectClassByName(e) {
      return this._objectClassesByName.get(e.toLowerCase()) || null;
    }
    GetObjectClassBySID(e) {
      return this._objectClassesBySid.get(e) || null;
    }
    GetSingleGlobalObjectClassByCtor(e) {
      const t = C32.AddonManager.GetPluginByConstructorFunction(e);
      return t ? t.GetSingleGlobalObjectClass() : null;
    }
    GetAllObjectClasses() {
      return this._allObjectClasses;
    }
    *allInstances() {
      for (const e of this._allObjectClasses) e.IsFamily() || (yield* e.instances());
    }
    Dispatcher() {
      return this._dispatcher;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    DispatchUserScriptEvent(e) {
      e.runtime = this.GetIRuntime();
      const t = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
      t && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), t && C3Debugger.AddScriptTime();
    }
    DispatchUserScriptEventAsyncWait(e) {
      return e.runtime = this.GetIRuntime(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);
    }
    GetOriginalViewportWidth() {
      return this._originalViewportWidth;
    }
    GetOriginalViewportHeight() {
      return this._originalViewportHeight;
    }
    SetOriginalViewportSize(e, t) {
      if (this._originalViewportWidth === e && this._originalViewportHeight === t) return;
      this._originalViewportWidth = e, this._originalViewportHeight = t;
      const s = this.GetLayoutManager();
      s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();
    }
    GetViewportWidth() {
      return this._viewportWidth;
    }
    GetViewportHeight() {
      return this._viewportHeight;
    }
    SetViewportSize(e, t) {
      if (this._viewportWidth === e && this._viewportHeight === t) return;
      this._viewportWidth = e, this._viewportHeight = t;
      const s = this.GetLayoutManager();
      s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();
    }
    _SetDevicePixelRatio(e) {
      this.IsExportToVideo() || (this._devicePixelRatio = e);
    }
    GetDevicePixelRatio() {
      return this._devicePixelRatio;
    }
    GetParallaxXOrigin() {
      return this._parallaxXorigin;
    }
    GetParallaxYOrigin() {
      return this._parallaxYorigin;
    }
    GetCanvasManager() {
      return this._canvasManager;
    }
    GetDrawWidth() {
      return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth;
    }
    GetDrawHeight() {
      return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight;
    }
    GetRenderScale() {
      return this._canvasManager ? this._canvasManager.GetRenderScale() : 1;
    }
    GetDisplayScale() {
      return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1;
    }
    GetEffectLayerScaleParam() {
      return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1;
    }
    GetEffectDevicePixelRatioParam() {
      return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() : 1;
    }
    GetCanvasClientX() {
      return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0;
    }
    GetCanvasClientY() {
      return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0;
    }
    GetCanvasCssWidth() {
      return this._canvasManager ? this._canvasManager.GetCssWidth() : 0;
    }
    GetCanvasCssHeight() {
      return this._canvasManager ? this._canvasManager.GetCssHeight() : 0;
    }
    GetFullscreenMode() {
      return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off";
    }
    GetAdditionalRenderTarget(e) {
      return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(e) : null;
    }
    ReleaseAdditionalRenderTarget(e) {
      this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(e);
    }
    UsesAnyBackgroundBlending() {
      return this._usesAnyBackgroundBlending;
    }
    UsesAnyCrossSampling() {
      return this._usesAnyCrossSampling;
    }
    UsesAnyDepthSampling() {
      return this._usesAnyDepthSampling;
    }
    GetGPUUtilisation() {
      return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN;
    }
    IsLinearSampling() {
      return "nearest" !== this.GetSampling();
    }
    GetFramerateMode() {
      return this._framerateMode;
    }
    _SetFramerateMode(e) {
      this._framerateMode !== e && (this._framerateMode = e, -1 === this._rafId && -1 === this._ruafId || (this._CancelAnimationFrame(), this._RequestAnimationFrame()));
    }
    GetSampling() {
      return this._sampling;
    }
    UsesLoaderLayout() {
      return this._usesLoaderLayout;
    }
    GetLoadingLogoAsset() {
      return this._loadingLogoAsset;
    }
    ReleaseLoadingLogoAsset() {
      this._loadingLogoAsset && (this._loadingLogoAsset.ReleaseTexture(), this._loadingLogoAsset.Release(), this._loadingLogoAsset = null);
    }
    GetLayoutManager() {
      return this._layoutManager;
    }
    GetMainRunningLayout() {
      return this._layoutManager.GetMainRunningLayout();
    }
    GetTimelineManager() {
      return this._timelineManager;
    }
    GetTransitionManager() {
      return this._transitionManager;
    }
    GetTemplateManager() {
      return this._templateManager;
    }
    GetFlowchartManager() {
      return this._flowchartManager;
    }
    GetAssetManager() {
      return this._assetManager;
    }
    LoadImage(e) {
      return this._assetManager.LoadImage(e);
    }
    CreateInstance(e, t, s, i, n, a) {
      if (a && this._templateManager) {
        if (e instanceof C32.ObjectClass && e.IsFamily()) {
          const r2 = e.GetFamilyMembers(), o = Math.floor(this.Random() * r2.length);
          return this.CreateInstance(r2[o], t, s, i, n, a);
        }
        const r = this._templateManager.GetTemplateData(e, a);
        if (r) {
          const e2 = this.CreateInstanceFromData(r, t, false, s, i, false, n, void 0, n);
          return this._templateManager.MapInstanceToTemplateName(e2, a), e2;
        }
      }
      return this.CreateInstanceFromData(e, t, false, s, i, false, n, void 0, n);
    }
    CreateInstanceFromData(e, t, s, i, n, a, r, o, h) {
      let l = null, c = null;
      if (e instanceof C32.ObjectClass) {
        if (c = e, c.IsFamily()) {
          const e2 = c.GetFamilyMembers();
          c = e2[Math.floor(this.Random() * e2.length)];
        }
        l = c.GetDefaultInstanceData();
      } else l = e, c = this.GetObjectClassByIndex(l[1]);
      const d = c.GetPlugin().IsWorldType();
      if (this._isLoading && d && !c.IsOnLoaderLayout()) return null;
      const _ = t;
      let u;
      d || (t = null), u = s && !a && l && !this._instancesByUid.has(l[2]) ? l[2] : this._nextUid++;
      const g = l ? l[0] : null, m = C32.New(C32.Instance, { runtime: this, objectType: c, layer: t, worldData: g, instVarData: l ? l[3] : null, uid: u, tags: l ? l[6] : null });
      this._instancesByUid.set(u, m);
      let p = null;
      if (d && (p = m.GetWorldInfo(), void 0 !== i && void 0 !== n && (p.SetX(i), p.SetY(n)), c._SetAnyCollisionCellChanged(true)), t && (h || t._AddInstance(m, true), t.GetLayout().MaybeLoadTexturesFor(c)), this._objectCount++, c.IsInContainer() && !s && !a) {
        const e2 = /* @__PURE__ */ new Set();
        for (const t2 of c.GetContainer().objectTypes()) {
          if (t2 === c) continue;
          const s2 = this._MaybeGetChildInstanceForObjectTypeData(t2, p, e2);
          if (s2) {
            const e3 = this.CreateInstanceFromData(s2, _, false, p ? p.GetX() : i, p ? p.GetY() : n, true, false, void 0, h);
            m._AddSibling(e3);
          } else {
            const e3 = this.CreateInstanceFromData(t2, _, false, p ? p.GetX() : i, p ? p.GetY() : n, true, false, void 0, h);
            m._AddSibling(e3);
          }
        }
        for (const e3 of m.siblings()) {
          e3._AddSibling(m);
          for (const t2 of m.siblings()) e3 !== t2 && e3._AddSibling(t2);
        }
      }
      if (d && !s && r && this._CreateChildInstancesFromData(m, g, p, t, i, n, h), c.IsInContainer() && !s && !a && r) for (const e2 of m.siblings()) {
        const s2 = e2.GetWorldInfo();
        if (!s2) continue;
        const i2 = e2.GetPlugin(), n2 = e2.GetObjectClass().GetDefaultInstanceData()[0];
        i2.IsWorldType() ? this._CreateChildInstancesFromData(e2, n2, s2, t, s2.GetX(), s2.GetY(), h) : this._CreateChildInstancesFromData(e2, n2, s2, t, void 0, void 0, h);
      }
      if (!a && r) {
        void 0 === i && (i = g[0]), void 0 === n && (n = g[1]);
        const e2 = p.GetTopParent(), t2 = i - p.GetX() + e2.GetX(), s2 = n - p.GetY() + e2.GetY();
        e2.SetXY(t2, s2);
      }
      c._SetIIDsStale();
      const f = l ? C32.cloneArray(l[5]) : null, C = l ? l[4].map((e2) => C32.cloneArray(e2)) : null, S = d && g && g[13];
      if (S && m._SetHasTilemap(), m._CreateSdkInstance(f, C), S) {
        const e2 = g[13];
        m.GetSdkInstance().LoadTilemapData(e2[2], e2[0], e2[1]);
      }
      this._instancesPendingCreate.push(m), this._hasPendingInstances = true, this.IsDebug() && C3Debugger.InstanceCreated(m);
      const I = this._eventObjects["instancecreate"];
      return I.instance = m, this._dispatcher.dispatchEvent(I), m;
    }
    _GetInstanceData(e) {
      const t = e[0], s = e[1], i = e[2], n = e[6];
      if (n) return n;
      return this._layoutManager.GetLayoutBySID(t).GetLayer(s).GetInitialInstanceData(i);
    }
    _MaybeGetChildInstanceForObjectTypeData(e, t, s) {
      const i = t?.GetSceneGraphChildrenExportData() ?? [];
      for (const t2 of i) {
        const i2 = this._GetInstanceData(t2), n = !!t2[4], a = this.GetObjectClassByIndex(i2[1]);
        if (!s.has(i2) && (e === a && n)) return s.add(i2), i2;
      }
    }
    _CreateChildInstancesFromData(e, t, s, i, n, a, r) {
      const o = s.GetSceneGraphZIndexExportData(), h = s.GetSceneGraphChildrenExportData();
      if (e.GetWorldInfo().SetSceneGraphZIndex(o), !h) return;
      void 0 === n && (n = t[0]), void 0 === a && (a = t[1]);
      const l = /* @__PURE__ */ new Set(), c = t[0], d = t[1];
      for (const t2 of h) {
        const s2 = t2[0], o2 = t2[1], h2 = t2[2], _ = t2[3], u = !!t2[4], g = t2[5], m = t2[6];
        let p;
        if (m) p = m;
        else {
          p = this._layoutManager.GetLayoutBySID(s2).GetLayer(o2).GetInitialInstanceData(h2);
        }
        const f = this.GetObjectClassByIndex(p[1]), C = e.HasSibling(f), S = l.has(f);
        if (C && !S && u) {
          const t3 = e.GetSibling(f);
          t3.GetWorldInfo().Init(p[0]);
          const s3 = n + p[0][0] - c, i2 = a + p[0][1] - d;
          t3.GetWorldInfo().SetXY(s3, i2), t3.GetWorldInfo().SetSceneGraphZIndex(g), e.AddChild(t3, { transformX: !!(1 & _), transformY: !!(_ >> 1 & 1), transformWidth: !!(_ >> 2 & 1), transformHeight: !!(_ >> 3 & 1), transformAngle: !!(_ >> 4 & 1), destroyWithParent: !!(_ >> 5 & 1), transformZElevation: !!(_ >> 6 & 1), transformOpacity: !!(_ >> 7 & 1), transformVisibility: !!(_ >> 8 & 1) }), l.add(f);
        } else {
          const t3 = n + p[0][0] - c, s3 = a + p[0][1] - d, o3 = this.CreateInstanceFromData(p, i, false, t3, s3, false, true, e, r);
          o3.GetWorldInfo().SetSceneGraphZIndex(g), e.AddChild(o3, { transformX: !!(1 & _), transformY: !!(_ >> 1 & 1), transformWidth: !!(_ >> 2 & 1), transformHeight: !!(_ >> 3 & 1), transformAngle: !!(_ >> 4 & 1), destroyWithParent: !!(_ >> 5 & 1), transformZElevation: !!(_ >> 6 & 1), transformOpacity: !!(_ >> 7 & 1), transformVisibility: !!(_ >> 8 & 1) });
        }
      }
    }
    DestroyInstance(e) {
      if (this._instancesPendingRelease.has(e)) return;
      const t = e.GetObjectClass();
      let s = this._instancesPendingDestroy.get(t);
      if (s) {
        if (s.has(e)) return;
        s.add(e);
      } else s = /* @__PURE__ */ new Set(), s.add(e), this._instancesPendingDestroy.set(t, s);
      if (this.IsDebug() && C3Debugger.InstanceDestroyed(e), e._MarkDestroyed(), this._hasPendingInstances = true, e.IsInContainer()) for (const t2 of e.siblings()) this.DestroyInstance(t2);
      for (const t2 of e.children()) t2.GetDestroyWithParent() && this.DestroyInstance(t2);
      if (!this._layoutManager.IsEndingLayout() && !this._isLoadingState) {
        const t2 = this.GetEventSheetManager();
        t2.BlockFlushingInstances(true), e._TriggerOnDestroyed(), t2.BlockFlushingInstances(false);
      }
      e._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout());
    }
    FlushPendingInstances() {
      this._hasPendingInstances && (this._isFlushingPendingInstances = true, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._isFlushingPendingInstances = false, this._hasPendingInstances = false, this.UpdateRender());
    }
    _FlushInstancesPendingCreate() {
      for (const e of this._instancesPendingCreate) {
        const t = e.GetObjectClass();
        t._AddInstance(e);
        for (const s of t.GetFamilies()) s._AddInstance(e), s._SetIIDsStale();
      }
      C32.clearArray(this._instancesPendingCreate);
    }
    _FlushInstancesPendingDestroy() {
      this._dispatcher.SetDelayRemoveEventsEnabled(true);
      for (const [e, t] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(e, t), t.clear();
      this._instancesPendingDestroy.clear(), this._dispatcher.SetDelayRemoveEventsEnabled(false);
    }
    _FlushInstancesPendingDestroyForObjectClass(e, t) {
      for (const e2 of t) {
        const t2 = this._eventObjects["instancedestroy"];
        t2.instance = e2, this._dispatcher.dispatchEvent(t2), this._instancesByUid.delete(e2.GetUID()), this._instanceTimes.delete(e2);
        const s = e2.GetWorldInfo();
        s && (s._RemoveFromCollisionCells(), s._RemoveFromRenderCells(), s._MarkDestroyed()), this._instancesPendingRelease.add(e2), this._objectCount--;
      }
      C32.arrayRemoveAllInSet(e.GetInstances(), t), e._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(e);
      for (const s of e.GetFamilies()) C32.arrayRemoveAllInSet(s.GetInstances(), t), s._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(s);
      if (e.GetPlugin().IsWorldType()) {
        const e2 = new Set([...t].map((e3) => e3.GetWorldInfo().GetLayer()));
        for (const s of e2) s._RemoveAllInstancesInSet(t);
      }
    }
    _GetInstancesPendingCreate() {
      return this._instancesPendingCreate;
    }
    *instancesPendingCreateForObjectClass(e) {
      for (const t of this._GetInstancesPendingCreate()) e.IsFamily() ? t.GetObjectClass().BelongsToFamily(e) && (yield t) : t.GetObjectClass() === e && (yield t);
    }
    _GetNewUID() {
      return this._nextUid++;
    }
    _MapInstanceByUID(e, t) {
      this._instancesByUid.set(e, t);
    }
    _SetAutoSuspendEnabled(e) {
      e = !!e, this._isAutoSuspendEnabled !== e && (this._isAutoSuspendEnabled = !!e, this._isAutoSuspendEnabled && this._isPageVisibilitySuspended && (this.SetSuspended(false), this._isPageVisibilitySuspended = false));
    }
    _IsAutoSuspendEnabled() {
      return this._isAutoSuspendEnabled;
    }
    _OnRendererContextLost() {
      this._dispatcher.dispatchEvent(C32.New(C32.Event, "renderercontextlost")), this.SetSuspended(true);
      for (const e2 of this._allObjectClasses) !e2.IsFamily() && e2.HasLoadedTextures() && e2.ReleaseTextures();
      const e = this.GetMainRunningLayout();
      e && e._OnRendererContextLost(), C32.ImageInfo.OnRendererContextLost(), C32.ImageAsset.OnRendererContextLost();
    }
    async _OnRendererContextRestored() {
      await this.GetMainRunningLayout()._Load(null, this.GetRenderer()), this._dispatcher.dispatchEvent(C32.New(C32.Event, "renderercontextrestored")), this.SetSuspended(false), this.UpdateRender();
    }
    _OnVisibilityChange(e) {
      if (!this._isAutoSuspendEnabled) return;
      const t = e["hidden"];
      this.SetSuspended(t), this._isPageVisibilitySuspended = t, t || this.UpdateRender();
    }
    _OnWindowBlur(e) {
      this.IsPreview() && this._pauseOnBlur && !C32.Platform.IsMobile && (e.data["parentHasFocus"] || (this.SetSuspended(true), this._isPausedOnBlur = true));
    }
    _OnWindowFocus() {
      this._isPausedOnBlur && (this.SetSuspended(false), this._isPausedOnBlur = false);
    }
    _RequestAnimationFrame() {
      const e = this._tickCallbacks;
      "vsync" === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C32.RequestUnlimitedAnimationFrame(e.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.renderOnly))) : -1 === this._ruafId && (this._ruafId = C32.RequestUnlimitedAnimationFrame(e.normal));
    }
    _CancelAnimationFrame() {
      -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1), -1 !== this._ruafId && (C32.CancelUnlimitedAnimationFrame(this._ruafId), this._ruafId = -1);
    }
    IsSuspended() {
      return this._suspendCount > 0;
    }
    SetSuspended(e) {
      if (this.IsExportToVideo()) return;
      const t = this.IsSuspended();
      this._suspendCount += e ? 1 : -1, this._suspendCount < 0 && (this._suspendCount = 0);
      const s = this.IsSuspended();
      if (!t && s) console.log("[Construct] Suspending"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(C32.New(C32.Event, "suspend")), this.DispatchUserScriptEvent(C32.New(C32.Event, "suspend")), this.Trigger(C32.Plugins.System.Cnds.OnSuspend, null, null);
      else if (t && !s) {
        console.log("[Construct] Resuming");
        const e2 = performance.now();
        this._lastTickTime = e2, this._fpsLastTime = e2, this._fpsFrameCount = 0, this._fps = 0, this._tpsTickCount = 0, this._tps = 0, this._mainThreadTime = 0, this._mainThreadTimeCounter = 0, this._dispatcher.dispatchEvent(C32.New(C32.Event, "resume")), this.DispatchUserScriptEvent(C32.New(C32.Event, "resume")), this.Trigger(C32.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(e2);
      }
    }
    _AddBehInstToTick(e) {
      this._behInstsToTick.Add(e);
    }
    _AddBehInstToPostTick(e) {
      this._behInstsToPostTick.Add(e);
    }
    _AddBehInstToTick2(e) {
      this._behInstsToTick2.Add(e);
    }
    _RemoveBehInstToTick(e) {
      this._behInstsToTick.Remove(e);
    }
    _RemoveBehInstToPostTick(e) {
      this._behInstsToPostTick.Remove(e);
    }
    _RemoveBehInstToTick2(e) {
      this._behInstsToTick2.Remove(e);
    }
    _CallBehaviorTickMethod(e, t) {
      const s = t ? performance.now() : 0;
      let i;
      return e instanceof ISDKBehaviorInstanceBase ? (i = e._tick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.Tick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;
    }
    _BehaviorTick() {
      const e = this.IsDebug();
      this._behInstsToTick.SetQueueingEnabled(true);
      for (const t of this._behInstsToTick) this._CallBehaviorTickMethod(t, e);
      this._behInstsToTick.SetQueueingEnabled(false);
    }
    _CallBehaviorPostTickMethod(e, t) {
      const s = t ? performance.now() : 0;
      let i;
      return e instanceof ISDKBehaviorInstanceBase ? (i = e._postTick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.PostTick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;
    }
    _BehaviorPostTick() {
      const e = this.IsDebug();
      this._behInstsToPostTick.SetQueueingEnabled(true);
      for (const t of this._behInstsToPostTick) this._CallBehaviorPostTickMethod(t, e);
      this._behInstsToPostTick.SetQueueingEnabled(false);
    }
    _CallBehaviorTick2Method(e, t) {
      const s = t ? performance.now() : 0;
      let i;
      return e instanceof ISDKBehaviorInstanceBase ? (i = e._tick2(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.Tick2(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;
    }
    _BehaviorTick2() {
      const e = this.IsDebug();
      this._behInstsToTick2.SetQueueingEnabled(true);
      for (const t of this._behInstsToTick2) this._CallBehaviorTick2Method(t, e);
      this._behInstsToTick2.SetQueueingEnabled(false);
    }
    *_DebugBehaviorTick() {
      const e = this.IsDebug();
      this._behInstsToTick.SetQueueingEnabled(true);
      for (const t of this._behInstsToTick) {
        const s = this._CallBehaviorTickMethod(t, e);
        C32.IsIterator(s) && (yield* s);
      }
      this._behInstsToTick.SetQueueingEnabled(false);
    }
    *_DebugBehaviorPostTick() {
      const e = this.IsDebug();
      this._behInstsToPostTick.SetQueueingEnabled(true);
      for (const t of this._behInstsToPostTick) {
        const s = this._CallBehaviorPostTickMethod(t, e);
        C32.IsIterator(s) && (yield* s);
      }
      this._behInstsToPostTick.SetQueueingEnabled(false);
    }
    *_DebugBehaviorTick2() {
      const e = this.IsDebug();
      this._behInstsToTick2.SetQueueingEnabled(true);
      for (const t of this._behInstsToTick2) {
        const s = this._CallBehaviorTick2Method(t, e);
        C32.IsIterator(s) && (yield* s);
      }
      this._behInstsToTick2.SetQueueingEnabled(false);
    }
    async Tick(e, t, s) {
      this._hasStartedTicking = true;
      const i = "background-wake" === s, n = "background-wake" !== s && "skip-render" !== s, a = this.GetLayoutManager(), r = this.GetCanvasManager();
      if (!this._hasStarted || this.IsSuspended() && !t && !i) return;
      const o = performance.now();
      this._isInTick = true, this._MeasureDt(e || 0), this._tpsTickCount++, this._ReleasePendingInstances();
      const h = this.Step_BeforePreTick();
      this.IsDebugging() && await h;
      const l = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects["pretick"]);
      l instanceof Promise && await l, this.DispatchUserScriptEvent(this._userScriptEventObjects["pretick"]);
      const c = this.Step_AfterPreTick();
      this.IsDebugging() && await c, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), a.IsPendingChangeMainLayout() && await this._MaybeChangeLayout();
      const d = this.Step_RunEventsEtc();
      this.IsDebugging() && await d;
      const _ = a.GetMainRunningLayout(), u = _._GetPendingSetHTMLLayerCount();
      let g = false;
      if (-1 !== u && (_._ResetPendingHTMLLayerCount(), r.GetHTMLLayerCount() !== u)) {
        const e2 = this.GetCanvasManager().SetHTMLLayerCount(u);
        this.IsInWorker() && (g = true, await e2);
      }
      this.PostComponentMessageToDOM("canvas", "update-html-layer-dom-state", { "layersDomState": _._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()) }), n && this.Render(), g && this.PostComponentMessageToDOM("canvas", "cleanup-html-layers"), this.IsExportToVideo() && (await this._ExportToVideoAddFrame(), this.GetGameTime() >= this.GetExportVideoDuration()) ? this._ExportToVideoFinish() : (this.IsSuspended() || i || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._isInTick = false, this._mainThreadTimeCounter += performance.now() - o);
    }
    async Step_BeforePreTick() {
      const e = this._eventSheetManager, t = this.IsDebug();
      this.FlushPendingInstances(), e.BlockFlushingInstances(true), this.PushCurrentLayout(this.GetMainRunningLayout()), t && C3Debugger.StartMeasuringTime(), this.IsDebugging() ? await e.DebugRunScheduledWaits() : e.RunScheduledWaits(), t && C3Debugger.AddEventsTime(), this.PopCurrentLayout(), e.BlockFlushingInstances(false), this.FlushPendingInstances(), e.BlockFlushingInstances(true);
    }
    async Step_AfterPreTick() {
      const e = this._eventSheetManager, t = this.IsDebug(), s = this.IsDebugging(), i = this._dispatcher, n = this._eventObjects, a = this._userScriptEventObjects;
      t && C3Debugger.StartMeasuringTime(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick(), t && C3Debugger.AddBehaviorTotalTickTime(), t && C3Debugger.StartMeasuringTime(), s ? await this.DebugFireGeneratorEventAndBreak(n["tick"]) : i.dispatchEvent(n["tick"]), t && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(a["tick"]);
    }
    async Step_RunEventsEtc() {
      const e = this._eventSheetManager, t = this._dispatcher, s = this._eventObjects, i = this._userScriptEventObjects, n = this.IsDebug(), a = this.IsDebugging();
      n && C3Debugger.StartMeasuringTime(), a ? await e.DebugRunEvents(this._layoutManager) : e.RunEvents(this._layoutManager), n && C3Debugger.AddEventsTime(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), this._isLayoutFirstTick = false, e.BlockFlushingInstances(true), n && C3Debugger.StartMeasuringTime(), a ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2(), n && C3Debugger.AddBehaviorTotalTickTime(), n && C3Debugger.StartMeasuringTime(), a ? await this.DebugFireGeneratorEventAndBreak(s["tick2"]) : t.dispatchEvent(s["tick2"]), n && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(i["tick2"]), a && await e.RunQueuedDebugTriggersAsync(), this.FlushPendingInstances(), this._ReleasePendingInstances();
    }
    _ReleasePendingInstances() {
      if (0 === this._instancesPendingRelease.size) return;
      const e = this._dispatcher;
      e.SetDelayRemoveEventsEnabled(true);
      for (const e2 of this._instancesPendingReleaseAffectedObjectClasses) e2.GetSolStack().RemoveInstances(this._instancesPendingRelease);
      this._instancesPendingReleaseAffectedObjectClasses.clear(), this._eventSheetManager._OnInstancesReleased(this._instancesPendingRelease);
      for (const e2 of this._instancesPendingRelease) e2.Release();
      this._instancesPendingRelease.clear(), e.SetDelayRemoveEventsEnabled(false);
    }
    async _MaybeChangeLayout() {
      const e = this.GetLayoutManager();
      let t = 0;
      for (; e.IsPendingChangeMainLayout() && t++ < 10; ) await this._DoChangeLayout(e.GetPendingChangeMainLayout());
    }
    _MeasureDt(e) {
      let t = 0;
      if (this.IsExportToVideo()) t = 1 / this.GetExportVideoFramerate(), this._dtRaw = t, this._dt1 = t;
      else if (0 !== this._lastTickTime) {
        t = Math.max(e - this._lastTickTime, 0) / 1e3, t > 0.5 && (t = 0), this._dtRaw = t, this._dt1 = C32.clamp(t, this._minDt, this._maxDt);
      }
      this._lastTickTime = e, this._dt = this._dt1 * this._timeScale, this._gameTime.Add(this._dt), this._gameTimeRaw.Add(t * this._timeScale), this._wallTime.Add(this._dt1);
      for (const [e2, t2] of this._instanceTimes) t2.Add(this._dt1 * e2.GetTimeScale());
      this._canvasManager && this._canvasManager._UpdateTick(), e - this._fpsLastTime >= 1e3 && (this._fpsLastTime += 1e3, e - this._fpsLastTime >= 1e3 && (this._fpsLastTime = e), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._tps = this._tpsTickCount, this._tpsTickCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && C3Debugger.Update1sPerfStats());
    }
    _SetTrackingInstanceTime(e, t) {
      if (t) {
        if (!this._instanceTimes.has(e)) {
          const t2 = C32.New(C32.KahanSum);
          t2.Copy(this._gameTime), this._instanceTimes.set(e, t2);
        }
      } else this._instanceTimes.delete(e);
    }
    _GetInstanceGameTime(e) {
      const t = this._instanceTimes.get(e);
      return t ? t.Get() : this.GetGameTime();
    }
    async _DoChangeLayout(e) {
      const t = this._dispatcher, s = this.GetLayoutManager().GetMainRunningLayout();
      await s._StopRunning(), s._Unload(e, this.GetRenderer()), s === e && this._eventSheetManager.ClearAllScheduledWaits(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), t.dispatchEvent(this._eventObjects["beforelayoutchange"]), C32.Asyncify.SetHighThroughputMode(true), await e._Load(s, this.GetRenderer()), C32.Asyncify.SetHighThroughputMode(false), await e._StartRunning(false), t.dispatchEvent(this._eventObjects["layoutchange"]), this.UpdateRender(), this._isLayoutFirstTick = true, this.FlushPendingInstances(), this._ExportToVideoAddKeyframe();
    }
    UpdateRender() {
      this._needRender = true;
    }
    GetWebGLRenderer() {
      return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null;
    }
    GetWebGPURenderer() {
      return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null;
    }
    GetRenderer() {
      return this._canvasManager ? this._canvasManager.GetRenderer() : null;
    }
    Render() {
      const e = this._canvasManager;
      if (!e || e.IsRendererContextLost()) return;
      const t = this.GetRenderer(), s = t.SupportsGPUProfiling(), i = s && t.IsWebGL(), n = s && t.IsWebGPU();
      if (i && t.CheckForQueryResults(), !this._needRender && !this.IsExportToVideo()) return void t.IncrementFrameNumber();
      const a = this._layoutManager.GetMainRunningLayout();
      this._fpsFrameCount++, t.Start();
      const r = this.IsDebug();
      r && C3Debugger.StartMeasuringTime(), this._needRender = false;
      let o = null;
      i && (o = e.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), t.StartQuery(o));
      let h = null;
      n && (h = t.StartFrameTiming(2 * (1 + a.GetLayerCount())), t.StartMeasuringRenderPassTime(0, 1)), this.Uses3DFeatures() && "low" === e.GetCurrentFullscreenScalingQuality() ? t.SetFixedSizeDepthBuffer(e.GetDrawWidth(), e.GetDrawHeight()) : t.SetAutoSizeDepthBuffer(), this._Render(this.GetRenderer(), a), o && t.EndQuery(o), n && (t.StopMeasuringRenderPassTime(), this._canvasManager._AddWebGPUFrameTiming(h)), t.Finish(), r && (C3Debugger.AddDrawCallsTime(), C3Debugger.UpdateInspectHighlight()), e && e._MaybeTakeSnapshot();
    }
    _NeedsHTMLLayerCompositing(e) {
      return "low" === this.GetCanvasManager().GetCurrentFullscreenScalingQuality() || e.IsWebGL() && (this.UsesAnyBackgroundBlending() || this.Uses3DFeatures());
    }
    _Render(e, t) {
      e.SetTextureFillMode(), e.SetAlphaBlend(), e.ResetCullState(), e.SetColorRgba(1, 1, 1, 1), e.SetRenderTarget(null), e.SetTexture(null), e.SetDepthEnabled(this.Uses3DFeatures()), this.Dispatcher().dispatchEvent(this._eventObjects["beforerender"]), this._NeedsHTMLLayerCompositing(e) && t._MaybeStartDrawToOwnTexture(e);
      const s = t.GetHTMLLayerCount();
      for (let i = 1; i < s; ++i) t.DrawForHTMLLayerIndex(e, i), e.IsWebGPU() && e.Restart();
      this._NeedsHTMLLayerCompositing(e) || t._MaybeStartDrawToOwnTexture(e), t.DrawMain(e), this.Dispatcher().dispatchEvent(this._eventObjects["afterrender"]);
    }
    Trigger(e, t, s) {
      if (!this._hasStarted) return false;
      const i = !this._isInTick && !this._eventSheetManager.IsInTrigger();
      let n = 0;
      i && (n = performance.now());
      const a = this.IsDebug();
      a && this.SetDebuggingEnabled(false);
      const r = this._eventSheetManager._Trigger(this._layoutManager, e, t, s);
      if (i) {
        const e2 = performance.now() - n;
        this._mainThreadTimeCounter += e2, a && C3Debugger.AddTriggersTime(e2);
      }
      return a && this.SetDebuggingEnabled(true), r;
    }
    DebugTrigger(e, t, s) {
      if (!this.IsDebugging()) return this.Trigger(e, t, s);
      if (this.HitBreakpoint()) throw new Error("called DebugTrigger() while stopped on breakpoint");
      if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
      return this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s);
    }
    async TriggerAsync(e, t, s) {
      if (!this.IsDebugging()) return this.Trigger(e, t, s);
      if (!this._hasStarted) return false;
      if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(e, t, s);
      if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(e, t, s);
      const i = performance.now(), n = this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s);
      let a = n.next();
      for (; !a.done; ) await this.DebugBreak(a.value), a = n.next();
      return this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame()), this._mainThreadTimeCounter += performance.now() - i, a.value;
    }
    FastTrigger(e, t, s) {
      const i = this.IsDebug();
      i && this.SetDebuggingEnabled(false);
      const n = this._eventSheetManager._FastTrigger(this._layoutManager, e, t, s);
      return i && this.SetDebuggingEnabled(true), n;
    }
    DebugFastTrigger(e, t, s) {
      return this._eventSheetManager._DebugFastTrigger(this._layoutManager, e, t, s);
    }
    ScheduleTriggers(e) {
      return this._scheduleTriggersThrottle.Add(e);
    }
    PushCurrentLayout(e) {
      this._currentLayoutStack.push(e);
    }
    PopCurrentLayout() {
      if (!this._currentLayoutStack.length) throw new Error("layout stack empty");
      this._currentLayoutStack.pop();
    }
    GetCurrentLayout() {
      return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout();
    }
    GetDt(e) {
      return e && -1 !== e.GetTimeScale() ? this._dt1 * e.GetTimeScale() : this._dt;
    }
    _GetDtFast() {
      return this._dt;
    }
    GetDt1() {
      return this._dt1;
    }
    GetDtRaw() {
      return this._dtRaw;
    }
    GetTimeScale() {
      return this._timeScale;
    }
    SetTimeScale(e) {
      (isNaN(e) || e < 0) && (e = 0), this._timeScale = e;
    }
    SetMinDt(e) {
      this._minDt = Math.max(e, 0);
    }
    GetMinDt() {
      return this._minDt;
    }
    SetMaxDt(e) {
      this._maxDt = Math.max(e, 0);
    }
    GetMaxDt() {
      return this._maxDt;
    }
    GetFramesPerSecond() {
      return this._fps;
    }
    GetTicksPerSecond() {
      return this._tps;
    }
    GetMainThreadTime() {
      return this._mainThreadTime;
    }
    GetStartTime() {
      return this._startTime;
    }
    GetGameTime() {
      return this._gameTime.Get();
    }
    GetGameTimeRaw() {
      return this._gameTimeRaw.Get();
    }
    GetWallTime() {
      return this._wallTime.Get();
    }
    GetTickCount() {
      return this._tickCount;
    }
    GetTickCountNoSave() {
      return this._tickCountNoSave;
    }
    GetObjectCount() {
      return this._objectCount;
    }
    GetProjectName() {
      return this._projectName;
    }
    GetProjectVersion() {
      return this._projectVersion;
    }
    GetProjectUniqueId() {
      return this._projectUniqueId;
    }
    GetAppId() {
      return this._appId;
    }
    GetExportTimestamp() {
      return this._exportTimestamp;
    }
    GetInstanceByUID(e) {
      if (this._isLoadingState) throw new Error("cannot call while loading state - wait until afterload event");
      return this._instancesByUid.get(e) || null;
    }
    _RemoveInstanceFromUIDMap(e) {
      if (this._isLoadingState) throw new Error("cannot call while loading state - wait until afterload event");
      this._instancesByUid.delete(e);
    }
    _RefreshUidMap() {
      this._instancesByUid.clear();
      for (const e of this._allObjectClasses) if (!e.IsFamily()) for (const t of e.GetInstances()) this._instancesByUid.set(t.GetUID(), t);
    }
    IsPreview() {
      return "preview" === this._exportType;
    }
    IsDebug() {
      return this._isDebug;
    }
    GetExportType() {
      return this._exportType;
    }
    IsCordova() {
      return "cordova" === this._exportType;
    }
    IsAndroidWebView() {
      return "Android" === C32.Platform.OS && ("cordova" === this._exportType || "playable-ad-single-file" === this._exportType || "playable-ad-zip" === this._exportType || "instant-games" === this._exportType);
    }
    IsiOSCordova() {
      return this._isiOSCordova;
    }
    IsiOSWebView() {
      return this._isiOSWebView;
    }
    IsWindowsWebView2() {
      return this._isWindowsWebView2;
    }
    IsAnyWebView2Wrapper() {
      return this._isAnyWebView2Wrapper;
    }
    GetCollisionEngine() {
      return this._collisionEngine;
    }
    GetSolidBehavior() {
      return this._addonManager.GetSolidBehavior();
    }
    GetJumpthruBehavior() {
      return this._addonManager.GetJumpthruBehavior();
    }
    Uses3DFeatures() {
      return this._uses3dFeatures;
    }
    GetZScaleFactor() {
      return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight());
    }
    GetDefaultCameraZ(e) {
      return this.GetRenderer().GetDefaultCameraZ(e || this.GetViewportHeight());
    }
    IsLayoutFirstTick() {
      return this._isLayoutFirstTick;
    }
    SetPixelRoundingEnabled(e) {
      e = !!e, this._isPixelRoundingEnabled !== e && (this._isPixelRoundingEnabled = e, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender());
    }
    IsPixelRoundingEnabled() {
      return this._isPixelRoundingEnabled;
    }
    GetTextIconSet(e) {
      if (!this._iconChangeHandlers.has(e)) {
        const t2 = () => this.DeleteTextIconSet(e);
        this._iconChangeHandlers.set(e, t2), e.Dispatcher().addEventListener("animationframeimagechange", t2);
      }
      const t = this._textIconManager.GetIconSet(e);
      return t.HasLoaded() || t.LoadContent().then(() => this.UpdateRender()), t;
    }
    DeleteTextIconSet(e) {
      this._textIconManager.DeleteIconSet(e);
    }
    _GetTextIconSetMeta(e) {
      const t = [];
      for (const s of e.GetAnimations()) for (const e2 of s.GetFrames()) {
        const s2 = e2.GetImageInfo();
        t.push({ source: e2, width: s2.GetWidth(), height: s2.GetHeight(), tag: e2.GetTag() });
      }
      return { icons: t };
    }
    async _GetTextIconSetContent(e) {
      const t = C32.New(C32.PromiseThrottle), s = [], i = /* @__PURE__ */ new Map();
      for (const n2 of e.GetAnimations()) for (const e2 of n2.GetFrames()) {
        const n3 = e2.GetImageInfo().GetImageAsset();
        i.has(n3) || (i.set(n3, null), s.push(t.Add(async () => {
          const e3 = await n3.LoadToDrawable();
          i.set(n3, e3);
        })));
      }
      await Promise.all(s);
      const n = [];
      for (const s2 of e.GetAnimations()) for (const e2 of s2.GetFrames()) n.push(t.Add(async () => {
        const t2 = e2.GetImageInfo(), s3 = i.get(t2.GetImageAsset()), n2 = await t2.ExtractImageToCanvas(s3);
        return { drawable: await createImageBitmap(n2) };
      }));
      const a = await Promise.all(n);
      for (const e2 of i.values()) e2 instanceof ImageBitmap && e2["close"] && e2["close"]();
      return { icons: a };
    }
    SaveToSlot(e) {
      this._saveToSlotName = e, this._saveToJsonString = false;
    }
    SaveToJsonString() {
      this._saveToSlotName = "", this._saveToJsonString = true;
    }
    LoadFromSlot(e) {
      this._loadFromSlotName = e;
    }
    LoadFromJsonString(e) {
      this._loadFromJson = e;
    }
    GetLastSaveJsonString() {
      return this._lastSaveJson;
    }
    _NeedsHandleSaveOrLoad() {
      return !!(this._saveToSlotName || this._saveToJsonString || this._loadFromSlotName || null !== this._loadFromJson);
    }
    async _HandleSaveOrLoad() {
      if (this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad()), this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() && C3Debugger.StepIfPausedInDebugger()), this._saveToJsonString) {
        const e = await this._SaveToJsonString();
        this._lastSaveJson = e, await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = "", this._ClearSaveOrLoad();
      }
      if (null !== this._loadFromJson) {
        this.FlushPendingInstances();
        try {
          await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = "";
        } catch (e) {
          console.error("[Construct] Failed to load state from JSON string: ", e), await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadFailed, null);
        }
        this._ClearSaveOrLoad();
      }
    }
    _ClearSaveOrLoad() {
      this._saveToSlotName = "", this._saveToJsonString = false, this._loadFromSlotName = "", this._loadFromJson = null;
    }
    _GetProjectStorage() {
      return this._projectStorage || (this._projectStorage = localforage.createInstance({ name: "c3-localstorage-" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._projectStorage;
    }
    _GetSavegamesStorage() {
      return this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({ name: "c3-savegames-" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._savegamesStorage;
    }
    async _DoSaveToSlot(e) {
      const t = await this._SaveToJsonString();
      try {
        await this._GetSavegamesStorage().setItem(e, t), console.log("[Construct] Saved state to storage (" + t.length + " chars)"), this._lastSaveJson = t, await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = "";
      } catch (e2) {
        console.error("[Construct] Failed to save state to storage: ", e2), await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveFailed, null);
      }
    }
    async _DoLoadFromSlot(e) {
      try {
        const t = await this._GetSavegamesStorage().getItem(e);
        if (!t) throw new Error("empty slot");
        console.log("[Construct] Loaded state from storage (" + t.length + " chars)"), await this._DoLoadFromJsonString(t), this._lastSaveJson = t, await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = "";
      } catch (e2) {
        console.error("[Construct] Failed to load state from storage: ", e2), await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadFailed, null);
      }
    }
    async _SaveToJsonString() {
      const e = { "c3save": true, "version": 1, "rt": { "time": this.GetGameTime(), "timeRaw": this.GetGameTimeRaw(), "walltime": this.GetWallTime(), "timescale": this.GetTimeScale(), "tickcount": this.GetTickCount(), "next_uid": this._nextUid, "running_layout": this.GetMainRunningLayout().GetSID(), "start_time_offset": Date.now() - this._startTime }, "types": {}, "layouts": {}, "events": this._eventSheetManager._SaveToJson(), "timelines": this._timelineManager._SaveToJson(), "user_script_data": null };
      for (const t2 of this._allObjectClasses) t2.IsFamily() || t2.HasNoSaveBehavior() || (e["types"][t2.GetSID().toString()] = t2._SaveToJson());
      for (const t2 of this._layoutManager.GetAllLayouts()) e["layouts"][t2.GetSID().toString()] = t2._SaveToJson();
      const t = this._CreateUserScriptEvent("save");
      return t.saveData = null, await this.DispatchUserScriptEventAsyncWait(t), e["user_script_data"] = t.saveData, JSON.stringify(e);
    }
    IsLoadingState() {
      return this._isLoadingState;
    }
    async _DoLoadFromJsonString(e) {
      const t = this.GetLayoutManager(), s = JSON.parse(e);
      if (s["c2save"]) throw new Error("C2 saves are incompatible with C3 runtime");
      if (!s["c3save"]) throw new Error("not valid C3 save data");
      if (s["version"] > 1) throw new Error("C3 save data from future version");
      this.ClearIntancesNeedingAfterLoad(), this._dispatcher.dispatchEvent(C32.New(C32.Event, "beforeload"));
      for (const e2 of this.allInstances()) {
        e2.GetObjectClass().HasNoSaveBehavior() || e2._OnBeforeLoad();
      }
      const i = s["rt"];
      this._gameTime.Set(i["time"]), i.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(i["timeRaw"]), this._wallTime.Set(i["walltime"]), this._timeScale = i["timescale"], this._tickCount = i["tickcount"], this._startTime = Date.now() - i["start_time_offset"];
      const n = i["running_layout"];
      this._isLoadingState = true;
      let a = false;
      if (n !== this.GetMainRunningLayout().GetSID()) {
        const e2 = t.GetLayoutBySID(n);
        if (!e2) return;
        await this._DoChangeLayout(e2), a = true;
      }
      for (const [e2, i2] of Object.entries(s["layouts"])) {
        const s2 = parseInt(e2, 10), n2 = t.GetLayoutBySID(s2);
        n2 && n2._LoadFromJson(i2);
      }
      const r = /* @__PURE__ */ new Set();
      for (const [e2, t2] of Object.entries(s["types"])) {
        const s2 = parseInt(e2, 10), i2 = this.GetObjectClassBySID(s2);
        !i2 || i2.IsFamily() || i2.HasNoSaveBehavior() || i2._LoadFromJson(t2, r);
      }
      for (const e2 of this._layoutManager.GetAllLayouts()) for (const t2 of e2.allLayers()) t2._LoadFromJsonAfterInstances();
      if (this.FlushPendingInstances(), this._RefreshUidMap(), this._isLoadingState = false, a) {
        for (const e2 of this.allInstances()) e2.SetupInitialSceneGraphConnections();
        for (const [e2, t2] of Object.entries(s["types"])) {
          const s2 = parseInt(e2, 10), i2 = this.GetObjectClassBySID(s2);
          !i2 || i2.IsFamily() || i2.HasNoSaveBehavior() || i2._SetupSceneGraphConnectionsOnChangeOfLayout(t2);
        }
      }
      this._nextUid = i["next_uid"], this._eventSheetManager._LoadFromJson(s["events"]);
      for (const e2 of this._allObjectClasses) if (!e2.IsFamily() && e2.IsInContainer()) for (const t2 of e2.GetInstances()) {
        const s2 = t2.GetIID();
        t2._ClearSiblings();
        for (const i2 of e2.GetContainer().objectTypes()) {
          if (i2 === e2) continue;
          const n2 = i2.GetInstances();
          if (s2 < 0 || s2 >= n2.length) throw new Error("missing sibling instance");
          t2._AddSibling(n2[s2]);
        }
      }
      this._timelineManager._LoadFromJson(s["timelines"]), t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
      for (const e2 of r) e2._OnCreatedForLoadingSavegame();
      this.DoAfterLoad(), this._dispatcher.dispatchEvent(C32.New(C32.Event, "afterload")), this.DispatchUserScriptEvent(this._CreateUserScriptEvent("afterload"));
      for (const [e2, t2] of Object.entries(s["types"])) {
        const t3 = parseInt(e2, 10), s2 = this.GetObjectClassBySID(t3);
        s2 && s2._ClearLoadInstancesJson();
      }
      const o = this._CreateUserScriptEvent("load");
      o.saveData = s["user_script_data"], await this.DispatchUserScriptEventAsyncWait(o), this.UpdateRender();
    }
    SortOnTmpHierarchyPosition(e, t) {
      return t.GetWorldInfo().GetTmpHierarchyPosition() - e.GetWorldInfo().GetTmpHierarchyPosition();
    }
    AddInstanceNeedingAfterLoad(e, t) {
      e.GetWorldInfo() && (this._instancesNeedingAfterLoadMap.has(e) || (this._instancesNeedingAfterLoadMap.set(e, t), this._instancesNeedingAfterLoadArray.push(e)));
    }
    ClearIntancesNeedingAfterLoad() {
      this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), C32.clearArray(this._instancesNeedingAfterLoadArray), C32.SceneGraphInfo.ClearUpdatedInstances();
    }
    DoAfterLoad(e = "full", t = null) {
      this._instancesNeedingAfterLoadArray.sort(this.SortOnTmpHierarchyPosition), t || (t = {}), t.processedWorldInfo = /* @__PURE__ */ new Set();
      const s = this._instancesNeedingAfterLoadArray.length;
      for (const s2 of this._instancesNeedingAfterLoadArray) s2._OnAfterLoad(this._instancesNeedingAfterLoadMap.get(s2), e, t);
      for (const s2 of this._instancesNeedingAfterLoadArray) s2._OnAfterLoad2(this._instancesNeedingAfterLoadMap.get(s2), e, t);
      if (this.ClearIntancesNeedingAfterLoad(), s) {
        this.FlushPendingInstances(), this._RefreshUidMap();
        for (const e2 of this._layoutManager.GetAllLayouts()) for (const t2 of e2.allLayers()) t2._SortInstancesByLastCachedZIndex(), t2.SetZIndicesChanged();
      }
    }
    async AddJobWorkerScripts(e) {
      const t = e.map((e2) => new URL(e2, location.href).toString());
      this._jobScheduler.ImportScriptsToJobWorkers(t);
    }
    AddJobWorkerBlob(e, t) {
      this._jobScheduler.SendBlobToJobWorkers(e, t);
    }
    AddJobWorkerBuffer(e, t) {
      this._jobScheduler.SendBufferToJobWorkers(e, t);
    }
    AddJob(e, t, s, i) {
      return this._jobScheduler.AddJob(e, t, s, null, null, i);
    }
    BroadcastJob(e, t, s, i) {
      return this._jobScheduler.BroadcastJob(e, t, s, i);
    }
    GetMaxNumJobWorkers() {
      return this._jobScheduler.GetMaxNumWorkers();
    }
    InvokeDownload(e, t) {
      this.PostComponentMessageToDOM("runtime", "invoke-download", { "url": e, "filename": t });
    }
    async RasterSvgImage(e, t, s, i, n, a) {
      if (i = i || t, n = n || s, this.IsInWorker()) {
        return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", { "blob": e, "imageWidth": t, "imageHeight": s, "surfaceWidth": i, "surfaceHeight": n, "imageBitmapOpts": a }))["imageBitmap"];
      }
      {
        const r = await self["C3_RasterSvgImageBlob"](e, t, s, i, n);
        return a ? await self.createImageBitmap(r, a) : r;
      }
    }
    async GetSvgImageSize(e) {
      return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", { "blob": e }) : await self["C3_GetSvgImageSize"](e);
    }
    RequestDeviceOrientationEvent() {
      this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = true, this.PostComponentMessageToDOM("runtime", "enable-device-orientation"));
    }
    RequestDeviceMotionEvent() {
      this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = true, this.PostComponentMessageToDOM("runtime", "enable-device-motion"));
    }
    Random() {
      return this._randomNumberCallback();
    }
    SetRandomNumberGeneratorCallback(e) {
      this._randomNumberCallback = e;
    }
    _GetRemotePreviewStatusInfo() {
      const e = this.GetRenderer();
      return { "fps": this.GetFramesPerSecond(), "tps": this.GetTicksPerSecond(), "cpu": this.GetMainThreadTime(), "gpu": this.GetGPUUtilisation(), "layout": this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "", "renderer": e.IsWebGL() ? e.GetUnmaskedRenderer() : e.GetAdapterInfoString() };
    }
    HitBreakpoint() {
      return !!this.IsDebug() && C3Debugger.HitBreakpoint();
    }
    DebugBreak(e) {
      return this.IsDebugging() ? C3Debugger.DebugBreak(e) : Promise.resolve();
    }
    DebugBreakNext() {
      return !!this.IsDebugging() && C3Debugger.BreakNext();
    }
    SetDebugBreakpointsEnabled(e) {
      this._breakpointsEnabled = !!e, this._UpdateDebuggingFlag();
    }
    AreDebugBreakpointsEnabled() {
      return this._breakpointsEnabled;
    }
    IsDebugging() {
      return this._isDebugging;
    }
    SetDebuggingEnabled(e) {
      e ? this._debuggingDisabled-- : this._debuggingDisabled++, this._UpdateDebuggingFlag();
    }
    _UpdateDebuggingFlag() {
      this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled;
    }
    IsCPUProfiling() {
      return this.IsDebug() && C3Debugger.IsCPUProfiling();
    }
    IsGPUProfiling() {
      return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger.IsGPUProfiling();
    }
    async DebugIterateAndBreak(e) {
      if (e) for (const t of e) await this.DebugBreak(t);
    }
    DebugFireGeneratorEventAndBreak(e) {
      return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(e));
    }
    _InvokeFunctionFromJS(e) {
      return this._eventSheetManager._InvokeFunctionFromJS(e["name"], e["params"]);
    }
    _GetHTMLLayerWrapElement(e) {
      if (this.IsInWorker()) throw new Error("not supported in worker mode");
      return self["c3_runtimeInterface"]["_GetHTMLWrapElement"](e);
    }
    GetIRuntime() {
      return this._iRuntime;
    }
    GetConstructVersionCode() {
      return this._constructVersionCode;
    }
    _CreateUserScriptEvent(e) {
      const t = C32.New(C32.Event, e, false);
      return t.runtime = this._iRuntime, t;
    }
    _InitScriptInterfaces() {
      this._iRuntime = new self.IRuntime(this), this._userScriptEventObjects = { "pretick": this._CreateUserScriptEvent("pretick"), "tick": this._CreateUserScriptEvent("tick"), "tick2": this._CreateUserScriptEvent("tick2") };
    }
    _InitObjectsScriptInterface() {
      const e = {};
      for (const t of this._allObjectClasses) e[t.GetJsPropName()] = { value: t.GetIObjectClass(), enumerable: true, writable: false };
      this._iRuntime._InitObjects(e);
    }
    _InitGlobalVariableScriptInterface() {
      const e = {};
      for (const t of this.GetEventSheetManager().GetAllGlobalVariables()) e[t.GetJsPropName()] = t._GetScriptInterfaceDescriptor();
      this._iRuntime._InitGlobalVars(e);
    }
    _GetCommonScriptInterfaces() {
      return this._commonScriptInterfaces;
    }
    _MapScriptInterface(e, t) {
      this._interfaceMap.set(e, t);
    }
    _UnwrapScriptInterface(e) {
      return this._interfaceMap.get(e);
    }
    _UnwrapIObjectClass(e) {
      if (!(e instanceof self.IObjectClass)) throw new TypeError("expected IObjectClass");
      const t = this._UnwrapScriptInterface(e);
      if (!(t && t instanceof C32.ObjectClass)) throw new Error("invalid IObjectClass");
      return t;
    }
    _UnwrapIInstance(e) {
      if (!(e instanceof self.IInstance)) throw new TypeError("expected IInstance");
      const t = this._UnwrapScriptInterface(e);
      if (!(t && t instanceof C32.Instance)) throw new Error("invalid IInstance");
      return t;
    }
    _UnwrapIWorldInstance(e) {
      if (!(e instanceof self.IWorldInstance)) throw new TypeError("expected IWorldInstance");
      const t = this._UnwrapScriptInterface(e);
      if (!(t && t instanceof C32.Instance)) throw new Error("invalid IInstance");
      return t;
    }
  }, self["C3_CreateRuntime"] = C32.Runtime.Create, self["C3_InitRuntime"] = (e, t) => e.Init(t);
}
{
  const C32 = self.C3;
  C32.JobSchedulerRuntime = class extends C32.DefendedBase {
    constructor(r, e) {
      super(), this._runtime = r, this._jobPromises = /* @__PURE__ */ new Map(), this._nextJobId = 0, this._inputPort = e["inputPort"], e["outputPort"].onmessage = (r2) => this._OnJobWorkerMessage(r2), this._maxNumWorkers = e["maxNumWorkers"], this._jobWorkerCount = 1, this._isCreatingWorker = false, this._hadErrorCreatingWorker = false;
    }
    GetMaxNumWorkers() {
      return this._maxNumWorkers;
    }
    ImportScriptsToJobWorkers(r) {
      this._inputPort.postMessage({ "type": "_import_scripts", "scripts": r });
    }
    SendBlobToJobWorkers(r, e) {
      this._inputPort.postMessage({ "type": "_send_blob", "blob": r, "id": e });
    }
    SendBufferToJobWorkers(r, e) {
      this._inputPort.postMessage({ "type": "_send_buffer", "buffer": r, "id": e }, [r]);
    }
    AddJob(r, e, o, s, t, i) {
      if (o || (o = []), "number" == typeof i && (i = Math.floor(i)) <= 0) throw new Error("invalid maxWorkerNum");
      const n = this._nextJobId++, a = { "type": r, "isBroadcast": false, "maxWorkerNum": i, "jobId": n, "params": e, "transferables": o }, _ = new Promise((r2, e2) => {
        this._jobPromises.set(n, { resolve: r2, progress: s, reject: e2, cancelled: false, maxWorkerNum: i });
      });
      return t && t.SetAction(() => this._CancelJob(n)), this._inputPort.postMessage(a, o), this._MaybeCreateExtraWorker(), _;
    }
    BroadcastJob(r, e, o, s) {
      if (o || (o = []), "number" == typeof s && (s = Math.floor(s)) <= 0) throw new Error("invalid maxWorkerNum");
      const t = { "type": r, "isBroadcast": true, "maxWorkerNum": s, "jobId": this._nextJobId++, "params": e, "transferables": o };
      this._inputPort.postMessage(t, o);
    }
    _CancelJob(r) {
      const e = this._jobPromises.get(r);
      e && (e.cancelled = true, e.resolve = null, e.progress = null, e.reject = null, this._inputPort.postMessage({ "type": "_cancel", "jobId": r }));
    }
    _OnJobWorkerMessage(r) {
      const e = r.data, o = e["type"], s = e["jobId"];
      switch (o) {
        case "result":
          this._OnJobResult(s, e["result"]);
          break;
        case "progress":
          this._OnJobProgress(s, e["progress"]);
          break;
        case "error":
          this._OnJobError(s, e["error"]);
          break;
        case "ready":
          this._OnJobWorkerReady();
          break;
        default:
          throw new Error(`unknown message from worker '${o}'`);
      }
    }
    _OnJobResult(r, e) {
      const o = this._jobPromises.get(r);
      if (!o) throw new Error("invalid job ID");
      o.cancelled || o.resolve(e), this._jobPromises.delete(r);
    }
    _OnJobProgress(r, e) {
      const o = this._jobPromises.get(r);
      if (!o) throw new Error("invalid job ID");
      !o.cancelled && o.progress && o.progress(e);
    }
    _OnJobError(r, e) {
      const o = this._jobPromises.get(r);
      if (!o) throw new Error("invalid job ID");
      o.cancelled || o.reject(e), this._jobPromises.delete(r);
    }
    _OnJobWorkerReady() {
      this._isCreatingWorker && (this._isCreatingWorker = false, this._jobWorkerCount++, this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({ "type": "_no_more_workers" }));
    }
    _GetWorkerCountNeededForPendingJobs() {
      let r = 0;
      const e = [...this._jobPromises.values()].sort((r2, e2) => (r2.maxWorkerNum || 1 / 0) - (e2.maxWorkerNum || 1 / 0));
      for (const o of e) {
        r < (o.maxWorkerNum || 1 / 0) && r++;
      }
      return r;
    }
    async _MaybeCreateExtraWorker() {
      if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount)) try {
        this._isCreatingWorker = true;
        (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker"))["outputPort"].onmessage = (r) => this._OnJobWorkerMessage(r);
      } catch (r) {
        this._hadErrorCreatingWorker = true, this._isCreatingWorker = false, console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, r);
      }
    }
  };
}
{
  self["C3_Shaders"] = {};
}
{
  {
    let ForEachOrdered_SortInstances = function(e2, t2) {
      const n2 = e2[1], r2 = t2[1];
      if ("number" == typeof n2 && "number" == typeof r2) return n2 - r2;
      {
        const e3 = "" + n2, t3 = "" + r2;
        return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
      }
    };
    ForEachOrdered_SortInstances2 = ForEachOrdered_SortInstances;
    const e = self.C3;
    let t = null, n = "", r = "", a = [], i = "", s = "", o = "";
    const u = e.New(e.ArrayStack);
    e.Plugins.System = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2), this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack(), this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._imagesLoadingTotal = 0, this._imagesLoadingComplete = 0, this._functionMaps = /* @__PURE__ */ new Map();
      }
      Release() {
        super.Release();
      }
      UpdateRender() {
        this._runtime.UpdateRender();
      }
      Trigger(e2) {
        this._runtime.Trigger(e2, null, null);
      }
      GetRegex(e2, a2) {
        return t && e2 === n && a2 === r || (t = new RegExp(e2, a2), n = e2, r = a2), t.lastIndex = 0, t;
      }
      GetRegexMatches(e2, t2, n2) {
        if (e2 === i && t2 === s && n2 === o) return a;
        const r2 = this.GetRegex(t2, n2);
        return a = e2.match(r2), i = e2, s = t2, o = n2, a;
      }
      async _LoadTexturesForObjectClasses(t2, n2) {
        if (!n2.length) return;
        this._imagesLoadingTotal += n2.length;
        const r2 = [];
        for (const e2 of n2) r2.push(t2.MaybeLoadTexturesFor(e2));
        await e.PromiseAllWithProgress(r2, () => {
          this._imagesLoadingComplete++;
        }), this._imagesLoadingComplete++, this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingComplete = 0, this._imagesLoadingTotal = 0, this._runtime.Trigger(e.Plugins.System.Cnds.OnImageLoadingComplete, null, null));
      }
      GetImageLoadingProgress() {
        return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal;
      }
      _UnloadTexturesForObjectClasses(e2, t2) {
        for (const n2 of t2) 0 === n2.GetInstanceCount() && e2.MaybeUnloadTexturesFor(n2);
      }
      _GetForEachStack() {
        return u;
      }
      _Repeat(e2) {
        const t2 = this._runtime.GetEventSheetManager(), n2 = t2.GetEventStack(), r2 = n2.GetCurrentStackFrame(), a2 = r2.GetCurrentEvent(), i2 = a2.GetSolModifiers(), s2 = r2.IsSolModifierAfterCnds(), o2 = n2.Push(a2), u2 = t2.GetLoopStack(), l = u2.Push();
        if (l.SetEnd(e2), s2) for (let n3 = 0; n3 < e2 && !l.IsStopped(); ++n3) t2.PushCopySol(i2), l.SetIndex(n3), a2.Retrigger(r2, o2), t2.PopSol(i2);
        else for (let t3 = 0; t3 < e2 && !l.IsStopped(); ++t3) l.SetIndex(t3), a2.Retrigger(r2, o2);
        return n2.Pop(), u2.Pop(), false;
      }
      *_DebugRepeat(e2) {
        const t2 = this._runtime.GetEventSheetManager(), n2 = t2.GetEventStack(), r2 = n2.GetCurrentStackFrame(), a2 = r2.GetCurrentEvent(), i2 = a2.GetSolModifiers(), s2 = r2.IsSolModifierAfterCnds(), o2 = n2.Push(a2), u2 = t2.GetLoopStack(), l = u2.Push();
        if (l.SetEnd(e2), s2) for (let n3 = 0; n3 < e2 && !l.IsStopped(); ++n3) t2.PushCopySol(i2), l.SetIndex(n3), yield* a2.DebugRetrigger(r2, o2), t2.PopSol(i2);
        else for (let t3 = 0; t3 < e2 && !l.IsStopped(); ++t3) l.SetIndex(t3), yield* a2.DebugRetrigger(r2, o2);
        return n2.Pop(), u2.Pop(), false;
      }
      _While() {
        const e2 = this._runtime.GetEventSheetManager(), t2 = e2.GetEventStack(), n2 = t2.GetCurrentStackFrame(), r2 = n2.GetCurrentEvent(), a2 = r2.GetSolModifiers(), i2 = n2.IsSolModifierAfterCnds(), s2 = t2.Push(r2), o2 = e2.GetLoopStack(), u2 = o2.Push();
        if (i2) for (let t3 = 0; !u2.IsStopped(); ++t3) e2.PushCopySol(a2), u2.SetIndex(t3), r2.Retrigger(n2, s2) || u2.Stop(), e2.PopSol(a2);
        else for (let e3 = 0; !u2.IsStopped(); ++e3) u2.SetIndex(e3), r2.Retrigger(n2, s2) || u2.Stop();
        return t2.Pop(), o2.Pop(), false;
      }
      *_DebugWhile() {
        const e2 = this._runtime.GetEventSheetManager(), t2 = e2.GetEventStack(), n2 = t2.GetCurrentStackFrame(), r2 = n2.GetCurrentEvent(), a2 = r2.GetSolModifiers(), i2 = n2.IsSolModifierAfterCnds(), s2 = t2.Push(r2), o2 = e2.GetLoopStack(), u2 = o2.Push();
        if (i2) for (let t3 = 0; !u2.IsStopped(); ++t3) {
          e2.PushCopySol(a2), u2.SetIndex(t3);
          (yield* r2.DebugRetrigger(n2, s2)) || u2.Stop(), e2.PopSol(a2);
        }
        else for (let e3 = 0; !u2.IsStopped(); ++e3) {
          u2.SetIndex(e3);
          (yield* r2.DebugRetrigger(n2, s2)) || u2.Stop();
        }
        return t2.Pop(), o2.Pop(), false;
      }
      _For(e2, t2, n2) {
        const r2 = this._runtime.GetEventSheetManager(), a2 = r2.GetEventStack(), i2 = a2.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o2 = s2.GetSolModifiers(), u2 = i2.IsSolModifierAfterCnds(), l = a2.Push(s2), c = r2.GetLoopStack(), h = c.Push();
        if (h.SetName(e2), h.SetEnd(n2), n2 < t2) if (u2) for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) r2.PushCopySol(o2), h.SetIndex(e3), s2.Retrigger(i2, l), r2.PopSol(o2);
        else for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) h.SetIndex(e3), s2.Retrigger(i2, l);
        else if (u2) for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) r2.PushCopySol(o2), h.SetIndex(e3), s2.Retrigger(i2, l), r2.PopSol(o2);
        else for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) h.SetIndex(e3), s2.Retrigger(i2, l);
        return a2.Pop(), c.Pop(), false;
      }
      *_DebugFor(e2, t2, n2) {
        const r2 = this._runtime.GetEventSheetManager(), a2 = r2.GetEventStack(), i2 = a2.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o2 = s2.GetSolModifiers(), u2 = i2.IsSolModifierAfterCnds(), l = a2.Push(s2), c = r2.GetLoopStack(), h = c.Push();
        if (h.SetName(e2), h.SetEnd(n2), n2 < t2) if (u2) for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) r2.PushCopySol(o2), h.SetIndex(e3), yield* s2.DebugRetrigger(i2, l), r2.PopSol(o2);
        else for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) h.SetIndex(e3), yield* s2.DebugRetrigger(i2, l);
        else if (u2) for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) r2.PushCopySol(o2), h.SetIndex(e3), yield* s2.DebugRetrigger(i2, l), r2.PopSol(o2);
        else for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) h.SetIndex(e3), yield* s2.DebugRetrigger(i2, l);
        return a2.Pop(), c.Pop(), false;
      }
      _ForEach(t2) {
        const n2 = t2.GetCurrentSol(), r2 = n2.GetInstances();
        if (0 === r2.length) return false;
        const a2 = this._runtime.GetEventSheetManager(), i2 = a2.GetEventStack(), s2 = i2.GetCurrentStackFrame(), o2 = s2.GetCurrentEvent(), l = o2.GetSolModifiers(), c = s2.IsSolModifierAfterCnds(), h = i2.Push(o2), g = a2.GetLoopStack(), S = g.Push(), d = t2.IsInContainer(), p = u.Push();
        if (e.shallowAssignArray(p, r2), S.SetEnd(p.length), c) for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {
          a2.PushCopySol(l);
          const n4 = p[e2];
          t2.GetCurrentSol().SetSinglePicked(n4), d && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), o2.Retrigger(s2, h), a2.PopSol(l);
        }
        else {
          n2._SetSelectAll(false);
          const t3 = n2._GetOwnInstances();
          e.clearArray(t3), t3.push(null);
          for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {
            const n4 = p[e2];
            t3[0] = n4, d && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), o2.Retrigger(s2, h);
          }
        }
        return i2.Pop(), g.Pop(), e.clearArray(p), u.Pop(), false;
      }
      *_DebugForEach(t2) {
        const n2 = t2.GetCurrentSol(), r2 = n2.GetInstances();
        if (0 === r2.length) return false;
        const a2 = this._runtime.GetEventSheetManager(), i2 = a2.GetEventStack(), s2 = i2.GetCurrentStackFrame(), o2 = s2.GetCurrentEvent(), l = o2.GetSolModifiers(), c = s2.IsSolModifierAfterCnds(), h = i2.Push(o2), g = a2.GetLoopStack(), S = g.Push(), d = t2.IsInContainer(), p = u.Push();
        if (e.shallowAssignArray(p, r2), S.SetEnd(p.length), c) for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {
          a2.PushCopySol(l);
          const n4 = p[e2];
          t2.GetCurrentSol().SetSinglePicked(n4), d && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* o2.DebugRetrigger(s2, h), a2.PopSol(l);
        }
        else {
          n2._SetSelectAll(false);
          const t3 = n2._GetOwnInstances();
          e.clearArray(t3), t3.push(null);
          for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {
            const n4 = p[e2];
            t3[0] = n4, d && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* o2.DebugRetrigger(s2, h);
          }
        }
        return i2.Pop(), g.Pop(), e.clearArray(p), u.Pop(), false;
      }
      _ForEachOrdered(t2, n2) {
        const r2 = t2.GetCurrentSol(), a2 = r2.GetInstances();
        if (0 === a2.length) return false;
        const i2 = this._runtime.GetEventSheetManager(), s2 = i2.GetEventStack(), o2 = i2.GetCurrentCondition(), l = s2.GetCurrentStackFrame(), c = l.GetCurrentEvent(), h = c.GetSolModifiers(), g = l.IsSolModifierAfterCnds(), S = s2.Push(c), d = i2.GetLoopStack(), p = d.Push(), m = t2.IsInContainer(), G = u.Push();
        e.clearArray(G), p.SetEnd(a2.length);
        for (let e2 = 0, t3 = a2.length; e2 < t3; ++e2) G.push([a2[e2], o2.ReevaluateParameter(1, e2)]);
        if (G.sort(ForEachOrdered_SortInstances), 1 === n2 && G.reverse(), g) for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {
          i2.PushCopySol(h);
          const n4 = G[e2][0];
          t2.GetCurrentSol().SetSinglePicked(n4), m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), c.Retrigger(l, S), i2.PopSol(h);
        }
        else {
          r2._SetSelectAll(false);
          const t3 = r2._GetOwnInstances();
          e.clearArray(t3), t3.push(null);
          for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {
            const n4 = G[e2][0];
            t3[0] = n4, m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), c.Retrigger(l, S);
          }
        }
        return s2.Pop(), d.Pop(), e.clearArray(G), u.Pop(), false;
      }
      *_DebugForEachOrdered(t2, n2) {
        const r2 = t2.GetCurrentSol(), a2 = r2.GetInstances();
        if (0 === a2.length) return false;
        const i2 = this._runtime.GetEventSheetManager(), s2 = i2.GetEventStack(), o2 = i2.GetCurrentCondition(), l = s2.GetCurrentStackFrame(), c = l.GetCurrentEvent(), h = c.GetSolModifiers(), g = l.IsSolModifierAfterCnds(), S = s2.Push(c), d = i2.GetLoopStack(), p = d.Push(), m = t2.IsInContainer(), G = u.Push();
        e.clearArray(G), p.SetEnd(a2.length);
        for (let e2 = 0, t3 = a2.length; e2 < t3; ++e2) G.push([a2[e2], o2.ReevaluateParameter(1, e2)]);
        if (G.sort(ForEachOrdered_SortInstances), 1 === n2 && G.reverse(), g) for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {
          i2.PushCopySol(h);
          const n4 = G[e2][0];
          t2.GetCurrentSol().SetSinglePicked(n4), m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c.DebugRetrigger(l, S), i2.PopSol(h);
        }
        else {
          r2._SetSelectAll(false);
          const t3 = r2._GetOwnInstances();
          e.clearArray(t3), t3.push(null);
          for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {
            const n4 = G[e2][0];
            t3[0] = n4, m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c.DebugRetrigger(l, S);
          }
        }
        return s2.Pop(), d.Pop(), e.clearArray(G), u.Pop(), false;
      }
      _GetFunctionMap(e2, t2) {
        let n2 = this._functionMaps.get(e2);
        return n2 || (t2 ? (n2 = { defaultFunc: null, strMap: /* @__PURE__ */ new Map() }, this._functionMaps.set(e2, n2), n2) : null);
      }
      _DoCallMappedFunction(e2, t2, n2, r2, a2) {
        t2.GetEventBlock().RunAsMappedFunctionCall(n2, t2.IsCopyPicked()), r2 && e2.PopSol(a2);
      }
      *_DebugDoCallMappedFunction(e2, t2, n2, r2, a2) {
        yield* t2.GetEventBlock().DebugRunAsMappedFunctionCall(n2, t2.IsCopyPicked()), r2 && e2.PopSol(a2);
      }
    };
  }
  {
    const l = self.C3;
    l.Plugins.System.Type = class extends l.DefendedBase {
      constructor(e) {
        super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();
      }
      OnCreate() {
      }
      Release() {
        this._objectClass = null, this._runtime = null, this._plugin = null;
      }
    };
  }
  {
    const c = self.C3;
    c.Plugins.System.Instance = class extends c.DefendedBase {
      constructor(e, t) {
        super(), this._inst = e, this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._runtime = this._inst.GetRuntime();
      }
      Release() {
        this._inst = null, this._objectClass = null, this._sdkType = null, this._runtime = null;
      }
    };
  }
  {
    const h = self.C3, g = [];
    h.Plugins.System.Cnds = { EveryTick: () => true, OnLayoutStart: () => true, OnLayoutEnd: () => true, OnSuspend: () => true, OnResume: () => true, IsSuspended() {
      return this._runtime.IsSuspended();
    }, Else() {
      const e = this._runtime.GetCurrentEventStackFrame();
      return !e.GetElseBranchRan() && !e.GetLastEventTrue();
    }, TriggerOnce() {
      const e = this._runtime.GetCurrentCondition().GetSavedDataMap();
      let t = e.get("TriggerOnce_lastTick");
      void 0 === t && (t = -1, e.set("TriggerOnce_lastTick", -1));
      const n = this._runtime.GetTickCount();
      return e.set("TriggerOnce_lastTick", n), this._runtime.IsLayoutFirstTick() || t !== n - 1;
    }, Every(e) {
      const t = this._runtime.GetCurrentCondition().GetSavedDataMap(), n = t.get("Every_lastTime") || 0, r = this._runtime.GetGameTime();
      t.has("Every_seconds") || t.set("Every_seconds", e);
      const a = t.get("Every_seconds");
      return r >= n + a ? (t.set("Every_lastTime", n + a), r >= t.get("Every_lastTime") + 0.04 && t.set("Every_lastTime", r), t.set("Every_seconds", e), true) : (r < n - 0.1 && t.set("Every_lastTime", r), false);
    }, IsGroupActive(e) {
      const t = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
      return t && t.IsGroupActive();
    }, IsPreview() {
      return this._runtime.IsPreview();
    }, IsMobile: () => h.Platform.IsMobile, OnLoadFinished: () => true, OnCanvasSnapshot: () => true, EffectsSupported: () => true, OnSaveComplete: () => true, OnSaveFailed: () => true, OnLoadComplete: () => true, OnLoadFailed: () => true, ObjectUIDExists(e) {
      return !!this._runtime.GetInstanceByUID(e);
    }, IsOnPlatform(e) {
      switch (e) {
        case 0:
          return "browser" === h.Platform.Context;
        case 1:
          return "iOS" === h.Platform.OS;
        case 2:
          return "Android" === h.Platform.OS;
        case 8:
          return "cordova" === h.Platform.Context;
        case 9:
          return "scirra-arcade" === this._runtime.GetExportType();
        case 13:
          return "windows-uwp" === this._runtime.GetExportType();
        default:
          return false;
      }
    }, RegexTest(e, t, n) {
      return this.GetRegex(t, n).test(e);
    }, Compare: (e, t, n) => h.compare(e, t, n), CompareBetween: (e, t, n) => e >= t && e <= n, CompareVar: (e, t, n) => h.compare(e.GetValue(), t, n), CompareBoolVar: (e) => !!e.GetValue(), CompareTime(e, t) {
      const n = this._runtime.GetGameTime();
      if (0 === e) {
        const e2 = this._runtime.GetCurrentCondition().GetSavedDataMap();
        return !e2.get("CompareTime_executed") && n >= t && (e2.set("CompareTime_executed", true), true);
      }
      return h.compare(n, e, t);
    }, IsNaN: (e) => isNaN(e), AngleWithin: (e, t, n) => h.angleDiff(h.toRadians(e), h.toRadians(n)) <= h.toRadians(t), IsClockwiseFrom: (e, t) => h.angleClockwise(h.toRadians(e), h.toRadians(t)), IsBetweenAngles(e, t, n) {
      let r = h.toRadians(e), a = h.toRadians(t), i = h.toRadians(n);
      return !h.angleClockwise(i, a) ? !(!h.angleClockwise(r, a) && h.angleClockwise(r, i)) : h.angleClockwise(r, a) && !h.angleClockwise(r, i);
    }, IsValueType: (e, t) => "number" == typeof e ? 0 === t : 1 === t, EvaluateExpression: (e) => !!e, OnSignal(e) {
      return e.toLowerCase() === this._runtime.GetEventSheetManager().GetCurrentSignalTag();
    }, PickByComparison(e, t, n, r) {
      if (!e) return false;
      const a = this._GetForEachStack(), i = a.Push(), s = e.GetCurrentSol();
      h.shallowAssignArray(i, s.GetInstances()), s.IsSelectAll() && h.clearArray(s._GetOwnElseInstances());
      const o = this._runtime.GetCurrentCondition();
      let u = 0;
      for (let e2 = 0, a2 = i.length; e2 < a2; ++e2) {
        const a3 = i[e2];
        i[u] = a3, t = o.ReevaluateParameter(1, e2), r = o.ReevaluateParameter(3, e2), h.compare(t, n, r) ? ++u : s._PushElseInstance(a3);
      }
      h.truncateArray(i, u), s.SetArrayPicked(i);
      const l = !!i.length;
      return h.clearArray(i), a.Pop(), e.ApplySolToContainer(), l;
    }, PickByEvaluate(e, t) {
      if (!e) return false;
      const n = this._GetForEachStack(), r = n.Push(), a = e.GetCurrentSol();
      h.shallowAssignArray(r, a.GetInstances()), a.IsSelectAll() && h.clearArray(a._GetOwnElseInstances());
      const i = this._runtime.GetCurrentCondition();
      let s = 0;
      for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) {
        const t3 = r[e2];
        r[s] = t3, i.ReevaluateParameter(1, e2) ? ++s : a._PushElseInstance(t3);
      }
      h.truncateArray(r, s), a.SetArrayPicked(r);
      const o = !!r.length;
      return h.clearArray(r), n.Pop(), e.ApplySolToContainer(), o;
    }, PickByHighestLowestValue(e, t, n) {
      if (!e) return false;
      const r = e.GetCurrentSol(), a = r.GetInstances();
      if (0 === a.length) return false;
      const i = this._runtime.GetCurrentCondition();
      let s = null, o = 0;
      for (let e2 = 0, r2 = a.length; e2 < r2; ++e2) {
        const r3 = a[e2];
        n = i.ReevaluateParameter(2, e2), (null === s || 0 === t && n < o || 1 === t && n > o) && (o = n, s = r3);
      }
      return r.PickOne(s), e.ApplySolToContainer(), true;
    }, PickNth(e, t) {
      if (!e) return false;
      const n = e.GetCurrentSol(), r = n.GetInstances();
      if ((t = Math.floor(t)) >= r.length) return false;
      const a = r[t];
      return n.PickOne(a), e.ApplySolToContainer(), true;
    }, PickRandom(e) {
      if (!e) return false;
      const t = e.GetCurrentSol(), n = t.GetInstances(), r = Math.floor(this._runtime.Random() * n.length);
      if (r >= n.length) return false;
      const a = n[r];
      return t.PickOne(a), e.ApplySolToContainer(), true;
    }, PickAll(e) {
      if (!e) return false;
      if (!e.GetInstanceCount()) return false;
      return e.GetCurrentSol()._SetSelectAll(true), e.ApplySolToContainer(), true;
    }, PickOverlappingPoint(e, t, n) {
      if (!e) return false;
      const r = e.GetCurrentSol(), a = r.GetInstances(), i = this._runtime.GetCurrentEvent().IsOrBlock(), s = this._runtime.GetCurrentCondition().IsInverted();
      r.IsSelectAll() ? (h.shallowAssignArray(g, a), r.ClearArrays(), r._SetSelectAll(false)) : i ? (h.shallowAssignArray(g, r._GetOwnElseInstances()), h.clearArray(r._GetOwnElseInstances())) : (h.shallowAssignArray(g, r._GetOwnInstances()), h.clearArray(r._GetOwnInstances()));
      for (let e2 = 0, a2 = g.length; e2 < a2; ++e2) {
        const a3 = g[e2];
        h.xor(a3.GetWorldInfo().ContainsPoint(t, n), s) ? r._PushInstance(a3) : r._PushElseInstance(a3);
      }
      return e.ApplySolToContainer(), h.xor(!!r._GetOwnInstances().length, s);
    }, PickLastCreated(e) {
      if (!e) return false;
      const t = e.IsFamily();
      let n = null;
      const r = this._runtime._GetInstancesPendingCreate();
      for (let a = r.length - 1; a >= 0; --a) {
        const i = r[a];
        if (t) {
          if (i.GetObjectClass().BelongsToFamily(e)) {
            n = i;
            break;
          }
        } else if (i.GetObjectClass() === e) {
          n = i;
          break;
        }
      }
      if (!n) {
        const t2 = e.GetInstances();
        t2.length && (n = t2.at(-1));
      }
      if (!n) return false;
      return e.GetCurrentSol().PickOne(n), e.ApplySolToContainer(), true;
    }, Repeat(e) {
      return this._runtime.IsDebugging() ? this._DebugRepeat(e) : this._Repeat(e);
    }, While() {
      return this._runtime.IsDebugging() ? this._DebugWhile() : this._While();
    }, For(e, t, n) {
      return this._runtime.IsDebugging() ? this._DebugFor(e, t, n) : this._For(e, t, n);
    }, ForEach(e) {
      return this._runtime.IsDebugging() ? this._DebugForEach(e) : this._ForEach(e);
    }, ForEachOrdered(e, t, n) {
      return this._runtime.IsDebugging() ? this._DebugForEachOrdered(e, n) : this._ForEachOrdered(e, n);
    }, LayerVisible: (e) => !!e && e.IsVisible(), LayerInteractive: (e) => !!e && e.IsSelfAndParentsInteractive(), LayerIsHTML: (e) => !!e && e.IsHTMLElementsLayer(), LayerEmpty: (e) => !!e && !e.GetInstanceCount(), LayerCmpOpacity: (e, t, n) => !!e && h.compare(100 * e.GetOpacity(), t, n), LayerNameExists(e) {
      const t = this._runtime.GetMainRunningLayout();
      return !!t && t.HasLayerByName(e);
    }, OnImageLoadingComplete: () => true, IsLoadingImages() {
      return this._imagesLoadingTotal > 0;
    }, TemplateExists(e, t) {
      const n = this._runtime.GetTemplateManager();
      return !!n && (!!t && !!n.GetTemplateData(e, t));
    } };
  }
  {
    let SortZOrderList = function(e, t) {
      const n = e[0] - t[0];
      if (0 !== n) return n;
      return e[1] - t[1];
    }, SortInstancesByValue = function(e, t) {
      return e[1] - t[1];
    };
    SortZOrderList2 = SortZOrderList, SortInstancesByValue2 = SortInstancesByValue;
    const S = self.C3;
    const d = [], p = [], m = S.New(S.Rect), G = S.New(S.Color), y = [];
    S.Plugins.System.Acts = { SetVar(e, t) {
      e.SetValue(t);
    }, AddVar(e, t) {
      e.IsNumber() && "number" != typeof t && (t = parseFloat(t)), e.SetValue(e.GetValue() + t);
    }, SubVar(e, t) {
      e.IsNumber() && e.SetValue(e.GetValue() - t);
    }, SetBoolVar(e, t) {
      e.SetValue(!!t);
    }, ToggleBoolVar(e) {
      e.SetValue(!e.GetValue());
    }, ResetEventVar(e) {
      e.SetValue(e.GetInitialValue());
    }, ResetGlobals(e) {
      this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue(e);
    }, CreateObject(e, t, n, r, a, i) {
      if (!e || !t) return;
      const s = this._runtime.CreateInstance(e, t, n, r, a, i);
      if (!s) return;
      a && t.SortAndAddInstancesByZIndex(s);
      const o = this._runtime.GetEventSheetManager();
      o.BlockFlushingInstances(true), s._TriggerOnCreatedOnSelfAndRelated(), o.BlockFlushingInstances(false);
      const u = /* @__PURE__ */ new Map();
      s.CollectInstancesToPick(u, e, a);
      for (const [e2, t2] of u) e2.GetCurrentSol().SetSetPicked(t2);
    }, CreateObjectByName(e, t, n, r, a, i) {
      if (!e || !t) return;
      const s = this._runtime.GetObjectClassByName(e);
      s && S.Plugins.System.Acts.CreateObject.call(this, s, t, n, r, a, i);
    }, RecreateInitialObjects(e, t, n, r, a, i, s, o, u, l, c) {
      if (!e) return;
      const h = this._runtime.GetCurrentLayout();
      let g = h;
      if (i) {
        const e2 = this._runtime.GetLayoutManager().GetLayoutByName(i);
        if (!e2) return;
        g = e2;
      }
      let S2 = null;
      if (("number" != typeof s || s >= 0) && (S2 = g.GetLayer(s), !S2)) return;
      let d2 = null;
      if (("number" != typeof o || o >= 0) && (d2 = h.GetLayer(o), !d2)) return;
      m.set(t, n, r, a);
      const p2 = g.RecreateInitialObjects(e, m, S2, d2, u, l, c);
      e.GetCurrentSol().SetArrayPicked(p2), e.ApplySolToContainer();
    }, StopLoop() {
      const e = this._loopStack;
      e.IsInLoop() && e.GetCurrent().Stop();
    }, SetGroupActive(e, t) {
      const n = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
      n && (0 === t ? n.SetGroupActive(false) : 1 === t ? n.SetGroupActive(true) : n.SetGroupActive(!n.IsGroupActive()));
    }, SetTimescale(e) {
      this._runtime.SetTimeScale(e);
    }, SetObjectTimescale(e, t) {
      if (t < 0 && (t = 0), !e) return;
      const n = e.GetCurrentSol().GetInstances();
      for (const e2 of n) e2.SetTimeScale(t);
    }, RestoreObjectTimescale(e) {
      if (!e) return;
      const t = e.GetCurrentSol().GetInstances();
      for (const e2 of t) e2.RestoreTimeScale();
    }, Wait(e, t) {
      if (e < 0) return;
      const n = this._runtime.GetEventSheetManager().AddScheduledWait();
      return t ? n.InitTimer(e) : n.InitWallTimer(e), true;
    }, WaitForSignal(e) {
      return this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(e), true;
    }, WaitForPreviousActions() {
      const e = this._runtime.GetEventSheetManager();
      return e.AddScheduledWait().InitPromise(e.GetPromiseForAllAsyncActions()), true;
    }, Signal(e) {
      this._runtime.GetEventSheetManager().Signal(e);
    }, async SnapshotCanvas(e, t, n, r, a, i) {
      const s = this._runtime.GetCanvasManager();
      s && (this.UpdateRender(), await s.SnapshotCanvas(0 === e ? "image/png" : "image/jpeg", t / 100, n, r, a, i), await this._runtime.TriggerAsync(S.Plugins.System.Cnds.OnCanvasSnapshot, null));
    }, SetCanvasSize(e, t) {
      if (e <= 0 || t <= 0) return;
      this._runtime.SetViewportSize(e, t), this._runtime.GetCurrentLayout().BoundScrolling();
      const n = this._runtime.GetCanvasManager();
      n && ("off" === n.GetCurrentFullscreenMode() || this._runtime.SetOriginalViewportSize(e, t), n.SetSize(n.GetLastWidth(), n.GetLastHeight(), true), this._runtime.UpdateRender());
    }, SetFullscreenQuality(e) {
      const t = this._runtime.GetCanvasManager();
      t && "off" !== t.GetCurrentFullscreenMode() && (t.SetFullscreenScalingQuality(0 !== e ? "high" : "low"), t.SetSize(t.GetLastWidth(), t.GetLastHeight(), true));
    }, SaveState(e) {
      this._runtime.SaveToSlot(e);
    }, SaveStateJSON() {
      this._runtime.SaveToJsonString();
    }, LoadState(e) {
      this._runtime.LoadFromSlot(e);
    }, LoadStateJSON(e) {
      this._runtime.LoadFromJsonString(e);
    }, SetHalfFramerateMode(e) {
    }, ResetPersisted() {
      for (const e of this._runtime.GetLayoutManager().GetAllLayouts()) e.ResetPersistData();
    }, SetPixelRounding(e) {
      this._runtime.SetPixelRoundingEnabled(0 !== e);
    }, SetFramerateMinMax(e, t) {
      this._runtime.SetMaxDt(1 / e), this._runtime.SetMinDt(1 / t);
    }, SetDeltaTimeMinMax(e, t) {
      this._runtime.SetMinDt(e), this._runtime.SetMaxDt(t);
    }, SetFramerateMode(e) {
      this._runtime._SetFramerateMode(["vsync", "unlimited-tick", "unlimited-frame"][e]);
    }, SortZOrderByInstVar(e, t) {
      if (!e) return;
      const n = e.GetCurrentSol().GetInstances(), r = d, a = p, i = this._runtime.GetCurrentLayout(), s = e.IsFamily(), o = e.GetFamilyIndex();
      for (let e2 = 0, i2 = n.length; e2 < i2; ++e2) {
        const i3 = n[e2], u2 = i3.GetWorldInfo();
        if (!u2 || u2.IsDestroyed()) continue;
        let l;
        l = s ? i3.GetInstanceVariableValue(t + i3.GetObjectClass().GetFamilyInstanceVariableOffset(o)) : i3.GetInstanceVariableValue(t), r.push([u2.GetLayer().GetIndex(), u2.GetZIndex()]), a.push([i3, l]);
      }
      if (!r.length) return;
      r.sort(SortZOrderList), a.sort(SortInstancesByValue);
      let u = false;
      for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) {
        const t3 = a[e2][0], n2 = i.GetLayerByIndex(r[e2][0]), s2 = r[e2][1], o2 = n2._GetInstances();
        o2[s2] !== t3 && (o2[s2] = t3, t3.GetWorldInfo()._SetLayer(n2, true), n2.SetZIndicesChanged(t3), u = true);
      }
      u && this._runtime.UpdateRender(), S.clearArray(d), S.clearArray(p);
    }, SetCollisionCellSize(e, t) {
      e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0 || !Number.isFinite(e) || !Number.isFinite(t) || this._runtime.GetCollisionEngine().SetCollisionCellSize(e, t);
    }, GoToLayout(e) {
      if (this._runtime.IsLoading()) return;
      const t = this._runtime.GetLayoutManager();
      t.IsPendingChangeMainLayout() || t.ChangeMainLayout(e);
    }, GoToLayoutByName(e) {
      if (this._runtime.IsLoading()) return;
      const t = this._runtime.GetLayoutManager();
      if (t.IsPendingChangeMainLayout()) return;
      const n = t.GetLayoutByName(e);
      n && t.ChangeMainLayout(n);
    }, NextPrevLayout(e) {
      if (this._runtime.IsLoading()) return;
      const t = this._runtime.GetLayoutManager();
      if (t.IsPendingChangeMainLayout()) return;
      const n = t.GetAllLayouts(), r = n.indexOf(t.GetMainRunningLayout());
      if (e && 0 === r) return;
      if (!e && r === n.length - 1) return;
      const a = n[r + (e ? -1 : 1)];
      t.ChangeMainLayout(a);
    }, RestartLayout() {
      if (this._runtime.IsLoading()) return;
      const e = this._runtime.GetLayoutManager();
      e.IsPendingChangeMainLayout() || (e.ChangeMainLayout(e.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation());
    }, SetLayerVisible(e, t) {
      e && e.SetVisible(t);
    }, SetLayerInteractive(e, t) {
      e && e.SetInteractive(t);
    }, SetLayerHTML(e, t) {
      e && e.SetIsHTMLElementsLayer(t);
    }, SetLayerOpacity(e, t) {
      e && e.SetOpacity(t / 100);
    }, SetLayerScale(e, t) {
      e && e.SetOwnScale(t);
    }, SetLayerScaleRate(e, t) {
      e && e.SetScaleRate(t);
    }, SetLayerAngle(e, t) {
      e && e.SetAngle(S.toRadians(+t));
    }, SetLayerScroll(e, t, n) {
      e && (e.SetOwnScrollPositionEnabled(true), e.SetScrollX(t), e.SetScrollY(n));
    }, RestoreLayerScroll(e) {
      e && e.SetOwnScrollPositionEnabled(false);
    }, SetLayerParallax(e, t, n) {
      e && e.SetParallax(t / 100, n / 100);
    }, SetLayerZElevation(e, t) {
      e && e.SetZElevation(+t);
    }, SetLayerRenderingMode(e, t) {
      e && e.SetRenderAs3D(1 === t);
    }, SetLayerBackground(e, t) {
      if (!e) return;
      G.setFromRgbValue(t), G.clamp();
      const n = e.GetBackgroundColor();
      n.equalsIgnoringAlpha(G) || (n.copyRgb(G), this.UpdateRender());
    }, SetLayerTransparent(e, t) {
      e && e.SetTransparent(t);
    }, SetLayerBlendMode(e, t) {
      e && e.SetBlendMode(t);
    }, SetLayerEffectEnabled(e, t, n) {
      if (!e) return;
      const r = e.GetEffectList().GetEffectTypeByName(n);
      if (!r) return;
      const a = 1 === t;
      r.IsActive() !== a && (r.SetActive(a), e.UpdateActiveEffects(), this._runtime.UpdateRender());
    }, SetLayerEffectParam(e, t, n, r) {
      if (!e) return;
      const a = e.GetEffectList(), i = a.GetEffectTypeByName(t);
      if (!i) return;
      n = Math.floor(n);
      const s = i.GetShaderProgram().GetParameterType(n);
      if (!s) return;
      "color" === s ? (G.setFromRgbValue(r), r = G) : "percent" === s && (r /= 100);
      a.SetEffectParameter(i.GetIndex(), n, r) && i.IsActive() && this._runtime.UpdateRender();
    }, SetLayerForceOwnTexture(e, t) {
      e && e.SetForceOwnTexture(t);
    }, SetLayoutScale(e) {
      this._runtime.GetCurrentLayout().SetScale(+e);
    }, SetLayoutAngle(e) {
      this._runtime.GetCurrentLayout().SetAngle(S.toRadians(+e));
    }, SetLayoutEffectEnabled(e, t) {
      const n = this._runtime.GetCurrentLayout(), r = n.GetEffectList().GetEffectTypeByName(t);
      if (!r) return;
      const a = 1 === e;
      r.IsActive() !== a && (r.SetActive(a), n.UpdateActiveEffects(), this._runtime.UpdateRender());
    }, SetLayoutEffectParam(e, t, n) {
      const r = this._runtime.GetCurrentLayout().GetEffectList(), a = r.GetEffectTypeByName(e);
      if (!a) return;
      t = Math.floor(t);
      const i = a.GetShaderProgram().GetParameterType(t);
      if (!i) return;
      "color" === i ? (G.setFromRgbValue(n), n = G) : "percent" === i && (n /= 100);
      r.SetEffectParameter(a.GetIndex(), t, n) && a.IsActive() && this._runtime.UpdateRender();
    }, SetLayoutVanishingPoint(e, t) {
      this._runtime.GetCurrentLayout().SetVanishingPointXY(e / 100, t / 100);
    }, SetLayoutProjection(e) {
      const t = this._runtime.GetCurrentLayout();
      0 === e ? t.SetPerspectiveProjection() : t.SetOrthographicProjection();
    }, ScrollX(e) {
      this._runtime.GetCurrentLayout().SetScrollX(e);
    }, ScrollY(e) {
      this._runtime.GetCurrentLayout().SetScrollY(e);
    }, Scroll(e, t) {
      const n = this._runtime.GetCurrentLayout();
      n.SetScrollX(e), n.SetScrollY(t);
    }, ScrollToObject(e) {
      if (!e) return;
      const t = e.GetFirstPicked();
      if (!t) return;
      const n = t.GetWorldInfo();
      if (!n) return;
      const r = this._runtime.GetCurrentLayout();
      r.SetScrollX(n.GetX()), r.SetScrollY(n.GetY());
    }, AddLayer(e, t, n) {
      const r = this._runtime.GetCurrentLayout();
      try {
        r.AddLayer(e, t, n);
      } catch (e2) {
        console.warn("[Construct] Cannot add layer: ", e2);
      }
    }, MoveLayer(e, t, n) {
      if (!e) return;
      const r = this._runtime.GetCurrentLayout();
      try {
        r.MoveLayer(e, t, n);
      } catch (e2) {
        console.warn("[Construct] Cannot move layer: ", e2);
      }
    }, RemoveLayer(e) {
      if (!e) return;
      this._runtime.GetCurrentLayout().RemoveLayer(e);
    }, RemoveAllDynamicLayers() {
      this._runtime.GetCurrentLayout().RemoveAllDynamicLayers();
    }, async LoadObjectTextures(e) {
      const t = this._runtime.GetMainRunningLayout();
      if (!t || !e || this._runtime.IsLoading()) return;
      const n = e.IsFamily() ? e.GetFamilyMembers() : [e];
      await this._LoadTexturesForObjectClasses(t, n);
    }, async LoadObjectTexturesByName(e) {
      await S.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));
    }, UnloadObjectTextures(e) {
      const t = this._runtime.GetMainRunningLayout();
      if (!t || !e) return;
      const n = e.IsFamily() ? e.GetFamilyMembers() : [e];
      this._UnloadTexturesForObjectClasses(t, n);
    }, UnloadObjectTexturesByName(e) {
      S.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));
    }, UnloadUnusedTextures() {
      const e = this._runtime.GetMainRunningLayout();
      if (!e) return;
      const t = e._GetTextureLoadedObjectTypes();
      this._UnloadTexturesForObjectClasses(e, t);
    }, async LoadLayoutTextures(e) {
      const t = this._runtime.GetMainRunningLayout();
      e && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, e._GetInitialObjectClasses());
    }, async LoadLayoutTexturesByName(e) {
      const t = this._runtime.GetMainRunningLayout(), n = this._runtime.GetLayoutManager().GetLayoutByName(e);
      n && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, n._GetInitialObjectClasses());
    }, SetFunctionReturnValue(e) {
      const t = this._eventStack.GetCurrentExpFuncStackFrame();
      if (t) switch (t.GetFunctionReturnType()) {
        case 1:
          "number" == typeof e && t.SetFunctionReturnValue(e);
          break;
        case 2:
          "string" == typeof e && t.SetFunctionReturnValue(e);
          break;
        case 3:
          t.SetFunctionReturnValue(e);
      }
    }, MapFunction(e, t, n) {
      const r = this._GetFunctionMap(e.toLowerCase(), true), a = r.strMap, i = t.toLowerCase();
      a.has(i) && console.warn(`[Construct] Function map '${e}' string '${t}' already in map; overwriting entry`);
      const s = S.first(a.values()) || r.defaultFunc;
      if (s) {
        if (0 !== s.GetReturnType() !== (0 !== n.GetReturnType())) return void console.error(`[Construct] Function map '${e}' string '${t}' function return type not compatible with other functions in the map; entry ignored`);
      }
      a.set(i, n);
    }, MapFunctionDefault(e, t) {
      const n = this._GetFunctionMap(e.toLowerCase(), true);
      n.defaultFunc && console.warn(`[Construct] Function map '${e}' already has a default; overwriting entry`);
      const r = S.first(n.strMap.values()) || n.defaultFunc;
      if (r) {
        if (0 !== r.GetReturnType() !== (0 !== t.GetReturnType())) return void console.error(`[Construct] Function map '${e}' default: function return type not compatible with other functions in the map; entry ignored`);
      }
      n.defaultFunc = t;
    }, CallMappedFunction(e, t, n) {
      const r = this._runtime, a = r.IsDebugging() ? y : null;
      n = Math.floor(n);
      const i = this._GetFunctionMap(e.toLowerCase(), false);
      if (!i) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; call ignored`), a;
      let s = i.strMap.get(t.toLowerCase());
      if (!s) {
        if (!i.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; call ignored (consider setting a default)`), a;
        s = i.defaultFunc, n = 0;
      }
      if (!s.IsEnabled()) return a;
      if (0 !== s.GetReturnType()) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has a return type so cannot be called`), a;
      const o = r.GetEventSheetManager(), u = o.GetCurrentEvent(), l = u.GetSolModifiersIncludingParents(), c = l.length > 0;
      c && (s.IsCopyPicked() ? o.PushCopySol(l) : o.PushCleanSol(l));
      const h = [], g = o.FindFirstFunctionBlockParent(u);
      if (g) {
        const e2 = g.GetFunctionParameters();
        for (let t2 = n, r2 = e2.length; t2 < r2; ++t2) h.push(e2[t2].GetValue());
      }
      const S2 = s.GetFunctionParameters();
      for (let e2 = h.length, t2 = S2.length; e2 < t2; ++e2) h.push(S2[e2].GetInitialValue());
      return r.IsDebugging() ? this._DebugDoCallMappedFunction(o, s, h, c, l) : this._DoCallMappedFunction(o, s, h, c, l);
    } };
  }
  {
    const f = self.C3, C = f.New(f.Color);
    f.Plugins.System.Exps = { int: function(e) {
      return "string" == typeof e && (e = parseInt(e, 10), isNaN(e) && (e = 0)), Math.floor(e);
    }, float: function(e) {
      return "string" == typeof e && (e = parseFloat(e), isNaN(e) && (e = 0)), e;
    }, str: (e) => e.toString(), len: (e) => "string" == typeof e ? e.length : 0, random(e, t) {
      return void 0 === t ? this._runtime.Random() * e : this._runtime.Random() * (t - e) + e;
    }, choose(...e) {
      return e[Math.floor(this._runtime.Random() * e.length)];
    }, chooseindex: (e, ...t) => ("number" != typeof e && (e = 0), t[e = f.clamp(Math.floor(e), 0, t.length - 1)]), pi: () => Math.PI, infinity: () => 1 / 0, sqrt: (e) => Math.sqrt(e), abs: (e) => Math.abs(e), round: (e) => Math.round(e), roundtodp(e, t) {
      t = Math.max(Math.floor(t), 0);
      const n = Math.pow(10, t);
      return Math.round((e + Number.EPSILON) * n) / n;
    }, floor: (e) => Math.floor(e), ceil: (e) => Math.ceil(e), sign: (e) => Math.sign(e), sin: (e) => Math.sin(f.toRadians(e)), cos: (e) => Math.cos(f.toRadians(e)), tan: (e) => Math.tan(f.toRadians(e)), asin: (e) => f.toDegrees(Math.asin(e)), acos: (e) => f.toDegrees(Math.acos(e)), atan: (e) => f.toDegrees(Math.atan(e)), exp: (e) => Math.exp(e), ln: (e) => Math.log(e), log10: (e) => Math.log10(e), max(...e) {
      let t = e[0];
      "number" != typeof t && (t = 0);
      for (let n = 1, r = e.length; n < r; ++n) {
        let r2 = e[n];
        "number" == typeof r2 && (t < r2 && (t = r2));
      }
      return t;
    }, min(...e) {
      let t = e[0];
      "number" != typeof t && (t = 0);
      for (let n = 1, r = e.length; n < r; ++n) {
        let r2 = e[n];
        "number" == typeof r2 && (t > r2 && (t = r2));
      }
      return t;
    }, clamp: (e, t, n) => f.clamp(e, t, n), distance: (e, t, n, r) => f.distanceTo(e, t, n, r), angle: (e, t, n, r) => f.toDegrees(f.angleTo(e, t, n, r)), lerp: (e, t, n) => f.lerp(e, t, n), unlerp: (e, t, n) => f.unlerp(e, t, n), qarp: (e, t, n, r) => f.qarp(e, t, n, r), cubic: (e, t, n, r, a) => f.cubic(e, t, n, r, a), cosp: (e, t, n) => f.cosp(e, t, n), anglediff: (e, t) => f.toDegrees(f.angleDiff(f.toRadians(e), f.toRadians(t))), anglelerp: (e, t, n) => f.toDegrees(f.angleLerp(f.toRadians(e), f.toRadians(t), n)), anglerotate: (e, t, n) => f.toDegrees(f.angleRotate(f.toRadians(e), f.toRadians(t), f.toRadians(n))), setbit: (e, t, n) => (e |= 0) & ~(1 << (t |= 0)) | (n = 0 !== n ? 1 : 0) << t, togglebit: (e, t) => (e |= 0) ^ 1 << (t |= 0), getbit: (e, t) => (e |= 0) & 1 << (t |= 0) ? 1 : 0, newline: () => "\n", uppercase: (e) => "string" == typeof e ? e.toUpperCase() : "", lowercase: (e) => "string" == typeof e ? e.toLowerCase() : "", left: (e, t) => "string" == typeof e ? e.substr(0, t) : "", mid: (e, t, n) => "string" != typeof e ? "" : n < 0 ? e.substr(t) : e.substr(t, n), right: (e, t) => "string" == typeof e ? e.substr(Math.max(e.length - t, 0)) : "", trim: (e) => "string" == typeof e ? e.trim() : "", tokenat(e, t, n) {
      if ("string" != typeof e || "string" != typeof n) return "";
      let r = e.split(n);
      return (t = Math.floor(t)) < 0 || t >= r.length ? "" : r[t];
    }, tokencount: (e, t) => "string" == typeof e && "string" == typeof t && e.length ? e.split(t).length : 0, find: (e, t) => "string" == typeof e && "string" == typeof t ? e.search(new RegExp(f.EscapeRegex(t), "i")) : -1, findcase: (e, t) => "string" == typeof e && "string" == typeof t ? e.search(new RegExp(f.EscapeRegex(t), "")) : -1, replace: (e, t, n) => "string" == typeof e && "string" == typeof t && "string" == typeof n ? e.replace(new RegExp(f.EscapeRegex(t), "gi"), n) : "string" == typeof e ? e : "", stringsub(e, ...t) {
      let n = e;
      for (let e2 = 0, r = t.length; e2 < r; ++e2) n = n.replaceAll(`{${e2}}`, t[e2].toString());
      return n;
    }, regexsearch(e, t, n) {
      const r = this.GetRegex(t, n);
      return e ? e.search(r) : -1;
    }, regexreplace(e, t, n, r) {
      const a = this.GetRegex(t, n);
      return e ? e.replace(a, r) : "";
    }, regexmatchcount(e, t, n) {
      const r = this.GetRegexMatches(e.toString(), t, n);
      return r ? r.length : 0;
    }, regexmatchat(e, t, n, r) {
      r = Math.floor(r);
      const a = this.GetRegexMatches(e.toString(), t, n);
      return !a || r < 0 || r >= a.length ? "" : a[r];
    }, zeropad(e, t) {
      let n = e < 0 ? "-" : "";
      e < 0 && (e = -e);
      const r = t - e.toString().length;
      return n += "0".repeat(Math.max(r, 0)), n + e.toString();
    }, urlencode: (e) => encodeURIComponent(e), urldecode: (e) => decodeURIComponent(e), dt() {
      return this._runtime._GetDtFast();
    }, wallclockdt() {
      return this._runtime.GetDt1();
    }, timescale() {
      return this._runtime.GetTimeScale();
    }, wallclocktime() {
      return (Date.now() - this._runtime.GetStartTime()) / 1e3;
    }, unixtime: () => Date.now(), time() {
      return this._runtime.GetGameTime();
    }, tickcount() {
      return this._runtime.GetTickCount();
    }, objectcount() {
      return this._runtime.GetObjectCount();
    }, fps() {
      return this._runtime.GetFramesPerSecond();
    }, cpuutilisation() {
      return this._runtime.GetMainThreadTime();
    }, gpuutilisation() {
      return this._runtime.GetGPUUtilisation();
    }, windowwidth() {
      return this._runtime.GetCanvasManager().GetDeviceWidth();
    }, windowheight() {
      return this._runtime.GetCanvasManager().GetDeviceHeight();
    }, originalwindowwidth() {
      return this._runtime.GetOriginalViewportWidth();
    }, originalwindowheight() {
      return this._runtime.GetOriginalViewportHeight();
    }, originalviewportwidth() {
      return this._runtime.GetOriginalViewportWidth();
    }, originalviewportheight() {
      return this._runtime.GetOriginalViewportHeight();
    }, scrollx() {
      return this._runtime.GetCurrentLayout().GetScrollX();
    }, scrolly() {
      return this._runtime.GetCurrentLayout().GetScrollY();
    }, layoutname() {
      return this._runtime.GetCurrentLayout().GetName();
    }, layoutscale() {
      return this._runtime.GetCurrentLayout().GetScale();
    }, layoutangle() {
      return f.toDegrees(this._runtime.GetCurrentLayout().GetAngle());
    }, layoutwidth() {
      return this._runtime.GetCurrentLayout().GetWidth();
    }, layoutheight() {
      return this._runtime.GetCurrentLayout().GetHeight();
    }, vanishingpointx() {
      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX();
    }, vanishingpointy() {
      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY();
    }, viewportleft(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetViewport3D().getLeft() : 0;
    }, viewporttop(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetViewport3D().getTop() : 0;
    }, viewportright(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetViewport3D().getRight() : 0;
    }, viewportbottom(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetViewport3D().getBottom() : 0;
    }, viewportwidth(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetViewport3D().width() : 0;
    }, viewportheight(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetViewport3D().height() : 0;
    }, viewportmidx(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      if (t) {
        const e2 = t.GetViewport3D();
        return (e2.getLeft() + e2.getRight()) / 2;
      }
      return 0;
    }, viewportmidy(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      if (t) {
        const e2 = t.GetViewport3D();
        return (e2.getTop() + e2.getBottom()) / 2;
      }
      return 0;
    }, canvastolayerx(e, t, n) {
      const r = this._runtime.GetCurrentLayout().GetLayer(e);
      return r ? r.CanvasCssToLayer(t, n)[0] : 0;
    }, canvastolayery(e, t, n) {
      const r = this._runtime.GetCurrentLayout().GetLayer(e);
      return r ? r.CanvasCssToLayer(t, n)[1] : 0;
    }, layertocanvasx(e, t, n) {
      const r = this._runtime.GetCurrentLayout().GetLayer(e);
      return r ? r.LayerToCanvasCss(t, n)[0] : 0;
    }, layertocanvasy(e, t, n) {
      const r = this._runtime.GetCurrentLayout().GetLayer(e);
      return r ? r.LayerToCanvasCss(t, n)[1] : 0;
    }, layertolayerx(e, t, n, r) {
      const a = this._runtime.GetCurrentLayout(), i = a.GetLayer(e), s = a.GetLayer(t);
      if (!i || !s || i === s) return n;
      const [o, u] = i.LayerToCanvasCss(n, r);
      return s.CanvasCssToLayer(o, u)[0];
    }, layertolayery(e, t, n, r) {
      const a = this._runtime.GetCurrentLayout(), i = a.GetLayer(e), s = a.GetLayer(t);
      if (!i || !s || i === s) return r;
      const [o, u] = i.LayerToCanvasCss(n, r);
      return s.CanvasCssToLayer(o, u)[1];
    }, layerscale(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetOwnScale() : 0;
    }, layerangle(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? f.toDegrees(t.GetOwnAngle()) : 0;
    }, layeropacity(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? 100 * t.GetOpacity() : 0;
    }, layerscalerate(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetScaleRate() : 0;
    }, layerscrollx(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetScrollX() : 0;
    }, layerscrolly(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetScrollY() : 0;
    }, layerparallaxx(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? 100 * t.GetParallaxX() : 0;
    }, layerparallaxy(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? 100 * t.GetParallaxY() : 0;
    }, layerzelevation(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetZElevation() : 0;
    }, layerindex(e) {
      const t = this._runtime.GetCurrentLayout().GetLayer(e);
      return t ? t.GetIndex() : -1;
    }, canvassnapshot() {
      const e = this._runtime.GetCanvasManager();
      return e ? e.GetCanvasSnapshotUrl() : "";
    }, loopindex(e) {
      const t = this._loopStack;
      if (!t.IsInLoop()) return 0;
      if (e) {
        const n = t.FindByName(e);
        return n ? n.GetIndex() : 0;
      }
      return t.GetCurrent().GetIndex();
    }, savestatejson() {
      return this._runtime.GetLastSaveJsonString();
    }, callmapped(e, t, ...n) {
      const r = this._GetFunctionMap(e.toLowerCase(), false);
      if (!r) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; returning 0`), 0;
      let a = r.strMap.get(t.toLowerCase());
      if (!a) {
        if (!r.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; returning 0 (consider setting a default)`), 0;
        a = r.defaultFunc;
      }
      const i = a.GetReturnType(), s = a.GetDefaultReturnValue();
      if (0 === i) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has no return type so cannot be called from an expression; returning 0`), 0;
      if (!a.IsEnabled()) return s;
      const o = this._runtime.GetEventSheetManager(), u = o.GetCurrentEvent().GetSolModifiersIncludingParents(), l = u.length > 0;
      l && (a.IsCopyPicked() ? o.PushCopySol(u) : o.PushCleanSol(u));
      const c = a.GetFunctionParameters();
      for (let e2 = n.length, t2 = c.length; e2 < t2; ++e2) n.push(c[e2].GetInitialValue());
      const h = a.GetEventBlock(), g = h.RunAsExpressionOrJSFunctionCall(h.GetSolModifiersIncludingParents(), a.IsCopyPicked(), i, s, null, ...n);
      return l && o.PopSol(u), g;
    }, loadingprogress() {
      return this._runtime.GetAssetManager().GetLoadProgress();
    }, imageloadingprogress() {
      return this.GetImageLoadingProgress();
    }, renderer() {
      return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl";
    }, rendererdetail() {
      return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
    }, imagememoryusage() {
      let e = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
      return Math.round(100 * e / 1048576) / 100;
    }, rgb: (e, t, n) => f.PackRGB(e, t, n), rgbex: (e, t, n) => f.PackRGBEx(e / 100, t / 100, n / 100), rgba: (e, t, n, r) => f.PackRGBAEx(e / 100, t / 100, n / 100, r / 100), rgbex255: (e, t, n) => f.PackRGBEx(e / 255, t / 255, n / 255), rgba255: (e, t, n, r) => f.PackRGBAEx(e / 255, t / 255, n / 255, r / 255), hexcolor: (e) => (C.setRgba(0, 0, 0, 1), C.parseHexString(e), f.PackRGBAEx(C.getR(), C.getG(), C.getB(), C.getA())), colortohexstring: (e) => (C.setFromRgbValue(e), C.toHexString(1 !== C.getA())), projectname() {
      return this._runtime.GetProjectName();
    }, projectversion() {
      return this._runtime.GetProjectVersion();
    }, projectid() {
      return this._runtime.GetAppId();
    }, projectuniqueid() {
      return this._runtime.GetProjectUniqueId();
    }, currenteventsheetname() {
      return this._runtime.GetCurrentEvent().GetEventSheet().GetName();
    }, currenteventnumber() {
      return this._runtime.GetCurrentEvent().GetDisplayNumber();
    }, projectfilecount() {
      return this._runtime.GetAssetManager().GetExportedFileList().length;
    }, projectfilenameat(e) {
      e = Math.floor(e);
      const t = this._runtime.GetAssetManager().GetExportedFileList();
      return e < 0 || e >= t.length ? "" : t[e].name;
    } };
  }
}
var ForEachOrdered_SortInstances2;
var SortZOrderList2;
var SortInstancesByValue2;
{
  {
    const t = self.C3;
    t.Plugins.Sprite = class extends t.SDKPluginBase {
      constructor(t2) {
        super(t2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const t = self.C3, e = self.C3X, n = [];
    t.Plugins.Sprite.Type = class extends t.SDKTypeBase {
      constructor(t2) {
        super(t2), this._animations = t2.GetAnimations();
      }
      Release() {
        t.clearArray(this._animations), super.Release();
      }
      OnCreate() {
        for (const t2 of this._animations) t2.LoadAllAssets(this._runtime);
      }
      LoadTextures(t2) {
        const e2 = { sampling: this._runtime.GetSampling() };
        return Promise.all(this._animations.map((n2) => n2.LoadAllTextures(t2, e2)));
      }
      ReleaseTextures() {
        for (const t2 of this._animations) t2.ReleaseAllTextures();
      }
      OnDynamicTextureLoadComplete() {
        this._UpdateAllCurrentTexture();
      }
      _UpdateAllCurrentTexture() {
        for (const t2 of this._objectClass.instancesIncludingPendingCreate()) t2.GetSdkInstance()._UpdateCurrentTexture();
      }
      FinishCondition(e2) {
        t.Plugins.Sprite.FinishCollisionCondition(this, e2);
      }
      BeforeRunAction(t2) {
        n.push({ objectClass: null, createHierarchy: false, instances: [] });
      }
      _SpawnPickInstance(t2, e2, i2) {
        const r = n.at(-1);
        r.objectClass = t2, r.createHierarchy = i2, r.instances.push(e2);
      }
      AfterRunAction(t2) {
        const e2 = n.pop(), i2 = e2.objectClass, r = e2.createHierarchy;
        if (!i2) return;
        const a = /* @__PURE__ */ new Map();
        for (const t3 of e2.instances) t3.CollectInstancesToPick(a, i2, r);
        for (const [t3, e3] of a) t3.GetCurrentSol().SetSetPicked(e3);
      }
      _AddAnimation(t2) {
        const e2 = this.GetObjectClass().AddAnimation(t2), n2 = this.GetRuntime();
        return e2.GetFrameAt(0).GetImageInfo().LoadStaticTexture(n2.GetRenderer(), { sampling: n2.GetSampling() }).then(() => this._UpdateAllCurrentTexture()), e2;
      }
      _RemoveAnimation(t2) {
        for (const e2 of this._objectClass.instancesIncludingPendingCreate()) e2.GetSdkInstance()._OnAnimationRemoved(t2);
        this.GetObjectClass().RemoveAnimation(t2);
      }
      _AddAnimationFrame(e2, n2) {
        const i2 = this._objectClass.GetAnimationByName(e2);
        if (!i2) throw new Error(`cannot find animation name '${e2}'`);
        let r = i2.FrameTagOrIndexToIndex(n2);
        r < 0 && (r += i2.GetFrameCount() + 1);
        const a = t.AnimationFrameInfo.CreateDynamic(this.GetRuntime());
        i2.InsertFrameAt(a, r);
        const s = this.GetRuntime();
        a.GetImageInfo().LoadStaticTexture(s.GetRenderer(), { sampling: s.GetSampling() }).then(() => this._UpdateAllCurrentTexture());
        for (const t2 of this._objectClass.instancesIncludingPendingCreate()) t2.GetSdkInstance()._OnAnimationFramesChanged();
        return a;
      }
      _RemoveAnimationFrame(t2, e2) {
        const n2 = this._objectClass.GetAnimationByName(t2);
        if (!n2) throw new Error(`cannot find animation name '${t2}'`);
        if (1 === n2.GetFrameCount()) throw new Error(`cannot remove last frame from animation '${t2}'`);
        let i2 = n2.FrameTagOrIndexToIndex(e2);
        i2 < 0 && (i2 += n2.GetFrameCount()), n2.RemoveFrameAt(i2);
        for (const t3 of this._objectClass.instancesIncludingPendingCreate()) t3.GetSdkInstance()._OnAnimationFramesChanged();
      }
      GetScriptInterfaceClass() {
        return self.ISpriteObjectType;
      }
    };
    const i = /* @__PURE__ */ new WeakMap();
    self.ISpriteObjectType = class extends self.IObjectType {
      constructor(t2) {
        super(t2), i.set(this, t2.GetSdkType());
      }
      getAnimation(t2) {
        e.RequireString(t2);
        const n2 = i.get(this).GetObjectClass().GetAnimationByName(t2);
        return n2 ? n2.GetIAnimation() : null;
      }
      getAllAnimations() {
        return i.get(this).GetObjectClass().GetAllAnimations().map((t2) => t2.GetIAnimation());
      }
      addAnimation(t2) {
        return e.RequireString(t2), i.get(this)._AddAnimation(t2).GetIAnimation();
      }
      removeAnimation(t2) {
        e.RequireString(t2), i.get(this)._RemoveAnimation(t2);
      }
      addAnimationFrame(t2, n2) {
        if (e.RequireString(t2), "number" != typeof n2 && "string" != typeof n2) throw new TypeError("invalid insert location");
        return i.get(this)._AddAnimationFrame(t2, n2).GetIAnimationFrame();
      }
      removeAnimationFrame(t2, n2) {
        if (e.RequireString(t2), "number" != typeof n2 && "string" != typeof n2) throw new TypeError("invalid insert location");
        i.get(this)._RemoveAnimationFrame(t2, n2);
      }
    };
  }
  {
    const t = self.C3, e = self.C3X, n = 0, i = 1, r = 2, a = 3, s = t.New(t.Rect), o = t.New(t.Quad), m = t.New(t.Vector2), h = 1, u = 2, c = 4;
    t.Plugins.Sprite.Instance = class extends t.SDKWorldInstanceBase {
      constructor(e2, s2) {
        super(e2);
        let o2 = true, m2 = "", c2 = 0, l2 = true;
        s2 && (o2 = !!s2[n], m2 = s2[i], c2 = s2[r], l2 = s2[a]), this._currentAnimation = this._objectClass.GetAnimationByName(m2) || this._objectClass.GetAnimations()[0], this._currentFrameIndex = t.clamp(c2, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        const d2 = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = d2.GetTexture(), this._currentRcTex = d2.GetTexRect(), this._currentQuadTex = d2.GetTexQuad(), this.HandleRendererContextLoss(), e2.SetFlag(u, true), e2.SetFlag(h, this._currentAnimation.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed()), this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo(), this._animationTimer = t.New(t.KahanSum), this._frameStartTime = 0, this._animationRepeats = 0, this._animTriggerName = "", this._changeAnimFrameIndex = -1, this._changeAnimationName = "", this._changeAnimationFrom = 0;
        const g = this.GetWorldInfo();
        this._bquadRef = g.GetBoundingQuad(), g.SetVisible(o2), g.SetCollisionEnabled(l2), g.SetOriginX(this._currentAnimationFrame.GetOriginX()), g.SetOriginY(this._currentAnimationFrame.GetOriginY()), g.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly()), g.SetBboxChanged(), 1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking();
      }
      Release() {
        this._currentAnimation = null, this._currentAnimationFrame = null, this._currentTexture = null, this._animationTimer = null, super.Release();
      }
      GetCurrentImageInfo() {
        return this._currentAnimationFrame.GetImageInfo();
      }
      IsOriginalSizeKnown() {
        return true;
      }
      OnRendererContextLost() {
        this._currentTexture = null;
      }
      OnRendererContextRestored() {
        this._UpdateCurrentTexture();
      }
      Draw(t2) {
        const e2 = this._currentTexture;
        if (null === e2) return;
        t2.SetTexture(e2);
        const n2 = this.GetWorldInfo();
        n2.HasMesh() ? this._DrawMesh(n2, t2) : this._DrawStandard(n2, t2);
      }
      _DrawStandard(t2, e2) {
        let n2 = this._bquadRef;
        this._runtime.IsPixelRoundingEnabled() && (n2 = t2.PixelRoundQuad(n2)), e2.Quad4(n2, this._currentQuadTex);
      }
      _DrawMesh(t2, e2) {
        const n2 = t2.GetTransformedMesh();
        if (t2.IsMeshChanged()) {
          t2.CalculateBbox(s, o, false);
          let e3 = o;
          this._runtime.IsPixelRoundingEnabled() && (e3 = t2.PixelRoundQuad(e3)), n2.CalculateTransformedMesh(t2.GetSourceMesh(), e3, this._currentQuadTex), t2.SetMeshChanged(false);
        }
        n2.Draw(e2, t2.GetTotalZElevation());
      }
      GetAnimationTime() {
        return this._animationTimer.Get();
      }
      IsAnimationPlaying() {
        return this._inst.GetFlag(u);
      }
      SetAnimationPlaying(t2) {
        this._inst.SetFlag(u, t2);
      }
      IsPlayingForwards() {
        return this._inst.GetFlag(h);
      }
      SetPlayingForwards(t2) {
        this._inst.SetFlag(h, t2);
      }
      IsInAnimationTrigger() {
        return this._inst.GetFlag(c);
      }
      SetInAnimationTrigger(t2) {
        this._inst.SetFlag(c, t2);
      }
      Tick() {
        this._changeAnimationName && this._DoChangeAnimation(), this._changeAnimFrameIndex >= 0 && this._DoChangeAnimFrame();
        const e2 = this._currentAnimationSpeed;
        if (!this.IsAnimationPlaying() || 0 === e2) return void this._StopTicking();
        const n2 = this._runtime.GetDt(this._inst);
        this._animationTimer.Add(n2);
        const i2 = this.GetAnimationTime(), r2 = this._currentAnimationFrame, a2 = r2.GetDuration() / e2;
        if (i2 < this._frameStartTime + a2) return;
        const s2 = this._currentAnimation, o2 = this._currentAnimationRepeatTo, m2 = s2.GetFrameCount(), h2 = s2.GetRepeatCount(), u2 = s2.IsLooping(), c2 = s2.IsPingPong();
        this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--, this._frameStartTime += a2, this._currentFrameIndex >= m2 && (c2 ? (this.SetPlayingForwards(false), this._currentFrameIndex = m2 - 2) : u2 ? this._currentFrameIndex = o2 : (this._animationRepeats++, this._animationRepeats >= h2 ? this._FinishAnimation(false) : this._currentFrameIndex = o2)), this._currentFrameIndex < 0 && (c2 ? (this._currentFrameIndex = 1, this.SetPlayingForwards(true), u2 || (this._animationRepeats++, this._animationRepeats >= h2 && this._FinishAnimation(true))) : u2 ? this._currentFrameIndex = o2 : (this._animationRepeats++, this._animationRepeats >= h2 ? this._FinishAnimation(true) : this._currentFrameIndex = o2)), this._currentFrameIndex = t.clamp(this._currentFrameIndex, 0, m2 - 1);
        const l2 = s2.GetFrameAt(this._currentFrameIndex);
        i2 > this._frameStartTime + l2.GetDuration() / e2 && (this._frameStartTime = i2), this._OnFrameChanged(r2, l2);
      }
      _FinishAnimation(e2) {
        this._currentFrameIndex = e2 ? 0 : this._currentAnimation.GetFrameCount() - 1, this.SetAnimationPlaying(false), this._animTriggerName = this._currentAnimation.GetName(), this.SetInAnimationTrigger(true), this.DispatchScriptEvent("animationend", false, { animationName: this._animTriggerName }), this.Trigger(t.Plugins.Sprite.Cnds.OnAnyAnimFinished), this.Trigger(t.Plugins.Sprite.Cnds.OnAnimFinished), this.SetInAnimationTrigger(false), this._animationRepeats = 0;
      }
      _OnFrameChanged(e2, n2, i2) {
        if (e2 === n2) return;
        const r2 = this.GetWorldInfo(), a2 = e2.GetImageInfo(), s2 = n2.GetImageInfo(), o2 = a2.GetWidth(), m2 = a2.GetHeight(), h2 = s2.GetWidth(), u2 = s2.GetHeight();
        i2 && i2.onFrameChange ? i2.onFrameChange(r2, o2, m2, h2, u2) : (o2 !== h2 && r2.SetWidth(r2.GetWidth() * (h2 / o2)), m2 !== u2 && r2.SetHeight(r2.GetHeight() * (u2 / m2))), r2.SetOriginX(n2.GetOriginX()), r2.SetOriginY(n2.GetOriginY()), r2.SetSourceCollisionPoly(n2.GetCollisionPoly()), r2.SetBboxChanged(), this._currentAnimationFrame = n2, this._currentTexture = s2.GetTexture(), this._currentRcTex = s2.GetTexRect(), this._currentQuadTex = s2.GetTexQuad();
        const c2 = this.GetInstance().GetBehaviorInstances();
        for (let t2 = 0, i3 = c2.length; t2 < i3; ++t2) c2[t2].OnSpriteFrameChanged(e2, n2);
        this.DispatchScriptEvent("framechange", false, { animationName: this._currentAnimation.GetName(), animationFrame: this._currentFrameIndex }), this.Trigger(t.Plugins.Sprite.Cnds.OnFrameChanged), this._runtime.UpdateRender();
      }
      _StartAnim(t2) {
        this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime(), 1 === t2 && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame()), this._StartTicking();
      }
      _SetAnim(t2, e2, n2) {
        this._changeAnimationName = t2, this._changeAnimationFrom = e2, this._StartTicking(), !n2 && this.IsInAnimationTrigger() || this._DoChangeAnimation();
      }
      _GetCurrentAnimation() {
        return this._currentAnimation;
      }
      _GetCurrentAnimationName() {
        return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName();
      }
      _OnAnimationRemoved(e2) {
        t.equalsNoCase(e2, this._GetCurrentAnimationName()) && this._SetAnim(this._objectClass.GetFirstAnimation().GetName(), 1, true);
      }
      _SetAnimFrame(t2) {
        if ("string" == typeof t2) if (String(Number(t2)) === t2) t2 = Number(t2);
        else {
          const e2 = this._objectClass.GetAnimationByName(this._GetCurrentAnimationName());
          if (!e2) return;
          if (-1 === (t2 = e2.GetFrameIndexByTag(t2))) return;
        }
        isFinite(t2) && (this._changeAnimFrameIndex = t2, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
      }
      _OnAnimationFramesChanged() {
        if (this._changeAnimationName || -1 !== this._changeAnimFrameIndex) return;
        const e2 = this._currentAnimationFrame, n2 = this._currentAnimation.GetFrameAt(t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1));
        e2 !== n2 && this._OnFrameChanged(e2, n2), this._currentAnimation.GetFrameCount() > 1 && this._currentAnimationSpeed > 0 && this._StartTicking();
      }
      _GetAnimFrame() {
        return this._currentFrameIndex;
      }
      _GetAnimFrameTag() {
        return this._currentAnimationFrame.GetTag();
      }
      _SetAnimSpeed(t2) {
        this._currentAnimationSpeed = Math.abs(t2), this.SetPlayingForwards(t2 >= 0), this._currentAnimationSpeed > 0 && this._StartTicking();
      }
      _GetAnimSpeed() {
        return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed;
      }
      _SetAnimRepeatToFrame(e2) {
        "string" == typeof e2 && -1 === (e2 = this._currentAnimation.GetFrameIndexByTag(e2)) || (e2 = t.clamp(Math.floor(e2), 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationRepeatTo = e2);
      }
      _GetAnimRepeatToFrame() {
        return this._currentAnimationRepeatTo;
      }
      _DoChangeAnimation(e2) {
        const n2 = this._currentAnimationFrame, i2 = this._objectClass.GetAnimationByName(this._changeAnimationName);
        if (this._changeAnimationName = "", !i2) return;
        if (i2 === this._currentAnimation && this.IsAnimationPlaying()) return;
        this._currentAnimation = i2, this.SetPlayingForwards(i2.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(i2.GetSpeed()), this._currentAnimationRepeatTo = i2.GetRepeatTo(), this._currentFrameIndex = t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime();
        const r2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._OnFrameChanged(n2, r2, e2);
      }
      _DoChangeAnimFrame(e2) {
        const n2 = this._currentAnimationFrame, i2 = this._currentFrameIndex;
        if (this._currentFrameIndex = t.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1), this._changeAnimFrameIndex = -1, !e2 && i2 === this._currentFrameIndex) return;
        const r2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._OnFrameChanged(n2, r2), this._frameStartTime = this.GetAnimationTime();
      }
      _UpdateCurrentTexture() {
        const t2 = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = t2.GetTexture(), this._currentRcTex = t2.GetTexRect(), this._currentQuadTex = t2.GetTexQuad(), this.GetWorldInfo().SetMeshChanged(true);
      }
      GetTexture() {
        return this._currentTexture;
      }
      GetTexRect() {
        return this._currentRcTex;
      }
      GetTexQuad() {
        return this._currentQuadTex;
      }
      GetImagePointCount() {
        return this._currentAnimationFrame.GetImagePointCount();
      }
      GetImagePoint(t2) {
        const e2 = this._currentAnimationFrame, n2 = this.GetWorldInfo();
        let i2 = null;
        if ("string" == typeof t2) i2 = e2.GetImagePointByName(t2);
        else {
          if ("number" != typeof t2) throw new TypeError("expected string or number");
          i2 = e2.GetImagePointByIndex(t2 - 1);
        }
        let r2 = n2.GetTotalZElevation();
        if (!i2) return [n2.GetX(), n2.GetY(), r2];
        if (m.copy(i2.GetVec2()), n2.HasMesh()) {
          const [t3, e3, i3] = n2.GetSourceMesh().TransformPoint(m.getX(), m.getY());
          m.set(t3, e3), r2 += i3;
        }
        return m.offset(-e2.GetOriginX(), -e2.GetOriginY()), m.scale(n2.GetWidth(), n2.GetHeight()), m.rotate(n2.GetAngle()), m.offset(n2.GetX(), n2.GetY()), [m.getX(), m.getY(), r2];
      }
      GetCollisionPolyPointCount() {
        return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount();
      }
      GetCollisionPolyPoint(t2) {
        t2 = Math.floor(t2);
        const e2 = this.GetWorldInfo(), n2 = e2.GetTransformedCollisionPoly(), i2 = n2.pointCount();
        if (t2 === i2 && (t2 = 0), t2 < 0 || t2 >= i2) return [0, 0];
        const r2 = n2.pointsArr();
        return [r2[2 * t2 + 0] + e2.GetX(), r2[2 * t2 + 1] + e2.GetY()];
      }
      GetDebuggerProperties() {
        const e2 = t.Plugins.Sprite.Acts, n2 = "plugins.sprite.debugger.animation-properties";
        return [{ title: n2 + ".title", properties: [{ name: n2 + ".current-animation", value: this._currentAnimation.GetName(), onedit: (t2) => this.CallAction(e2.SetAnim, t2, 0) }, { name: n2 + ".current-frame", value: this._currentFrameIndex, onedit: (t2) => this.CallAction(e2.SetAnimFrame, t2) }, { name: n2 + ".is-playing", value: this.IsAnimationPlaying(), onedit: (t2) => t2 ? this.CallAction(e2.StartAnim, 0) : this.CallAction(e2.StopAnim) }, { name: n2 + ".speed", value: this._currentAnimationSpeed, onedit: (t2) => this.CallAction(e2.SetAnimSpeed, t2) }, { name: n2 + ".repeats", value: this._animationRepeats, onedit: (t2) => this._animationRepeats = t2 }] }];
      }
      SaveToJson() {
        const t2 = { "a": this._currentAnimation.GetSID() };
        0 !== this._frameStartTime && (t2["fs"] = this._frameStartTime);
        const e2 = this.GetAnimationTime();
        0 !== e2 && (t2["at"] = e2), 0 !== this._currentFrameIndex && (t2["f"] = this._currentFrameIndex), 0 !== this._currentAnimationSpeed && (t2["cas"] = this._currentAnimationSpeed), 1 !== this._animationRepeats && (t2["ar"] = this._animationRepeats), 0 !== this._currentAnimationRepeatTo && (t2["rt"] = this._currentAnimationRepeatTo), this.IsAnimationPlaying() || (t2["ap"] = this.IsAnimationPlaying()), this.IsPlayingForwards() || (t2["af"] = this.IsPlayingForwards());
        const n2 = this.GetWorldInfo();
        return n2.IsCollisionEnabled() && (t2["ce"] = n2.IsCollisionEnabled()), t2;
      }
      LoadFromJson(e2) {
        const n2 = this.GetObjectClass().GetAnimationBySID(e2["a"]);
        n2 && (this._currentAnimation = n2), this._frameStartTime = e2.hasOwnProperty("fs") ? e2["fs"] : 0, this._animationTimer.Set(e2.hasOwnProperty("at") ? e2["at"] : 0);
        const i2 = e2.hasOwnProperty("f") ? e2["f"] : 0;
        this._currentFrameIndex = t.clamp(i2, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationSpeed = e2.hasOwnProperty("cas") ? e2["cas"] : 0, this._animationRepeats = e2.hasOwnProperty("ar") ? e2["ar"] : 1;
        const r2 = e2.hasOwnProperty("rt") ? e2["rt"] : 0;
        this._currentAnimationRepeatTo = t.clamp(r2, 0, this._currentAnimation.GetFrameCount() - 1), this.SetAnimationPlaying(!e2.hasOwnProperty("ap") || !!e2["ap"]), this.SetPlayingForwards(!e2.hasOwnProperty("af") || !!e2["af"]);
        const a2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._currentAnimationFrame = a2, this._UpdateCurrentTexture();
        const s2 = this.GetWorldInfo();
        s2.SetOriginX(a2.GetOriginX()), s2.SetOriginY(a2.GetOriginY()), s2.SetSourceCollisionPoly(a2.GetCollisionPoly()), s2.SetCollisionEnabled(!!e2["ce"]), this.IsAnimationPlaying() && this._StartTicking();
      }
      GetPropertyValueByIndex(e2) {
        const n2 = this.GetWorldInfo();
        switch (e2) {
          case a:
            return n2.IsCollisionEnabled();
          case r:
            return t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);
          case i:
            return this._currentAnimation.GetName();
        }
      }
      SetPropertyValueByIndex(e2, n2, s2) {
        const o2 = this.GetWorldInfo();
        switch (e2) {
          case a:
            o2.SetCollisionEnabled(!!n2);
            break;
          case r:
            if (s2.isChunkDiscreteLike) {
              if (!s2.keyframeReached) return;
              {
                const e3 = this._currentAnimation.GetFrameCount() - 1, i2 = n2 = t.clamp(n2, 0, e3), r2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex), a2 = this._currentAnimation.GetFrameAt(i2);
                this._OnFrameChanged(r2, a2, s2), this._currentFrameIndex = t.clamp(i2, 0, e3);
              }
            } else {
              this.SetAnimationPlaying(false);
              const e3 = this._currentAnimation.GetFrameCount() - 1, i2 = n2 = t.clamp(n2, 0, e3), r2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex), a2 = this._currentAnimation.GetFrameAt(i2);
              this._OnFrameChanged(r2, a2, s2), this._currentFrameIndex = t.clamp(i2, 0, e3);
            }
            break;
          case i:
            this._changeAnimationName = n2, this._changeAnimationFrom = s2?.startFrom ?? 0, this._DoChangeAnimation(s2);
            this._currentAnimation.GetFrameCount() > 1 && this._currentAnimation.GetSpeed() > 0 ? this._StartTicking() : this._StopTicking();
            break;
        }
      }
      GetScriptInterfaceClass() {
        return self.ISpriteInstance;
      }
    };
    const l = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new Map([["current-frame", 0], ["beginning", 1]]);
    self.ISpriteInstance = class extends self.IWorldInstance {
      constructor() {
        super(), l.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      getImagePointCount() {
        return l.get(this).GetImagePointCount();
      }
      getImagePointX(t2) {
        return this.getImagePoint(t2)[0];
      }
      getImagePointY(t2) {
        return this.getImagePoint(t2)[1];
      }
      getImagePointZ(t2) {
        return this.getImagePoint(t2)[2];
      }
      getImagePoint(t2) {
        if ("string" != typeof t2 && "number" != typeof t2) throw new TypeError("expected string or number");
        return l.get(this).GetImagePoint(t2);
      }
      getPolyPointCount() {
        return l.get(this).GetCollisionPolyPointCount();
      }
      getPolyPointX(t2) {
        return e.RequireFiniteNumber(t2), l.get(this).GetCollisionPolyPoint(t2)[0];
      }
      getPolyPointY(t2) {
        return e.RequireFiniteNumber(t2), l.get(this).GetCollisionPolyPoint(t2)[1];
      }
      getPolyPoint(t2) {
        return e.RequireFiniteNumber(t2), l.get(this).GetCollisionPolyPoint(t2);
      }
      stopAnimation() {
        l.get(this).SetAnimationPlaying(false);
      }
      startAnimation(t2 = "current-frame") {
        e.RequireString(t2);
        const n2 = d.get(t2);
        if (void 0 === n2) throw new Error("invalid mode");
        l.get(this)._StartAnim(n2);
      }
      setAnimation(t2, n2 = "beginning") {
        e.RequireString(t2), e.RequireString(n2);
        const i2 = d.get(n2);
        if (void 0 === i2) throw new Error("invalid mode");
        const r2 = l.get(this);
        if (!r2.GetObjectClass().GetAnimationByName(t2)) throw new Error(`animation name "${t2}" does not exist`);
        r2._SetAnim(t2, i2);
      }
      getAnimation(t2) {
        e.RequireString(t2);
        const n2 = l.get(this).GetObjectClass().GetAnimationByName(t2);
        return n2 ? n2.GetIAnimation() : null;
      }
      get animation() {
        return l.get(this)._GetCurrentAnimation().GetIAnimation();
      }
      get animationName() {
        return l.get(this)._GetCurrentAnimationName();
      }
      set animationFrame(t2) {
        e.RequireFiniteNumber(t2), l.get(this)._SetAnimFrame(t2);
      }
      get animationFrame() {
        return l.get(this)._GetAnimFrame();
      }
      set animationFrameTag(t2) {
        e.RequireString(t2), l.get(this)._SetAnimFrame(t2);
      }
      get animationFrameTag() {
        return l.get(this)._GetAnimFrameTag();
      }
      set animationSpeed(t2) {
        e.RequireFiniteNumber(t2), l.get(this)._SetAnimSpeed(t2);
      }
      get animationSpeed() {
        return l.get(this)._GetAnimSpeed();
      }
      set animationRepeatToFrame(t2) {
        e.RequireFiniteNumber(t2), l.get(this)._SetAnimRepeatToFrame(t2);
      }
      get animationRepeatToFrame() {
        return l.get(this)._GetAnimRepeatToFrame();
      }
      get imageWidth() {
        return l.get(this).GetCurrentImageInfo().GetWidth();
      }
      get imageHeight() {
        return l.get(this).GetCurrentImageInfo().GetHeight();
      }
      getImageSize() {
        const t2 = l.get(this).GetCurrentImageInfo();
        return [t2.GetWidth(), t2.GetHeight()];
      }
      async replaceCurrentAnimationFrame(n2) {
        e.RequireInstanceOf(n2, Blob);
        const i2 = l.get(this), r2 = i2.GetRuntime(), a2 = i2.GetCurrentImageInfo(), s2 = t.New(t.ImageInfo);
        if (s2.LoadDynamicBlobAsset(r2, n2), await s2.LoadStaticTexture(r2.GetRenderer(), { sampling: r2.GetSampling() }), i2.WasReleased()) return void s2.Release();
        a2.ReplaceWith(s2);
        const o2 = i2.GetSdkType();
        o2._UpdateAllCurrentTexture(), o2.GetObjectClass().Dispatcher().dispatchEvent(new t.Event("animationframeimagechange")), r2.UpdateRender();
      }
      setSolidCollisionFilter(e2, n2) {
        "string" == typeof n2 && (n2 = t.splitStringAndNormalize(n2)), l.get(this).GetWorldInfo().SetSolidCollisionFilter(!!e2, n2);
      }
    };
  }
  {
    const t = self.C3;
    t.Plugins.Sprite.Cnds = { IsAnimPlaying(e) {
      return t.equalsNoCase(this._GetCurrentAnimationName(), e);
    }, CompareFrame(e, n) {
      return t.compare(this._currentFrameIndex, e, n);
    }, CompareFrameTag(e, n) {
      if ("string" != typeof n) return false;
      const i = this._currentAnimationFrame.GetTag();
      return t.compare(i.toLowerCase(), e, n.toLowerCase());
    }, CompareAnimSpeed(e, n) {
      return t.compare(this._GetAnimSpeed(), e, n);
    }, OnAnimFinished(e) {
      return t.equalsNoCase(this._animTriggerName, e);
    }, OnAnyAnimFinished: () => true, OnFrameChanged: () => true, IsMirrored() {
      return this.GetWorldInfo().GetWidth() < 0;
    }, IsFlipped() {
      return this.GetWorldInfo().GetHeight() < 0;
    }, OnURLLoaded: () => true, OnURLFailed: () => true, IsCollisionEnabled() {
      return this.GetWorldInfo().IsCollisionEnabled();
    } };
  }
  {
    const t = self.C3;
    t.Plugins.Sprite.Acts = { Spawn(t2, e, n, i, r) {
      if (!t2 || !e) return;
      const [a, s] = this.GetImagePoint(n), o = this._runtime.CreateInstance(t2, e, a, s, i, r);
      if (!o) return;
      if (i && e.SortAndAddInstancesByZIndex(o), t2.GetPlugin().IsRotatable()) {
        const t3 = o.GetWorldInfo();
        t3.SetAngle(this.GetWorldInfo().GetAngle()), t3.SetBboxChanged();
      }
      const m = this._runtime.GetEventSheetManager();
      m.BlockFlushingInstances(true), o._TriggerOnCreatedOnSelfAndRelated(), m.BlockFlushingInstances(false), t2 !== this._runtime.GetCurrentAction().GetObjectClass() && this._sdkType._SpawnPickInstance(t2, o, i);
    }, StopAnim() {
      this.SetAnimationPlaying(false);
    }, StartAnim(t2) {
      this._StartAnim(t2);
    }, SetAnim(t2, e) {
      this._SetAnim(t2, e);
    }, SetAnimFrame(t2) {
      this._SetAnimFrame(t2);
    }, SetAnimSpeed(t2) {
      this._SetAnimSpeed(t2);
    }, SetAnimRepeatToFrame(t2) {
      this._SetAnimRepeatToFrame(t2);
    }, AddRemoveAnimation(t2, e) {
      try {
        0 === t2 ? this.GetSdkType()._AddAnimation(e) : this.GetSdkType()._RemoveAnimation(e);
      } catch (e2) {
        console.error(`[Construct] Error ${0 === t2 ? "adding" : "removing"} animation: `, e2);
      }
    }, AddRemoveAnimationFrame(t2, e, n) {
      try {
        0 === t2 ? this.GetSdkType()._AddAnimationFrame(e, n) : this.GetSdkType()._RemoveAnimationFrame(e, n);
      } catch (e2) {
        console.error(`[Construct] Error ${0 === t2 ? "adding" : "removing"} animation frame: `, e2);
      }
    }, SetMirrored(t2) {
      const e = this.GetWorldInfo(), n = e.GetWidth(), i = Math.abs(n) * (0 === t2 ? -1 : 1);
      n !== i && (e.SetWidth(i), e.SetBboxChanged());
    }, SetFlipped(t2) {
      const e = this.GetWorldInfo(), n = e.GetHeight(), i = Math.abs(n) * (0 === t2 ? -1 : 1);
      n !== i && (e.SetHeight(i), e.SetBboxChanged());
    }, SetScale(t2) {
      const e = this._currentAnimationFrame.GetImageInfo(), n = this.GetWorldInfo(), i = n.GetWidth() < 0 ? -1 : 1, r = n.GetHeight() < 0 ? -1 : 1, a = e.GetWidth() * t2 * i, s = e.GetHeight() * t2 * r;
      n.GetWidth() === a && n.GetHeight() === s || (n.SetSize(a, s), n.SetBboxChanged());
    }, async LoadURL(e, n, i) {
      const r = this._currentAnimationFrame.GetImageInfo(), a = this.GetWorldInfo(), s = this._runtime, o = this._sdkType;
      if (r.GetURL() === e) return 0 === n && (a.SetSize(r.GetWidth(), r.GetHeight()), a.SetBboxChanged()), void this.Trigger(t.Plugins.Sprite.Cnds.OnURLLoaded);
      const m = t.New(t.ImageInfo);
      try {
        if (await m.LoadDynamicAsset(s, e), !m.IsLoaded()) throw new Error("image failed to load");
        if (this.WasReleased()) return void m.Release();
        await m.LoadStaticTexture(s.GetRenderer(), { sampling: s.GetSampling() });
      } catch (e2) {
        return console.error("Load image from URL failed: ", e2), void (this.WasReleased() || this.Trigger(t.Plugins.Sprite.Cnds.OnURLFailed));
      }
      this.WasReleased() ? m.Release() : (r.ReplaceWith(m), o._UpdateAllCurrentTexture(), o.GetObjectClass().Dispatcher().dispatchEvent(new t.Event("animationframeimagechange")), s.UpdateRender(), 0 === n && (a.SetSize(r.GetWidth(), r.GetHeight()), a.SetBboxChanged()), await this.TriggerAsync(t.Plugins.Sprite.Cnds.OnURLLoaded));
    }, SetCollisions(t2) {
      this.GetWorldInfo().SetCollisionEnabled(t2);
    }, SetSolidCollisionFilter(e, n) {
      this.GetWorldInfo().SetSolidCollisionFilter(0 === e, t.splitStringAndNormalize(n));
    }, SetEffect(t2) {
      this.GetWorldInfo().SetBlendMode(t2), this._runtime.UpdateRender();
    } };
  }
  self.C3.Plugins.Sprite.Exps = { AnimationFrame() {
    return this._GetAnimFrame();
  }, AnimationFrameTag() {
    return this._GetAnimFrameTag();
  }, AnimationFrameCount() {
    return this._currentAnimation.GetFrameCount();
  }, AnimationName() {
    return this._currentAnimation.GetName();
  }, AnimationSpeed() {
    return this._GetAnimSpeed();
  }, OriginalAnimationSpeed() {
    return this._currentAnimation.GetSpeed();
  }, ImagePointX(t) {
    return this.GetImagePoint(t)[0];
  }, ImagePointY(t) {
    return this.GetImagePoint(t)[1];
  }, ImagePointZ(t) {
    return this.GetImagePoint(t)[2];
  }, ImagePointCount() {
    return this.GetImagePointCount();
  }, ImageWidth() {
    return this.GetCurrentImageInfo().GetWidth();
  }, ImageHeight() {
    return this.GetCurrentImageInfo().GetHeight();
  }, PolyPointXAt(t) {
    return this.GetCollisionPolyPoint(t)[0];
  }, PolyPointYAt(t) {
    return this.GetCollisionPolyPoint(t)[1];
  }, PolyPointCount() {
    return this.GetCollisionPolyPointCount();
  } };
}
{
  {
    const t = self.C3;
    t.Plugins.Touch = class extends t.SDKPluginBase {
      constructor(t2) {
        super(t2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    let GetTouchSdkInstance = function() {
      return i.GetSingleGlobalInstance().GetSdkInstance();
    };
    GetTouchSdkInstance2 = GetTouchSdkInstance;
    const e = self.C3, s = self.C3X;
    e.Plugins.Touch.Type = class extends e.SDKTypeBase {
      constructor(t) {
        super(t);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      GetScriptInterfaceClass() {
        return self.ITouchObjectType;
      }
    };
    let i = null;
    self.ITouchObjectType = class extends self.IObjectType {
      constructor(t) {
        super(t), i = t, t.GetRuntime()._GetCommonScriptInterfaces().touch = this;
      }
      requestPermission(t) {
        s.RequireString(t);
        const e2 = GetTouchSdkInstance();
        if ("orientation" === t) return e2._RequestPermission(0);
        if ("motion" === t) return e2._RequestPermission(1);
        throw new Error("invalid type");
      }
    };
  }
  {
    const n = self.C3, r = "touch";
    n.Plugins.Touch.Instance = class extends n.SDKInstanceBase {
      constructor(t, e) {
        super(t, r), this._touches = /* @__PURE__ */ new Map(), this._useMouseInput = false, this._isMouseDown = false, this._orientCompassHeading = 0, this._orientAlpha = 0, this._orientBeta = 0, this._orientGamma = 0, this._accX = 0, this._accY = 0, this._accZ = 0, this._accWithGX = 0, this._accWithGY = 0, this._accWithGZ = 0, this._triggerIndex = 0, this._triggerId = 0, this._triggerPermission = 0, this._curTouchX = 0, this._curTouchY = 0, this._getTouchIndex = 0, this._triggerType = 0, this._permissionPromises = [], e && (this._useMouseInput = e[0]), this.AddDOMMessageHandler("permission-result", (t2) => this._OnPermissionResult(t2));
        const s = this.GetRuntime().Dispatcher();
        this._disposables = new n.CompositeDisposable(n.Disposable.From(s, "pointerdown", (t2) => this._OnPointerDown(t2.data)), n.Disposable.From(s, "pointermove", (t2) => this._OnPointerMove(t2.data)), n.Disposable.From(s, "pointerup", (t2) => this._OnPointerUp(t2.data, false)), n.Disposable.From(s, "pointercancel", (t2) => this._OnPointerUp(t2.data, true)), n.Disposable.From(s, "deviceorientation", (t2) => this._OnDeviceOrientation(t2.data)), n.Disposable.From(s, "deviceorientationabsolute", (t2) => this._OnDeviceOrientationAbsolute(t2.data)), n.Disposable.From(s, "devicemotion", (t2) => this._OnDeviceMotion(t2.data)), n.Disposable.From(s, "tick2", (t2) => this._OnTick2()));
      }
      Release() {
        this._touches.clear(), super.Release();
      }
      _OnPointerDown(t) {
        if ("mouse" === t["pointerType"]) {
          if (!this._useMouseInput) return;
          this._isMouseDown = true;
        }
        const e = t["pointerId"];
        if (this._touches.has(e)) return;
        const s = t["pageX"] - this._runtime.GetCanvasClientX(), i = t["pageY"] - this._runtime.GetCanvasClientY(), r2 = performance.now(), o = this._touches.size;
        this._triggerIndex = o, this._triggerId = e;
        const u = n.New(n.Plugins.Touch.TouchInfo);
        u.Init(r2, s, i, e, o), this._touches.set(e, u), this.Trigger(n.Plugins.Touch.Cnds.OnNthTouchStart), this.Trigger(n.Plugins.Touch.Cnds.OnTouchStart), this._curTouchX = s, this._curTouchY = i, this._triggerType = 0, this.Trigger(n.Plugins.Touch.Cnds.OnTouchObject);
      }
      _OnPointerMove(t) {
        if ("mouse" === t["pointerType"] && !this._isMouseDown) return;
        const e = this._touches.get(t["pointerId"]);
        if (!e) return;
        const s = performance.now();
        if (s - e.GetTime() < 2) return;
        const i = t["pageX"] - this._runtime.GetCanvasClientX(), n2 = t["pageY"] - this._runtime.GetCanvasClientY();
        e.Update(s, i, n2, t["width"], t["height"], t["pressure"]);
      }
      _OnPointerUp(t, e) {
        if ("mouse" === t["pointerType"]) {
          if (!this._isMouseDown) return;
          this._isMouseDown = false;
        }
        const s = performance.now(), i = t["pointerId"], r2 = this._touches.get(i);
        if (r2) {
          if (this._triggerIndex = r2.GetStartIndex(), this._triggerId = r2.GetId(), !e) {
            const e2 = t["pageX"] - this._runtime.GetCanvasClientX(), s2 = t["pageY"] - this._runtime.GetCanvasClientY();
            this._curTouchX = e2, this._curTouchY = s2, this._triggerType = 1, this.Trigger(n.Plugins.Touch.Cnds.OnTouchObject);
          }
          if (this.Trigger(n.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(n.Plugins.Touch.Cnds.OnTouchEnd), !e) {
            const t2 = r2.ShouldTriggerTap(s);
            "single-tap" === t2 ? (this.Trigger(n.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = r2.GetX(), this._curTouchY = r2.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnTapGestureObject)) : "double-tap" === t2 && (this.Trigger(n.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = r2.GetX(), this._curTouchY = r2.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnDoubleTapGestureObject));
          }
          r2.Release(), this._touches.delete(i);
        }
      }
      _RequestPermission(t) {
        return this._PostToDOMMaybeSync("request-permission", { "type": t }), new Promise((e, s) => {
          this._permissionPromises.push({ type: t, resolve: e, reject: s });
        });
      }
      _OnPermissionResult(t) {
        const e = t["result"], s = t["type"];
        this._triggerPermission = s;
        const i = this._permissionPromises.filter((t2) => t2.type === s);
        for (const t2 of i) t2.resolve(e ? "granted" : "denied");
        this._permissionPromises = this._permissionPromises.filter((t2) => t2.type !== s), e ? (this.Trigger(n.Plugins.Touch.Cnds.OnPermissionGranted), 0 === s ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(n.Plugins.Touch.Cnds.OnPermissionDenied);
      }
      _OnDeviceOrientation(t) {
        "number" == typeof t["webkitCompassHeading"] ? this._orientCompassHeading = t["webkitCompassHeading"] : t["absolute"] && (this._orientCompassHeading = t["alpha"]), this._orientAlpha = t["alpha"], this._orientBeta = t["beta"], this._orientGamma = t["gamma"];
      }
      _OnDeviceOrientationAbsolute(t) {
        this._orientCompassHeading = t["alpha"];
      }
      _OnDeviceMotion(t) {
        const e = t["acceleration"];
        e && (this._accX = e["x"], this._accY = e["y"], this._accZ = e["z"]);
        const s = t["accelerationIncludingGravity"];
        s && (this._accWithGX = s["x"], this._accWithGY = s["y"], this._accWithGZ = s["z"]);
      }
      _OnTick2() {
        const t = performance.now();
        let e = 0;
        for (const s of this._touches.values()) s.GetTime() <= t - 50 && s._SetLastTime(t), s.ShouldTriggerHold(t) && (this._triggerIndex = s.GetStartIndex(), this._triggerId = s.GetId(), this._getTouchIndex = e, this.Trigger(n.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = s.GetX(), this._curTouchY = s.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++e;
      }
      _GetTouchByIndex(t) {
        t = Math.floor(t);
        for (const e of this._touches.values()) {
          if (0 === t) return e;
          --t;
        }
        return null;
      }
      _IsClientPosOnCanvas(t, e) {
        return t >= 0 && e >= 0 && t < this._runtime.GetCanvasCssWidth() && e < this._runtime.GetCanvasCssHeight();
      }
      GetDebuggerProperties() {
        return [{ title: "plugins.touch.debugger.touches", properties: [...this._touches.values()].map((t) => ({ name: "$" + t.GetId(), value: t.GetX() + ", " + t.GetY() })) }];
      }
    };
  }
  {
    const o = self.C3;
    o.Plugins.Touch.Cnds = { OnTouchStart: () => true, OnTouchEnd: () => true, IsInTouch() {
      return this._touches.size > 0;
    }, OnTouchObject(t, e) {
      return !!t && (e === this._triggerType && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false)));
    }, IsTouchingObject(t) {
      if (!t) return false;
      const e = this._runtime.GetCurrentCondition().IsInverted(), s = [...this._touches.values()].filter((t2) => this._IsClientPosOnCanvas(t2.GetX(), t2.GetY())).map((t2) => [t2.GetX(), t2.GetY()]);
      return o.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, s, e), e);
    }, CompareTouchSpeed(t, e, s) {
      const i = this._GetTouchByIndex(t);
      return !!i && o.compare(i.GetSpeed(), e, s);
    }, OrientationSupported: () => true, MotionSupported: () => true, CompareOrientation(t, e, s) {
      this._runtime.RequestDeviceOrientationEvent();
      let i = 0;
      return i = 0 === t ? this._orientAlpha : 1 === t ? this._orientBeta : this._orientGamma, o.compare(i, e, s);
    }, CompareAcceleration(t, e, s) {
      this._runtime.RequestDeviceMotionEvent();
      let i = 0;
      return i = 0 === t ? this._accWithGX : 1 === t ? this._accWithGY : 2 === t ? this._accWithGZ : 3 === t ? this._accX : 4 === t ? this._accY : this._accZ, o.compare(i, e, s);
    }, OnNthTouchStart(t) {
      return (t = Math.floor(t)) === this._triggerIndex;
    }, OnNthTouchEnd(t) {
      return (t = Math.floor(t)) === this._triggerIndex;
    }, HasNthTouch(t) {
      return t = Math.floor(t), this._touches.size >= t + 1;
    }, OnHoldGesture: () => true, OnTapGesture: () => true, OnDoubleTapGesture: () => true, OnHoldGestureObject(t) {
      return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));
    }, OnTapGestureObject(t) {
      return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));
    }, OnDoubleTapGestureObject(t) {
      return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));
    }, OnPermissionGranted(t) {
      return this._triggerPermission === t;
    }, OnPermissionDenied(t) {
      return this._triggerPermission === t;
    } };
  }
  self.C3.Plugins.Touch.Acts = { RequestPermission(t) {
    this._RequestPermission(t);
  } };
  {
    const u = self.C3;
    u.Plugins.Touch.Exps = { TouchCount() {
      return this._touches.size;
    }, X(t) {
      const e = this._GetTouchByIndex(this._getTouchIndex);
      return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, true) : 0;
    }, Y(t) {
      const e = this._GetTouchByIndex(this._getTouchIndex);
      return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, false) : 0;
    }, XAt(t, e) {
      const s = this._GetTouchByIndex(t);
      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;
    }, YAt(t, e) {
      const s = this._GetTouchByIndex(t);
      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;
    }, XForID(t, e) {
      const s = this._touches.get(t);
      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;
    }, YForID(t, e) {
      const s = this._touches.get(t);
      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;
    }, AbsoluteX() {
      const t = this._GetTouchByIndex(0);
      return t ? t.GetX() : 0;
    }, AbsoluteY() {
      const t = this._GetTouchByIndex(0);
      return t ? t.GetY() : 0;
    }, AbsoluteXAt(t) {
      const e = this._GetTouchByIndex(t);
      return e ? e.GetX() : 0;
    }, AbsoluteYAt(t) {
      const e = this._GetTouchByIndex(t);
      return e ? e.GetY() : 0;
    }, AbsoluteXForID(t) {
      const e = this._touches.get(t);
      return e ? e.GetX() : 0;
    }, AbsoluteYForID(t) {
      const e = this._touches.get(t);
      return e ? e.GetY() : 0;
    }, SpeedAt(t) {
      const e = this._GetTouchByIndex(t);
      return e ? e.GetSpeed() : 0;
    }, SpeedForID(t) {
      const e = this._touches.get(t);
      return e ? e.GetSpeed() : 0;
    }, AngleAt(t) {
      const e = this._GetTouchByIndex(t);
      return e ? u.toDegrees(e.GetAngle()) : 0;
    }, AngleForID(t) {
      const e = this._touches.get(t);
      return e ? u.toDegrees(e.GetAngle()) : 0;
    }, CompassHeading() {
      return this._runtime.RequestDeviceOrientationEvent(), this._orientCompassHeading;
    }, Alpha() {
      return this._runtime.RequestDeviceOrientationEvent(), this._orientAlpha;
    }, Beta() {
      return this._runtime.RequestDeviceOrientationEvent(), this._orientBeta;
    }, Gamma() {
      return this._runtime.RequestDeviceOrientationEvent(), this._orientGamma;
    }, AccelerationXWithG() {
      return this._runtime.RequestDeviceMotionEvent(), this._accWithGX;
    }, AccelerationYWithG() {
      return this._runtime.RequestDeviceMotionEvent(), this._accWithGY;
    }, AccelerationZWithG() {
      return this._runtime.RequestDeviceMotionEvent(), this._accWithGZ;
    }, AccelerationX() {
      return this._runtime.RequestDeviceMotionEvent(), this._accX;
    }, AccelerationY() {
      return this._runtime.RequestDeviceMotionEvent(), this._accY;
    }, AccelerationZ() {
      return this._runtime.RequestDeviceMotionEvent(), this._accZ;
    }, TouchIndex() {
      return this._triggerIndex;
    }, TouchID() {
      return this._triggerId;
    }, WidthForID(t) {
      const e = this._touches.get(t);
      return e ? e.GetWidth() : 0;
    }, HeightForID(t) {
      const e = this._touches.get(t);
      return e ? e.GetHeight() : 0;
    }, PressureForID(t) {
      const e = this._touches.get(t);
      return e ? e.GetPressure() : 0;
    } };
  }
}
var GetTouchSdkInstance2;
{
  const C32 = self.C3, GESTURE_HOLD_THRESHOLD = 15, GESTURE_HOLD_TIMEOUT = 500, GESTURE_TAP_TIMEOUT = 333, GESTURE_DOUBLETAP_THRESHOLD = 25;
  let lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4;
  C32.Plugins.Touch.TouchInfo = class extends C32.DefendedBase {
    constructor() {
      super(), this._pointerId = 0, this._startIndex = 0, this._startTime = 0, this._time = 0, this._lastTime = 0, this._startX = 0, this._startY = 0, this._x = 0, this._y = 0, this._lastX = 0, this._lastY = 0, this._width = 0, this._height = 0, this._pressure = 0, this._hasTriggeredHold = false, this._isTooFarForHold = false;
    }
    Release() {
    }
    Init(t, s, i, e, h) {
      this._pointerId = e, this._startIndex = h, this._time = t, this._lastTime = t, this._startTime = t, this._startX = s, this._startY = i, this._x = s, this._y = i, this._lastX = s, this._lastY = i;
    }
    Update(t, s, i, e, h, _) {
      this._lastTime = this._time, this._time = t, this._lastX = this._x, this._lastY = this._y, this._x = s, this._y = i, this._width = e, this._height = h, this._pressure = _, !this._isTooFarForHold && C32.distanceTo(this._startX, this._startY, this._x, this._y) >= 15 && (this._isTooFarForHold = true);
    }
    GetId() {
      return this._pointerId;
    }
    GetStartIndex() {
      return this._startIndex;
    }
    GetTime() {
      return this._time;
    }
    _SetLastTime(t) {
      this._lastTime = t;
    }
    GetX() {
      return this._x;
    }
    GetY() {
      return this._y;
    }
    GetSpeed() {
      const t = C32.distanceTo(this._x, this._y, this._lastX, this._lastY), s = (this._time - this._lastTime) / 1e3;
      return s > 0 ? t / s : 0;
    }
    GetAngle() {
      return C32.angleTo(this._lastX, this._lastY, this._x, this._y);
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetPressure() {
      return this._pressure;
    }
    ShouldTriggerHold(t) {
      return !this._hasTriggeredHold && (t - this._startTime >= 500 && !this._isTooFarForHold && C32.distanceTo(this._startX, this._startY, this._x, this._y) < 15 && (this._hasTriggeredHold = true, true));
    }
    ShouldTriggerTap(t) {
      return this._hasTriggeredHold ? "" : t - this._startTime <= 333 && !this._isTooFarForHold && C32.distanceTo(this._startX, this._startY, this._x, this._y) < 15 ? t - lastTapTime <= 666 && C32.distanceTo(lastTapX, lastTapY, this._x, this._y) < 25 ? (lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4, "double-tap") : (lastTapX = this._x, lastTapY = this._y, lastTapTime = t, "single-tap") : "";
    }
    GetPositionForLayer(t, s, i) {
      if (void 0 === s) {
        return t.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[i ? 0 : 1];
      }
      {
        const e = t.GetLayer(s);
        return e ? e.CanvasCssToLayer(this._x, this._y)[i ? 0 : 1] : 0;
      }
    }
  };
}
{
  {
    const e = self.C3;
    e.Plugins.Keyboard = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    let GetKeyboardSdkInstance = function() {
      return t.GetSingleGlobalInstance().GetSdkInstance();
    };
    GetKeyboardSdkInstance2 = GetKeyboardSdkInstance;
    const r = self.C3;
    self.C3X;
    r.Plugins.Keyboard.Type = class extends r.SDKTypeBase {
      constructor(e) {
        super(e);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      GetScriptInterfaceClass() {
        return self.IKeyboardObjectType;
      }
    };
    let t = null;
    self.IKeyboardObjectType = class extends self.IObjectType {
      constructor(e) {
        super(e), t = e, e.GetRuntime()._GetCommonScriptInterfaces().keyboard = this;
      }
      isKeyDown(e) {
        const r2 = GetKeyboardSdkInstance();
        if ("string" == typeof e) return r2.IsKeyDown(e);
        if ("number" == typeof e) return r2.IsKeyCodeDown(e);
        throw new TypeError("expected string or number");
      }
    };
  }
  {
    const s = self.C3, n = "keyboard";
    s.Plugins.Keyboard.Instance = class extends s.SDKInstanceBase {
      constructor(e, r) {
        super(e, n), this._keysDownByString = /* @__PURE__ */ new Set(), this._keysDownByWhich = /* @__PURE__ */ new Set(), this._triggerWhich = 0, this._triggerString = "", this._triggerTypedKey = "", this._isKeyboardLockSupported = false;
        const t = this.GetRuntime().Dispatcher();
        this._disposables = new s.CompositeDisposable(s.Disposable.From(t, "keydown", (e2) => this._OnKeyDown(e2.data)), s.Disposable.From(t, "keyup", (e2) => this._OnKeyUp(e2.data)), s.Disposable.From(t, "window-blur", () => this._OnWindowOrKeyboardBlur()), s.Disposable.From(t, "keyboard-blur", () => this._OnWindowOrKeyboardBlur())), this._runtime.AddLoadPromise(this._Init());
      }
      Release() {
        super.Release();
      }
      async _Init() {
        const e = await this.PostToDOMAsync("init");
        this._isKeyboardLockSupported = e["isKeyboardLockSupported"];
      }
      _OnKeyDown(e) {
        const r = e["which"], t = e["code"] || r.toString(), n2 = e["key"];
        this._keysDownByString.has(t) || (this._keysDownByString.add(t), this._keysDownByWhich.add(r), this._triggerString = t, this._triggerWhich = r, this._triggerTypedKey = n2, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(s.Plugins.Keyboard.Cnds.OnKey), this.Trigger(s.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCode));
      }
      _OnKeyUp(e) {
        const r = e["which"], t = e["code"] || r.toString(), n2 = e["key"];
        this._keysDownByString.delete(t), this._keysDownByWhich.delete(r), this._triggerString = t, this._triggerWhich = r, this._triggerTypedKey = n2, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
      }
      _OnWindowOrKeyboardBlur() {
        for (const e of this._keysDownByWhich) this._keysDownByWhich.delete(e), this._triggerWhich = e, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
        this._keysDownByString.clear();
      }
      IsKeyDown(e) {
        return this._keysDownByString.has(e);
      }
      IsKeyCodeDown(e) {
        return this._keysDownByWhich.has(e);
      }
      SaveToJson() {
        return { "tk": this._triggerWhich, "tkk": this._triggerTypedKey };
      }
      LoadFromJson(e) {
        this._triggerWhich = e["tk"], e.hasOwnProperty("tkk") && (this._triggerTypedKey = e["tkk"]);
      }
      GetDebuggerProperties() {
        const e = "plugins.keyboard";
        return [{ title: e + ".name", properties: [{ name: e + ".debugger.last-key-code", value: this._triggerWhich }, { name: e + ".debugger.last-key-string", value: s.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich) }, { name: e + ".debugger.last-typed-key", value: this._triggerTypedKey }] }];
      }
    };
  }
  {
    const i = self.C3, a = ["ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight", "MetaLeft", "MetaRight"];
    i.Plugins.Keyboard.Cnds = { IsKeyDown(e) {
      return this._keysDownByWhich.has(e);
    }, OnKey(e) {
      return this._triggerWhich === e;
    }, OnAnyKey: () => true, OnAnyKeyReleased: () => true, OnKeyReleased(e) {
      return this._triggerWhich === e;
    }, IsKeyCodeDown(e) {
      return e = Math.floor(e), this._keysDownByWhich.has(e);
    }, OnKeyCode(e) {
      return this._triggerWhich === e;
    }, OnKeyCodeReleased(e) {
      return this._triggerWhich === e;
    }, OnLeftRightKeyPressed(e) {
      const r = a[e];
      return this._triggerString === r;
    }, OnLeftRightKeyReleased(e) {
      const r = a[e];
      return this._triggerString === r;
    }, IsLeftRightKeyDown(e) {
      const r = a[e];
      return this._keysDownByString.has(r);
    }, IsKeyboardLockSupported() {
      return this._isKeyboardLockSupported;
    }, OnKeyboardLocked: () => true, OnKeyboardLockError: () => true };
  }
  {
    const o = self.C3;
    o.Plugins.Keyboard.Acts = { async LockKeyboard(e) {
      if (!this._isKeyboardLockSupported) return;
      let r = [];
      e && (r = e.split(","));
      (await this.PostToDOMAsync("lock-keyboard", { "keysArr": r }))["isOk"] ? this.Trigger(o.Plugins.Keyboard.Cnds.OnKeyboardLocked) : this.Trigger(o.Plugins.Keyboard.Cnds.OnKeyboardLockError);
    }, UnlockKeyboard() {
      this._isKeyboardLockSupported && this.PostToDOMAsync("unlock-keyboard");
    } };
  }
  {
    let StringFromCharCode = function(e) {
      switch (e = Math.floor(e)) {
        case 8:
          return "backspace";
        case 9:
          return "tab";
        case 13:
          return "enter";
        case 16:
          return "shift";
        case 17:
          return "control";
        case 18:
          return "alt";
        case 19:
          return "pause";
        case 20:
          return "capslock";
        case 27:
          return "esc";
        case 33:
          return "pageup";
        case 34:
          return "pagedown";
        case 35:
          return "end";
        case 36:
          return "home";
        case 37:
          return "\u2190";
        case 38:
          return "\u2191";
        case 39:
          return "\u2192";
        case 40:
          return "\u2193";
        case 45:
          return "insert";
        case 46:
          return "del";
        case 91:
          return "left window key";
        case 92:
          return "right window key";
        case 93:
          return "select";
        case 96:
          return "numpad 0";
        case 97:
          return "numpad 1";
        case 98:
          return "numpad 2";
        case 99:
          return "numpad 3";
        case 100:
          return "numpad 4";
        case 101:
          return "numpad 5";
        case 102:
          return "numpad 6";
        case 103:
          return "numpad 7";
        case 104:
          return "numpad 8";
        case 105:
          return "numpad 9";
        case 106:
          return "numpad *";
        case 107:
          return "numpad +";
        case 109:
          return "numpad -";
        case 110:
          return "numpad .";
        case 111:
          return "numpad /";
        case 112:
          return "F1";
        case 113:
          return "F2";
        case 114:
          return "F3";
        case 115:
          return "F4";
        case 116:
          return "F5";
        case 117:
          return "F6";
        case 118:
          return "F7";
        case 119:
          return "F8";
        case 120:
          return "F9";
        case 121:
          return "F10";
        case 122:
          return "F11";
        case 123:
          return "F12";
        case 144:
          return "numlock";
        case 145:
          return "scroll lock";
        case 186:
          return ";";
        case 187:
          return "=";
        case 188:
          return ",";
        case 189:
          return "-";
        case 190:
          return ".";
        case 191:
          return "/";
        case 192:
          return "'";
        case 219:
          return "[";
        case 220:
          return "\\";
        case 221:
          return "]";
        case 222:
          return "#";
        case 223:
          return "`";
        default:
          return String.fromCharCode(e);
      }
    };
    StringFromCharCode2 = StringFromCharCode;
    self.C3.Plugins.Keyboard.Exps = { LastKeyCode() {
      return this._triggerWhich;
    }, StringFromKeyCode: (e) => StringFromCharCode(e), TypedKey() {
      return this._triggerTypedKey;
    } };
  }
}
var GetKeyboardSdkInstance2;
var StringFromCharCode2;
{
  {
    const e = self.C3;
    e.Plugins.Text = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.Text.Type = class extends e.SDKTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      LoadTextures(e2) {
      }
      ReleaseTextures() {
      }
    };
  }
  {
    const e = self.C3, t = self.C3X, i = [0, 0, 0], r = 0, s = 1, n = 2, a = 3, o = 4, h = 5, _ = 6, l = 7, c = 8, d = 9, g = 10, u = 11, T = 12, S = 13, p = 15, x = ["left", "center", "right"], G = ["top", "center", "bottom"], m = ["ltr", "rtl"], f = ["word", "cjk", "character"], w = new e.Rect(), I = new e.Quad(), R = new e.Color(), y = e.New(e.Vector2), b = /* @__PURE__ */ new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["iconoffsety", null]]);
    e.Plugins.Text.Instance = class extends e.SDKWorldInstanceBase {
      constructor(t2, i2) {
        if (super(t2), this._text = "", this._enableBBcode = true, this._faceName = "Arial", this._ptSize = 12, this._lineHeightOffset = 0, this._isBold = false, this._isItalic = false, this._color = e.New(e.Color), this._horizontalAlign = 0, this._verticalAlign = 0, this._wrapMode = "word", this._textDirection = 0, this._resolutionMode = "auto", this._fixedScaleFactor = 1, this._iconObjectClass = null, this._htmlString = "", this._isHtmlStringUpToDate = false, this._readAloud = false, this._screenReaderText = null, this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText = e.New(e.Gfx.RendererText, this._runtime.GetRenderer(), { timeout: 5 }), this._rendererText.ontextureupdate = () => this._runtime.UpdateRender(), this._animationframeimagechange_handler = () => this._OnIconObjectClassImageChanged(), this._pendingUpdateIconSet = false, this._beforerender_handler = () => this._OnBeforeRender(), i2) {
          this._text = i2[r], this._enableBBcode = !!i2[s], this._faceName = i2[n], this._ptSize = i2[a], this._lineHeightOffset = i2[o], this._isBold = !!i2[h], this._isItalic = !!i2[_], this._horizontalAlign = i2[c], this._verticalAlign = i2[d], this._wrapMode = f[i2[g]], this._textDirection = i2[u], this._SetIconObjectClass(this._runtime.GetObjectClassBySID(i2[T]));
          const e2 = i2[l];
          this._color.setRgb(e2[0], e2[1], e2[2]), this.GetWorldInfo().SetVisible(i2[S]), this._readAloud = !!i2[p];
        }
        this._UpdateTextSettings(), this._UpdateScreenReaderText(), this._runtime.Dispatcher().addEventListener("beforerender", this._beforerender_handler);
      }
      Release() {
        this._runtime.Dispatcher().removeEventListener("beforerender", this._beforerender_handler), this._beforerender_handler = null, this._SetIconObjectClass(null), this._CancelTypewriter(), this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null), this._rendererText.Release(), this._rendererText = null, super.Release();
      }
      _UpdateTextSettings() {
        const e2 = this._rendererText;
        e2.SetText(this._text), e2.SetBBCodeEnabled(this._enableBBcode), this._rendererText.IsBBCodeEnabled() && this._iconObjectClass ? this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)) : this._rendererText.SetIconSet(null), e2.SetIconSmoothing("nearest" !== this._runtime.GetSampling()), e2.SetFontName(this._faceName), e2.SetLineHeight(this._lineHeightOffset), e2.SetBold(this._isBold), e2.SetItalic(this._isItalic), e2.SetColor(this._color), e2.SetHorizontalAlignment(x[this._horizontalAlign]), e2.SetVerticalAlignment(G[this._verticalAlign]), e2.SetWordWrapMode(this._wrapMode), e2.SetTextDirection(m[this._textDirection]);
      }
      _UpdateTextSize() {
        const e2 = this.GetWorldInfo();
        this._rendererText.SetText(this._text), this._rendererText.SetFontSize(this._ptSize), this._rendererText.SetFontSizeScale(e2.GetSceneGraphScale());
        const t2 = e2.GetLayer();
        let i2;
        "auto" === this._resolutionMode ? (i2 = t2.GetResolutionScaleFactorToZ(e2.GetTotalZElevation()), this._rendererText.SetMipMapEnabled(false)) : "fixed" === this._resolutionMode && (i2 = this._fixedScaleFactor, this._rendererText.SetMipMapEnabled(true)), e2.HasMesh() && i2 !== this._rendererText.GetZoom() && e2.SetMeshChanged(true), this._rendererText.SetSize(e2.GetWidth(), e2.GetHeight(), i2);
      }
      _SetIconObjectClass(t2) {
        t2 && (t2.IsFamily() || t2.GetPlugin().constructor !== e.Plugins.Sprite) || t2 !== this._iconObjectClass && (this._iconObjectClass && this._iconObjectClass.Dispatcher().removeEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._iconObjectClass = t2, this._iconObjectClass && this._iconObjectClass.Dispatcher().addEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._UpdateTextSettings(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());
      }
      _OnIconObjectClassImageChanged() {
        this._runtime.DeleteTextIconSet(this._iconObjectClass), this._runtime.UpdateRender(), this._pendingUpdateIconSet = true;
      }
      _UpdateScreenReaderText() {
        if (this._readAloud) {
          let t2 = this._text;
          this._enableBBcode && (t2 = e.BBString.StripAnyTags(t2)), this._screenReaderText ? this._screenReaderText.SetText(t2) : this._screenReaderText = e.New(e.ScreenReaderText, this._runtime, t2);
        } else this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null);
      }
      _OnBeforeRender() {
        const e2 = this.GetWorldInfo(), t2 = e2.GetLayer(), i2 = e2.GetLayout();
        e2.IsVisible() && e2.IsInViewport(t2.GetViewport(), i2.HasVanishingPointOutsideViewport(), i2.IsOrthographicProjection()) && (this._UpdateTextForDraw(), this._rendererText.GetTexture());
      }
      _UpdateTextForDraw() {
        this._UpdateTextSize(), this._pendingUpdateIconSet && (this._pendingUpdateIconSet = false, this._rendererText.IsBBCodeEnabled() && this._iconObjectClass && this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)));
      }
      Draw(e2) {
        const t2 = this._runtime.GetCanvasManager().IsPastingToDrawingCanvas();
        t2 && this._UpdateTextForDraw();
        const i2 = this._rendererText.GetTexture();
        if (!i2) return;
        const r2 = this.GetWorldInfo(), s2 = r2.GetLayer();
        if (0 !== r2.GetAngle() || 0 !== s2.GetAngle() || 0 !== r2.GetTotalZElevation() || r2.HasMesh() || !s2.RendersIn2DMode() || t2) e2.SetTexture(i2), r2.HasMesh() ? this._DrawMesh(r2, e2) : this._DrawStandard(r2, e2);
        else {
          const t3 = r2.GetBoundingQuad(), [n2, a2] = s2.LayerToDrawSurface(t3.getTlx(), t3.getTly()), [o2, h2] = s2.LayerToDrawSurface(t3.getBrx(), t3.getBry()), _2 = n2 - Math.round(n2), l2 = a2 - Math.round(a2);
          w.set(n2, a2, o2, h2), w.offset(-_2, -l2), I.setFromRect(w);
          const [c2, d2] = e2.GetRenderTargetSize(e2.GetRenderTarget());
          e2.IsWebGL() ? this._runtime.GetCanvasManager().SetDeviceTransform(e2, c2, d2) : (e2.SetNormalizedCoordsProgramVariant(true), I.divide(c2, d2)), e2.SetTexture(i2), e2.Quad3(I, this._rendererText.GetTexRect()), e2.IsWebGL() ? s2._SetTransform(e2) : e2.SetNormalizedCoordsProgramVariant(false);
        }
      }
      _DrawStandard(e2, t2) {
        let i2 = e2.GetBoundingQuad();
        this._runtime.IsPixelRoundingEnabled() && (i2 = this._PixelRoundQuad(i2)), t2.Quad3(i2, this._rendererText.GetTexRect());
      }
      _DrawMesh(e2, t2) {
        const i2 = e2.GetTransformedMesh();
        if (e2.IsMeshChanged()) {
          e2.CalculateBbox(w, I, false);
          let t3 = I;
          this._runtime.IsPixelRoundingEnabled() && (t3 = this._PixelRoundQuad(t3)), i2.CalculateTransformedMesh(e2.GetSourceMesh(), t3, this._rendererText.GetTexRect()), e2.SetMeshChanged(false);
        }
        i2.Draw(t2, e2.GetTotalZElevation());
      }
      _PixelRoundQuad(e2) {
        const t2 = e2.getTlx() - Math.round(e2.getTlx()), i2 = e2.getTly() - Math.round(e2.getTly());
        return 0 === t2 && 0 === i2 ? e2 : (I.copy(e2), I.offset(-t2, -i2), I);
      }
      GetCurrentSurfaceSize() {
        const e2 = this._rendererText.GetTexture();
        return e2 ? [e2.GetWidth(), e2.GetHeight()] : [100, 100];
      }
      GetCurrentTexRect() {
        return this._rendererText.GetTexRect();
      }
      IsCurrentTexRotated() {
        return false;
      }
      SaveToJson() {
        const e2 = { "t": this._text, "c": this._color.toJSON(), "fn": this._faceName, "ps": this._ptSize };
        return this._enableBBcode && (e2["bbc"] = this._enableBBcode), 0 !== this._horizontalAlign && (e2["ha"] = this._horizontalAlign), 0 !== this._verticalAlign && (e2["va"] = this._verticalAlign), "word" !== this._wrapMode && (e2["wr"] = this._wrapMode), 0 !== this._lineHeightOffset && (e2["lho"] = this._lineHeightOffset), this._isBold && (e2["b"] = this._isBold), this._isItalic && (e2["i"] = this._isItalic), -1 !== this._typewriterEndTime && (e2["tw"] = { "st": this._typewriterStartTime, "en": this._typewriterEndTime, "l": this._typewriterLength }), this._iconObjectClass && (e2["ioc"] = this._iconObjectClass.GetSID()), "fixed" === this._resolutionMode && (e2["fs"] = this._fixedScaleFactor), e2;
      }
      LoadFromJson(e2) {
        if (this._CancelTypewriter(), this._text = e2["t"], this._color.setFromJSON(e2["c"]), this._faceName = e2["fn"], this._ptSize = e2["ps"], this._enableBBcode = !!e2.hasOwnProperty("bbc") && e2["bbc"], this._horizontalAlign = e2.hasOwnProperty("ha") ? e2["ha"] : 0, this._verticalAlign = e2.hasOwnProperty("va") ? e2["va"] : 0, e2.hasOwnProperty("wr")) {
          const t2 = e2["wr"];
          this._wrapMode = "boolean" == typeof t2 ? t2 ? "word" : "character" : t2;
        } else this._wrapMode = "word";
        if (this._lineHeightOffset = e2.hasOwnProperty("lho") ? e2["lho"] : 0, this._isBold = !!e2.hasOwnProperty("b") && e2["b"], this._isItalic = !!e2.hasOwnProperty("i") && e2["i"], e2.hasOwnProperty("tw")) {
          const t2 = e2["tw"];
          this._typewriterStartTime = t2["st"], this._typewriterEndTime = t2["en"], this._typewriterLength = t2["l"];
        }
        if (e2.hasOwnProperty("ioc")) {
          const t2 = this.GetRuntime().GetObjectClassBySID(e2["ioc"]);
          t2 && this._SetIconObjectClass(t2);
        } else this._SetIconObjectClass(null);
        e2.hasOwnProperty("fs") ? (this._resolutionMode = "fixed", this._fixedScaleFactor = e2["fs"]) : this._resolutionMode = "auto", this._UpdateTextSettings(), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, -1 !== this._typewriterEndTime && this._StartTicking();
      }
      GetPropertyValueByIndex(e2) {
        switch (e2) {
          case r:
            return this.GetText();
          case s:
            return this._enableBBcode;
          case n:
            return this._GetFontFace();
          case a:
            return this._GetFontSize();
          case o:
            return this._GetLineHeight();
          case h:
            return this._IsBold();
          case _:
            return this._IsItalic();
          case l:
            return i[0] = this._color.getR(), i[1] = this._color.getG(), i[2] = this._color.getB(), i;
          case c:
            return this._GetHAlign();
          case d:
            return this._GetVAlign();
          case g:
            return this._GetWrapMode();
          case p:
            return this._IsReadAloud();
        }
      }
      SetPropertyValueByIndex(e2, t2) {
        switch (e2) {
          case r:
            this._SetText(t2);
            break;
          case s:
            if (this._enableBBcode === !!t2) return;
            this._enableBBcode = !!t2, this._UpdateTextSettings();
            break;
          case n:
            this._SetFontFace(t2);
            break;
          case a:
            this._SetFontSize(t2);
            break;
          case o:
            this._SetLineHeight(t2);
            break;
          case h:
            this._SetBold(t2);
            break;
          case _:
            this._SetItalic(t2);
            break;
          case l:
            const e3 = this._color, i2 = t2;
            if (e3.getR() === i2[0] && e3.getG() === i2[1] && e3.getB() === i2[2]) return;
            this._color.setRgb(i2[0], i2[1], i2[2]), this._UpdateTextSettings();
            break;
          case c:
            this._SetHAlign(t2);
            break;
          case d:
            this._SetVAlign(t2);
            break;
          case g:
            this._SetWrapMode(t2);
        }
      }
      SetPropertyColorOffsetValueByIndex(e2, t2, i2, r2) {
        if ((0 !== t2 || 0 !== i2 || 0 !== r2) && e2 === l) this._color.addRgb(t2, i2, r2), this._UpdateTextSettings();
      }
      _SetText(e2) {
        this._text !== e2 && (this._text = e2, this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());
      }
      GetText() {
        return this._text;
      }
      _StartTypewriter(e2, t2) {
        this._SetText(e2), this._UpdateTextSize(), this._typewriterStartTime = this._runtime.GetWallTime(), this._typewriterEndTime = this._typewriterStartTime + t2 / this.GetInstance().GetActiveTimeScale(), this._typewriterLength = this._rendererText.GetLengthInGraphemes(), this._rendererText.SetDrawMaxCharacterCount(0), this._StartTicking();
      }
      _CancelTypewriter() {
        this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText.SetDrawMaxCharacterCount(-1), this._StopTicking();
      }
      _FinishTypewriter() {
        -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender());
      }
      _SetFontFace(e2) {
        this._faceName !== e2 && (this._faceName = e2, this._rendererText.SetFontName(e2), this._runtime.UpdateRender());
      }
      _GetFontFace() {
        return this._faceName;
      }
      _SetBold(e2) {
        e2 = !!e2, this._isBold !== e2 && (this._isBold = e2, this._rendererText.SetBold(e2), this._runtime.UpdateRender());
      }
      _IsBold() {
        return this._isBold;
      }
      _SetItalic(e2) {
        e2 = !!e2, this._isItalic !== e2 && (this._isItalic = e2, this._rendererText.SetItalic(e2), this._runtime.UpdateRender());
      }
      _IsItalic() {
        return this._isItalic;
      }
      _SetFontSize(e2) {
        this._ptSize !== e2 && (this._ptSize = e2, this._runtime.UpdateRender());
      }
      _GetFontSize() {
        return this._ptSize;
      }
      _SetFontColor(e2) {
        this._color.equalsIgnoringAlpha(e2) || (this._color.copyRgb(e2), this._rendererText.SetColor(this._color), this._runtime.UpdateRender());
      }
      _GetFontColor() {
        return this._color;
      }
      _SetLineHeight(e2) {
        this._lineHeightOffset !== e2 && (this._lineHeightOffset = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetLineHeight() {
        return this._lineHeightOffset;
      }
      _SetHAlign(e2) {
        this._horizontalAlign !== e2 && (this._horizontalAlign = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetHAlign() {
        return this._horizontalAlign;
      }
      _SetVAlign(e2) {
        this._verticalAlign !== e2 && (this._verticalAlign = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetVAlign() {
        return this._verticalAlign;
      }
      _SetWrapModeByIndex(e2) {
        this._SetWrapMode(f[e2]);
      }
      _SetWrapMode(e2) {
        this._wrapMode !== e2 && (this._wrapMode = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetWrapMode() {
        return this._wrapMode;
      }
      _SetTextDirection(e2) {
        this._textDirection !== e2 && (this._textDirection = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetTextDirection() {
        return this._textDirection;
      }
      _SetReadAloud(e2) {
        this._readAloud = !!e2, this._UpdateScreenReaderText();
      }
      _IsReadAloud() {
        return this._readAloud;
      }
      _SetResolutionMode(e2) {
        this._resolutionMode !== e2 && (this._resolutionMode = e2, this._runtime.UpdateRender());
      }
      _GetResolutionMode() {
        return this._resolutionMode;
      }
      _SetFixedScaleFactor(e2) {
        this._fixedScaleFactor !== e2 && (this._fixedScaleFactor = e2, "fixed" === this._resolutionMode && this._runtime.UpdateRender());
      }
      _GetFixedScaleFactor() {
        return this._fixedScaleFactor;
      }
      _GetTextWidth() {
        return this._UpdateTextSize(), this._rendererText.GetTextWidth();
      }
      _GetTextHeight() {
        return this._UpdateTextSize(), this._rendererText.GetTextHeight();
      }
      _GetTagAtPosition(e2, t2) {
        this._UpdateTextSize();
        const i2 = this.GetWorldInfo();
        y.set(e2 - i2.GetX(), t2 - i2.GetY()), y.rotate(-i2.GetAngle()), y.offset(i2.GetWidth() * i2.GetOriginX(), i2.GetHeight() * i2.GetOriginY()), y.divide(i2.GetWidth(), i2.GetHeight()), y.scale(this._rendererText.GetWidth(), this._rendererText.GetHeight());
        const r2 = this._rendererText.HitTestFragment(y.getX(), y.getY());
        if (r2) {
          const e3 = r2.GetStyleTag("tag");
          if (e3) return e3.param;
        }
        return "";
      }
      _HasTagAtPosition(t2, i2, r2) {
        const s2 = this._GetTagAtPosition(i2, r2);
        return s2 && e.equalsNoCase(t2, s2);
      }
      _GetTagPosition(e2, t2) {
        this._UpdateTextSize(), t2 = Math.floor(t2);
        const i2 = this._rendererText.FindFragmentWithTag(e2, t2);
        if (!i2) return null;
        const r2 = this.GetWorldInfo(), s2 = this._rendererText.GetDrawScale(), n2 = i2.GetPosX(), a2 = i2.GetPosY() - (i2.GetHeight() - i2.GetFontBoundingBoxDescent()) * s2, o2 = i2.GetWidth() * s2 / this._rendererText.GetWidth() * r2.GetWidth(), h2 = i2.GetHeight() * s2 / this._rendererText.GetHeight() * r2.GetHeight();
        return y.set(n2, a2), y.divide(this._rendererText.GetWidth(), this._rendererText.GetHeight()), y.scale(r2.GetWidth(), r2.GetHeight()), y.offset(-r2.GetWidth() * r2.GetOriginX(), -r2.GetHeight() * r2.GetOriginY()), y.rotate(r2.GetAngle()), y.offset(r2.GetX(), r2.GetY()), { x: y.getX(), y: y.getY(), width: o2, height: h2 };
      }
      _GetTagCount(e2) {
        return this._UpdateTextSize(), this._rendererText.CountFragmentsWithTag(e2);
      }
      _GetHTMLCloseTag(e2) {
        let t2 = b.get(e2);
        return null === t2 ? "" : (t2 || (t2 = "span"), `</${t2 || "span"}>`);
      }
      _GetHTMLOpenTag(e2, t2) {
        let i2 = b.get(e2);
        if (null === i2) return "";
        switch (i2 || (i2 = "span"), e2) {
          case "color":
            return `<${i2} style="color: ${t2}">`;
          case "font":
            return `<${i2} style="font-family: '${t2}'">`;
          case "opacity":
            return `<${i2} style="opacity: ${t2}%">`;
          case "size":
            return `<${i2} style="font-size: ${t2}pt">`;
          case "background":
            return `<${i2} style="background-color: ${t2}">`;
          case "hide":
            return `<${i2} style="visibility: hidden">`;
          case "class":
            return `<${i2} class="${t2}">`;
          case "tag":
            return `<${i2} data-tag="${t2}">`;
          default:
            return `<${i2}>`;
        }
      }
      async _UpdateHTMLString() {
        if (this._isHtmlStringUpToDate) return this._htmlString;
        const t2 = new e.BBString(this._text, { noEscape: true }).toFragmentList(), i2 = /* @__PURE__ */ new Map();
        let r2 = '<span class="c3-text"';
        const s2 = [];
        s2.push(`font-family: '${this._GetFontFace()}';`), this._IsBold() && s2.push("font-weight: bold;"), this._IsItalic() && s2.push("font-style: italic;"), "character" === this._GetWrapMode() && s2.push("word-break: break-all;"), r2 += ` style="${s2.join(" ")}">`;
        const n2 = this._iconObjectClass ? this.GetRuntime().GetTextIconSet(this._iconObjectClass) : null;
        if (this._iconObjectClass) {
          const r3 = e.New(e.PromiseThrottle), s3 = [], a3 = /* @__PURE__ */ new Map();
          for (const e2 of t2) if (e2.IsIcon()) {
            const t3 = e2.GetTextIcon(n2);
            if (t3) {
              const e3 = t3.GetSource().GetImageInfo().GetImageAsset();
              if (a3.has(e3)) continue;
              a3.set(e3, null), s3.push(r3.Add(async () => {
                const t4 = await e3.LoadToDrawable();
                a3.set(e3, t4);
              }));
            }
          }
          await Promise.all(s3);
          const o3 = [];
          for (const e2 of t2) if (e2.IsIcon()) {
            const t3 = e2.GetTextIcon(n2);
            if (t3) {
              const e3 = t3.GetSource(), s4 = e3.GetImageInfo().GetImageAsset();
              o3.push(r3.Add(async () => {
                const r4 = await e3.GetImageInfo().ExtractImageToBlobURL(a3.get(s4));
                i2.set(t3, r4);
              }));
            }
          }
          await Promise.all(o3);
          for (const e2 of a3.values()) e2 instanceof ImageBitmap && e2["close"] && e2["close"]();
        }
        const a2 = /* @__PURE__ */ new Map();
        for (const s3 of t2) {
          const t3 = s3.GetStyleMap();
          let o3 = [...a2.keys()];
          o3.reverse();
          for (const e2 of o3) t3.has(e2) && t3.get(e2) === a2.get(e2) || (a2.delete(e2), r2 += this._GetHTMLCloseTag(e2));
          for (const [e2, i3] of t3) a2.has(e2) || (a2.set(e2, i3), r2 += this._GetHTMLOpenTag(e2, i3));
          if (s3.IsText() && (r2 += e.ReplaceAll(e.EscapeHTML(s3.GetCharacterArray().join("")), "\n", "<br>")), s3.IsIcon() && n2) {
            const e2 = s3.GetTextIcon(n2);
            if (e2) {
              const n3 = i2.get(e2);
              if (n3) {
                const i3 = [];
                let a3 = "0.2em";
                const o4 = t3.get("iconoffsety");
                if (o4) {
                  let e3 = o4.trim();
                  a3 = e3.endsWith("%") ? parseFloat(e3) / 100 + "em" : e3 + "px";
                }
                i3.push(`top: ${a3}`), "nearest" === this._runtime.GetSampling() && i3.push("image-rendering: pixelated"), r2 += `<img class="c3-text-icon" data-icon="${s3.GetIconParameter()}" width="${e2.GetWidth()}" height="${e2.GetHeight()}" style="${i3.join(";")}" src="${n3}">`;
              }
            }
          }
        }
        const o2 = [...a2.keys()];
        o2.reverse();
        for (const e2 of o2) r2 += this._GetHTMLCloseTag(e2);
        return r2 += "</span>", this._htmlString = r2, this._isHtmlStringUpToDate = true, this._htmlString;
      }
      Tick() {
        const t2 = this._runtime.GetWallTime();
        if (t2 >= this._typewriterEndTime) this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender();
        else {
          let i2 = e.relerp(this._typewriterStartTime, this._typewriterEndTime, t2, 0, this._typewriterLength);
          i2 = Math.floor(i2), i2 !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(i2), this._runtime.UpdateRender());
        }
      }
      GetDebuggerProperties() {
        const e2 = "plugins.text";
        return [{ title: e2 + ".name", properties: [{ name: e2 + ".properties.text.name", value: this.GetText(), onedit: (e3) => this._SetText(e3) }, { name: e2 + ".properties.font.name", value: this._GetFontFace(), onedit: (e3) => this._SetFontFace(e3) }, { name: e2 + ".properties.size.name", value: this._GetFontSize(), onedit: (e3) => this._SetFontSize(e3) }, { name: e2 + ".properties.line-height.name", value: this._GetLineHeight(), onedit: (e3) => this._SetLineHeight(e3) }, { name: e2 + ".properties.bold.name", value: this._IsBold(), onedit: (e3) => this._SetBold(e3) }, { name: e2 + ".properties.italic.name", value: this._IsItalic(), onedit: (e3) => this._SetItalic(e3) }, { name: e2 + ".debugger.text-width", value: this._GetTextWidth() }, { name: e2 + ".debugger.text-height", value: this._GetTextHeight() }] }];
      }
      GetScriptInterfaceClass() {
        return self.ITextInstance;
      }
    };
    const C = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new Map([["left", 0], ["center", 1], ["right", 2]]), M = /* @__PURE__ */ new Map([["top", 0], ["center", 1], ["bottom", 2]]), A = ["ltr", "rtl"];
    /* @__PURE__ */ new Set(["auto", "fixed"]);
    self.ITextInstance = class extends self.IWorldInstance {
      constructor() {
        super(), C.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      get text() {
        return C.get(this).GetText();
      }
      set text(e2) {
        t.RequireString(e2);
        const i2 = C.get(this);
        i2._CancelTypewriter(), i2._SetText(e2);
      }
      typewriterText(e2, i2) {
        t.RequireString(e2), t.RequireFiniteNumber(i2);
        const r2 = C.get(this);
        r2._CancelTypewriter(), r2._StartTypewriter(e2, i2);
      }
      typewriterFinish() {
        C.get(this)._FinishTypewriter();
      }
      set fontFace(e2) {
        t.RequireString(e2), C.get(this)._SetFontFace(e2);
      }
      get fontFace() {
        return C.get(this)._GetFontFace();
      }
      set isBold(e2) {
        C.get(this)._SetBold(e2);
      }
      get isBold() {
        return C.get(this)._IsBold();
      }
      set isItalic(e2) {
        C.get(this)._SetItalic(e2);
      }
      get isItalic() {
        return C.get(this)._IsItalic();
      }
      set sizePt(e2) {
        t.RequireFiniteNumber(e2), C.get(this)._SetFontSize(e2);
      }
      get sizePt() {
        return C.get(this)._GetFontSize();
      }
      set fontColor(e2) {
        if (t.RequireArray(e2), e2.length < 3) throw new Error("expected 3 elements");
        R.setRgb(e2[0], e2[1], e2[2]), C.get(this)._SetFontColor(R);
      }
      get fontColor() {
        const e2 = C.get(this)._GetFontColor();
        return [e2.getR(), e2.getG(), e2.getB()];
      }
      set lineHeight(e2) {
        t.RequireFiniteNumber(e2), C.get(this)._SetLineHeight(e2);
      }
      get lineHeight() {
        return C.get(this)._GetLineHeight();
      }
      set horizontalAlign(e2) {
        t.RequireString(e2);
        const i2 = F.get(e2);
        if (void 0 === i2) throw new Error("invalid mode");
        C.get(this)._SetHAlign(i2);
      }
      get horizontalAlign() {
        return x[C.get(this)._GetHAlign()];
      }
      set verticalAlign(e2) {
        t.RequireString(e2);
        const i2 = M.get(e2);
        if (void 0 === i2) throw new Error("invalid mode");
        C.get(this)._SetVAlign(i2);
      }
      get verticalAlign() {
        return G[C.get(this)._GetVAlign()];
      }
      set wordWrapMode(e2) {
        if (!f.includes(e2)) throw new Error("invalid mode");
        C.get(this)._SetWrapMode(e2);
      }
      get wordWrapMode() {
        return C.get(this)._GetWrapMode();
      }
      set textDirection(e2) {
        t.RequireString(e2);
        const i2 = A.indexOf(e2);
        if (-1 === i2) throw new Error("invalid text direction");
        C.get(this)._SetTextDirection(i2);
      }
      get textDirection() {
        return A[C.get(this)._GetTextDirection()];
      }
      set readAloud(e2) {
        C.get(this)._SetReadAloud(!!e2);
      }
      get readAloud() {
        return C.get(this)._IsReadAloud();
      }
      setFixedResolutionMode(e2) {
        t.RequireFiniteNumber(e2);
        const i2 = C.get(this);
        i2._SetResolutionMode("fixed"), i2._SetFixedScaleFactor(e2);
      }
      setAutoResolutionMode() {
        C.get(this)._SetResolutionMode("auto");
      }
      get textWidth() {
        return C.get(this)._GetTextWidth();
      }
      get textHeight() {
        return C.get(this)._GetTextHeight();
      }
      getTextSize() {
        const e2 = C.get(this);
        return [e2._GetTextWidth(), e2._GetTextHeight()];
      }
      hasTagAtPosition(e2, i2, r2) {
        return t.RequireString(e2), t.RequireFiniteNumber(i2), t.RequireFiniteNumber(r2), C.get(this)._HasTagAtPosition(e2, i2, r2);
      }
      getTagAtPosition(e2, i2) {
        return t.RequireFiniteNumber(e2), t.RequireFiniteNumber(i2), C.get(this)._GetTagAtPosition(e2, i2);
      }
      getTagPositionAndSize(e2, i2 = 0) {
        return t.RequireString(e2), t.RequireFiniteNumber(i2), C.get(this)._GetTagPosition(e2, i2);
      }
      getTagCount(e2) {
        return t.RequireString(e2), C.get(this)._GetTagCount(e2);
      }
      changeIconSet(e2) {
        const t2 = C.get(this), i2 = t2.GetRuntime()._UnwrapIObjectClass(e2);
        t2._SetIconObjectClass(i2);
      }
      getAsHtmlString() {
        return C.get(this)._UpdateHTMLString();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.Text.Cnds = { CompareText(t, i) {
      return i ? this._text === t : e.equalsNoCase(this._text, t);
    }, IsRunningTypewriterText() {
      return -1 !== this._typewriterEndTime;
    }, OnTypewriterTextFinished: () => true, HasTagAtPosition(e2, t, i) {
      return this._HasTagAtPosition(e2, t, i);
    } };
  }
  {
    const e = self.C3, t = e.New(e.Color);
    e.Plugins.Text.Acts = { SetText(e2) {
      this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), this._SetText(e2.toString());
    }, AppendText(e2) {
      this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), (e2 = e2.toString()) && this._SetText(this._text + e2);
    }, TypewriterText(e2, t2) {
      this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), this._StartTypewriter(e2.toString(), t2);
    }, SetFontFace(e2, t2) {
      let i = false, r = false;
      switch (t2) {
        case 1:
          i = true;
          break;
        case 2:
          r = true;
          break;
        case 3:
          i = true, r = true;
      }
      e2 === this._faceName && i === this._isBold && r === this._isItalic || (this._SetFontFace(e2), this._SetBold(i), this._SetItalic(r));
    }, SetFontSize(e2) {
      this._SetFontSize(e2);
    }, SetFontColor(e2) {
      t.setFromRgbValue(e2), t.clamp(), this._SetFontColor(t);
    }, SetWebFont(e2, t2) {
      console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect");
    }, SetEffect(e2) {
      this.GetWorldInfo().SetBlendMode(e2), this._runtime.UpdateRender();
    }, TypewriterFinish() {
      this._FinishTypewriter();
    }, SetLineHeight(e2) {
      this._SetLineHeight(e2);
    }, SetHAlign(e2) {
      this._SetHAlign(e2);
    }, SetVAlign(e2) {
      this._SetVAlign(e2);
    }, SetWrapping(e2) {
      this._SetWrapModeByIndex(e2);
    }, SetTextDirection(e2) {
      this._SetTextDirection(e2);
    }, ChangeIconSet(e2) {
      this._SetIconObjectClass(e2);
    }, UpdateHTML() {
      return this._UpdateHTMLString();
    }, SetReadAloud(e2) {
      this._SetReadAloud(e2);
    }, SetResolutionMode(e2, t2) {
      this._SetResolutionMode(["auto", "fixed"][e2]), this._SetFixedScaleFactor(t2);
    } };
  }
  {
    const e = self.C3;
    e.Plugins.Text.Exps = { Text() {
      return this._text;
    }, PlainText() {
      return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text;
    }, FaceName() {
      return this._faceName;
    }, FaceSize() {
      return this._ptSize;
    }, TextWidth() {
      return this._GetTextWidth();
    }, TextHeight() {
      return this._GetTextHeight();
    }, LineHeight() {
      return this._lineHeightOffset;
    }, TagAtPosition(e2, t) {
      return this._GetTagAtPosition(e2, t);
    }, TagCount(e2) {
      return this._GetTagCount(e2);
    }, TagX(e2, t) {
      const i = this._GetTagPosition(e2, t);
      return i ? i.x : 0;
    }, TagY(e2, t) {
      const i = this._GetTagPosition(e2, t);
      return i ? i.y : 0;
    }, TagWidth(e2, t) {
      const i = this._GetTagPosition(e2, t);
      return i ? i.width : 0;
    }, TagHeight(e2, t) {
      const i = this._GetTagPosition(e2, t);
      return i ? i.height : 0;
    }, AsHTML() {
      return this._htmlString;
    } };
  }
}
{
  {
    const e = self.C3;
    e.Plugins.Mouse = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    let GetMouseSdkInstance = function() {
      return n.GetSingleGlobalInstance().GetSdkInstance();
    };
    GetMouseSdkInstance2 = GetMouseSdkInstance;
    const t = self.C3, s = self.C3X;
    t.Plugins.Mouse.Type = class extends t.SDKTypeBase {
      constructor(e) {
        super(e);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      GetScriptInterfaceClass() {
        return self.IMouseObjectType;
      }
    };
    let n = null;
    self.IMouseObjectType = class extends self.IObjectType {
      constructor(e) {
        super(e), n = e, e.GetRuntime()._GetCommonScriptInterfaces().mouse = this;
      }
      getMouseX(e) {
        return GetMouseSdkInstance().GetMousePositionForLayer(e)[0];
      }
      getMouseY(e) {
        return GetMouseSdkInstance().GetMousePositionForLayer(e)[1];
      }
      getMousePosition(e) {
        return GetMouseSdkInstance().GetMousePositionForLayer(e);
      }
      isMouseButtonDown(e) {
        return GetMouseSdkInstance().IsMouseButtonDown(e);
      }
      setCursorStyle(e) {
        s.RequireString(e), GetMouseSdkInstance().SetCursorStyle(e);
      }
      setCursorObjectClass(e) {
        const t2 = GetMouseSdkInstance(), s2 = t2.GetRuntime()._UnwrapIObjectClass(e);
        t2.SetCursorObjectClass(s2);
      }
    };
  }
  {
    const o = self.C3, i = "mouse";
    let r = null;
    o.Plugins.Mouse.Instance = class extends o.SDKInstanceBase {
      constructor(e, t) {
        super(e, i), this._buttonMap = [false, false, false, false, false], this._mouseXcanvas = 0, this._mouseYcanvas = 0, this._triggerButton = 0, this._triggerType = 0, this._triggerDir = 0, this._wheelDeltaX = 0, this._wheelDeltaY = 0, this._wheelDeltaZ = 0, this._hasPointerLock = false, this._movementX = 0, this._movementY = 0, this.AddDOMMessageHandlers([["pointer-lock-change", (e2) => this._OnPointerLockChange(e2)], ["pointer-lock-error", (e2) => this._OnPointerLockError(e2)]]);
        const s = this.GetRuntime().Dispatcher();
        this._disposables = new o.CompositeDisposable(o.Disposable.From(s, "pointermove", (e2) => this._OnPointerMove(e2.data)), o.Disposable.From(s, "pointerdown", (e2) => this._OnPointerDown(e2.data)), o.Disposable.From(s, "pointerup", (e2) => this._OnPointerUp(e2.data)), o.Disposable.From(s, "dblclick", (e2) => this._OnDoubleClick(e2.data)), o.Disposable.From(s, "wheel", (e2) => this._OnMouseWheel(e2.data)), o.Disposable.From(s, "window-blur", () => this._OnWindowBlur()));
      }
      Release() {
        super.Release();
      }
      _OnPointerDown(e) {
        "mouse" === e["pointerType"] && (this._mouseXcanvas = e["pageX"] - this._runtime.GetCanvasClientX(), this._mouseYcanvas = e["pageY"] - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(e["lastButtons"], e["buttons"]));
      }
      _OnPointerMove(e) {
        this._movementX = e["movementX"], this._movementY = e["movementY"], this.Trigger(o.Plugins.Mouse.Cnds.OnMovement), this._movementX = 0, this._movementY = 0, "mouse" === e["pointerType"] && (this._mouseXcanvas = e["pageX"] - this._runtime.GetCanvasClientX(), this._mouseYcanvas = e["pageY"] - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(e["lastButtons"], e["buttons"]));
      }
      _OnPointerUp(e) {
        "mouse" === e["pointerType"] && this._CheckButtonChanges(e["lastButtons"], e["buttons"]);
      }
      _CheckButtonChanges(e, t) {
        this._CheckButtonChange(e, t, 1, 0), this._CheckButtonChange(e, t, 4, 1), this._CheckButtonChange(e, t, 2, 2), this._CheckButtonChange(e, t, 8, 3), this._CheckButtonChange(e, t, 16, 4);
      }
      _CheckButtonChange(e, t, s, n) {
        !(e & s) && t & s ? this._OnMouseDown(n) : e & s && !(t & s) && this._OnMouseUp(n);
      }
      _OnMouseDown(e) {
        this._buttonMap[e] = true, this.Trigger(o.Plugins.Mouse.Cnds.OnAnyClick), this._triggerButton = e, this._triggerType = 0, this.Trigger(o.Plugins.Mouse.Cnds.OnClick), this.Trigger(o.Plugins.Mouse.Cnds.OnObjectClicked);
      }
      _OnMouseUp(e) {
        this._buttonMap[e] && (this._buttonMap[e] = false, this._triggerButton = e, this.Trigger(o.Plugins.Mouse.Cnds.OnRelease));
      }
      _OnDoubleClick(e) {
        this._triggerButton = e["button"], this._triggerType = 1, this.Trigger(o.Plugins.Mouse.Cnds.OnClick), this.Trigger(o.Plugins.Mouse.Cnds.OnObjectClicked);
      }
      _OnMouseWheel(e) {
        this._triggerDir = e["deltaY"] < 0 ? 1 : 0, this._wheelDeltaX = e["deltaX"], this._wheelDeltaY = e["deltaY"], this._wheelDeltaZ = e["deltaZ"], this.Trigger(o.Plugins.Mouse.Cnds.OnWheel);
      }
      _OnWindowBlur() {
        for (let e = 0, t = this._buttonMap.length; e < t; ++e) {
          if (!this._buttonMap[e]) return;
          this._buttonMap[e] = false, this._triggerButton = e, this.Trigger(o.Plugins.Mouse.Cnds.OnRelease);
        }
      }
      GetMousePositionForLayer(e) {
        const t = this._runtime.GetMainRunningLayout(), s = this._mouseXcanvas, n = this._mouseYcanvas;
        if (void 0 === e) {
          return t.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(s, n);
        }
        {
          const o2 = t.GetLayer(e);
          return o2 ? o2.CanvasCssToLayer(s, n) : [0, 0];
        }
      }
      IsMouseButtonDown(e) {
        return e = Math.floor(e), !!this._buttonMap[e];
      }
      _IsMouseOverCanvas() {
        return this._mouseXcanvas >= 0 && this._mouseYcanvas >= 0 && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight();
      }
      SetCursorStyle(e) {
        r !== e && (r = e, this.PostToDOM("cursor", e));
      }
      async SetCursorObjectClass(e) {
        if (o.Platform.IsMobile || !e) return;
        const t = e.GetFirstPicked();
        if (!t) return;
        const s = t.GetWorldInfo(), n = t.GetCurrentImageInfo();
        if (!s || !n) return;
        if (r === n) return;
        r = n;
        const i2 = `url(${await n.ExtractImageToBlobURL()}) ${Math.round(s.GetOriginX() * n.GetWidth())} ${Math.round(s.GetOriginY() * n.GetHeight())}, auto`;
        this.PostToDOM("cursor", i2);
      }
      _OnPointerLockChange(e) {
        this._UpdatePointerLockState(e["has-pointer-lock"]);
      }
      _OnPointerLockError(e) {
        this._UpdatePointerLockState(e["has-pointer-lock"]), this.Trigger(o.Plugins.Mouse.Cnds.OnPointerLockError);
      }
      _UpdatePointerLockState(e) {
        this._hasPointerLock !== e && (this._hasPointerLock = e, this._hasPointerLock ? this.Trigger(o.Plugins.Mouse.Cnds.OnPointerLocked) : this.Trigger(o.Plugins.Mouse.Cnds.OnPointerUnlocked));
      }
      GetDebuggerProperties() {
        const e = "plugins.mouse";
        return [{ title: e + ".name", properties: [{ name: e + ".debugger.absolute-position", value: this._mouseXcanvas + "," + this._mouseYcanvas }, { name: e + ".debugger.left-button", value: this._buttonMap[0] }, { name: e + ".debugger.middle-button", value: this._buttonMap[1] }, { name: e + ".debugger.right-button", value: this._buttonMap[2] }, { name: e + ".debugger.button-4", value: this._buttonMap[3] }, { name: e + ".debugger.button-5", value: this._buttonMap[4] }] }, { title: e + ".debugger.position-on-each-layer", properties: this._runtime.GetMainRunningLayout().GetLayers().map((e2) => ({ name: "$" + e2.GetName(), value: e2.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(", ") })) }];
      }
    };
  }
  {
    const u = self.C3;
    u.Plugins.Mouse.Cnds = { OnClick(e, t) {
      return this._triggerButton === e && this._triggerType === t;
    }, OnAnyClick: () => true, IsButtonDown(e) {
      return this._buttonMap[e];
    }, OnRelease(e) {
      return this._triggerButton === e;
    }, IsOverObject(e) {
      const t = this._runtime.GetCurrentCondition().IsInverted(), s = [];
      return this._IsMouseOverCanvas() && s.push([this._mouseXcanvas, this._mouseYcanvas]), u.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, s, t), t);
    }, OnObjectClicked(e, t, s) {
      if (e !== this._triggerButton || t !== this._triggerType) return false;
      if (!this._IsMouseOverCanvas()) return false;
      const n = this._mouseXcanvas, o = this._mouseYcanvas;
      return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(s, [[n, o]], false);
    }, OnWheel(e) {
      return 2 === e || this._triggerDir === e;
    }, OnPointerLocked: () => true, OnPointerUnlocked: () => true, OnPointerLockError: () => true, HasPointerLock() {
      return this._hasPointerLock;
    }, OnMovement: () => true };
  }
  {
    const a = self.C3, h = ["auto", "pointer", "text", "crosshair", "move", "help", "wait", "none"], l = ["auto", "all-scroll", "none", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "not-allowed", "grab", "grabbing", "col-resize", "row-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"];
    a.Plugins.Mouse.Acts = { SetCursor(e) {
      this.SetCursorStyle(h[e]);
    }, SetCursor2(e) {
      this.SetCursorStyle(l[e]);
    }, SetCursorSprite(e) {
      this.SetCursorObjectClass(e);
    }, RequestPointerLock(e) {
      this._PostToDOMMaybeSync("request-pointer-lock", { "unadjustedMovement": e });
    }, ReleasePointerLock() {
      this.PostToDOM("release-pointer-lock");
    } };
  }
  self.C3.Plugins.Mouse.Exps = { X(e) {
    return this.GetMousePositionForLayer(e)[0];
  }, Y(e) {
    return this.GetMousePositionForLayer(e)[1];
  }, AbsoluteX() {
    return this._mouseXcanvas;
  }, AbsoluteY() {
    return this._mouseYcanvas;
  }, MovementX() {
    return this._movementX;
  }, MovementY() {
    return this._movementY;
  }, WheelDeltaX() {
    return this._wheelDeltaX;
  }, WheelDeltaY() {
    return this._wheelDeltaY;
  }, WheelDeltaZ() {
    return this._wheelDeltaZ;
  } };
}
var GetMouseSdkInstance2;
{
  {
    const e = self.C3;
    e.Plugins.PlatformInfo = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.PlatformInfo.Type = class extends e.SDKTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t = "platform-info";
    e.Plugins.PlatformInfo.Instance = class extends e.SDKInstanceBase {
      constructor(e2, n) {
        super(e2, t), this._screenWidth = 0, this._screenHeight = 0, this._windowOuterWidth = 0, this._windowOuterHeight = 0, this._safeAreaInset = [0, 0, 0, 0], this._supportsWakeLock = false, this._isWakeLockActive = false, this.AddDOMMessageHandlers([["window-resize", (e3) => this._OnWindowResize(e3)], ["wake-lock-acquired", (e3) => this._OnWakeLockAcquired(e3)], ["wake-lock-error", (e3) => this._OnWakeLockError(e3)], ["wake-lock-released", (e3) => this._OnWakeLockReleased(e3)]]), navigator.connection && navigator.connection.addEventListener("change", () => this._OnNetworkChange()), this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state").then((e3) => {
          this._screenWidth = e3["screenWidth"], this._screenHeight = e3["screenHeight"], this._windowOuterWidth = e3["windowOuterWidth"], this._windowOuterHeight = e3["windowOuterHeight"], this._safeAreaInset = e3["safeAreaInset"], this._supportsWakeLock = e3["supportsWakeLock"];
        }));
      }
      Release() {
        super.Release();
      }
      _OnWindowResize(e2) {
        this._windowOuterWidth = e2["windowOuterWidth"], this._windowOuterHeight = e2["windowOuterHeight"], this._safeAreaInset = e2["safeAreaInset"];
      }
      async _OnNetworkChange() {
        await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnNetworkChange);
      }
      async _OnWakeLockAcquired() {
        this._isWakeLockActive = true, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired);
      }
      async _OnWakeLockError() {
        this._isWakeLockActive = false, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockError);
      }
      async _OnWakeLockReleased() {
        this._isWakeLockActive = false, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockReleased);
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.PlatformInfo.Cnds = { IsOnMobile: () => e.Platform.IsMobile, IsOnWindows: () => "Windows" === e.Platform.OS, IsOnMacOS: () => "macOS" === e.Platform.OS, IsOnLinux: () => "Linux" === e.Platform.OS, IsOnChromeOS: () => "Chrome OS" === e.Platform.OS, IsOnAndroid: () => "Android" === e.Platform.OS, IsOniOS: () => "iOS" === e.Platform.OS, IsWebExport() {
      const e2 = this._runtime.GetExportType();
      return "html5" === e2 || "scirra-arcade" === e2 || "preview" === e2 || "instant-games" === e2;
    }, IsCordovaExport() {
      return this._runtime.IsCordova();
    }, IsNWjsExport: () => false, IsWindowsUWPExport() {
      return "windows-uwp" === this._runtime.GetExportType();
    }, IsWindowsWebView2Export() {
      return this._runtime.IsWindowsWebView2();
    }, IsMacOSWKWebView2Export() {
      return "macos-wkwebview" === this._runtime.GetExportType();
    }, IsLinuxCEFExport() {
      return "linux-cef" === this._runtime.GetExportType();
    }, OnNetworkChange: () => true, OnWakeLockAcquired: () => true, OnWakeLockError: () => true, OnWakeLockReleased: () => true, IsWakeLockActive() {
      return this._isWakeLockActive;
    }, IsWakeLockSupported() {
      return this._supportsWakeLock;
    } };
  }
  self.C3.Plugins.PlatformInfo.Acts = { RequestWakeLock() {
    this._supportsWakeLock && this._PostToDOMMaybeSync("request-wake-lock");
  }, ReleaseWakeLock() {
    this._supportsWakeLock && (this._isWakeLockActive = false, this.PostToDOM("release-wake-lock"));
  } };
  self.C3.Plugins.PlatformInfo.Exps = { Renderer() {
    return this._runtime.GetCanvasManager().GetRendererString();
  }, RendererDetail() {
    return this._runtime.GetCanvasManager().GetRendererDetailString();
  }, DevicePixelRatio() {
    return this._runtime.GetDevicePixelRatio();
  }, ScreenWidth() {
    return this._screenWidth;
  }, ScreenHeight() {
    return this._screenHeight;
  }, WindowInnerWidth() {
    return this._runtime.GetCanvasManager().GetLastWidth();
  }, WindowInnerHeight() {
    return this._runtime.GetCanvasManager().GetLastHeight();
  }, WindowOuterWidth() {
    return this._windowOuterWidth;
  }, WindowOuterHeight() {
    return this._windowOuterHeight;
  }, CanvasCssWidth() {
    return this._runtime.GetCanvasManager().GetCssWidth();
  }, CanvasCssHeight() {
    return this._runtime.GetCanvasManager().GetCssHeight();
  }, CanvasDeviceWidth() {
    return this._runtime.GetCanvasManager().GetDeviceWidth();
  }, CanvasDeviceHeight() {
    return this._runtime.GetCanvasManager().GetDeviceHeight();
  }, Downlink: () => navigator.connection && navigator.connection["downlink"] || 0, DownlinkMax: () => navigator.connection && navigator.connection["downlinkMax"] || 0, ConnectionType: () => navigator.connection && navigator.connection["type"] || "unknown", ConnectionEffectiveType: () => navigator.connection && navigator.connection["effectiveType"] || "unknown", ConnectionRTT: () => navigator.connection && navigator.connection["rtt"] || 0, HardwareConcurrency: () => navigator.hardwareConcurrency || 0, DeviceMemory: () => navigator.deviceMemory || 0, SafeAreaInsetTop() {
    return this._safeAreaInset[0];
  }, SafeAreaInsetRight() {
    return this._safeAreaInset[1];
  }, SafeAreaInsetBottom() {
    return this._safeAreaInset[2];
  }, SafeAreaInsetLeft() {
    return this._safeAreaInset[3];
  }, FramesPerSecond() {
    return this._runtime.GetFramesPerSecond();
  }, TicksPerSecond() {
    return this._runtime.GetTicksPerSecond();
  } };
}
{
  {
    const t = self.C3, e = [];
    t.Plugins.Audio = class extends t.SDKPluginBase {
      constructor(t2) {
        super(t2);
      }
      _AddActionPromise(t2) {
        e.push(t2);
      }
      static async WaitForAllActionPromises() {
        await Promise.all(e), t.clearArray(e);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    let GetAudioSdkInstance = function() {
      return a.GetSingleGlobalInstance().GetSdkInstance();
    }, GetAudioDOMInterface = function() {
      if (self["C3Audio_DOMInterface"]) return self["C3Audio_DOMInterface"];
      throw new Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
    };
    GetAudioSdkInstance2 = GetAudioSdkInstance, GetAudioDOMInterface2 = GetAudioDOMInterface;
    const s = self.C3, i = self.C3X;
    s.Plugins.Audio.Type = class extends s.SDKTypeBase {
      constructor(t) {
        super(t);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      GetScriptInterfaceClass() {
        return self.IAudioObjectType;
      }
    };
    let a = null;
    self.IAudioObjectType = class extends self.IObjectType {
      constructor(t) {
        super(t), a = t;
      }
      get audioContext() {
        return GetAudioDOMInterface()["GetAudioContextExtern"]();
      }
      get destinationNode() {
        return GetAudioDOMInterface()["GetDestinationNodeExtern"]();
      }
      get isSilent() {
        return GetAudioSdkInstance()._IsSilent();
      }
      set isSilent(t) {
        GetAudioSdkInstance()._SetSilent(t);
      }
      get masterVolume() {
        return GetAudioSdkInstance()._GetMasterVolume();
      }
      set masterVolume(t) {
        i.RequireFiniteNumber(t), GetAudioSdkInstance()._SetMasterVolume(t);
      }
      stopAll() {
        GetAudioSdkInstance()._StopAll();
      }
    };
  }
  {
    const n = self.C3, r = "audio", o = ["interactive", "balanced", "playback"];
    n.Plugins.Audio.Instance = class extends n.SDKInstanceBase {
      constructor(t, e) {
        super(t, r), this._nextPlayTime = 0, this._nextPlayOffset = 0, this._triggerTags = [], this._enableMultiTags = true, this._timeScaleMode = 0, this._saveLoadMode = 0, this._playInBackground = false, this._panningModel = 1, this._distanceModel = 1, this._listenerPos = [this._runtime.GetViewportWidth() / 2, this._runtime.GetViewportHeight() / 2, 600], this._listenerForwardVec = [0, 0, -1], this._listenerUpVec = [0, 1, 0], this._referenceDistance = 600, this._maxDistance = 1e4, this._rolloffFactor = 1, this._listenerInst = null, this._loadListenerUid = -1, this._masterVolume = 1, this._isSilent = false, this._sampleRate = 0, this._audioContextState = "suspended", this._outputLatency = 0, this._effectCount = /* @__PURE__ */ new Map(), this._preloadTotal = 0, this._preloadCount = 0, this._bufferMetadata = /* @__PURE__ */ new Map(), this._remoteUrls = /* @__PURE__ */ new Map();
        let s = "interactive";
        e && (this._timeScaleMode = e[0], this._saveLoadMode = e[1], this._playInBackground = e[2], s = o[e[3]], this._enableMultiTags = e[4], this._panningModel = e[5], this._distanceModel = e[6], this._listenerPos[2] = e[7], this._referenceDistance = e[8], this._maxDistance = e[9], this._rolloffFactor = e[10]), this._lastAIState = [], this._lastFxState = [], this._lastAnalysersData = [], this.AddDOMMessageHandlers([["state", (t2) => this._OnUpdateState(t2)], ["audiocontext-state", (t2) => this._OnAudioContextStateChanged(t2)], ["fxstate", (t2) => this._OnUpdateFxState(t2)], ["trigger", (t2) => this._OnTrigger(t2)], ["buffer-metadata", (t2) => this._OnBufferMetadata(t2)]]);
        const i = this.GetRuntime().Dispatcher();
        this._disposables = new n.CompositeDisposable(n.Disposable.From(i, "instancedestroy", (t2) => this._OnInstanceDestroyed(t2.instance)), n.Disposable.From(i, "afterload", () => this._OnAfterLoad()), n.Disposable.From(i, "suspend", () => this._OnSuspend()), n.Disposable.From(i, "resume", () => this._OnResume()));
        const a = this._runtime.GetExportType(), l = "Safari" === n.Platform.Browser, h = this._runtime.IsiOSWebView() || "macos-wkwebview" === a, u = "playable-ad-single-file" === a, c = "cordova" === a && "Android" === n.Platform.OS, d = l || h || u || c;
        this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", { "preloadList": this._runtime.GetAssetManager().GetAudioToPreload().map((t2) => ({ "originalUrl": t2.originalUrl, "url": t2.url, "type": t2.type, "fileSize": t2.fileSize })), "timeScaleMode": this._timeScaleMode, "latencyHint": s, "panningModel": this._panningModel, "distanceModel": this._distanceModel, "refDistance": this._referenceDistance, "maxDistance": this._maxDistance, "rolloffFactor": this._rolloffFactor, "listenerPos": this._listenerPos, "usePlayMusicAsSoundWorkaround": d }).then((t2) => {
          this._sampleRate = t2["sampleRate"], this._audioContextState = t2["audioContextState"], this._outputLatency = t2["outputLatency"];
        })), this._StartTicking();
      }
      Release() {
        this._listenerInst = null, super.Release();
      }
      _SplitTags(t) {
        return this._enableMultiTags ? t.split(" ").filter((t2) => !!t2) : t ? [t] : [];
      }
      _MatchTagLists(t, e) {
        for (const s of e) {
          let e2 = false;
          for (const i of t) if (n.equalsNoCase(i, s)) {
            e2 = true;
            break;
          }
          if (!e2) return false;
        }
        return true;
      }
      _MatchTagListToStr(t, e) {
        return this._MatchTagLists(t, this._SplitTags(e));
      }
      _AddActionPromise(t) {
        this.GetPlugin()._AddActionPromise(t);
      }
      _OnInstanceDestroyed(t) {
        this._listenerInst === t && (this._listenerInst = null);
      }
      DbToLinearNoCap(t) {
        return Math.pow(10, t / 20);
      }
      DbToLinear(t) {
        const e = this.DbToLinearNoCap(t);
        return isFinite(e) ? Math.max(Math.min(e, 1), 0) : 0;
      }
      LinearToDbNoCap(t) {
        return Math.log(t) / Math.log(10) * 20;
      }
      LinearToDb(t) {
        return this.LinearToDbNoCap(Math.max(Math.min(t, 1), 0));
      }
      _GetScheduledPlayInfo() {
        let t = 0;
        const e = !!self["C3_GetAudioContextCurrentTime"];
        return t = e ? this._nextPlayTime : this._nextPlayOffset, this._nextPlayTime = 0, this._nextPlayOffset = 0, { playOffset: t, isTrueClock: e };
      }
      _OnSuspend() {
        this._playInBackground || this.PostToDOM("set-suspended", { "isSuspended": true });
      }
      _OnResume() {
        this._playInBackground || this.PostToDOM("set-suspended", { "isSuspended": false });
      }
      _OnUpdateState(t) {
        const e = t["tickCount"];
        this._outputLatency = t["outputLatency"];
        const s = this._lastAIState.filter((t2) => t2.hasOwnProperty("placeholder") && (t2["placeholder"] > e || -1 === t2["placeholder"]));
        this._lastAIState = t["audioInstances"], this._lastAnalysersData = t["analysers"], s.length > 0 && n.appendArray(this._lastAIState, s);
      }
      _OnBufferMetadata(t) {
        this._bufferMetadata.set(t["originalUrl"], { duration: t["duration"] });
      }
      _OnAudioContextStateChanged(t) {
        this._audioContextState = t["audioContextState"];
      }
      GetAudioContextState() {
        return this._runtime.IsExportToVideo() ? "running" : this._audioContextState;
      }
      _OnUpdateFxState(t) {
        this._lastFxState = t["fxstate"];
      }
      _GetFirstAudioStateByTags(t) {
        const e = this._SplitTags(t);
        for (const t2 of this._lastAIState) if (this._MatchTagLists(t2["tags"], e)) return t2;
        return null;
      }
      _IsTagPlaying(t) {
        const e = this._SplitTags(t);
        return this._lastAIState.some((t2) => this._MatchTagLists(t2["tags"], e) && t2["isPlaying"]);
      }
      _MaybeMarkAsPlaying(t, e, s, i, a) {
        if (this._IsTagPlaying(e)) return null;
        const n2 = this._bufferMetadata.get(t), r2 = { "tags": this._SplitTags(e), "duration": n2 ? n2.duration : 0, "volume": a, "isPlaying": true, "playbackTime": 0, "playbackRate": 1, "uid": -1, "bufferOriginalUrl": t, "bufferUrl": "", "bufferType": "", "isMusic": s, "isLooping": i, "isMuted": false, "resumePosition": 0, "pan": null, "placeholder": -1 };
        return this._lastAIState.push(r2), r2;
      }
      _MaybeMarkAsStopped(t) {
        const e = this._SplitTags(t);
        for (const t2 of this._lastAIState) this._MatchTagLists(t2["tags"], e) && (t2["isPlaying"] = false);
      }
      async _OnTrigger(t) {
        const e = t["type"];
        this._triggerTags = t["tags"];
        const s = t["aiid"];
        if ("ended" === e) {
          for (const t2 of this._lastAIState) if (t2["aiid"] === s) {
            t2["isPlaying"] = false;
            break;
          }
          await this.TriggerAsync(n.Plugins.Audio.Cnds.OnEnded);
        } else "fade-ended" === e && await this.TriggerAsync(n.Plugins.Audio.Cnds.OnFadeEnded);
      }
      _MatchTriggerTag(t) {
        return this._MatchTagListToStr(this._triggerTags, t);
      }
      Tick() {
        const t = { "timeScale": this._runtime.GetTimeScale(), "gameTime": this._runtime.GetGameTimeRaw(), "instPans": this.GetInstancePans(), "tickCount": this._runtime.GetTickCountNoSave() };
        if (this._listenerInst) {
          const e = this._listenerInst.GetWorldInfo();
          this._listenerPos[0] = e.GetX(), this._listenerPos[1] = e.GetY(), t["listenerPos"] = this._listenerPos, t["listenerOrientation"] = [...this._listenerForwardVec, ...this._listenerUpVec];
        }
        this.PostToDOM("tick", t);
      }
      rotatePtAround(t, e, s, i, a) {
        if (0 === s) return [t, e];
        const n2 = Math.sin(s), r2 = Math.cos(s), o2 = (t -= i) * n2;
        return t = t * r2 - (e -= a) * n2, e = e * r2 + o2, [t += i, e += a];
      }
      GetInstancePans() {
        return this._lastAIState.filter((t) => -1 !== t["uid"]).map((t) => this._runtime.GetInstanceByUID(t["uid"])).filter((t) => t).map((t) => {
          const e = t.GetWorldInfo(), s = e.GetLayer().GetAngle(), [i, a] = this.rotatePtAround(e.GetX(), e.GetY(), -s, this._listenerPos[0], this._listenerPos[1]);
          return { "uid": t.GetUID(), "x": i, "y": a, "z": e.GetTotalZElevation(), "angle": e.GetAngle() - s };
        });
      }
      GetAnalyserData(t, e) {
        for (const s of this._lastAnalysersData) if (s.index === e && n.equalsNoCase(s["tag"], t)) return s;
        return null;
      }
      _IncrementEffectCount(t) {
        for (const e of this._SplitTags(t)) {
          const t2 = e.toLowerCase();
          this._effectCount.set(t2, (this._effectCount.get(t2) || 0) + 1);
        }
      }
      _IsSilent() {
        return this._isSilent;
      }
      _SetSilent(t) {
        t = !!t, this._isSilent !== t && (this._isSilent = t, this.PostToDOM("set-silent", { "isSilent": t }));
      }
      _GetMasterVolume() {
        return this._masterVolume;
      }
      _SetMasterVolume(t) {
        this._masterVolume !== t && (this._masterVolume = t, this.PostToDOM("set-master-volume", { "vol": t }));
      }
      _StopAll() {
        this.PostToDOM("stop-all");
        for (const t of this._lastAIState) t["isPlaying"] = false;
      }
      _ShouldSave(t) {
        return !t.hasOwnProperty("placeholder") && (3 !== this._saveLoadMode && ((!t["isMusic"] || 1 !== this._saveLoadMode) && !(!t["isMusic"] && 2 === this._saveLoadMode)));
      }
      SaveToJson() {
        return { "isSilent": this._isSilent, "masterVolume": this._masterVolume, "listenerZ": this._listenerPos[2], "listenerForwardVec": this._listenerForwardVec, "listenerUpVec": this._listenerUpVec, "listenerUid": this._listenerInst ? this._listenerInst.GetUID() : -1, "remoteUrls": [...this._remoteUrls.entries()], "playing": this._lastAIState.filter((t) => this._ShouldSave(t)), "effects": this._lastFxState, "analysers": this._lastAnalysersData };
      }
      LoadFromJson(t) {
        if (this._isSilent = t["isSilent"], this._masterVolume = t["masterVolume"], this._listenerPos[2] = t["listenerZ"], this._listenerInst = null, this._loadListenerUid = t["listenerUid"], t.hasOwnProperty("listenerForwardVec") ? this._listenerForwardVec = t["listenerForwardVec"] : this._listenerForwardVec = [0, 0, -1], t.hasOwnProperty("listenerUpVec") ? this._listenerUpVec = t["listenerUpVec"] : this._listenerUpVec = [0, 1, 0], this._remoteUrls.clear(), t["remoteUrls"]) for (const [e, s] of t["remoteUrls"]) this._remoteUrls.set(e, s);
        this._lastAIState = t["playing"];
        for (const t2 of this._lastAIState) t2.hasOwnProperty("tag") && !t2.hasOwnProperty("tags") && (t2["tags"] = [t2["tag"]].filter((t3) => !!t3));
        this._lastFxState = t["effects"], this._lastAnalysersData = t["analysers"];
      }
      _OnAfterLoad() {
        if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid), this._loadListenerUid = -1, this._listenerInst)) {
          const t = this._listenerInst.GetWorldInfo();
          this._listenerPos[0] = t.GetX(), this._listenerPos[1] = t.GetY();
        }
        for (const t of this._lastAIState) {
          const e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t["bufferOriginalUrl"]);
          e ? (t["bufferUrl"] = e.url, t["bufferType"] = e.type) : t["bufferUrl"] = null;
        }
        for (const t of Object.values(this._lastFxState)) for (const e of t) if (e.hasOwnProperty("bufferOriginalUrl")) {
          const t2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e["bufferOriginalUrl"]);
          t2 && (e["bufferUrl"] = t2.url, e["bufferType"] = t2.type);
        }
        this.PostToDOM("load-state", { "saveLoadMode": this._saveLoadMode, "timeScale": this._runtime.GetTimeScale(), "gameTime": this._runtime.GetGameTimeRaw(), "listenerPos": this._listenerPos, "listenerOrientation": [...this._listenerForwardVec, ...this._listenerUpVec], "isSilent": this._isSilent, "masterVolume": this._masterVolume, "playing": this._lastAIState.filter((t) => null !== t["bufferUrl"]), "effects": this._lastFxState });
      }
      GetDebuggerProperties() {
        const t = [];
        for (const [e2, s] of Object.entries(this._lastFxState)) t.push({ name: "$" + e2, value: s.map((t2) => t2["type"]).join(", ") });
        const e = "plugins.audio.debugger";
        return [{ title: e + ".tag-effects", properties: t }, { title: e + ".currently-playing", properties: [{ name: e + ".currently-playing-count", value: this._lastAIState.length }, ...this._lastAIState.map((t2, e2) => ({ name: "$#" + e2, value: `${t2["bufferOriginalUrl"]} ("${t2["tags"]}") ${Math.round(10 * t2["playbackTime"]) / 10} / ${Math.round(10 * t2["duration"]) / 10}` }))] }];
      }
    };
  }
  self.C3.Plugins.Audio.Cnds = { OnEnded(t) {
    return this._MatchTriggerTag(t);
  }, OnFadeEnded(t) {
    return this._MatchTriggerTag(t);
  }, PreloadsComplete() {
    return this._preloadCount === this._preloadTotal;
  }, AdvancedAudioSupported: () => true, IsSilent() {
    return this._IsSilent();
  }, IsAnyPlaying() {
    for (const t of this._lastAIState) if (t["isPlaying"]) return true;
    return false;
  }, IsTagPlaying(t) {
    return this._IsTagPlaying(t);
  } };
  {
    const l = self.C3, h = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];
    l.Plugins.Audio.Acts = { Play(t, e, s, i, a) {
      const n = l.Plugins.Audio.Acts._DoPlay.call(this, t, e, s, i, a);
      return this._AddActionPromise(n), n;
    }, PlayFromTimeline(t, e, s, i) {
      l.Plugins.Audio.Acts._DoPlay.call(this, t, 0, e, 0, s, i);
    }, async _DoPlay(t, e, s, i, a, n) {
      if (this._isSilent) return;
      const r = t[1], o = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
      if (!o) return;
      const { playOffset: h2, isTrueClock: u } = this._GetScheduledPlayInfo(), c = this._MaybeMarkAsPlaying(t[0], a, r, 0 !== e, this.DbToLinear(s));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": t[0], "url": o.url, "type": o.type, "isMusic": r, "tags": this._SplitTags(a), "isLooping": 0 !== e, "vol": this.DbToLinear(s), "stereoPan": l.clamp(i / 100, -1, 1), "pos": n || 0, "off": h2, "trueClock": u });
      } finally {
        c && (c["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayAtPosition(t, e, s, i, a, n, r, o, h2, u, c) {
      if (this._isSilent) return;
      const d = t[1], _ = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
      if (!_) return;
      const { playOffset: f, isTrueClock: p } = this._GetScheduledPlayInfo(), g = this._MaybeMarkAsPlaying(t[0], c, d, 0 !== e, this.DbToLinear(s));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": t[0], "url": _.url, "type": _.type, "isMusic": d, "tags": this._SplitTags(c), "isLooping": 0 !== e, "vol": this.DbToLinear(s), "pos": 0, "off": f, "trueClock": p, "panning": { "x": i, "y": a, "z": n, "angle": l.toRadians(r), "innerAngle": l.toRadians(o), "outerAngle": l.toRadians(h2), "outerGain": this.DbToLinear(u) } });
      } finally {
        g && (g["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayAtObject(t, e, s, i, a, n, r, o) {
      if (this._isSilent) return;
      if (!i) return;
      const h2 = i.GetFirstPicked();
      if (!h2 || !h2.GetWorldInfo()) return;
      const u = h2.GetWorldInfo(), c = u.GetLayer().GetAngle(), [d, _] = this.rotatePtAround(u.GetX(), u.GetY(), -c, this._listenerPos[0], this._listenerPos[1]), f = t[1], p = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
      if (!p) return;
      const { playOffset: g, isTrueClock: y } = this._GetScheduledPlayInfo(), m = this._MaybeMarkAsPlaying(t[0], o, f, 0 !== e, this.DbToLinear(s));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": t[0], "url": p.url, "type": p.type, "isMusic": f, "tags": this._SplitTags(o), "isLooping": 0 !== e, "vol": this.DbToLinear(s), "pos": 0, "off": g, "trueClock": y, "panning": { "x": d, "y": _, "z": u.GetTotalZElevation(), "angle": u.GetAngle() - c, "innerAngle": l.toRadians(a), "outerAngle": l.toRadians(n), "outerGain": this.DbToLinear(r), "uid": h2.GetUID() } });
      } finally {
        m && (m["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayByName(t, e, s, i, a, n) {
      if (this._isSilent) return;
      const r = 1 === t, o = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      if (!o) return;
      const { playOffset: h2, isTrueClock: u } = this._GetScheduledPlayInfo(), c = this._MaybeMarkAsPlaying(e, n, r, 0 !== s, this.DbToLinear(i));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": e, "url": o.url, "type": o.type, "isMusic": r, "tags": this._SplitTags(n), "isLooping": 0 !== s, "vol": this.DbToLinear(i), "stereoPan": l.clamp(a / 100, -1, 1), "pos": 0, "off": h2, "trueClock": u });
      } finally {
        c && (c["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayAtPositionByName(t, e, s, i, a, n, r, o, h2, u, c, d) {
      if (this._isSilent) return;
      const _ = 1 === t, f = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      if (!f) return;
      const { playOffset: p, isTrueClock: g } = this._GetScheduledPlayInfo(), y = this._MaybeMarkAsPlaying(e, d, _, 0 !== s, this.DbToLinear(i));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": e, "url": f.url, "type": f.type, "isMusic": _, "tags": this._SplitTags(d), "isLooping": 0 !== s, "vol": this.DbToLinear(i), "pos": 0, "off": p, "trueClock": g, "panning": { "x": a, "y": n, "z": r, "angle": l.toRadians(o), "innerAngle": l.toRadians(h2), "outerAngle": l.toRadians(u), "outerGain": this.DbToLinear(c) } });
      } finally {
        y && (y["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayAtObjectByName(t, e, s, i, a, n, r, o, h2) {
      if (this._isSilent) return;
      if (this._isSilent) return;
      if (!a) return;
      const u = a.GetFirstPicked();
      if (!u || !u.GetWorldInfo()) return;
      const c = u.GetWorldInfo(), d = c.GetLayer().GetAngle(), [_, f] = this.rotatePtAround(c.GetX(), c.GetY(), -d, this._listenerPos[0], this._listenerPos[1]), p = 1 === t, g = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      if (!g) return;
      const { playOffset: y, isTrueClock: m } = this._GetScheduledPlayInfo(), T = this._MaybeMarkAsPlaying(e, h2, p, 0 !== s, this.DbToLinear(i));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": e, "url": g.url, "type": g.type, "isMusic": p, "tags": this._SplitTags(h2), "isLooping": 0 !== s, "vol": this.DbToLinear(i), "pos": 0, "off": y, "trueClock": m, "panning": { "x": _, "y": f, "z": c.GetTotalZElevation(), "angle": c.GetAngle() - d, "innerAngle": l.toRadians(n), "outerAngle": l.toRadians(r), "outerGain": this.DbToLinear(o), "uid": u.GetUID() } });
      } finally {
        T && (T["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, SetLooping(t, e) {
      this.PostToDOM("set-looping", { "tags": this._SplitTags(t), "isLooping": 0 === e });
    }, SetMuted(t, e) {
      this.PostToDOM("set-muted", { "tags": this._SplitTags(t), "isMuted": 0 === e });
    }, SetVolume(t, e) {
      this.PostToDOM("set-volume", { "tags": this._SplitTags(t), "vol": this.DbToLinear(e) });
    }, FadeVolume(t, e, s, i) {
      this.PostToDOM("fade-volume", { "tags": this._SplitTags(t), "vol": this.DbToLinear(e), "duration": s, "stopOnEnd": 0 === i });
    }, SetStereoPan(t, e) {
      this.PostToDOM("set-stereo-pan", { "tags": this._SplitTags(t), "p": l.clamp(e / 100, -1, 1) });
    }, async Preload(t) {
      const e = t[1], s = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
      s && (this._preloadTotal++, await this.PostToDOMAsync("preload", { "originalUrl": t[0], "url": s.url, "type": s.type, "isMusic": e }), this._preloadCount++);
    }, async PreloadByName(t, e) {
      const s = 1 === t, i = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      i && (this._preloadTotal++, await this.PostToDOMAsync("preload", { "originalUrl": e, "url": i.url, "type": i.type, "isMusic": s }), this._preloadCount++);
    }, SetPlaybackRate(t, e) {
      this.PostToDOM("set-playback-rate", { "tags": this._SplitTags(t), "rate": Math.max(e, 0) });
    }, Stop(t) {
      this._MaybeMarkAsStopped(t), this.PostToDOM("stop", { "tags": this._SplitTags(t) });
    }, StopAll() {
      this._StopAll();
    }, SetPaused(t, e) {
      this.PostToDOM("set-paused", { "tags": this._SplitTags(t), "paused": 0 === e });
    }, Seek(t, e) {
      this.PostToDOM("seek", { "tags": this._SplitTags(t), "pos": e });
    }, SetSilent(t) {
      2 === t && (t = this._IsSilent() ? 1 : 0), this._SetSilent(0 === t);
    }, SetMasterVolume(t) {
      const e = this.DbToLinear(t);
      this._SetMasterVolume(e);
    }, AddFilterEffect(t, e, s, i, a, n, r) {
      const o = h[e];
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "filter", "tags": this._SplitTags(t), "params": [o, s, i, a, n, l.clamp(r / 100, 0, 1)] });
    }, AddDelayEffect(t, e, s, i) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "delay", "tags": this._SplitTags(t), "params": [e, this.DbToLinear(s), l.clamp(i / 100, 0, 1)] });
    }, AddFlangerEffect(t, e, s, i, a, n) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "flanger", "tags": this._SplitTags(t), "params": [e / 1e3, s / 1e3, i, a / 100, l.clamp(n / 100, 0, 1)] });
    }, AddPhaserEffect(t, e, s, i, a, n, r) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "phaser", "tags": this._SplitTags(t), "params": [e, s, i, a, n, l.clamp(r / 100, 0, 1)] });
    }, AddConvolutionEffect(t, e, s, i) {
      const a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);
      a && (this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "convolution", "tags": this._SplitTags(t), "bufferOriginalUrl": e[0], "bufferUrl": a.url, "bufferType": a.type, "params": [0 === s, l.clamp(i / 100, 0, 1)] }));
    }, AddGainEffect(t, e) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "gain", "tags": this._SplitTags(t), "params": [this.DbToLinear(e)] });
    }, AddStereoPanEffect(t, e) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "stereopan", "tags": this._SplitTags(t), "params": [l.clamp(e / 100, -1, 1)] });
    }, AddMuteEffect(t) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "gain", "tags": this._SplitTags(t), "params": [0] });
    }, AddTremoloEffect(t, e, s) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "tremolo", "tags": this._SplitTags(t), "params": [e, l.clamp(s / 100, 0, 1)] });
    }, AddRingModEffect(t, e, s) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "ringmod", "tags": this._SplitTags(t), "params": [e, l.clamp(s / 100, 0, 1)] });
    }, AddDistortionEffect(t, e, s, i, a, n) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "distortion", "tags": this._SplitTags(t), "params": [this.DbToLinearNoCap(e), this.DbToLinearNoCap(s), i, this.DbToLinearNoCap(a), l.clamp(n / 100, 0, 1)] });
    }, AddCompressorEffect(t, e, s, i, a, n) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "compressor", "tags": this._SplitTags(t), "params": [e, s, i, a / 1e3, n / 1e3] });
    }, AddAnalyserEffect(t, e, s) {
      this._IncrementEffectCount(t), this.PostToDOM("add-effect", { "type": "analyser", "tags": this._SplitTags(t), "params": [e, s] });
    }, RemoveEffects(t) {
      const e = this._SplitTags(t);
      for (const t2 of e) this._effectCount.set(t2.toLowerCase(), 0);
      this.PostToDOM("remove-effects", { "tags": e }), this._lastFxState = {};
    }, SetEffectParameter(t, e, s, i, a, n) {
      this.PostToDOM("set-effect-param", { "tags": this._SplitTags(t), "index": Math.floor(e), "param": s, "value": i, "ramp": a, "time": n });
    }, SetListenerObject(t) {
      if (!t) return;
      const e = t.GetFirstPicked();
      e && e.GetWorldInfo() && (this._listenerInst = e);
    }, SetListenerZ(t) {
      this._listenerPos[2] = t;
    }, SetListenerOrientation(t, e, s, i, a, n) {
      this._listenerForwardVec[0] = t, this._listenerForwardVec[1] = e, this._listenerForwardVec[2] = -s, this._listenerUpVec[0] = i, this._listenerUpVec[1] = a, this._listenerUpVec[2] = -n;
    }, ScheduleNextPlay(t) {
      this._nextPlayTime = Math.max(t, 0), this._nextPlayOffset = Math.max(t - performance.now() / 1e3, 0);
    }, UnloadAudio(t) {
      const e = t[1], s = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
      s && this.PostToDOM("unload", { "url": s.url, "type": s.type, "isMusic": e });
    }, UnloadAudioByName(t, e) {
      const s = 1 === t, i = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      i && this.PostToDOM("unload", { "url": i.url, "type": i.type, "isMusic": s });
    }, UnloadAll() {
      this.PostToDOM("unload-all");
    }, AddRemoteURL(t, e, s) {
      this._remoteUrls.set(s.toLowerCase(), { url: t, type: e });
    } };
  }
  {
    const u = self.C3;
    u.Plugins.Audio.Exps = { Duration(t) {
      const e = this._GetFirstAudioStateByTags(t);
      return e ? e["duration"] : 0;
    }, PlaybackTime(t) {
      const e = this._GetFirstAudioStateByTags(t);
      return e ? e["playbackTime"] : 0;
    }, PlaybackRate(t) {
      const e = this._GetFirstAudioStateByTags(t);
      return e ? e["playbackRate"] : 0;
    }, Volume(t) {
      const e = this._GetFirstAudioStateByTags(t);
      return e ? this.LinearToDb(e["volume"]) : 0;
    }, MasterVolume() {
      return this.LinearToDb(this._GetMasterVolume());
    }, EffectCount(t) {
      return this._effectCount.get(t.toLowerCase()) || 0;
    }, AnalyserFreqBinCount(t, e) {
      const s = this.GetAnalyserData(t, Math.floor(e));
      return s ? s["binCount"] : 0;
    }, AnalyserFreqBinAt(t, e, s) {
      const i = this.GetAnalyserData(t, Math.floor(e));
      return i ? (s = Math.floor(s)) < 0 || s >= i["binCount"] ? 0 : i["freqBins"][s] : 0;
    }, AnalyserPeakLevel(t, e) {
      const s = this.GetAnalyserData(t, Math.floor(e));
      return s ? s["peak"] : 0;
    }, AnalyserRMSLevel(t, e) {
      const s = this.GetAnalyserData(t, Math.floor(e));
      return s ? s["rms"] : 0;
    }, SampleRate() {
      return this._sampleRate;
    }, CurrentTime: () => self["C3_GetAudioContextCurrentTime"] ? self["C3_GetAudioContextCurrentTime"]() : performance.now() / 1e3, OutputLatency() {
      return this._outputLatency;
    }, NormalizedVolume(t, e) {
      return 0 === (t = u.clamp(+t, 0, 100) / 100) ? -1 / 0 : t < 0.1 ? this.LinearToDb(u.lerp(0, this.DbToLinear(e), 10 * t)) : u.lerp(e, 0, (t - 0.1) / 0.9);
    } };
  }
}
var GetAudioSdkInstance2;
var GetAudioDOMInterface2;
{
  {
    const e = self.C3;
    e.Behaviors.Rotate = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Rotate.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t = self.C3X, s = self.IBehaviorInstance, a = 0, i = 1, n = 2;
    e.Behaviors.Rotate.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(t2, s2) {
        super(t2), this._speed = 0, this._acceleration = 0, this._isEnabled = true, s2 && (this._speed = e.toRadians(s2[a]), this._acceleration = e.toRadians(s2[i]), this._isEnabled = s2[n]), this._isEnabled && this._StartTicking();
      }
      Release() {
        super.Release();
      }
      _SetSpeed(e2) {
        this._speed = e2;
      }
      _GetSpeed() {
        return this._speed;
      }
      _SetAcceleration(e2) {
        this._acceleration = e2;
      }
      _GetAcceleration() {
        return this._acceleration;
      }
      SaveToJson() {
        return { "s": this._speed, "a": this._acceleration, "e": this._isEnabled };
      }
      LoadFromJson(e2) {
        this._speed = e2["s"], this._acceleration = e2["a"], this._SetEnabled(e2["e"]);
      }
      Tick() {
        if (!this._isEnabled) return;
        const e2 = this._runtime.GetDt(this._inst);
        if (0 !== e2 && (0 !== this._acceleration && (this._speed += this._acceleration * e2), 0 !== this._speed)) {
          const t2 = this._inst.GetWorldInfo();
          t2.SetAngle(t2.GetAngle() + this._speed * e2), t2.SetBboxChanged();
        }
      }
      GetPropertyValueByIndex(t2) {
        switch (t2) {
          case a:
            return e.toDegrees(this._GetSpeed());
          case i:
            return e.toDegrees(this._GetAcceleration());
          case n:
            return this._IsEnabled();
        }
      }
      SetPropertyValueByIndex(t2, s2) {
        switch (t2) {
          case a:
            this._SetSpeed(e.toRadians(s2));
            break;
          case i:
            this._SetAcceleration(e.toRadians(s2));
            break;
          case n:
            this._SetEnabled(s2);
        }
      }
      _SetEnabled(e2) {
        this._isEnabled = !!e2, this._isEnabled ? this._StartTicking() : this._StopTicking();
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      GetDebuggerProperties() {
        const t2 = "behaviors.rotate";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t2 + ".properties.speed.name", value: e.toDegrees(this._GetSpeed()), onedit: (t3) => this._SetSpeed(e.toRadians(t3)) }, { name: t2 + ".properties.acceleration.name", value: e.toDegrees(this._GetAcceleration()), onedit: (t3) => this._SetAcceleration(e.toRadians(t3)) }, { name: t2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IRotateBehaviorInstance;
      }
    };
    const r = /* @__PURE__ */ new WeakMap();
    self.IRotateBehaviorInstance = class extends s {
      constructor() {
        super(), r.set(this, s._GetInitInst().GetSdkInstance());
      }
      set speed(e2) {
        t.RequireFiniteNumber(e2), r.get(this)._SetSpeed(e2);
      }
      get speed() {
        return r.get(this)._GetSpeed();
      }
      set acceleration(e2) {
        t.RequireFiniteNumber(e2), r.get(this)._SetAcceleration(e2);
      }
      get acceleration() {
        return r.get(this)._GetAcceleration();
      }
      get isEnabled() {
        return r.get(this)._IsEnabled();
      }
      set isEnabled(e2) {
        r.get(this)._SetEnabled(e2);
      }
    };
  }
  self.C3.Behaviors.Rotate.Cnds = { IsEnabled() {
    return this._IsEnabled();
  } };
  {
    const e = self.C3;
    e.Behaviors.Rotate.Acts = { SetSpeed(t) {
      this._SetSpeed(e.toRadians(t));
    }, SetAcceleration(t) {
      this._SetAcceleration(e.toRadians(t));
    }, SetEnabled(e2) {
      this._SetEnabled(e2);
    } };
  }
  {
    const e = self.C3;
    e.Behaviors.Rotate.Exps = { Speed() {
      return e.toDegrees(this._GetSpeed());
    }, Acceleration() {
      return e.toDegrees(this._GetAcceleration());
    } };
  }
}
{
  {
    const e = self.C3;
    e.Behaviors.jumpthru = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.jumpthru.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, s = self.IBehaviorInstance, t = 0;
    e.Behaviors.jumpthru.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(e2, s2) {
        super(e2), this.SetEnabled(true), s2 && this.SetEnabled(s2[t]);
      }
      Release() {
        super.Release();
      }
      SetEnabled(e2) {
        this._inst._SetJumpthruEnabled(!!e2);
      }
      IsEnabled() {
        return this._inst._IsJumpthruEnabled();
      }
      SaveToJson() {
        return { "e": this.IsEnabled() };
      }
      LoadFromJson(e2) {
        this.SetEnabled(e2["e"]);
      }
      GetPropertyValueByIndex(e2) {
        if (e2 === t) return this.IsEnabled();
      }
      SetPropertyValueByIndex(e2, s2) {
        if (e2 === t) this.SetEnabled(s2);
      }
      GetDebuggerProperties() {
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.jumpthru.properties.enabled.name", value: this.IsEnabled(), onedit: (e2) => this.SetEnabled(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IJumpthruBehaviorInstance;
      }
    };
    const r = /* @__PURE__ */ new WeakMap();
    self.IJumpthruBehaviorInstance = class extends s {
      constructor() {
        super(), r.set(this, s._GetInitInst().GetSdkInstance());
      }
      set isEnabled(e2) {
        r.get(this).SetEnabled(!!e2);
      }
      get isEnabled() {
        return r.get(this).IsEnabled();
      }
    };
  }
  self.C3.Behaviors.jumpthru.Cnds = { IsEnabled() {
    return this.IsEnabled();
  } };
  self.C3.Behaviors.jumpthru.Acts = { SetEnabled(e) {
    this.SetEnabled(e);
  } };
  self.C3.Behaviors.jumpthru.Exps = {};
}
{
  {
    const t = self.C3;
    t.Behaviors.Platform = class extends t.SDKBehaviorBase {
      constructor(t2) {
        super(t2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Platform.Type = class extends e.SDKBehaviorTypeBase {
      constructor(t) {
        super(t);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    let accelerate = function(t, e, s2, n2, h2) {
      const r2 = e * h2, o2 = s2 * h2;
      return i.clamp(t * h2 + 0.5 * n2 * h2 * h2, r2, o2);
    };
    accelerate2 = accelerate;
    const i = self.C3, s = self.C3X, n = self.IBehaviorInstance, h = 0, r = 1, o = 2, l = 3, a = 4, _ = 5, u = 6, d = 7, m = 8, p = 9, g = 0.05;
    i.Behaviors.Platform.Instance = class extends i.SDKBehaviorInstanceBase {
      constructor(t, e) {
        super(t), this._keyboardDisposables = null, this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false, this._doubleJumped = false, this._canDoubleJump = false, this._ignoreInput = false, this._simLeft = false, this._simRight = false, this._simJump = false, this._lastFloorObject = null, this._loadFloorUid = -1, this._lastFloorX = 0, this._lastFloorY = 0, this._floorIsJumpthru = false, this._wasOnFloor = false, this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst), this._loadJumpthruUid = -1, this._animMode = "stopped", this._fallThroughTime = -1, this._isFirstTick = true, this._dx = 0, this._dy = 0, this._downX = 0, this._downY = 0, this._rightX = 0, this._rightY = 0, this._g = 1500, this._g1 = 1500, this._ga = i.toRadians(90), this._maxSpeed = 330, this._acc = 1500, this._dec = 1500, this._jumpStrength = 650, this._maxFall = 1e3, this._enableDoubleJump = false, this._jumpSustain = 0, this._sustainTime = 0, this._defaultControls = true, this._ceilingCollisionMode = 0, this._isEnabled = true, e && (this._maxSpeed = e[h], this._acc = e[r], this._dec = e[o], this._jumpStrength = e[l], this._g = e[a], this._maxFall = e[_], this._enableDoubleJump = !!e[u], this._jumpSustain = e[d] / 1e3, this._defaultControls = !!e[m], this._isEnabled = !!e[p]);
        const s2 = this._runtime.Dispatcher();
        this._disposables = new i.CompositeDisposable(i.Disposable.From(s2, "instancedestroy", (t2) => this._OnInstanceDestroyed(t2.instance)), i.Disposable.From(s2, "afterload", (t2) => this._OnAfterLoad())), this._defaultControls && this._BindEvents(), this._isEnabled && this._StartPostTicking(), this._UpdateGravity();
      }
      Release() {
        this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null), this._lastFloorObject = null, this._wasOverJumpthru = null, super.Release();
      }
      _BindEvents() {
        if (this._keyboardDisposables) return;
        const t = this._runtime.Dispatcher();
        this._keyboardDisposables = new i.CompositeDisposable(i.Disposable.From(t, "keydown", (t2) => this._OnKeyDown(t2.data)), i.Disposable.From(t, "keyup", (t2) => this._OnKeyUp(t2.data)), i.Disposable.From(t, "window-blur", () => this._OnWindowOrKeyboardBlur()), i.Disposable.From(t, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()));
      }
      _UnBindEvents() {
        this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null);
      }
      _OnInstanceDestroyed(t) {
        this._lastFloorObject === t && (this._lastFloorObject = null), this._wasOverJumpthru === t && (this._wasOverJumpthru = null);
      }
      _OnKeyDown(t) {
        switch (t["key"]) {
          case "ArrowLeft":
            this._leftKey = true;
            break;
          case "ArrowRight":
            this._rightKey = true;
            break;
          case "ArrowUp":
            this._jumpKey = true;
        }
      }
      _OnKeyUp(t) {
        switch (t["key"]) {
          case "ArrowLeft":
            this._leftKey = false;
            break;
          case "ArrowRight":
            this._rightKey = false;
            break;
          case "ArrowUp":
            this._jumpKey = false, this._jumped = false;
        }
      }
      _OnWindowOrKeyboardBlur() {
        this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false;
      }
      SaveToJson() {
        return { "ii": this._ignoreInput, "lfx": this._lastFloorX, "lfy": this._lastFloorY, "lfo": this._lastFloorObject ? this._lastFloorObject.GetUID() : -1, "am": this._animMode, "en": this._isEnabled, "fallt": this._fallThroughTime, "ft": this._isFirstTick, "dx": this._dx, "dy": this._dy, "ms": this._maxSpeed, "acc": this._acc, "dec": this._dec, "js": this._jumpStrength, "g": this._g, "g1": this._g1, "mf": this._maxFall, "wof": this._wasOnFloor, "woj": this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1, "ga": this._ga, "edj": this._enableDoubleJump, "cdj": this._canDoubleJump, "dj": this._doubleJumped, "sus": this._jumpSustain, "dc": this._defaultControls, "cc": this._ceilingCollisionMode };
      }
      LoadFromJson(t) {
        this._ignoreInput = t["ii"], this._lastFloorX = t["lfx"], this._lastFloorY = t["lfy"], this._loadFloorUid = t["lfo"], this._animMode = t["am"];
        const e = t["en"];
        this._fallThroughTime = t["fallt"] || -1, this._isFirstTick = t["ft"], this._dx = t["dx"], this._dy = t["dy"], this._maxSpeed = t["ms"], this._acc = t["acc"], this._dec = t["dec"], this._jumpStrength = t["js"], this._g = t["g"], this._g1 = t["g1"], this._maxFall = t["mf"], this._wasOnFloor = t["wof"], this._loadJumpthruUid = t["woj"], this._ga = t["ga"], this._enableDoubleJump = t["edj"], this._canDoubleJump = t["cdj"], this._doubleJumped = t["dj"], this._jumpSustain = t["sus"], this._defaultControls = t["dc"], this._ceilingCollisionMode = t["cc"] || 0, this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false, this._simLeft = false, this._simRight = false, this._simJump = false, this._sustainTime = 0, this._defaultControls ? this._BindEvents() : this._UnBindEvents(), this._SetEnabled(e), this._UpdateGravity();
      }
      _OnAfterLoad() {
        -1 === this._loadFloorUid ? this._lastFloorObject = null : this._lastFloorObject = this._runtime.GetInstanceByUID(this._loadFloorUid), -1 === this._loadJumpthruUid ? this._wasOverJumpthru = null : this._wasOverJumpthru = this._runtime.GetInstanceByUID(this._loadJumpthruUid);
      }
      _SetLastFloorObject(t) {
        if (this._lastFloorObject = t, t) {
          const e = t.GetWorldInfo();
          this._lastFloorX = e.GetX(), this._lastFloorY = e.GetY();
        }
      }
      _IsFallThroughEnabled() {
        return this._runtime.GetGameTime() > this._fallThroughTime + g;
      }
      _UpdateGravity() {
        this._downX = Math.cos(this._ga), this._downY = Math.sin(this._ga), this._rightX = Math.cos(this._ga - Math.PI / 2), this._rightY = Math.sin(this._ga - Math.PI / 2), this._downX = i.roundToDp(this._downX, 6), this._downY = i.roundToDp(this._downY, 6), this._rightX = i.roundToDp(this._rightX, 6), this._rightY = i.roundToDp(this._rightY, 6), this._g1 = this._g, this._g < 0 && (this._downX *= -1, this._downY *= -1, this._g = Math.abs(this._g));
      }
      _GetGDir() {
        return this._g < 0 ? -1 : 1;
      }
      _IsOnFloor() {
        const t = this._inst.GetWorldInfo(), e = this._runtime.GetCollisionEngine(), i2 = this._inst, s2 = this._lastFloorObject, n2 = t.GetX(), h2 = t.GetY();
        if (t.OffsetXY(this._downX, this._downY), t.SetBboxChanged(), !s2 || !e.TestOverlap(i2, s2) || s2.GetObjectClass().HasSolidBehavior() && !e.IsSolidCollisionAllowed(s2, i2) || s2.GetObjectClass().HasJumpthruBehavior() && !s2._IsJumpthruEnabled()) {
          let s3 = e.TestOverlapSolid(i2), r2 = null;
          if (!s3 && this._IsFallThroughEnabled() && (r2 = e.TestOverlapJumpthru(i2, true)), t.SetXY(n2, h2), t.SetBboxChanged(), s3) return e.TestOverlap(i2, s3) ? null : (this._floorIsJumpthru = false, s3);
          if (r2 && r2.length) {
            let t2 = 0;
            for (let s4 = 0, n3 = r2.length; s4 < n3; ++s4) r2[t2] = r2[s4], e.TestOverlap(i2, r2[s4]) || ++t2;
            if (t2 >= 1) return this._floorIsJumpthru = true, r2[0];
          }
          return null;
        }
        return t.SetXY(n2, h2), t.SetBboxChanged(), s2;
      }
      PostTick() {
        if (!this._isEnabled) return;
        const t = this._runtime.GetDt(this._inst);
        this._jumpKey || this._simJump || (this._jumped = false);
        let e = this._leftKey || this._simLeft, i2 = this._rightKey || this._simRight, s2 = this._jumpKey || this._simJump, n2 = s2 && !this._jumped;
        this._simLeft = false, this._simRight = false, this._simJump = false, this._ignoreInput && (e = false, i2 = false, s2 = false, n2 = false), s2 || (this._sustainTime = 0), this._HandleFirstTick();
        const [h2, r2, o2] = this._TrackMovingPlatform();
        let l2 = this._IsOnFloor();
        const a2 = l2 && !this._wasOnFloor;
        let _2 = false;
        if ([_2, l2] = this._MaybePushOutSolid(l2), _2) return;
        this._TrackFloor(l2, o2, h2, s2), n2 = this._HandleJump(l2, n2, s2), l2 || this._HandleAirTime(n2, s2, t), this._wasOnFloor = !!l2;
        const u2 = this._CalculateHorizontalAcceleration(e, i2);
        let d2 = false, m2 = 0;
        if (0 !== this._dx && ([d2, l2] = this._HandleHorizontalMovement(t, u2, l2, n2)), 0 !== this._dy) {
          const [e2, i3] = this._HandleVerticalMovement(t, l2);
          d2 = d2 || e2, m2 = i3;
        }
        !d2 && a2 && this._dy < 0 && m2 > 0 && (this._dy = 0, d2 = true), this._ApplyHorizontalAcceleration(e, i2, u2, t), l2 && !n2 || d2 || (this._dy = Math.min(this._dy + this._g * t, this._maxFall)), this._HandleAnimationTriggers(l2, d2, n2), this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst);
      }
      _HandleFirstTick() {
        if (!this._isFirstTick) return;
        const t = this._inst, e = this._runtime.GetCollisionEngine();
        (e.TestOverlapSolid(t) || e.TestOverlapJumpthru(t)) && e.PushOutSolid(t, -this._downX, -this._downY, 4, true), this._isFirstTick = false;
      }
      _TrackMovingPlatform() {
        const t = this._lastFloorObject, e = t ? t.GetWorldInfo() : null;
        let s2 = 0, n2 = 0, h2 = false;
        if (t && 0 === this._dy && (e.GetY() !== this._lastFloorY || e.GetX() !== this._lastFloorX)) {
          const t2 = this._inst, r2 = t2.GetWorldInfo(), o2 = this._runtime.GetCollisionEngine(), l2 = e.GetX(), a2 = e.GetY();
          s2 = l2 - this._lastFloorX, n2 = a2 - this._lastFloorY, r2.OffsetXY(s2, n2), r2.SetBboxChanged(), this._lastFloorX = l2, this._lastFloorY = a2, h2 = true;
          const _2 = o2.TestOverlapSolid(t2);
          _2 && (o2.RegisterCollision(t2, _2), o2.PushOutSolid(t2, -s2, -n2, 2.5 * i.hypot2DFast(s2, n2)));
        }
        return [s2, n2, h2];
      }
      _MaybePushOutSolid(t) {
        let e = false;
        const i2 = this._inst, s2 = i2.GetWorldInfo(), n2 = this._runtime.GetCollisionEngine(), h2 = n2.TestOverlapSolid(i2);
        if (!h2) return [false, t];
        const r2 = Math.abs(s2.GetWidth()), o2 = Math.abs(s2.GetHeight());
        return n2.PushOutSolid(i2, -this._downX, -this._downY, o2 / 8) ? (n2.RegisterCollision(i2, h2), t = h2, this._SetLastFloorObject(h2), this._floorIsJumpthru = false, this._dy = 0) : n2.PushOutSolidAxis(i2, this._rightX, this._rightY, r2 / 2) || n2.PushOutSolidAxis(i2, this._downX, this._downY, o2 / 2) || n2.PushOutSolidNearest(i2, Math.max(r2, o2) / 2) ? n2.RegisterCollision(i2, h2) : e = true, [e, t];
      }
      _TrackFloor(t, e, i2, s2) {
        const n2 = this._inst, h2 = this._runtime.GetCollisionEngine();
        if (t) {
          const s3 = this._downX, r2 = this._downY, o2 = this._rightX, l2 = this._rightY;
          if (this._doubleJumped = false, this._canDoubleJump = false, this._dy > 0 && (this._wasOnFloor || (h2.PushInFractional(n2, -s3, -r2, t, 16), this._wasOnFloor = true), this._dy = 0), this._lastFloorObject !== t) this._SetLastFloorObject(t), h2.RegisterCollision(n2, t);
          else if (e) {
            const t2 = h2.TestOverlapSolid(n2);
            t2 && (h2.RegisterCollision(n2, t2), 0 !== i2 && (i2 > 0 ? h2.PushOutSolid(n2, -o2, -l2) : h2.PushOutSolid(n2, o2, l2)), h2.PushOutSolid(n2, -s3, -r2));
          }
        } else s2 || (this._canDoubleJump = true);
      }
      _HandleJump(t, e, s2) {
        if (t && e || !t && this._enableDoubleJump && s2 && this._canDoubleJump && !this._doubleJumped) {
          const s3 = this._inst, n2 = s3.GetWorldInfo(), h2 = this._runtime.GetCollisionEngine(), r2 = n2.GetX(), o2 = n2.GetY();
          n2.OffsetXY(-this._downX, -this._downY), n2.SetBboxChanged(), h2.TestOverlapSolid(s3) ? e = false : (this._sustainTime = this._jumpSustain, this.Trigger(i.Behaviors.Platform.Cnds.OnJump), this._animMode = "jumping", this._dy = -this._jumpStrength, e = true, t ? this._jumped = true : this._doubleJumped = true), n2.SetXY(r2, o2), n2.SetBboxChanged();
        }
        return e;
      }
      _HandleAirTime(t, e, i2) {
        e && this._sustainTime > 0 ? (this._dy = -this._jumpStrength, this._sustainTime -= i2) : this._lastFloorObject = null, t && (this._jumped = true);
      }
      _CalculateHorizontalAcceleration(t, e) {
        let i2 = 0;
        const s2 = this._acc, n2 = this._dec;
        return t && !e && (i2 = this._dx > 0 ? -(s2 + n2) : -s2), e && !t && (i2 = this._dx < 0 ? s2 + n2 : s2), i2;
      }
      _ApplyHorizontalAcceleration(t, e, s2, n2) {
        const h2 = this._dec;
        t === e && (this._dx < 0 ? this._dx = Math.min(this._dx + h2 * n2, 0) : this._dx > 0 && (this._dx = Math.max(this._dx - h2 * n2, 0))), this._dx = i.clamp(this._dx + s2 * n2, -this._maxSpeed, this._maxSpeed);
        const r2 = this._runtime.GetCollisionEngine(), o2 = this._dx < 0 ? this._GetWallObstacle(0, 1, 1) : null;
        if (o2) this._dx = 0, r2.RegisterCollision(this._inst, o2);
        else {
          const t2 = this._dx > 0 ? this._GetWallObstacle(1, 1, 1) : null;
          t2 && (this._dx = 0, r2.RegisterCollision(this._inst, t2));
        }
      }
      _HandleHorizontalMovement(t, e, i2, s2) {
        const n2 = this._inst, h2 = n2.GetWorldInfo(), r2 = this._runtime.GetCollisionEngine(), o2 = this._downX, l2 = this._downY, a2 = this._rightX, _2 = this._rightY, u2 = this._maxSpeed;
        let d2 = false;
        const m2 = new Set(r2.TestOverlapJumpthru(n2, true));
        let p2 = h2.GetX(), g2 = h2.GetY();
        const c2 = accelerate(this._dx, -u2, u2, e, t) * a2, S2 = accelerate(this._dx, -u2, u2, e, t) * _2;
        h2.OffsetXY(a2 * (this._dx > 1 ? 1 : -1) - o2, _2 * (this._dx > 1 ? 1 : -1) - l2), h2.SetBboxChanged();
        let b = false;
        const f = r2.TestOverlapSolid(n2);
        h2.SetXY(p2 + c2, g2 + S2), h2.SetBboxChanged();
        let G = r2.TestOverlapSolid(n2);
        if (!G && i2 && this._floorIsJumpthru && (G = r2.TestOverlapJumpthru(n2), m2.has(G) ? G = null : b = true), G) {
          let e2 = Math.abs(this._dx * t) + 2;
          f || !r2.PushOutSolid(n2, -o2, -l2, e2, b, G) ? (r2.RegisterCollision(n2, G), e2 = Math.max(Math.abs(this._dx * t * 2.5), Math.floor(h2.GetWidth())), r2.PushOutSolid(n2, a2 * (this._dx < 0 ? 1 : -1), _2 * (this._dx < 0 ? 1 : -1), e2, false) ? !i2 || b || this._floorIsJumpthru || (p2 = h2.GetX(), g2 = h2.GetY(), h2.OffsetXY(o2, l2), r2.TestOverlapSolid(n2) && r2.PushOutSolid(n2, -o2, -l2, 3, false) || (h2.SetXY(p2, g2), h2.SetBboxChanged())) : (h2.SetXY(p2, g2), h2.SetBboxChanged()), b || (this._dx = 0)) : !f && !s2 && Math.abs(this._dy) < Math.abs(this._jumpStrength / 4) && (this._dy = 0, i2 || (d2 = true));
        } else {
          const e2 = this._IsOnFloor();
          if (i2 && !e2) {
            const e3 = Math.ceil(Math.abs(this._dx * t)) + 2;
            p2 = h2.GetX(), g2 = h2.GetY(), h2.OffsetXY(o2 * e3, l2 * e3), h2.SetBboxChanged();
            const s3 = r2.TestOverlapJumpthru(n2);
            let a3 = false;
            s3 && !m2.has(s3) && r2.PushOutSolid(n2, -o2, -l2, e3 + 2, true, s3) && (i2 = s3, this._SetLastFloorObject(s3), this._floorIsJumpthru = true, a3 = true), a3 || (r2.TestOverlapSolid(n2) ? r2.PushOutSolid(n2, -o2, -l2, e3 + 2, false) : (h2.SetXY(p2, g2), h2.SetBboxChanged()));
          } else e2 && (!i2 && this._floorIsJumpthru && (this._SetLastFloorObject(e2), this._dy = 0, d2 = true), 0 === this._dy && r2.PushInFractional(n2, -o2, -l2, e2, 16));
        }
        return [d2, i2];
      }
      _HandleVerticalMovement(t, e) {
        const s2 = this._inst, n2 = s2.GetWorldInfo(), h2 = this._runtime.GetCollisionEngine(), r2 = this._downX, o2 = this._downY;
        let l2 = false, a2 = n2.GetX(), _2 = n2.GetY();
        const u2 = accelerate(this._dy, -1 / 0, this._maxFall, this._g, t);
        if (this._dy < 0 && u2 > 0 && e) return this._dy = 0, [false, 0];
        n2.OffsetXY(u2 * r2, u2 * o2);
        const d2 = n2.GetX(), m2 = n2.GetY();
        n2.SetBboxChanged();
        let p2 = h2.TestOverlapSolid(s2), g2 = false;
        if (!p2 && this._dy > 0 && !e) {
          const t2 = this._IsFallThroughEnabled() ? h2.TestOverlapJumpthru(s2, true) : null;
          if (t2 && t2.length) {
            if (this._wasOverJumpthru) {
              n2.SetXY(a2, _2), n2.SetBboxChanged();
              let e2 = 0;
              for (let i2 = 0, n3 = t2.length; i2 < n3; ++i2) t2[e2] = t2[i2], h2.TestOverlap(s2, t2[i2]) || ++e2;
              i.truncateArray(t2, e2), n2.SetXY(d2, m2), n2.SetBboxChanged();
            }
            t2.length >= 1 && (p2 = t2[0]);
          }
          g2 = !!p2;
        }
        if (p2) {
          h2.RegisterCollision(s2, p2), this._sustainTime = 0;
          let e2 = 1.1;
          g2 && !this._wasOverJumpthru && (e2 = 2);
          const i2 = Math.max(Math.abs(this._dy * t * e2), 2);
          h2.PushOutSolid(s2, r2 * (this._dy < 0 ? 1 : -1), o2 * (this._dy < 0 ? 1 : -1), i2, g2, p2) ? (this._SetLastFloorObject(p2), this._floorIsJumpthru = g2, this._dy > 0 && (l2 = true), (this._dy > 0 || 0 === this._ceilingCollisionMode) && (this._dy = 0), this._dy < 0 && 1 === this._ceilingCollisionMode && h2.PushInFractional(s2, r2, o2, p2, 32)) : (n2.SetXY(a2, _2), n2.SetBboxChanged(), this._wasOnFloor = true, g2 || (this._dy = 0));
        }
        return [l2, u2];
      }
      _HandleAnimationTriggers(t, e, s2) {
        "falling" !== this._animMode && this._dy > 0 && !t && (this.Trigger(i.Behaviors.Platform.Cnds.OnFall), this._animMode = "falling"), (t || e) && this._dy >= 0 && ("falling" === this._animMode || e || s2 && 0 === this._dy ? (this.Trigger(i.Behaviors.Platform.Cnds.OnLand), 0 === this._dx && 0 === this._dy ? this._animMode = "stopped" : this._animMode = "moving") : ("stopped" !== this._animMode && 0 === this._dx && 0 === this._dy && (this.Trigger(i.Behaviors.Platform.Cnds.OnStop), this._animMode = "stopped"), "moving" === this._animMode || 0 === this._dx && 0 === this._dy || s2 || (this.Trigger(i.Behaviors.Platform.Cnds.OnMove), this._animMode = "moving")));
      }
      _IsMoving() {
        return 0 !== this._GetVectorX() || 0 !== this._GetVectorY();
      }
      _CheckIfStandingOnFloor() {
        if (0 !== this._dy) return false;
        const t = this._inst, e = this.GetWorldInfo(), i2 = this._runtime.GetCollisionEngine(), s2 = e.GetX(), n2 = e.GetY();
        e.OffsetXY(this._downX, this._downY), e.SetBboxChanged();
        const h2 = i2.TestOverlapSolid(t);
        let r2 = null;
        if (!h2 && this._IsFallThroughEnabled() && (r2 = i2.TestOverlapJumpthru(t, true)), e.SetXY(s2, n2), e.SetBboxChanged(), h2) return !i2.TestOverlap(t, h2);
        if (r2 && r2.length) {
          let e2 = 0;
          for (let s3 = 0, n3 = r2.length; s3 < n3; ++s3) r2[e2] = r2[s3], i2.TestOverlap(t, r2[s3]) || e2++;
          if (e2 >= 1) return true;
        }
        return false;
      }
      _IsByWall(t, e = 2, i2 = 3) {
        return !!this._GetWallObstacle(t, e, i2);
      }
      _GetWallObstacle(t, e = 2, i2 = 3) {
        const s2 = this._inst, n2 = this.GetWorldInfo(), h2 = this._runtime.GetCollisionEngine(), r2 = n2.GetX(), o2 = n2.GetY();
        if (0 === t ? n2.OffsetXY(-this._rightX * e, -this._rightY * e) : n2.OffsetXY(this._rightX * e, this._rightY * e), n2.SetBboxChanged(), !h2.TestOverlapSolid(s2)) return n2.SetXY(r2, o2), n2.SetBboxChanged(), null;
        n2.OffsetXY(-this._downX * i2, -this._downY * i2), n2.SetBboxChanged();
        const l2 = h2.TestOverlapSolid(s2);
        return n2.SetXY(r2, o2), n2.SetBboxChanged(), l2;
      }
      _FallThroughJumpThru() {
        const t = this.GetWorldInfo(), e = t.GetX(), i2 = t.GetY();
        t.OffsetXY(this._downX, this._downY), t.SetBboxChanged();
        const s2 = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst, false);
        t.SetXY(e, i2), t.SetBboxChanged(), s2 && (this._fallThroughTime = this._runtime.GetGameTime(), this._lastFloorObject = null);
      }
      _ResetDoubleJump(t) {
        this._doubleJumped = !t;
      }
      _GetSpeed() {
        return Math.hypot(this._dx, this._dy);
      }
      _GetMovingAngle() {
        return Math.atan2(this._dy, this._dx);
      }
      _IsJumping() {
        return this._dy < 0;
      }
      _IsFalling() {
        return this._dy > 0;
      }
      _SetMaxSpeed(t) {
        this._maxSpeed = Math.max(t, 0);
      }
      _GetMaxSpeed() {
        return this._maxSpeed;
      }
      _SetAcceleration(t) {
        this._acc = Math.max(t, 0);
      }
      _GetAcceleration() {
        return this._acc;
      }
      _SetDeceleration(t) {
        this._dec = Math.max(t, 0);
      }
      _GetDeceleration() {
        return this._dec;
      }
      _SetJumpStrength(t) {
        this._jumpStrength = Math.max(t, 0);
      }
      _GetJumpStrength() {
        return this._jumpStrength;
      }
      _SetMaxFallSpeed(t) {
        this._maxFall = Math.max(t, 0);
      }
      _GetMaxFallSpeed() {
        return this._maxFall;
      }
      _SetGravity(t) {
        if (this._g1 === t) return;
        this._g = t, this._UpdateGravity();
        const e = this._runtime.GetCollisionEngine(), i2 = this.GetWorldInfo();
        e.TestOverlapSolid(this._inst) && (e.PushOutSolid(this._inst, this._downX, this._downY, 10), i2.OffsetXY(2 * this._downX, 2 * this._downY), i2.SetBboxChanged()), this._lastFloorObject = null;
      }
      _GetGravity() {
        return this._g;
      }
      _SetGravityAngle(t) {
        t = i.clampAngle(t), this._ga !== t && (this._ga = t, this._UpdateGravity(), this._lastFloorObject = null);
      }
      _GetGravityAngle() {
        return this._ga;
      }
      _SetDoubleJumpEnabled(t) {
        this._enableDoubleJump = !!t;
      }
      _IsDoubleJumpEnabled() {
        return this._enableDoubleJump;
      }
      _SetJumpSustain(t) {
        this._jumpSustain = t;
      }
      _GetJumpSustain() {
        return this._jumpSustain;
      }
      _SetCeilingCollisionMode(t) {
        this._ceilingCollisionMode = t;
      }
      _GetCeilingCollisionMode() {
        return this._ceilingCollisionMode;
      }
      _SetVectorX(t) {
        this._dx = t;
      }
      _GetVectorX() {
        return this._dx;
      }
      _SetVectorY(t) {
        this._dy = t;
      }
      _GetVectorY() {
        return this._dy;
      }
      _SimulateControl(t) {
        if (this._isEnabled) switch (t) {
          case 0:
            this._simLeft = true;
            break;
          case 1:
            this._simRight = true;
            break;
          case 2:
            this._simJump = true;
        }
      }
      _SetDefaultControls(t) {
        t = !!t, this._defaultControls !== t && (this._defaultControls = t, this._defaultControls ? this._BindEvents() : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()));
      }
      _IsDefaultControls() {
        return this._defaultControls;
      }
      _SetIgnoreInput(t) {
        this._ignoreInput = !!t;
      }
      _IsIgnoreInput() {
        return this._ignoreInput;
      }
      _SetEnabled(t) {
        t = !!t, this._isEnabled !== t && (this._isEnabled = t, this._isEnabled ? this._StartPostTicking() : (this._StopPostTicking(), this._lastFloorObject = null, this._simLeft = false, this._simRight = false, this._simJump = false));
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      GetPropertyValueByIndex(t) {
        switch (t) {
          case h:
            return this._GetMaxSpeed();
          case r:
            return this._GetAcceleration();
          case o:
            return this._GetDeceleration();
          case l:
            return this._GetJumpStrength();
          case a:
            return this._GetGravity();
          case _:
            return this._GetMaxFallSpeed();
          case u:
            return this._IsDoubleJumpEnabled();
          case d:
            return 1e3 * this._GetJumpSustain();
          case m:
            return this._IsDefaultControls();
          case p:
            return this._IsEnabled();
        }
      }
      SetPropertyValueByIndex(t, e) {
        switch (t) {
          case h:
            this._SetMaxSpeed(e);
            break;
          case r:
            this._SetAcceleration(e);
            break;
          case o:
            this._SetDeceleration(e);
            break;
          case l:
            this._SetJumpStrength(e);
            break;
          case a:
            this._SetGravity(e);
            break;
          case _:
            this._SetMaxFallSpeed(e);
            break;
          case u:
            this._SetDoubleJumpEnabled(!!e);
            break;
          case d:
            this._SetJumpSustain(e / 1e3);
            break;
          case m:
            this._SetDefaultControls(!!e);
            break;
          case p:
            this._SetEnabled(!!e);
        }
      }
      GetDebuggerProperties() {
        const t = "behaviors.platform";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t + ".debugger.vector-x", value: this._GetVectorX(), onedit: (t2) => this._SetVectorX(t2) }, { name: t + ".debugger.vector-y", value: this._GetVectorY(), onedit: (t2) => this._SetVectorY(t2) }, { name: t + ".properties.max-speed.name", value: this._GetMaxSpeed(), onedit: (t2) => this._SetMaxSpeed(t2) }, { name: t + ".properties.acceleration.name", value: this._GetAcceleration(), onedit: (t2) => this._SetAcceleration(t2) }, { name: t + ".properties.deceleration.name", value: this._GetDeceleration(), onedit: (t2) => this._SetDeceleration(t2) }, { name: t + ".properties.jump-strength.name", value: this._GetJumpStrength(), onedit: (t2) => this._SetJumpStrength(t2) }, { name: t + ".properties.gravity.name", value: this._GetGravity(), onedit: (t2) => this._SetGravity(t2) }, { name: t + ".debugger.gravity-angle", value: i.toDegrees(this._GetGravityAngle()), onedit: (t2) => this._SetGravityAngle(i.toRadians(t2)) }, { name: t + ".properties.max-fall-speed.name", value: this._GetMaxFallSpeed(), onedit: (t2) => this._SetMaxFallSpeed(t2) }, { name: t + ".properties.double-jump.name", value: this._IsDoubleJumpEnabled(), onedit: (t2) => this._SetDoubleJumpEnabled(t2) }, { name: t + ".properties.jump-sustain.name", value: 1e3 * this._GetJumpSustain(), onedit: (t2) => this._SetJumpSustain(t2 / 1e3) }, { name: t + ".debugger.animation-mode", value: [t + ".debugger.anim-" + this._animMode] }, { name: t + ".properties.enabled.name", value: this._IsEnabled(), onedit: (t2) => this._SetEnabled(t2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IPlatformBehaviorInstance;
      }
    };
    const c = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new Map([["left", 0], ["right", 1], ["jump", 2]]);
    self.IPlatformBehaviorInstance = class extends n {
      constructor() {
        super(), c.set(this, n._GetInitInst().GetSdkInstance());
      }
      fallThrough() {
        c.get(this)._FallThroughJumpThru();
      }
      resetDoubleJump(t) {
        c.get(this)._ResetDoubleJump(!!t);
      }
      simulateControl(t) {
        s.RequireString(t);
        const e = S.get(t);
        if ("number" != typeof e) throw new Error("invalid control");
        c.get(this)._SimulateControl(e);
      }
      get speed() {
        return c.get(this)._GetSpeed();
      }
      get maxSpeed() {
        return c.get(this)._GetMaxSpeed();
      }
      set maxSpeed(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetMaxSpeed(t);
      }
      get acceleration() {
        return c.get(this)._GetAcceleration();
      }
      set acceleration(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetAcceleration(t);
      }
      get deceleration() {
        return c.get(this)._GetDeceleration();
      }
      set deceleration(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetDeceleration(t);
      }
      get jumpStrength() {
        return c.get(this)._GetJumpStrength();
      }
      set jumpStrength(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetJumpStrength(t);
      }
      get maxFallSpeed() {
        return c.get(this)._GetMaxFallSpeed();
      }
      set maxFallSpeed(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetMaxFallSpeed(t);
      }
      get gravity() {
        return c.get(this)._GetGravity();
      }
      set gravity(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetGravity(t);
      }
      get gravityAngle() {
        return c.get(this)._GetGravityAngle();
      }
      set gravityAngle(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetGravityAngle(t);
      }
      get isDoubleJumpEnabled() {
        return c.get(this)._IsDoubleJumpEnabled();
      }
      set isDoubleJumpEnabled(t) {
        c.get(this)._SetDoubleJumpEnabled(!!t);
      }
      get jumpSustain() {
        return c.get(this)._GetJumpSustain();
      }
      set jumpSustain(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetJumpSustain(t);
      }
      get ceilingCollisionMode() {
        return 0 === c.get(this)._GetCeilingCollisionMode() ? "stop" : "preserve-momentum";
      }
      set ceilingCollisionMode(t) {
        s.RequireString(t);
        const e = c.get(this);
        if ("stop" === t) e._SetCeilingCollisionMode(0);
        else {
          if ("preserve-momentum" !== t) throw new Error("invalid mode");
          e._SetCeilingCollisionMode(1);
        }
      }
      get isOnFloor() {
        return c.get(this)._CheckIfStandingOnFloor();
      }
      isByWall(t) {
        s.RequireString(t);
        const e = c.get(this);
        if ("left" === t) return e._IsByWall(0);
        if ("right" === t) return e._IsByWall(1);
        throw new Error("invalid side");
      }
      get isMoving() {
        return c.get(this)._IsMoving();
      }
      get isJumping() {
        return c.get(this)._IsJumping();
      }
      get isFalling() {
        return c.get(this)._IsFalling();
      }
      get vectorX() {
        return c.get(this)._GetVectorX();
      }
      set vectorX(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetVectorX(t);
      }
      get vectorY() {
        return c.get(this)._GetVectorY();
      }
      set vectorY(t) {
        s.RequireFiniteNumber(t), c.get(this)._SetVectorY(t);
      }
      setVector(t, e) {
        s.RequireFiniteNumber(t), s.RequireFiniteNumber(e);
        const i2 = c.get(this);
        i2._SetVectorX(t), i2._SetVectorY(e);
      }
      getVector() {
        const t = c.get(this);
        return [t._GetVectorX(), t._GetVectorY()];
      }
      get isDefaultControls() {
        return c.get(this)._IsDefaultControls();
      }
      set isDefaultControls(t) {
        c.get(this)._SetDefaultControls(!!t);
      }
      get isIgnoringInput() {
        return c.get(this)._IsIgnoreInput();
      }
      set isIgnoringInput(t) {
        c.get(this)._SetIgnoreInput(!!t);
      }
      get isEnabled() {
        return c.get(this)._IsEnabled();
      }
      set isEnabled(t) {
        c.get(this)._SetEnabled(!!t);
      }
    };
  }
  {
    const b = self.C3;
    b.Behaviors.Platform.Cnds = { IsMoving() {
      return this._IsMoving();
    }, CompareSpeed(t, e) {
      return b.compare(this._GetSpeed(), t, e);
    }, IsOnFloor() {
      return this._CheckIfStandingOnFloor();
    }, IsByWall(t) {
      return this._IsByWall(t);
    }, IsJumping() {
      return this._IsJumping();
    }, IsFalling() {
      return this._IsFalling();
    }, IsDoubleJumpEnabled() {
      return this._IsDoubleJumpEnabled();
    }, OnJump: () => true, OnFall: () => true, OnStop: () => true, OnMove: () => true, OnLand: () => true, IsEnabled() {
      return this._IsEnabled();
    } };
  }
  {
    const f = self.C3;
    f.Behaviors.Platform.Acts = { SetMaxSpeed(t) {
      this._SetMaxSpeed(t);
    }, SetAcceleration(t) {
      this._SetAcceleration(t);
    }, SetDeceleration(t) {
      this._SetDeceleration(t);
    }, SetJumpStrength(t) {
      this._SetJumpStrength(t);
    }, SetMaxFallSpeed(t) {
      this._SetMaxFallSpeed(t);
    }, SetGravity(t) {
      this._SetGravity(t);
    }, SimulateControl(t) {
      this._SimulateControl(t);
    }, SetIgnoreInput(t) {
      this._SetIgnoreInput(!!t);
    }, SetVectorX(t) {
      this._SetVectorX(t);
    }, SetVectorY(t) {
      this._SetVectorY(t);
    }, SetGravityAngle(t) {
      this._SetGravityAngle(f.toRadians(t));
    }, SetEnabled(t) {
      this._SetEnabled(0 !== t);
    }, FallThrough() {
      this._FallThroughJumpThru();
    }, SetDoubleJumpEnabled(t) {
      this._SetDoubleJumpEnabled(0 !== t);
    }, SetJumpSustain(t) {
      this._SetJumpSustain(t / 1e3);
    }, SetCeilingCollision(t) {
      this._SetCeilingCollisionMode(t);
    }, SetDefaultControls(t) {
      this._SetDefaultControls(t);
    }, ResetDoubleJump(t) {
      this._ResetDoubleJump(t);
    } };
  }
  {
    const G = self.C3;
    G.Behaviors.Platform.Exps = { Speed() {
      return this._GetSpeed();
    }, MaxSpeed() {
      return this._GetMaxSpeed();
    }, Acceleration() {
      return this._GetAcceleration();
    }, Deceleration() {
      return this._GetDeceleration();
    }, JumpStrength() {
      return this._GetJumpStrength();
    }, Gravity() {
      return this._GetGravity();
    }, GravityAngle() {
      return G.toDegrees(this._GetGravityAngle());
    }, MaxFallSpeed() {
      return this._GetMaxFallSpeed();
    }, MovingAngle() {
      return G.toDegrees(this._GetMovingAngle());
    }, VectorX() {
      return this._GetVectorX();
    }, VectorY() {
      return this._GetVectorY();
    }, JumpSustain() {
      return 1e3 * this._GetJumpSustain();
    } };
  }
}
var accelerate2;
{
  {
    const e = self.C3;
    e.Behaviors.Sin = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Sin.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t = self.C3X, i = self.IBehaviorInstance, s = 0, a = 1, n = 2, h = 3, _ = 4, r = 5, o = 6, l = 7, u = 8, d = 0, m = 1, g = 2, v = 3, c = 4, p = 5, G = 6, b = 7, S = 8, V = 9, w = 0, P = 1, M = 2, I = 3, f = 4, k = 2 * Math.PI, W = Math.PI / 2, E = 3 * Math.PI / 2, R = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
    e.Behaviors.Sin.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(t2, i2) {
        super(t2), this._i = 0, this._movement = 0, this._wave = 0, this._period = 0, this._mag = 0, this._isEnabled = true, this._basePeriod = 0, this._basePeriodOffset = 0, this._baseMag = 0, this._periodRandom = 0, this._periodOffsetRandom = 0, this._magnitudeRandom = 0, this._initialValue = 0, this._initialValue2 = 0, this._lastKnownValue = 0, this._lastKnownValue2 = 0, this._ratio = 0, i2 && (this._movement = R[i2[s]], this._wave = i2[a], this._periodRandom = this._runtime.Random() * i2[h], this._basePeriod = i2[n], this._period = i2[n], this._period += this._periodRandom, this._basePeriodOffset = i2[_], 0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * i2[r], this._i = i2[_] / this._period * k, this._i += this._periodOffsetRandom / this._period * k), this._magnitudeRandom = this._runtime.Random() * i2[l], this._baseMag = i2[o], this._mag = i2[o], this._mag += this._magnitudeRandom, this._isEnabled = !!i2[u]), this._movement === p && (this._mag = e.toRadians(this._mag)), this.Init(), this._isEnabled && this._StartTicking();
      }
      Release() {
        super.Release();
      }
      SaveToJson() {
        return { "i": this._i, "e": this._isEnabled, "mv": this._movement, "w": this._wave, "p": this._period, "mag": this._mag, "iv": this._initialValue, "iv2": this._initialValue2, "r": this._ratio, "lkv": this._lastKnownValue, "lkv2": this._lastKnownValue2 };
      }
      LoadFromJson(e2) {
        this._i = e2["i"], this._SetEnabled(e2["e"]), this._movement = e2["mv"], this._wave = e2["w"], this._period = e2["p"], this._mag = e2["mag"], this._initialValue = e2["iv"], this._initialValue2 = e2["iv2"], this._ratio = e2["r"], this._lastKnownValue = e2["lkv"], this._lastKnownValue2 = e2["lkv2"];
      }
      Init() {
        const e2 = this._inst.GetWorldInfo();
        switch (this._movement) {
          case d:
            this._initialValue = e2.GetX();
            break;
          case m:
            this._initialValue = e2.GetY();
            break;
          case g:
            this._initialValue = e2.GetWidth(), this._ratio = e2.GetHeight() / e2.GetWidth();
            break;
          case v:
            this._initialValue = e2.GetWidth();
            break;
          case c:
            this._initialValue = e2.GetHeight();
            break;
          case p:
            this._initialValue = e2.GetAngle();
            break;
          case G:
            this._initialValue = e2.GetOpacity();
            break;
          case b:
            this._initialValue = 0;
            break;
          case S:
            this._initialValue = e2.GetX(), this._initialValue2 = e2.GetY();
            break;
          case V:
            this._initialValue = e2.GetZElevation();
        }
        this._lastKnownValue = this._initialValue, this._lastKnownValue2 = this._initialValue2;
      }
      WaveFunc(e2) {
        switch (e2 %= k, this._wave) {
          case w:
            return Math.sin(e2);
          case P:
            return e2 <= W ? e2 / W : e2 <= E ? 1 - 2 * (e2 - W) / Math.PI : (e2 - E) / W - 1;
          case M:
            return 2 * e2 / k - 1;
          case I:
            return -2 * e2 / k + 1;
          case f:
            return e2 < Math.PI ? -1 : 1;
        }
        return 0;
      }
      Tick() {
        const e2 = this._runtime.GetDt(this._inst);
        this._isEnabled && 0 !== e2 && (0 === this._period ? this._i = 0 : this._i = (this._i + e2 / this._period * k) % k, this._UpdateFromPhase());
      }
      _UpdateFromPhase() {
        const t2 = this._inst.GetWorldInfo();
        switch (this._movement) {
          case d:
            t2.GetX() !== this._lastKnownValue && (this._initialValue += t2.GetX() - this._lastKnownValue), t2.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t2.GetX();
            break;
          case m:
            t2.GetY() !== this._lastKnownValue && (this._initialValue += t2.GetY() - this._lastKnownValue), t2.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t2.GetY();
            break;
          case g:
            t2.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag), t2.SetHeight(t2.GetWidth() * this._ratio);
            break;
          case v:
            t2.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
          case c:
            t2.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
          case p:
            t2.GetAngle() !== this._lastKnownValue && (this._initialValue = e.clampAngle(this._initialValue + (t2.GetAngle() - this._lastKnownValue))), t2.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t2.GetAngle();
            break;
          case G:
            t2.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
            break;
          case S:
            t2.GetX() !== this._lastKnownValue && (this._initialValue += t2.GetX() - this._lastKnownValue), t2.GetY() !== this._lastKnownValue2 && (this._initialValue2 += t2.GetY() - this._lastKnownValue2), t2.SetX(this._initialValue + Math.cos(t2.GetAngle()) * this.WaveFunc(this._i) * this._mag), t2.SetY(this._initialValue2 + Math.sin(t2.GetAngle()) * this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t2.GetX(), this._lastKnownValue2 = t2.GetY();
            break;
          case V:
            t2.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag);
        }
        t2.SetBboxChanged();
      }
      _OnSpriteFrameChanged(e2, t2) {
      }
      _SetPeriod(e2) {
        this._period = e2;
      }
      _GetPeriod() {
        return this._period;
      }
      _SetMagnitude(e2) {
        this._mag = e2;
      }
      _SetMagnitude_ConvertAngle(t2) {
        5 === this._movement && (t2 = e.toRadians(t2)), this._SetMagnitude(t2);
      }
      _GetMagnitude() {
        return this._mag;
      }
      _GetMagnitude_ConvertAngle() {
        let t2 = this._GetMagnitude();
        return 5 === this._movement && (t2 = e.toDegrees(t2)), t2;
      }
      _SetMovement(t2) {
        5 === this._movement && 5 !== t2 && (this._mag = e.toDegrees(this._mag)), this._movement = t2, this.Init();
      }
      _GetMovement() {
        return this._movement;
      }
      _SetWave(e2) {
        this._wave = e2;
      }
      _GetWave() {
        return this._wave;
      }
      _SetPhase(t2) {
        this._i = e.clamp(t2, 0, 2 * Math.PI), this._UpdateFromPhase();
      }
      _GetPhase() {
        return this._i;
      }
      _SetEnabled(e2) {
        this._isEnabled = !!e2, this._isEnabled ? this._StartTicking() : this._StopTicking();
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      GetPropertyValueByIndex(e2) {
        switch (e2) {
          case s:
            return this._movement;
          case a:
            return this._wave;
          case n:
            return this._basePeriod;
          case o:
            return this._baseMag;
          case u:
            return this._isEnabled;
        }
      }
      SetPropertyValueByIndex(t2, i2) {
        switch (t2) {
          case s:
            this._movement = R[i2], this.Init();
            break;
          case a:
            this._wave = i2;
            break;
          case n:
            this._basePeriod = i2, this._period = this._basePeriod + this._periodRandom, this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * k, this._i += this._periodOffsetRandom / this._period * k) : this._i = 0);
            break;
          case o:
            this._baseMag = i2, this._mag = this._baseMag + this._magnitudeRandom, this._movement === p && (this._mag = e.toRadians(this._mag));
            break;
          case u:
            this._isEnabled = !!i2;
        }
      }
      GetDebuggerProperties() {
        const e2 = "behaviors.sin";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e3) => this._SetEnabled(e3) }, { name: e2 + ".properties.period.name", value: this._GetPeriod(), onedit: (e3) => this._SetPeriod(e3) }, { name: e2 + ".properties.magnitude.name", value: this._GetMagnitude_ConvertAngle(), onedit: (e3) => this._SetMagnitude_ConvertAngle(e3) }, { name: e2 + ".debugger.value", value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle() }] }];
      }
      GetScriptInterfaceClass() {
        return self.ISineBehaviorInstance;
      }
    };
    const C = /* @__PURE__ */ new WeakMap(), K = ["horizontal", "vertical", "size", "width", "height", "angle", "opacity", "value-only", "forwards-backwards", "z-elevation"], F = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
    self.ISineBehaviorInstance = class extends i {
      constructor() {
        super(), C.set(this, i._GetInitInst().GetSdkInstance());
      }
      set period(e2) {
        t.RequireFiniteNumber(e2), C.get(this)._SetPeriod(e2);
      }
      get period() {
        return C.get(this)._GetPeriod();
      }
      set magnitude(e2) {
        t.RequireFiniteNumber(e2), C.get(this)._SetMagnitude(e2);
      }
      get magnitude() {
        return C.get(this)._GetMagnitude();
      }
      set phase(e2) {
        C.get(this)._SetPhase(e2);
      }
      get phase() {
        return C.get(this)._GetPhase();
      }
      set movement(e2) {
        t.RequireString(e2);
        const i2 = K.indexOf(e2);
        if (-1 === i2) throw new Error("invalid movement");
        C.get(this)._SetMovement(i2);
      }
      get movement() {
        return K[C.get(this)._GetMovement()];
      }
      set wave(e2) {
        t.RequireString(e2);
        const i2 = F.indexOf(e2);
        if (-1 === i2) throw new Error("invalid wave");
        C.get(this)._SetWave(i2);
      }
      get wave() {
        return F[C.get(this)._GetWave()];
      }
      get value() {
        const e2 = C.get(this);
        return e2.WaveFunc(e2._GetPhase()) * e2._GetMagnitude();
      }
      updateInitialState() {
        C.get(this).Init();
      }
      set isEnabled(e2) {
        C.get(this)._SetEnabled(!!e2);
      }
      get isEnabled() {
        return C.get(this)._IsEnabled();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Sin.Cnds = { IsEnabled() {
      return this._IsEnabled();
    }, CompareMovement(e2) {
      return this._GetMovement() === e2;
    }, ComparePeriod(t, i) {
      return e.compare(this._GetPeriod(), t, i);
    }, CompareMagnitude(t, i) {
      return e.compare(this._GetMagnitude_ConvertAngle(), t, i);
    }, CompareWave(e2) {
      return this._GetWave() === e2;
    } };
  }
  self.C3.Behaviors.Sin.Acts = { SetEnabled(e) {
    this._SetEnabled(0 !== e);
  }, SetPeriod(e) {
    this._SetPeriod(e);
  }, SetMagnitude(e) {
    this._SetMagnitude_ConvertAngle(e);
  }, SetMovement(e) {
    this._SetMovement(e);
  }, SetWave(e) {
    this._wave = e;
  }, SetPhase(e) {
    const t = 2 * Math.PI;
    this._SetPhase(e * t % t);
  }, UpdateInitialState() {
    this.Init();
  } };
  self.C3.Behaviors.Sin.Exps = { CyclePosition() {
    return this._GetPhase() / (2 * Math.PI);
  }, Period() {
    return this._GetPeriod();
  }, Magnitude() {
    return this._GetMagnitude_ConvertAngle();
  }, Value() {
    return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle();
  } };
}
{
  {
    const e = self.C3;
    e.Behaviors.Tween = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Tween.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, s = e.Behaviors.Tween, t = 0;
    s.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(e2, s2) {
        super(e2), this._allowMultiple = false, this._enabled = true, s2 && (this._allowMultiple = false, this._enabled = !!s2[t]), this._activeTweens = /* @__PURE__ */ new Map(), this._disabledTweens = [], this._waitingForReleaseTweens = /* @__PURE__ */ new Map(), this._finishingTween = null, this._activeTweensJson = null, this._disabledTweensJson = null, this._waitingForReleaseTweensJson = null, this._finishingTweenName = "", this._triggerTweens = [], this._afterLoad = (e3) => this._OnAfterLoad(), this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad);
      }
      Release() {
        this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad), this._afterLoad = null, this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween), this._finishingTween = null), this.ReleaseAndCompleteTweens(), this._tweens = null, this.ClearDisabledList(), this._disabledTweens = null, this._ReleaseWaitingTweens(), this._waitingForReleaseTweens = null, this._triggerTweens = null, super.Release();
      }
      PushTriggerTween(e2) {
        this._triggerTweens.push(e2);
      }
      PopTriggerTween() {
        this._triggerTweens.pop();
      }
      GetTriggerTween() {
        return this._triggerTweens[this._triggerTweens.length - 1];
      }
      SetEnabled(e2) {
        this._enabled = !!e2, e2 ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();
        for (const s2 of this.AllTweens()) e2 ? this.IsInDisabledList(s2) && s2.Resume() : ((s2.IsPlaying() || s2.IsScheduled()) && this.AddToDisabledList(s2), s2.Stop());
        e2 && this.ClearDisabledList();
      }
      IsEnabled() {
        return this._enabled;
      }
      AddToDisabledList(e2) {
        this._disabledTweens.push(e2);
      }
      IsInDisabledList(e2) {
        return this._disabledTweens.includes(e2);
      }
      ClearDisabledList() {
        e.clearArray(this._disabledTweens);
      }
      GetFinishingTween() {
        return this._finishingTween;
      }
      IsInstanceValid() {
        const e2 = this.GetObjectInstance();
        return !!e2 && !e2.IsDestroyed();
      }
      GetTween(e2, s2, t2 = false) {
        const n = s2 ? this.PropertyTweens(s2, t2) : this.AllTweens(t2);
        if (n && n.length) {
          for (const s3 of n) if (s3.HasTags(e2)) return s3;
        }
      }
      CheckTweensWithTags(e2, s2) {
        for (const t2 of this._activeTweens.values()) for (const n of t2) if (!n.IsReleased() && n.HasTags(e2) && s2(n)) return true;
        for (const t2 of this._waitingForReleaseTweens.values()) for (const n of t2) if (!n.IsReleased() && n.HasTags(e2) && s2(n)) return true;
        return false;
      }
      CheckTweens(e2) {
        for (const s2 of this._activeTweens.values()) for (const t2 of s2) if (!t2.IsReleased() && e2(t2)) return true;
        for (const s2 of this._waitingForReleaseTweens.values()) for (const t2 of s2) if (!t2.IsReleased() && e2(t2)) return true;
        return false;
      }
      GetTweenIncludingWaitingForRelease(e2, s2) {
        return this.GetTween(e2, s2, true);
      }
      *GetTweens(e2, s2, t2 = false) {
        const n = s2 ? this.PropertyTweens(s2, t2) : this.AllTweens(t2);
        if (n && n.length) for (const s3 of n) s3.HasTags(e2) && (yield s3);
      }
      *GetTweensIncludingWaitingForRelease(e2, s2) {
        yield* this.GetTweens(e2, s2, true);
      }
      PropertyTweens(e2, s2) {
        if (s2) {
          let s3 = this._activeTweens.get(e2), t2 = this._waitingForReleaseTweens.get(e2);
          return s3 || (s3 = []), t2 || (t2 = []), s3.concat(t2).filter((e3) => e3).filter((e3) => !e3.IsReleased());
        }
        {
          let s3 = this._activeTweens.get(e2);
          return s3 || (s3 = []), s3.filter((e3) => e3).filter((e3) => !e3.IsReleased());
        }
      }
      AllTweens(e2) {
        if (e2) {
          const e3 = [...this._activeTweens.values()].flat(), s2 = [...this._waitingForReleaseTweens.values()].flat();
          return e3.concat(s2).filter((e4) => e4).filter((e4) => !e4.IsReleased());
        }
        return [...this._activeTweens.values()].flat().filter((e3) => e3).filter((e3) => !e3.IsReleased());
      }
      AllTweensIncludingWaitingForRelease() {
        return this.AllTweens(true);
      }
      SaveToJson(e2 = "full") {
        return { "s": false, "e": !!this._enabled, "at": this._SaveActiveTweensToJson(), "dt": this._SaveDisabledTweensToJson(), "wt": this._SaveWaitingForReleaseTweensToJson(), "ft": this._SaveFinishingTweenToJson() };
      }
      LoadFromJson(e2, s2 = "full") {
        e2 && (this._activeTweensJson = e2["at"], this._disabledTweensJson = e2["dt"], this._waitingForReleaseTweensJson = e2["wt"], this._finishingTweenName = e2["ft"], this._allowMultiple = false, this._enabled = !!e2["e"], "state" === s2 && this._OnAfterLoad());
      }
      _OnAfterLoad() {
        const s2 = this.GetRuntime().GetTimelineManager();
        if (this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, s2), this._disabledTweensJson) {
          e.clearArray(this._disabledTweens);
          for (const e2 of this._disabledTweensJson) this._PopulateTweenArray(this._disabledTweens, e2, s2);
        }
        this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, s2), this._finishingTween = this._GetTween(this._finishingTweenName, s2), this._enabled ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();
      }
      _PopulateTweenMap(s2, t2, n) {
        if (s2) for (const i in s2) {
          let a = t2.get(i);
          a ? e.clearArray(a) : a = [];
          const r = s2[i];
          for (const s3 of r) {
            if (this._PopulateTweenArray(a, s3["name"], n)) this._LoadTweenFromJson(s3["name"], s3, n);
            else {
              const t3 = e.TweenState.Build({ runtime: this.GetRuntime(), json: s3 });
              e.TweenState.SetInstanceUID(t3, this.GetObjectInstance().GetUID()), t3.AddCompletedCallback((e2) => this._FinishTriggers(e2)), t3.SetBehaviorInstance(this), n.AddScheduledTimeline(t3), this._PopulateTweenArray(a, t3, n);
            }
          }
          t2.set(i, a);
        }
      }
      _GetTween(e2, s2) {
        return s2.GetScheduledOrPlayingTimelineByName(e2);
      }
      _PopulateTweenArray(e2, s2, t2) {
        if ("string" != typeof s2) return !!e2.push(s2);
        {
          const n = this._GetTween(s2, t2);
          if (n) return !!e2.push(n);
        }
        return false;
      }
      _LoadTweenFromJson(s2, t2, n) {
        if ("string" == typeof s2) {
          const i = this._GetTween(s2, n);
          i && (i._LoadFromJson(t2), e.TweenState.SetInstanceUID(i, this.GetObjectInstance().GetUID()), e.TweenState.SetBehaviorInstance(i, this));
        } else s2._LoadFromJson(t2), e.TweenState.SetInstanceUID(s2, this.GetObjectInstance().GetUID()), e.TweenState.SetBehaviorInstance(s2, this);
      }
      _SaveActiveTweensToJson() {
        const e2 = {};
        for (const [s2, t2] of this._activeTweens) e2[s2] = t2.filter((e3) => !e3.IsReleased()).map((e3) => e3._SaveToJson());
        return e2;
      }
      _SaveDisabledTweensToJson() {
        return this._disabledTweens.filter((e2) => !e2.IsReleased()).map((e2) => e2.GetName());
      }
      _SaveWaitingForReleaseTweensToJson() {
        const e2 = {};
        for (const [s2, t2] of this._waitingForReleaseTweens) e2[s2] = t2.map((e3) => e3._SaveToJson());
        return e2;
      }
      _SaveFinishingTweenToJson() {
        return this._finishingTween ? this._finishingTween.GetName() : "";
      }
      Tick2() {
        this._ReleaseWaitingTweens();
      }
      CreateTween(t2) {
        const n = s.Config.GetPropertyTracksConfig(t2.property, t2.startValue, t2.endValue, t2.ease, t2.resultMode, this.GetObjectInstance()), i = s.Maps.GetPropertyFromIndex(t2.property);
        s.Maps.IsValueId(i) || this.ReleaseTweens(t2.property);
        const a = e.TweenState.Build({ runtime: this.GetRuntime(), id: i, tags: t2.tags, time: t2.time, instance: this.GetObjectInstance(), releaseOnComplete: !!t2.releaseOnComplete, loop: !!t2.loop, pingPong: !!t2.pingPong, repeatCount: t2.repeatCount, initialValueMode: t2.initialValueMode, propertyTracksConfig: n });
        return a.AddCompletedCallback((e2) => this._FinishTriggers(e2)), a.SetBehaviorInstance(this), this._AddTween(a, t2.property), a;
      }
      _MaybeRemoveFromActiveTweenMap(e2) {
        const s2 = e2.GetId();
        if (this._activeTweens.has(s2)) {
          const t2 = this._activeTweens.get(s2);
          if (t2) {
            const s3 = t2.indexOf(e2);
            -1 !== s3 && t2.splice(s3, 1);
          }
        }
      }
      ReleaseTween(e2, s2 = false) {
        this._MaybeRemoveFromActiveTweenMap(e2), e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(s2), this._AddToWaitingList(e2));
      }
      ReleaseTweens(t2, n = false) {
        if (e.IsFiniteNumber(t2)) {
          const i = s.Maps.GetPropertyFromIndex(t2);
          if (!this._activeTweens.has(i)) return;
          const a = this._activeTweens.get(i), r = this.GetFinishingTween();
          for (const e2 of a) e2 !== r && (e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(n), e2.Release()));
          e.clearArray(a);
        } else {
          const s2 = this.GetFinishingTween();
          for (const e2 of this.AllTweens()) e2 !== s2 && (e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(n), e2.Release()));
          for (const s3 of this._activeTweens.keys()) e.clearArray(this._activeTweens.get(s3)), this._activeTweens.delete(s3);
          this._activeTweens.clear();
        }
      }
      ReleaseAndCompleteTween(e2) {
        this.ReleaseTween(e2, true);
      }
      ReleaseAndCompleteTweens() {
        this.ReleaseTweens(NaN, true);
      }
      GetPropertyValueByIndex(e2) {
        if (e2 === t) return this._enabled;
      }
      SetPropertyValueByIndex(e2, s2) {
        if (e2 === t) this._enabled = !!s2;
      }
      _GetBehaviorType(e2) {
        const s2 = e2.GetInstance().GetBehaviorInstances();
        for (const e3 of s2) {
          const s3 = e3.GetBehaviorType();
          if (s3.GetInstanceSdkCtor() === this.constructor) return s3;
        }
      }
      Trigger(e2, s2, t2, n) {
        return this._runtime ? super.Trigger(e2) : s2.Trigger(e2, t2, n);
      }
      _FinishTriggers(e2) {
        let t2, n;
        if (this._finishingTween = e2, s.Cnds.SetFinishingTween(e2), this.GetRuntime()) t2 = this._inst, n = this._runtime, this.Trigger(s.Cnds.OnTweensFinished), this.Trigger(s.Cnds.OnAnyTweensFinished), this.ReleaseTween(e2);
        else {
          if (t2 = e2.GetInstance(), !t2) return;
          if (t2 && t2.IsDestroyed()) return;
          n = t2.GetRuntime();
          const i = this._GetBehaviorType(e2);
          this.Trigger(s.Cnds.OnTweensFinished, n, t2, i), this.Trigger(s.Cnds.OnAnyTweensFinished, n, t2, i), e2.Stop();
        }
        this._finishingTween = null, s.Cnds.SetFinishingTween(null), e2.GetDestroyInstanceOnComplete() && n.DestroyInstance(t2);
      }
      _AddTween(e2, t2) {
        const n = s.Maps.GetPropertyFromIndex(t2);
        this._activeTweens.has(n) || this._activeTweens.set(n, []);
        this._activeTweens.get(n).push(e2);
      }
      _AddToWaitingList(e2) {
        const s2 = e2.GetId();
        this._waitingForReleaseTweens.has(s2) || this._waitingForReleaseTweens.set(s2, []), this._waitingForReleaseTweens.get(s2).push(e2), this.IsTicking2() || this._StartTicking2();
      }
      _IsInWaitingList(e2) {
        const s2 = e2.GetId();
        return !!this._waitingForReleaseTweens.has(s2) && this._waitingForReleaseTweens.get(s2).includes(e2);
      }
      _ReleaseWaitingTweens() {
        if (this._waitingForReleaseTweens.size) {
          for (const s2 of this._waitingForReleaseTweens.values()) {
            for (const e2 of s2) e2.IsReleased() || e2.Release();
            e.clearArray(s2);
          }
          this._waitingForReleaseTweens.clear(), this.IsTicking2() && this._StopTicking2();
        }
      }
      GetDebuggerProperties() {
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.tween.properties.enabled.name", value: this.IsEnabled(), onedit: (e2) => this.SetEnabled(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.ITweenBehaviorInstance;
      }
    };
  }
  {
    const e = self.C3;
    let s = null;
    e.Behaviors.Tween.Cnds = { OnAnyTweenLoop: () => true, OnTweensLoop(e2) {
      const s2 = this.GetTriggerTween();
      return !!s2 && s2.HasTags(e2);
    }, OnAnyTweenPingPong(e2) {
      const s2 = this.GetTriggerTween();
      return !!s2 && (s2.GetPingPongState() === e2 || 2 === e2);
    }, OnTweensPingPong(e2, s2) {
      const t = this.GetTriggerTween();
      return !!t && ((t.GetPingPongState() === s2 || 2 === s2) && t.HasTags(e2));
    }, OnTweensReleased(e2) {
      return this.GetTriggerTween().HasTags(e2);
    }, OnAnyTweensReleased: () => true, SetFinishingTween(e2) {
      s = e2;
    }, OnTweensFinished: (e2) => s.HasTags(e2), OnAnyTweensFinished: () => true, IsPlaying(s2) {
      return this.CheckTweensWithTags(s2, e.TweenState.IsPlaying);
    }, IsAnyPlaying() {
      return this.CheckTweens(e.TweenState.IsPlaying);
    }, IsPaused(s2) {
      return this.CheckTweensWithTags(s2, e.TweenState.IsPaused);
    }, IsAnyPaused() {
      return this.CheckTweens(e.TweenState.IsPaused);
    }, IsPingPong(s2, t) {
      return 0 === t ? this.CheckTweensWithTags(s2, e.TweenState.IsPing) : 1 === t && this.CheckTweensWithTags(s2, e.TweenState.IsPong);
    }, IsAnyPingPong(s2) {
      return 0 === s2 ? this.CheckTweens(e.TweenState.IsPing) : 1 === s2 && this.CheckTweens(e.TweenState.IsPong);
    } };
  }
  {
    const e = self.C3, s = self.Ease, t = e.Behaviors.Tween;
    t.Acts = { SetEnabled(e2) {
      this.SetEnabled(!!e2);
    }, async TweenOneProperty(...e2) {
      if (!this.IsEnabled() || !this.IsInstanceValid()) return;
      const s2 = this.CreateTween(t.TweenArguments.OneProperty(this, ...e2));
      s2.Play() && await s2.GetPlayPromise();
    }, async TweenTwoProperties(...e2) {
      if (!this.IsEnabled() || !this.IsInstanceValid()) return;
      const s2 = this.CreateTween(t.TweenArguments.TwoProperties(this, ...e2));
      s2.Play() && await s2.GetPlayPromise();
    }, async TweenValue(...e2) {
      if (!this.IsEnabled() || !this.IsInstanceValid()) return;
      const s2 = this.CreateTween(t.TweenArguments.ValueProperty(this, ...e2));
      s2.Play() && await s2.GetPlayPromise();
    }, PauseTweens(e2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.GetTweens(e2)) s2.Stop();
    }, PauseAllTweens() {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) e2.Stop();
    }, ResumeTweens(e2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.GetTweens(e2)) s2.Resume();
    }, ResumeAllTweens() {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) e2.Resume();
    }, StopTweens(e2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.GetTweens(e2)) this.ReleaseTween(s2);
    }, StopAllTweens() {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) this.ReleaseTween(e2);
    }, SetOnePropertyTweensEndValue(s2, t2, n) {
      if (!this.IsEnabled() || !this.IsInstanceValid()) return;
      const i = e.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(t2);
      for (const e2 of this.GetTweens(s2)) e2.BeforeSetEndValues([i]), e2.SetEndValue(n, i);
    }, SetTwoPropertiesTweensEndValue(s2, t2, n, i) {
      if (!this.IsEnabled() || !this.IsInstanceValid()) return;
      const a = e.Behaviors.Tween.Maps.GetRealProperties(t2);
      for (const e2 of this.GetTweens(s2)) e2.BeforeSetEndValues(a), e2.SetEndValue(n, a[0]), e2.SetEndValue(i, a[1]);
    }, SetValuePropertyTweensStartValue(e2, s2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2, "value")) t2.SetStartValue(s2, "value");
    }, SetValuePropertyTweensEndValue(e2, s2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2, "value")) t2.BeforeSetEndValues(["value"]), t2.SetEndValue(s2, "value");
    }, SetTweensEase(e2, t2) {
      if (!this.IsEnabled() || !this.IsInstanceValid()) return;
      const n = s.GetEaseFromIndex(t2);
      for (const s2 of this.GetTweens(e2)) s2.SetEase(n);
    }, SetAllTweensEase(e2) {
      if (!this.IsEnabled() || !this.IsInstanceValid()) return;
      const t2 = s.GetEaseFromIndex(e2);
      for (const e3 of this.AllTweens()) e3.SetEase(t2);
    }, SetTweensTime(e2, s2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetTime(s2);
    }, SetAllTweensTime(e2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.AllTweens()) s2.SetTime(e2);
    }, SetTweensPlaybackRate(e2, s2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetPlaybackRate(s2);
    }, SetAllTweensPlaybackRate(e2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.AllTweens()) s2.SetPlaybackRate(e2);
    }, SetTweensDestroyOnComplete(e2, s2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetDestroyInstanceOnComplete(!!s2);
    }, SetAllTweensDestroyOnComplete(e2) {
      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.AllTweens()) s2.SetDestroyInstanceOnComplete(!!e2);
    } };
  }
  self.C3.Behaviors.Tween.Exps = { Time(e) {
    const s = this.GetTweenIncludingWaitingForRelease(e);
    return s ? s.GetTime() : 0;
  }, Progress(e) {
    const s = this.GetTweenIncludingWaitingForRelease(e);
    return s ? s.GetTime() / s.GetTotalTime() : 0;
  }, PlaybackRate(e) {
    const s = this.GetTweenIncludingWaitingForRelease(e);
    return s ? s.GetPlaybackRate() : 0;
  }, Value(e) {
    const s = this.GetTweenIncludingWaitingForRelease(e, "value");
    return s ? s.GetPropertyTrack("value").GetSourceAdapterValue() : 0;
  }, Tags() {
    let e = this.GetFinishingTween();
    return e ? e.GetStringTags() : (e = this.GetTriggerTween(), e ? e.GetStringTags() : "");
  } };
}
{
  const C32 = self.C3, Ease = self.Ease, PAIR_PROPERTIES = ["position", "size", "scale"], SINGLE_PROPERTIES = ["offsetX", "offsetY", "offsetWidth", "offsetHeight", "offsetAngle", "offsetOpacity", "offsetColor", "offsetZElevation", "offsetScaleX", "offsetScaleY"], VALUE_PROPERTIES = ["value"], PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES), PROPERTY_PAIR_TO_REAL_PROPERTIES = { "position": ["offsetX", "offsetY"], "size": ["offsetWidth", "offsetHeight"], "scale": ["offsetScaleX", "offsetScaleY"] }, ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce((e, t) => Object.assign({}, e, { [t]: [t] }), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);
  C32.Behaviors.Tween.Maps = class {
    constructor() {
    }
    static GetEases() {
      return [...Ease.GetRuntimeEaseNames()];
    }
    static GetEaseFromIndex(e) {
      return [...Ease.GetRuntimeEaseNames()][e];
    }
    static GetPropertyFromIndex(e) {
      return PROPERTY_INDEX_TO_NAME[e];
    }
    static GetPropertyIndexFromName(e) {
      return PROPERTY_INDEX_TO_NAME.indexOf(e);
    }
    static GetPairPropertyFromIndex(e) {
      return PAIR_PROPERTIES[e];
    }
    static GetSinglePropertyFromIndex(e) {
      return SINGLE_PROPERTIES[e];
    }
    static GetValuePropertyFromIndex(e) {
      return VALUE_PROPERTIES[e];
    }
    static GetPairProperties(e) {
      return PROPERTY_PAIR_TO_REAL_PROPERTIES[e];
    }
    static GetRealProperties(e) {
      return C32.IsString(e) ? ALL_REAL_PROPERTIES[e] : ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[e]];
    }
    static IsPairId(e) {
      return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[e];
    }
    static IsColorId(e) {
      return "offsetColor" === e;
    }
    static IsAngleId(e) {
      return "offsetAngle" === e;
    }
    static IsOpacityId(e) {
      return "offsetOpacity" === e;
    }
    static IsValueId(e) {
      return "value" === e;
    }
  };
}
{
  const C32 = self.C3, NAMESPACE = C32.Behaviors.Tween, TWEEN_CONFIGURATIONS = /* @__PURE__ */ new Map();
  NAMESPACE.Config = class {
    constructor() {
    }
    static GetPropertyTracksConfig(e, t, r, o, a, s) {
      0 === TWEEN_CONFIGURATIONS.size && this._CreateConfigObjects();
      const n = NAMESPACE.PropertyTypes.Pick(e);
      let i = TWEEN_CONFIGURATIONS.get(n);
      return C32.IsFiniteNumber(e) && (e = NAMESPACE.Maps.GetPropertyFromIndex(e)), this._GetConfig(i, e, t, r, o, a, s);
    }
    static TransformValue(e, t) {
      return C32.Behaviors.Tween.GetPropertyTracksConfig(e).valueGetter(t);
    }
    static _CreateConfigObjects() {
      const e = NAMESPACE.PropertyTypes, t = NAMESPACE.ValueGetters;
      this._AddConfigObject(e.PAIR, this._GetPairConfig, t._GetPropertyValue), this._AddConfigObject(e.COLOR, this._GetColorConfig, t._GetColorPropertyValue), this._AddConfigObject(e.ANGLE, this._GetAngleConfig, t._GetPropertyAngleValue), this._AddConfigObject(e.VALUE, this._GetValueConfig, t._GetPropertyValue), this._AddConfigObject(e.OTHER, this._GetCommonConfig, t._GetPropertyValue);
    }
    static _AddConfigObject(e, t, r) {
      TWEEN_CONFIGURATIONS.set(e, this._CreateConfigObject(e, t, r));
    }
    static _CreateConfigObject(e, t, r) {
      return { name: e, configFunc: t, valueGetter: r };
    }
    static _GetConfig(e, t, r, o, a, s, n) {
      return e.configFunc(t, e.valueGetter(r), e.valueGetter(o), a, s, n);
    }
    static _GetPairConfig(e, t, r, o, a, s) {
      return NAMESPACE.Maps.GetPairProperties(e).map((e2, s2) => ({ sourceId: "world-instance", property: e2, type: "float", valueType: "numeric", startValue: t[s2], endValue: r[s2], ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a }));
    }
    static _GetColorConfig(e, t, r, o, a, s) {
      return C32.Plugins.Text && s.GetPlugin() instanceof C32.Plugins.Text ? { sourceId: "plugin", sourceArgs: [7], property: "color", type: "color", valueType: "color", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a } : { sourceId: "world-instance", property: e, type: "color", valueType: "color", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };
    }
    static _GetAngleConfig(e, t, r, o, a, s) {
      return { sourceId: "world-instance", property: e, type: "angle", valueType: "angle", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };
    }
    static _GetCommonConfig(e, t, r, o, a, s) {
      return { sourceId: "world-instance", property: e, type: "float", valueType: "numeric", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };
    }
    static _GetValueConfig(e, t, r, o, a, s) {
      return { sourceId: "value", property: e, type: "float", valueType: "numeric", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };
    }
  };
}
{
  const C32 = self.C3, NAMESPACE = C32.Behaviors.Tween, COMMON_FIXED_ARGS = { resultMode: "absolute" }, COMMON_VARIABLE_ARGS = Object.assign({}, COMMON_FIXED_ARGS, { tags: "", property: "", time: 0, ease: 0, releaseOnComplete: 0, loop: false, pingPong: false, repeatCount: 1 }), ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: 0, endValue: 0 }), TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: [0, 0], endValue: [0, 0] }), COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: [0, 0, 0], endValue: [0, 0, 0] }), VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, { initialValueMode: "start-value" }), X = 0, Y = 1, R = 0, G = 1, B = 2;
  NAMESPACE.TweenArguments = class {
    constructor() {
    }
    static _SetCommonProperties(e, t, R2, r, P, a, E, O) {
      e.tags = t, e.time = R2, e.ease = r, e.releaseOnComplete = P, e.loop = a, e.pingPong = E, e.repeatCount = O;
    }
    static OneProperty(e, t, R2, r, P, a, E, O, A, _) {
      const o = "string" == typeof R2 ? R2 : NAMESPACE.Maps.GetSinglePropertyFromIndex(R2), s = NAMESPACE.Maps.IsColorId(o) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;
      return this._SetCommonProperties(s, t, P, a, E, O, A, _), NAMESPACE.Maps.IsColorId(o) ? (COLOR_PROPERTY_ARGS.endValue[0] = C32.GetRValue(r), COLOR_PROPERTY_ARGS.endValue[1] = C32.GetGValue(r), COLOR_PROPERTY_ARGS.endValue[2] = C32.GetBValue(r), COLOR_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(o)) : NAMESPACE.Maps.IsOpacityId(o) ? ONE_PROPERTY_ARGS.endValue = r / 100 : ONE_PROPERTY_ARGS.endValue = r, s.property = NAMESPACE.Maps.GetPropertyIndexFromName(o), s;
    }
    static TwoProperties(e, t, R2, r, P, a, E, O, A, _, o) {
      this._SetCommonProperties(TWO_PROPERTIES_ARGS, t, a, E, O, A, _, o);
      const s = "string" == typeof R2 ? R2 : NAMESPACE.Maps.GetPairPropertyFromIndex(R2);
      return TWO_PROPERTIES_ARGS.endValue[0] = r, TWO_PROPERTIES_ARGS.endValue[1] = P, TWO_PROPERTIES_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(s), TWO_PROPERTIES_ARGS;
    }
    static ValueProperty(e, t, R2, r, P, a, E, O, A, _) {
      return this._SetCommonProperties(VALUE_PROPERTY_ARGS, t, P, a, E, O, A, _), VALUE_PROPERTY_ARGS.startValue = R2, VALUE_PROPERTY_ARGS.endValue = r, VALUE_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName("value"), VALUE_PROPERTY_ARGS;
    }
  };
}
{
  const C32 = self.C3, NAMESPACE = C32.Behaviors.Tween, TYPE_CHECK_OBJECTS = [];
  NAMESPACE.PropertyTypes = class {
    constructor() {
    }
    static Pick(t) {
      if (0 === TYPE_CHECK_OBJECTS.length) {
        const t2 = TYPE_CHECK_OBJECTS;
        t2.push({ checkFunc: NAMESPACE.Maps.IsPairId, result: this.PAIR }), t2.push({ checkFunc: NAMESPACE.Maps.IsColorId, result: this.COLOR }), t2.push({ checkFunc: NAMESPACE.Maps.IsAngleId, result: this.ANGLE }), t2.push({ checkFunc: NAMESPACE.Maps.IsValueId, result: this.VALUE }), t2.push({ checkFunc: () => true, result: this.OTHER });
      }
      C32.IsFiniteNumber(t) && (t = C32.Behaviors.Tween.Maps.GetPropertyFromIndex(t));
      for (const e of TYPE_CHECK_OBJECTS) if (e.checkFunc(t)) return e.result;
    }
    static get PAIR() {
      return "pair";
    }
    static get COLOR() {
      return "color";
    }
    static get ANGLE() {
      return "angle";
    }
    static get VALUE() {
      return "value";
    }
    static get OTHER() {
      return "other";
    }
  };
}
{
  const C32 = self.C3, NAMESPACE = C32.Behaviors.Tween;
  NAMESPACE.ValueGetters = class {
    constructor() {
    }
    static _GetPropertyAngleValue(e) {
      const t = C32.toRadians(parseFloat(e));
      return C32.clampAngle(t);
    }
    static _GetColorPropertyValue(e) {
      return e.slice(0);
    }
    static _GetPropertyValue(e) {
      return e;
    }
  };
}
{
  let getIndexForEase = function(e) {
    C3X.RequireString(e);
    const t = Ease.ToInternal(e);
    let n;
    if (n = t ? Ease.GetIndexForEase(t, null) : Ease.GetIndexForEase(e, null), -1 === n) throw new Error(`invalid ease name '${e}'`);
    return n;
  }, ValidateTags = function(e, t = false) {
    if (!(t && null == e || "string" == typeof e || Array.isArray(e))) throw new Error("invalid tags");
  };
  getIndexForEase2 = getIndexForEase, ValidateTags2 = ValidateTags;
  const C32 = self.C3, C3X = self.C3X, IBehaviorInstance = self.IBehaviorInstance, Ease = self.Ease, NAMESPACE = C32.Behaviors.Tween, map = /* @__PURE__ */ new WeakMap(), TWEEN_PROPERTIES = /* @__PURE__ */ new Map([["x", { name: "offsetX", type: "one" }], ["y", { name: "offsetY", type: "one" }], ["width", { name: "offsetWidth", type: "one" }], ["height", { name: "offsetHeight", type: "one" }], ["angle", { name: "offsetAngle", type: "one" }], ["opacity", { name: "offsetOpacity", type: "one" }], ["color", { name: "offsetColor", type: "color" }], ["z-elevation", { name: "offsetZElevation", type: "one" }], ["x-scale", { name: "offsetScaleX", type: "one" }], ["y-scale", { name: "offsetScaleY", type: "one" }], ["position", { name: "position", type: "two" }], ["size", { name: "size", type: "two" }], ["scale", { name: "scale", type: "two" }], ["value", { name: "value", type: "value" }]]);
  const TWEEN_OPTS = { tags: "", destroyOnComplete: false, loop: false, pingPong: false, repeatCount: 1, startValue: 0 }, I_TWEEN_OPTS = { easeToIndexFunc: getIndexForEase };
  self.ITweenBehaviorInstance = class extends IBehaviorInstance {
    constructor() {
      super(), map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance());
    }
    startTween(e, t, n, a, o) {
      const s = map.get(this);
      if (!s.IsEnabled() || !s.IsInstanceValid()) return null;
      const r = TWEEN_PROPERTIES.get(e);
      if (!r) throw new Error("invalid tween property");
      "one" === r.type || "value" === r.type ? C3X.RequireNumber(t) : (C3X.RequireArray(t), "two" === r.type ? (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1])) : "color" === r.type && (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1]), C3X.RequireNumber(t[2]))), "angle" === e ? t = C32.toDegrees(t) : "opacity" === e ? t *= 100 : "color" === e && (t = C32.PackRGBEx(t[0], t[1], t[2]));
      const i = getIndexForEase(a);
      let l;
      if (C3X.RequireFiniteNumber(n), o = Object.assign({}, TWEEN_OPTS, o), "value" === r.type && C3X.RequireNumber(o.startValue), ValidateTags(o.tags, true), "one" === r.type || "color" === r.type ? l = s.CreateTween(NAMESPACE.TweenArguments.OneProperty(s, o.tags, r.name, t, n, i, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount)) : "two" === r.type ? l = s.CreateTween(NAMESPACE.TweenArguments.TwoProperties(s, o.tags, r.name, t[0], t[1], n, i, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount)) : "value" === r.type && (l = s.CreateTween(NAMESPACE.TweenArguments.ValueProperty(s, o.tags, o.startValue, t, n, i, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount))), l.SetBehaviorInstance(s.GetBehaviorInstance().GetSdkInstance()), !l.Play()) throw new Error("failed to start tween");
      return l.GetITweenState(s, I_TWEEN_OPTS);
    }
    *allTweens() {
      const e = map.get(this);
      for (const t of e.AllTweens()) yield t.GetITweenState(e, I_TWEEN_OPTS);
    }
    *tweensByTags(e) {
      ValidateTags(e);
      const t = map.get(this);
      for (const n of t.GetTweens(e)) yield n.GetITweenState(t, I_TWEEN_OPTS);
    }
    get isEnabled() {
      return map.get(this).IsEnabled();
    }
    set isEnabled(e) {
      map.get(this).SetEnabled(e);
    }
  };
}
var getIndexForEase2;
var ValidateTags2;
{
  {
    const e = self.C3;
    e.Behaviors.MoveTo = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.MoveTo.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t = self.C3X, i = self.IBehaviorInstance, s = 0, n = 1, a = 2, o = 3, r = 4, h = 5, _ = 6;
    e.Behaviors.MoveTo.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(t2, i2) {
        super(t2), this._maxSpeed = 200, this._acc = 600, this._dec = 600, this._rotateSpeed = 0, this._setAngle = true, this._stopOnSolids = false, this._isEnabled = true, this._speed = 0, this._movingAngle = this.GetWorldInfo().GetAngle(), this._waypoints = [], i2 && (this._maxSpeed = i2[s], this._acc = i2[n], this._dec = i2[a], this._rotateSpeed = e.toRadians(i2[o]), this._setAngle = i2[r], this._stopOnSolids = i2[h], this._isEnabled = i2[_]), this._timelineInfo = null, this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN, this._tRange = [0, 0], this._timelineInfoProjectionRange = { tRange: this._tRange };
      }
      Release() {
        this._timelineInfo && (this._timelineInfo.Release(), this._timelineInfo = null), this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN, this._tRange = null, this._timelineInfoProjectionRange = null, super.Release();
      }
      SaveToJson() {
        return { "ms": this._maxSpeed, "acc": this._acc, "dec": this._dec, "rs": this._rotateSpeed, "sa": this._setAngle, "sos": this._stopOnSolids, "s": this._speed, "ma": this._movingAngle, "wp": this._waypoints.map((e2) => ({ "x": e2.x, "y": e2.y })), "e": this._isEnabled };
      }
      LoadFromJson(e2) {
        this._maxSpeed = e2["ms"], this._acc = e2["acc"], this._dec = e2["dec"], this._rotateSpeed = e2["rs"], this._setAngle = e2["sa"], this._stopOnSolids = e2["sos"], this._speed = e2["s"], this._movingAngle = e2["ma"], this._waypoints = e2["wp"].map((e3) => ({ x: e3["x"], y: e3["y"] })), this._SetEnabled(e2["e"]), this._isEnabled && this._waypoints.length > 0 && this._StartTicking();
      }
      _AddWaypoint(t2, i2, s2, n2) {
        s2 && e.clearArray(this._waypoints), this._waypoints.push({ x: t2, y: i2, opts: n2 }), this._isEnabled && this._StartTicking();
      }
      _GetWaypointCount() {
        return this._waypoints.length;
      }
      _GetWaypointXAt(e2) {
        return (e2 = Math.floor(e2)) < 0 || e2 >= this._waypoints.length ? 0 : this._waypoints[e2].x;
      }
      _GetWaypointYAt(e2) {
        return (e2 = Math.floor(e2)) < 0 || e2 >= this._waypoints.length ? 0 : this._waypoints[e2].y;
      }
      _IsMoving() {
        return this._waypoints.length > 0;
      }
      _Stop() {
        e.clearArray(this._waypoints), this._speed = 0, this._StopTicking();
      }
      _GetTargetX() {
        return this._waypoints.length > 0 ? this._waypoints[0].x : 0;
      }
      _GetTargetY() {
        return this._waypoints.length > 0 ? this._waypoints[0].y : 0;
      }
      _GetTargetIsBezier() {
        if (this._waypoints.length > 0) {
          const e2 = this._waypoints[0];
          if (e2.opts) return e2.opts.isBezier;
        }
        return false;
      }
      _GetTargetIsBezierFirst() {
        if (this._waypoints.length > 0) {
          const e2 = this._waypoints[0];
          if (e2.opts) return e2.opts.isBezier && e2.opts.isFirst;
        }
        return false;
      }
      _GetTargetBezierAngle() {
        if (this._waypoints.length > 0) {
          const e2 = this._waypoints[0];
          if (e2.opts) return e2.opts.bezierAngle;
        }
        return NaN;
      }
      _SetSpeed(e2) {
        this._IsMoving() && (this._speed = Math.min(e2, this._maxSpeed));
      }
      _GetSpeed() {
        return this._speed;
      }
      _SetMaxSpeed(e2) {
        this._maxSpeed = Math.max(e2, 0), this._SetSpeed(this._speed);
      }
      _GetMaxSpeed() {
        return this._maxSpeed;
      }
      _IsRotationEnabled() {
        return 0 !== this._rotateSpeed;
      }
      Tick() {
        if (!this._isEnabled || !this._IsMoving()) return;
        const t2 = this._runtime.GetDt(this._inst), i2 = this._inst.GetWorldInfo(), s2 = i2.GetX(), n2 = i2.GetY(), a2 = i2.GetAngle();
        let o2 = this._speed, r2 = this._maxSpeed;
        const h2 = this._acc, _2 = this._dec, l2 = this._GetTargetX(), g = this._GetTargetY(), d = e.angleTo(s2, n2, l2, g);
        let p = false;
        if (_2 > 0 && 1 === this._waypoints.length) {
          const t3 = 0.5 * o2 * o2 / _2 * 1.0001;
          if (p = e.distanceSquared(s2, n2, l2, g) <= t3 * t3, p) {
            const t4 = e.distanceTo(s2, n2, l2, g);
            o2 = Math.sqrt(2 * _2 * t4), r2 = o2, this._speed = o2;
          }
        }
        if (this._IsRotationEnabled()) {
          const t3 = e.angleDiff(this._movingAngle, d);
          if (t3 > Number.EPSILON) {
            const s3 = t3 / this._rotateSpeed, n3 = e.distanceTo(i2.GetX(), i2.GetY(), l2, g) / (2 * Math.sin(t3)) * t3;
            r2 = Math.min(r2, e.clamp(n3 / s3, 0, this._maxSpeed));
          }
        }
        let c = p ? -_2 : h2;
        const S = Math.min(o2 * t2 + 0.5 * c * t2 * t2, r2 * t2);
        if (p) {
          if (_2 > 0 && (this._speed = Math.max(this._speed - _2 * t2, 0), 0 === this._speed)) return void this._OnArrived(i2, l2, g);
        } else this._speed = 0 === h2 ? r2 : Math.min(this._speed + h2 * t2, r2);
        if (e.distanceSquared(i2.GetX(), i2.GetY(), l2, g) <= S * S) this._OnArrived(i2, l2, g);
        else {
          if (this._IsRotationEnabled() ? this._movingAngle = e.angleRotate(this._movingAngle, d, this._rotateSpeed * t2) : this._movingAngle = d, i2.OffsetXY(Math.cos(this._movingAngle) * S, Math.sin(this._movingAngle) * S), this._setAngle) {
            const t3 = this._GetTargetIsBezier(), s3 = this._GetTargetIsBezierFirst();
            if (t3 && !s3) {
              const t4 = e.distanceTo(this._lastTargetX, this._lastTargetY, i2.GetX(), i2.GetY()) / e.distanceTo(this._lastTargetX, this._lastTargetY, l2, g);
              i2.SetAngle(e.angleLerp(this._lastTargetAngle, this._GetTargetBezierAngle(), t4));
            } else i2.SetAngle(this._movingAngle), this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN;
          }
          i2.SetBboxChanged(), this._CheckSolidCollision(s2, n2, a2);
        }
      }
      _OnArrived(t2, i2, s2) {
        t2.SetXY(i2, s2);
        const n2 = this._waypoints[0];
        n2.opts && n2.opts.isBezier ? (this._lastTargetX = n2.x, this._lastTargetY = n2.y, this._lastTargetAngle = n2.opts.bezierAngle, this._setAngle && t2.SetAngle(this._lastTargetAngle)) : (this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN), t2.SetBboxChanged(), this._waypoints.shift(), 0 === this._waypoints.length && (this._timelineInfo && (this._timelineInfo.Release(), this._timelineInfo = null, this._lastTargetX = NaN, this._lastTargetY = NaN, this._lastTargetAngle = NaN), this._speed = 0, this._StopTicking()), this.DispatchScriptEvent("arrived"), this.Trigger(e.Behaviors.MoveTo.Cnds.OnArrived);
      }
      _CheckSolidCollision(t2, i2, s2) {
        const n2 = this._runtime.GetCollisionEngine();
        if (this._stopOnSolids && n2.TestOverlapSolid(this._inst)) {
          this._Stop();
          const a2 = this._inst.GetWorldInfo(), o2 = a2.GetX(), r2 = a2.GetY(), h2 = e.angleTo(o2, r2, t2, i2), _2 = e.distanceTo(o2, r2, t2, i2);
          n2.PushOutSolid(this._inst, Math.cos(h2), Math.sin(h2), Math.max(_2, 1)) || (a2.SetXY(t2, i2), a2.SetAngle(s2), a2.SetBboxChanged()), this.DispatchScriptEvent("hitsolid"), this.Trigger(e.Behaviors.MoveTo.Cnds.OnHitSolid);
        }
      }
      _IsSetAngle() {
        return this._setAngle;
      }
      _SetSetAngle(e2) {
        this._setAngle = !!e2;
      }
      _SetAngleOfMotion(e2) {
        if (this._movingAngle = e2, this._isEnabled && this._setAngle && !this._IsMoving()) {
          const e3 = this.GetWorldInfo();
          e3.SetAngle(this._movingAngle), e3.SetBboxChanged();
        }
      }
      _GetAngleOfMotion() {
        return this._movingAngle;
      }
      _SetAcceleration(e2) {
        this._acc = Math.max(e2, 0);
      }
      _GetAcceleration() {
        return this._acc;
      }
      _SetDeceleration(e2) {
        this._dec = Math.max(e2, 0);
      }
      _GetDeceleration() {
        return this._dec;
      }
      _SetRotateSpeed(e2) {
        this._rotateSpeed = Math.max(e2, 0);
      }
      _GetRotateSpeed() {
        return this._rotateSpeed;
      }
      _SetStopOnSolids(e2) {
        this._stopOnSolids = !!e2;
      }
      _IsStopOnSolids() {
        return this._stopOnSolids;
      }
      _SetEnabled(e2) {
        e2 = !!e2, this._isEnabled !== e2 && (this._isEnabled = e2, this._isEnabled && this._IsMoving() ? this._StartTicking() : this._StopTicking());
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      GetPropertyValueByIndex(t2) {
        switch (t2) {
          case s:
            return this._GetMaxSpeed();
          case n:
            return this._GetAcceleration();
          case a:
            return this._GetDeceleration();
          case o:
            return e.toDegrees(this._GetRotateSpeed());
          case r:
            return this._IsSetAngle();
          case h:
            return this._IsStopOnSolids();
          case _:
            return this._IsEnabled();
        }
      }
      SetPropertyValueByIndex(t2, i2) {
        switch (t2) {
          case s:
            this._SetMaxSpeed(i2);
            break;
          case n:
            this._SetAcceleration(i2);
            break;
          case a:
            this._SetDeceleration(i2);
            break;
          case o:
            this._SetRotateSpeed(e.toRadians(i2));
            break;
          case r:
            this._SetSetAngle(i2);
            break;
          case h:
            this._SetStopOnSolids(i2);
            break;
          case _:
            this._SetEnabled(i2);
        }
      }
      GetDebuggerProperties() {
        const t2 = "behaviors.moveto";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t2 + ".debugger.speed", value: this._GetSpeed(), onedit: (e2) => this._SetSpeed(e2) }, { name: t2 + ".debugger.angle-of-motion", value: e.toDegrees(this._GetAngleOfMotion()), onedit: (t3) => this._movingAngle = e.toRadians(t3) }, { name: t2 + ".debugger.target-x", value: this._GetTargetX() }, { name: t2 + ".debugger.target-y", value: this._GetTargetY() }, { name: t2 + ".debugger.waypoint-count", value: this._GetWaypointCount() }, { name: t2 + ".properties.max-speed.name", value: this._GetMaxSpeed(), onedit: (e2) => this._SetMaxSpeed(e2) }, { name: t2 + ".properties.acceleration.name", value: this._GetAcceleration(), onedit: (e2) => this._SetAcceleration(e2) }, { name: t2 + ".properties.deceleration.name", value: this._GetDeceleration(), onedit: (e2) => this._SetDeceleration(e2) }, { name: t2 + ".properties.rotate-speed.name", value: e.toDegrees(this._GetRotateSpeed()), onedit: (t3) => this._SetRotateSpeed(e.toRadians(t3)) }, { name: t2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IMoveToBehaviorInstance;
      }
    };
    const l = /* @__PURE__ */ new WeakMap();
    self.IMoveToBehaviorInstance = class extends i {
      constructor() {
        super(), l.set(this, i._GetInitInst().GetSdkInstance());
      }
      moveToPosition(e2, i2, s2 = true) {
        t.RequireFiniteNumber(e2), t.RequireFiniteNumber(i2), l.get(this)._AddWaypoint(e2, i2, !!s2);
      }
      getTargetX() {
        return l.get(this)._GetTargetX();
      }
      getTargetY() {
        return l.get(this)._GetTargetY();
      }
      getTargetPosition() {
        const e2 = l.get(this);
        return [e2._GetTargetX(), e2._GetTargetY()];
      }
      getWaypointCount() {
        return l.get(this)._GetWaypointCount();
      }
      getWaypointX(e2) {
        return t.RequireFiniteNumber(e2), l.get(this)._GetWaypointXAt(e2);
      }
      getWaypointY(e2) {
        return t.RequireFiniteNumber(e2), l.get(this)._GetWaypointYAt(e2);
      }
      getWaypoint(e2) {
        t.RequireFiniteNumber(e2);
        const i2 = l.get(this);
        return [i2._GetWaypointXAt(e2), i2._GetWaypointYAt(e2)];
      }
      stop() {
        l.get(this)._Stop();
      }
      get isMoving() {
        return l.get(this)._IsMoving();
      }
      get speed() {
        return l.get(this)._GetSpeed();
      }
      set speed(e2) {
        t.RequireFiniteNumber(e2), l.get(this)._SetSpeed(e2);
      }
      get maxSpeed() {
        return l.get(this)._GetMaxSpeed();
      }
      set maxSpeed(e2) {
        t.RequireFiniteNumber(e2), l.get(this)._SetMaxSpeed(e2);
      }
      get acceleration() {
        return l.get(this)._GetAcceleration();
      }
      set acceleration(e2) {
        t.RequireFiniteNumber(e2), l.get(this)._SetAcceleration(e2);
      }
      get deceleration() {
        return l.get(this)._GetDeceleration();
      }
      set deceleration(e2) {
        t.RequireFiniteNumber(e2), l.get(this)._SetDeceleration(e2);
      }
      get angleOfMotion() {
        return l.get(this)._GetAngleOfMotion();
      }
      set angleOfMotion(e2) {
        t.RequireFiniteNumber(e2), l.get(this)._SetAngleOfMotion(e2);
      }
      get rotateSpeed() {
        return l.get(this)._GetRotateSpeed();
      }
      set rotateSpeed(e2) {
        t.RequireFiniteNumber(e2), l.get(this)._SetRotateSpeed(e2);
      }
      get isStopOnSolids() {
        return l.get(this)._IsStopOnSolids();
      }
      set isStopOnSolids(e2) {
        l.get(this)._SetStopOnSolids(e2);
      }
      get isEnabled() {
        return l.get(this)._IsEnabled();
      }
      set isEnabled(e2) {
        l.get(this)._SetEnabled(e2);
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.MoveTo.Cnds = { IsMoving() {
      return this._IsMoving();
    }, CompareSpeed(t, i) {
      return e.compare(this._GetSpeed(), t, i);
    }, IsEnabled() {
      return this._IsEnabled();
    }, OnArrived: () => true, OnHitSolid: () => true };
  }
  {
    const e = self.C3, t = 25;
    e.Behaviors.MoveTo.Acts = { MoveToPosition(e2, t2, i) {
      this._AddWaypoint(e2, t2, 0 === i);
    }, MoveToObject(e2, t2, i) {
      if (!e2) return;
      const s = e2.GetPairedInstance(this._inst);
      if (!s || !s.GetWorldInfo()) return;
      const [n, a] = s.GetImagePoint(t2);
      this._AddWaypoint(n, a, 0 === i);
    }, MoveAlongPathfindingPath(t2) {
      const i = this._inst.GetBehaviorSdkInstanceFromCtor(e.Behaviors.Pathfinding);
      if (!i) return;
      const s = i._GetPath();
      if (0 !== s.length) for (let e2 = 0, i2 = s.length; e2 < i2; ++e2) {
        const i3 = s[e2];
        this._AddWaypoint(i3.x, i3.y, 0 === e2 && 0 === t2);
      }
    }, MoveAlongTimeline(i, s, n) {
      const a = e.New(e.TimelineInfo, i, s);
      if (!a.WasInitialized()) return void a.Release();
      a.SetOrigin(this._inst.GetWorldInfo());
      let o = true;
      for (const i2 of a.segments()) switch (i2.GetType()) {
        case "line": {
          const e2 = i2.GetX(), t2 = i2.GetY();
          this._AddWaypoint(e2, t2, o && 0 === n), o = false;
          break;
        }
        case "cubic-bezier":
          for (let s2 = 0; s2 <= i2.GetStepCount(); s2++) {
            const a2 = s2 * i2.GetStepIncrement(), r = i2.Map(a2), h = r[0], _ = r[1], l = this._GetWaypointXAt(this._GetWaypointCount() - 1), g = this._GetWaypointYAt(this._GetWaypointCount() - 1);
            !o && e.IsFiniteNumber(l) && e.IsFiniteNumber(g) && e.distanceSquared(l, g, h, _) < t || (this._AddWaypoint(h, _, o && 0 === n, { isBezier: true, isFirst: o, bezierAngle: Math.atan2(_ - g, h - l) }), o = false);
          }
      }
      this._timelineInfo = a;
    }, MoveAlongTimelineByName(t2, i, s) {
      const n = this._runtime.GetTimelineManager().GetTimelineByName(t2);
      n && e.Behaviors.MoveTo.Acts.MoveAlongTimeline.call(this, n, i, s);
    }, Stop() {
      this._Stop();
    }, SetMovingAngle(t2) {
      this._SetAngleOfMotion(e.toRadians(t2));
    }, SetSpeed(e2) {
      this._SetSpeed(e2);
    }, SetMaxSpeed(e2) {
      this._SetMaxSpeed(e2);
    }, SetAcceleration(e2) {
      this._SetAcceleration(e2);
    }, SetDeceleration(e2) {
      this._SetDeceleration(e2);
    }, SetRotateSpeed(t2) {
      this._SetRotateSpeed(e.toRadians(t2));
    }, SetStopOnSolids(e2) {
      this._SetStopOnSolids(e2);
    }, SetEnabled(e2) {
      this._SetEnabled(e2);
    } };
  }
  {
    const e = self.C3;
    e.Behaviors.MoveTo.Exps = { Speed() {
      return this._GetSpeed();
    }, MaxSpeed() {
      return this._GetMaxSpeed();
    }, Acceleration() {
      return this._GetAcceleration();
    }, Deceleration() {
      return this._GetDeceleration();
    }, MovingAngle() {
      return e.toDegrees(this._GetAngleOfMotion());
    }, RotateSpeed() {
      return e.toDegrees(this._GetRotateSpeed());
    }, TargetX() {
      return this._GetTargetX();
    }, TargetY() {
      return this._GetTargetY();
    }, WaypointCount() {
      return this._GetWaypointCount();
    }, WaypointXAt(e2) {
      return this._GetWaypointXAt(e2);
    }, WaypointYAt(e2) {
      return this._GetWaypointYAt(e2);
    } };
  }
}
{
  let unaryminus = function(n) {
    return typeof n === "number" ? -n : n;
  }, bothNumbers = function(a, b) {
    return typeof a === "number" && typeof b === "number";
  }, add = function(l, r) {
    if (bothNumbers(l, r))
      return l + r;
    else
      return l;
  }, subtract = function(l, r) {
    if (bothNumbers(l, r))
      return l - r;
    else
      return l;
  }, multiply = function(l, r) {
    if (bothNumbers(l, r))
      return l * r;
    else
      return l;
  }, divide = function(l, r) {
    if (bothNumbers(l, r))
      return l / r;
    else
      return l;
  }, mod = function(l, r) {
    if (bothNumbers(l, r))
      return l % r;
    else
      return l;
  }, pow = function(l, r) {
    if (bothNumbers(l, r))
      return Math.pow(l, r);
    else
      return l;
  }, and = function(l, r) {
    if (typeof l === "string" || typeof r === "string") {
      let lstr, rstr;
      if (typeof l === "number")
        lstr = (Math.round(l * 1e10) / 1e10).toString();
      else
        lstr = l;
      if (typeof r === "number")
        rstr = (Math.round(r * 1e10) / 1e10).toString();
      else
        rstr = r;
      return lstr + rstr;
    } else {
      return l && r ? 1 : 0;
    }
  }, or = function(l, r) {
    if (bothNumbers(l, r))
      return l || r ? 1 : 0;
    else
      return l;
  };
  unaryminus2 = unaryminus, bothNumbers2 = bothNumbers, add2 = add, subtract2 = subtract, multiply2 = multiply, divide2 = divide, mod2 = mod, pow2 = pow, and2 = and, or2 = or;
  const C32 = self.C3;
  self.C3_ExpressionFuncs = [
    () => "Tilt Controls",
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      return () => f0("deck-the-halls", "frosty", "jinglebells", "rudolph", "wewishyou");
    },
    () => 0,
    () => "",
    (p) => {
      const v0 = p._GetNode(0).GetVar();
      return () => v0.GetValue();
    },
    (p) => {
      const n0 = p._GetNode(0);
      return () => n0.ExpObject();
    },
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      return () => f0("Game");
    },
    () => "Game",
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      const f1 = p._GetNode(1).GetBoundMethod();
      return () => f0(20, f1() - 40);
    },
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      const v1 = p._GetNode(1).GetVar();
      const f2 = p._GetNode(2).GetBoundMethod();
      return () => f0("Game") - v1.GetValue() + f2(-30, 30);
    },
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      return () => f0("Animation 1", "Animation 2", "Animation 3");
    },
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      const f1 = p._GetNode(1).GetBoundMethod();
      return () => f0("Game") - f1(20, 60);
    },
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      const f1 = p._GetNode(1).GetBoundMethod();
      return () => f0("Game") - f1(3e3, 5e3);
    },
    (p) => {
      const n0 = p._GetNode(0);
      return () => n0.ExpBehavior();
    },
    (p) => {
      const v0 = p._GetNode(0).GetVar();
      const f1 = p._GetNode(1).GetBoundMethod();
      return () => v0.GetValue() + f1() * 0.8;
    },
    () => 30,
    (p) => {
      const v0 = p._GetNode(0).GetVar();
      const f1 = p._GetNode(1).GetBoundMethod();
      return () => v0.GetValue() - f1() * 1.2;
    },
    () => 160,
    (p) => {
      const n0 = p._GetNode(0);
      const n1 = p._GetNode(1);
      return () => n0.ExpObject() - n1.ExpObject() / 2;
    },
    (p) => {
      const n0 = p._GetNode(0);
      const f1 = p._GetNode(1).GetBoundMethod();
      const n2 = p._GetNode(2);
      return () => n0.ExpInstVar() * f1(1, n2.ExpInstVar());
    },
    () => "Keyboard Controls",
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      const n1 = p._GetNode(1);
      return () => Math.abs(f0() * n1.ExpInstVar());
    },
    () => -3,
    () => 3,
    (p) => {
      const n0 = p._GetNode(0);
      const n1 = p._GetNode(1);
      return () => and(and("[color=red]Christmas Spirit: [/color]", n0.ExpInstVar()) + "\n\n[color=green]Total Presents Collected: [/color]", n1.ExpInstVar());
    },
    () => 5,
    () => 10,
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      return () => f0("Game") - 10;
    },
    () => 1,
    (p) => {
      const n0 = p._GetNode(0);
      return () => n0.ExpInstVar_Family();
    },
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      return () => f0("pickup", "Pickup11", "Pickup12", "Pickup6", "Pickup7", "Pickup9");
    },
    () => -20,
    (p) => {
      const f0 = p._GetNode(0).GetBoundMethod();
      const n1 = p._GetNode(1);
      return () => and("Christmas Spirit: ", f0(n1.ExpInstVar()));
    },
    (p) => {
      const n0 = p._GetNode(0);
      return () => n0.ExpInstVar().toString() + "x combo!";
    },
    () => 720,
    () => -720,
    () => 0.5,
    () => "UI",
    (p) => {
      const n0 = p._GetNode(0);
      const f1 = p._GetNode(1).GetBoundMethod();
      return () => n0.ExpObject() - f1("Game");
    },
    () => 3e3,
    () => 1200,
    () => "Permission denied"
  ];
}
var unaryminus2;
var bothNumbers2;
var add2;
var subtract2;
var multiply2;
var divide2;
var mod2;
var pow2;
var and2;
var or2;

// file-map:scripts/objRefTable.js
var C3 = self.C3;
self.C3_GetObjectRefTable = function() {
  return [
    C3.Plugins.Sprite,
    C3.Behaviors.Rotate,
    C3.Behaviors.jumpthru,
    C3.Plugins.Touch,
    C3.Plugins.Keyboard,
    C3.Plugins.Text,
    C3.Plugins.Mouse,
    C3.Plugins.PlatformInfo,
    C3.Behaviors.Platform,
    C3.Behaviors.Sin,
    C3.Behaviors.Tween,
    C3.Plugins.Audio,
    C3.Behaviors.MoveTo,
    C3.Plugins.PlatformInfo.Cnds.IsOnChromeOS,
    C3.Plugins.System.Acts.SetGroupActive,
    C3.Plugins.System.Cnds.OnLayoutStart,
    C3.Plugins.Audio.Acts.PlayByName,
    C3.Plugins.System.Exps.choose,
    C3.Plugins.Sprite.Cnds.CompareY,
    C3.Plugins.System.Acts.SetVar,
    C3.Plugins.Sprite.Exps.Y,
    C3.Plugins.System.Cnds.Compare,
    C3.Plugins.System.Exps.viewporttop,
    C3.Plugins.System.Acts.CreateObject,
    C3.Plugins.System.Exps.random,
    C3.Plugins.System.Exps.layoutwidth,
    C3.Plugins.Sprite.Acts.MoveToBottom,
    C3.Plugins.Sprite.Acts.SetWidth,
    C3.Plugins.Sprite.Acts.SetAnim,
    C3.Behaviors.Platform.Exps.VectorX,
    C3.Plugins.Sprite.Acts.SetMirrored,
    C3.Plugins.System.Cnds.EveryTick,
    C3.Plugins.System.Exps.dt,
    C3.Plugins.System.Cnds.CompareVar,
    C3.Plugins.System.Acts.Scroll,
    C3.Plugins.Sprite.Acts.SetPos,
    C3.Plugins.Sprite.Exps.X,
    C3.Plugins.Sprite.Exps.Height,
    C3.Behaviors.Platform.Cnds.IsOnFloor,
    C3.Behaviors.Platform.Acts.SimulateControl,
    C3.Behaviors.Platform.Acts.ResetDoubleJump,
    C3.Plugins.Sprite.Acts.AddInstanceVar,
    C3.Plugins.System.Exps.max,
    C3.Plugins.Sprite.Acts.SetInstanceVar,
    C3.Plugins.System.Cnds.IsGroupActive,
    C3.Plugins.Keyboard.Cnds.IsKeyDown,
    C3.Plugins.Keyboard.Cnds.OnKey,
    C3.Behaviors.Platform.Acts.SetAcceleration,
    C3.Plugins.Touch.Exps.Gamma,
    C3.Plugins.Touch.Cnds.CompareOrientation,
    C3.Plugins.Touch.Cnds.OnTapGesture,
    C3.Plugins.Sprite.Cnds.IsOnScreen,
    C3.Plugins.System.Exps.viewportbottom,
    C3.Plugins.Sprite.Cnds.CompareX,
    C3.Plugins.System.Exps.viewportright,
    C3.Plugins.System.Exps.viewportleft,
    C3.Plugins.Sprite.Acts.Destroy,
    C3.Plugins.System.Acts.ResetGlobals,
    C3.Plugins.Text.Acts.SetText,
    C3.Plugins.Text.Acts.SetVisible,
    C3.Plugins.System.Acts.Wait,
    C3.Plugins.System.Acts.WaitForPreviousActions,
    C3.Plugins.Audio.Acts.StopAll,
    C3.Plugins.System.Acts.RestartLayout,
    C3.Plugins.Sprite.Acts.SetX,
    C3.Plugins.Sprite.Cnds.IsOverlapping,
    C3.Plugins.Sprite.Acts.SetCollisions,
    C3.Plugins.System.Exps.int,
    C3.Plugins.Sprite.Cnds.CompareInstanceVar,
    C3.Plugins.System.Cnds.Else,
    C3.Behaviors.MoveTo.Cnds.OnArrived,
    C3.Behaviors.Rotate.Acts.SetSpeed,
    C3.Plugins.Sprite.Cnds.IsMirrored,
    C3.Plugins.Sprite.Acts.SetAngle,
    C3.Plugins.Sprite.Acts.MoveToLayer,
    C3.Behaviors.MoveTo.Acts.SetAcceleration,
    C3.Behaviors.MoveTo.Acts.SetMaxSpeed,
    C3.Behaviors.MoveTo.Acts.SetSpeed,
    C3.Behaviors.MoveTo.Acts.MoveToObject,
    C3.Plugins.Keyboard.Cnds.OnAnyKey,
    C3.Plugins.System.Acts.NextPrevLayout,
    C3.Plugins.Mouse.Cnds.OnAnyClick,
    C3.Plugins.Touch.Cnds.OnTouchEnd,
    C3.Plugins.PlatformInfo.Acts.RequestWakeLock,
    C3.Plugins.Touch.Acts.RequestPermission,
    C3.Plugins.Touch.Cnds.OnPermissionGranted,
    C3.Plugins.Touch.Cnds.OnPermissionDenied
  ];
};
self.C3_JsPropNameTable = [
  { GammaMultiplier: 0 },
  { TotalPresentsCollected: 0 },
  { Score: 0 },
  { Combo: 0 },
  { PresentsGrabbed: 0 },
  { TempPresentScore: 0 },
  { Rotate: 0 },
  { Santa: 0 },
  { Jumpthru: 0 },
  { Platform: 0 },
  { Touch: 0 },
  { Keyboard: 0 },
  { ScoreText: 0 },
  { StartText: 0 },
  { StartButton: 0 },
  { Mouse: 0 },
  { PlatformInfo: 0 },
  { SantaCollisionVolume: 0 },
  { ScoreValue: 0 },
  { Sine: 0 },
  { Present: 0 },
  { PresentBundle: 0 },
  { Tween: 0 },
  { Bag: 0 },
  { ComboText: 0 },
  { Audio: 0 },
  { FinalScoreText: 0 },
  { MoveTo: 0 },
  { Presents: 0 },
  { DifficultyPlatformSpawnRate: 0 },
  { DifficultyPlatformWidth: 0 },
  { MinScroll: 0 },
  { NextPlatform: 0 },
  { NextGift: 0 },
  { NextGiftBundle: 0 },
  { screenSpaceY: 0 },
  { screenSpaceX: 0 }
];
self.InstanceType = {
  Santa: class extends self.ISpriteInstance {
  },
  Platform: class extends self.ISpriteInstance {
  },
  Touch: class extends self.IInstance {
  },
  Keyboard: class extends self.IInstance {
  },
  ScoreText: class extends self.ITextInstance {
  },
  StartText: class extends self.ITextInstance {
  },
  StartButton: class extends self.ISpriteInstance {
  },
  Mouse: class extends self.IInstance {
  },
  PlatformInfo: class extends self.IInstance {
  },
  SantaCollisionVolume: class extends self.ISpriteInstance {
  },
  Present: class extends self.ISpriteInstance {
  },
  PresentBundle: class extends self.ISpriteInstance {
  },
  Bag: class extends self.ISpriteInstance {
  },
  ComboText: class extends self.ITextInstance {
  },
  Audio: class extends self.IInstance {
  },
  FinalScoreText: class extends self.ITextInstance {
  },
  Presents: class extends self.ISpriteInstance {
  }
};
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.4.1

Copyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
